<?xml version="1.0"?>
<doc>
  <assembly>
    <name>NSoft.NFramework</name>
  </assembly>
  <members>
    <member name="T:NSoft.NFramework.Caching.AbstractCacheRepository">
      <summary>
            캐시 저장소 관리의 기본 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.ICacheRepository">
      <summary>
            Cache 시스템을 이용하여, 정보를 캐싱하도록 해주는 Client 의 인터페이스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.ICacheRepository.Get(System.String)">
      <summary>
            캐시에 저장된 항목을 반환합니다.
            </summary>
      <param name="key">캐시 키</param>
      <returns>저장된 항목, 없으면 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.ICacheRepository.Set(System.String,System.Object,System.TimeSpan)">
      <summary>
            캐시에 항목을 저장합니다.
            </summary>
      <param name="key">캐시 키</param>
      <param name="item">저장할 항목</param>
      <param name="validFor">유효 기간</param>
    </member>
    <member name="M:NSoft.NFramework.ICacheRepository.Remove(System.String)">
      <summary>
            캐시에서 항목을 제거합니다.
            </summary>
      <param name="key">캐시 키</param>
    </member>
    <member name="M:NSoft.NFramework.ICacheRepository.Clear">
      <summary>
            캐시의 모든 항목을 삭제합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.ICacheRepository.Expiry">
      <summary>
            캐시 항목의 유효 기간
            </summary>
    </member>
    <member name="P:NSoft.NFramework.ICacheRepository.Serializer">
      <summary>
            캐시에 저장할 객체에 대해 직렬화/역직화를 수행할 경우에 사용합니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Caching.AbstractCacheRepository.MinExpiry">
      <summary>
            최소 유효 기간 (1분)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Caching.AbstractCacheRepository.DefaultExpiry">
      <summary>
            기본 유효 기간 (2시간)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Caching.AbstractCacheRepository.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Caching.AbstractCacheRepository.#ctor(NSoft.NFramework.ISerializer,System.TimeSpan)">
      <summary>
            생성자
            </summary>
      <param name="serializer">객체 Serializer</param>
      <param name="expiry">유효기간</param>
    </member>
    <member name="M:NSoft.NFramework.Caching.AbstractCacheRepository.Get(System.String)">
      <summary>
            캐시에 저장된 항목을 반환합니다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Caching.AbstractCacheRepository.Set(System.String,System.Object,System.TimeSpan)">
      <summary>
            캐시에 항목을 저장합니다.
            </summary>
      <param name="key">
      </param>
      <param name="item">
      </param>
      <param name="validFor">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Caching.AbstractCacheRepository.Remove(System.String)">
      <summary>
            캐시에서 항목을 제거합니다.
            </summary>
      <param name="key">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Caching.AbstractCacheRepository.Clear">
      <summary>
            캐시의 모든 항목을 삭제합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Caching.AbstractCacheRepository.Expiry">
      <summary>
            캐시 항목의 유효 기간
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Caching.AbstractCacheRepository.Serializer">
      <summary>
            캐시에 저장할 객체에 대해 직렬화/역직화를 수행할 경우에 사용합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.CacheRepositoryEx.GetAsync(NSoft.NFramework.ICacheRepository,System.String)">
      <summary>
            비동기 방식으로 캐시에 저장된 항목을 로드합니다.
            </summary>
      <param name="repository">
      </param>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.CacheRepositoryEx.SetAsync(NSoft.NFramework.ICacheRepository,System.String,System.Object,System.TimeSpan)">
      <summary>
            비동기 방식으로 캐시에 정보를 저장합니다.
            </summary>
      <param name="repository">
      </param>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <param name="validFor">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.CacheRepositoryEx.RemoveAsync(NSoft.NFramework.ICacheRepository,System.String)">
      <summary>
            비동기 방식으로 캐시에서 정보를 삭제합니다.
            </summary>
      <param name="repository">
      </param>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.CacheRepositoryEx.ClearAsync(NSoft.NFramework.ICacheRepository)">
      <summary>
            비동기 방식으로 캐시에 저장된 모든 정보를 삭제합니다.
            </summary>
      <param name="repository">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Caching.ConcurrentCacheRepository">
      <summary>
        <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> 를 캐시 저장소로 사용하는 CacheRepository입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Caching.ConcurrentCacheRepository.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Caching.ConcurrentCacheRepository.#ctor(NSoft.NFramework.ISerializer,System.TimeSpan)">
      <summary>
            생성자
            </summary>
      <param name="serializer">객체 Serializer</param>
      <param name="expiry">유효기간</param>
    </member>
    <member name="M:NSoft.NFramework.Caching.ConcurrentCacheRepository.Get(System.String)">
      <summary>
            캐시에 저장된 항목을 반환합니다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Caching.ConcurrentCacheRepository.Set(System.String,System.Object,System.TimeSpan)">
      <summary>
            캐시에 항목을 저장합니다.
            </summary>
      <param name="key">
      </param>
      <param name="item">
      </param>
      <param name="validFor">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Caching.ConcurrentCacheRepository.Remove(System.String)">
      <summary>
            캐시에서 항목을 제거합니다.
            </summary>
      <param name="key">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Caching.ConcurrentCacheRepository.Clear">
      <summary>
            캐시의 모든 항목을 삭제합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ArrayList`1">
      <summary>
             A list collection based on a plain dynamic array data structure.
             Expansion of the internal array is performed by doubling on demand. 
             The internal array is only shrinked by the Clear method. 
            
             <i>When the FIFO property is set to false this class works fine as a stack of T.
             When the FIFO property is set to true the class will function as a (FIFO) queue
             but very inefficiently, use a LinkedList (<see cref="T:C5.LinkedList`1" />) instead.</i></summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ArrayBase`1">
      <summary>
            Base class for collection classes of dynamic array type implementations.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.SequencedBase`1">
      <summary>
            Base class (abstract) for sequenced collection implementations.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.DirectedCollectionBase`1">
      <summary>
      </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.CollectionBase`1">
      <summary>
            Base class (abstract) for ICollection implementations.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.CollectionValueBase`1">
      <summary>
            Base class for classes implementing ICollectionValue[T]
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.EnumerableBase`1">
      <summary>
            A base class for implementing an IEnumerable&lt;T&gt;
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.EnumerableBase`1.GetEnumerator">
      <summary>
            Create an enumerator for this collection.
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.EnumerableBase`1.countItems(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Count the number of items in an enumerable by enumeration
            </summary>
      <param name="items">The enumerable to count</param>
      <returns>The size of the enumerable</returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ICollectionValue`1">
      <summary>
            A generic collection that may be enumerated and can answer
            efficiently how many items it contains. Like <code>IEnumerable&lt;T&gt;</code>,
            this interface does not prescribe any operations to initialize or update the 
            collection. The main usage for this interface is to be the return type of 
            query operations on generic collection.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IShowable">
      <summary>
        <i>(Describe usage of "L:300" format string.)</i>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IShowable.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
      <summary>
            Format <code>this</code> using at most approximately <code>rest</code> chars and 
            append the result, possibly truncated, to stringbuilder.
            Subtract the actual number of used chars from <code>rest</code>.
            </summary>
      <param name="stringbuilder">
      </param>
      <param name="rest">
      </param>
      <param name="formatProvider">
      </param>
      <returns>True if the appended formatted string was complete (not truncated).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollectionValue`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copy the items of this collection to a contiguous part of an array.
            </summary>
      <param name="array">The array to copy to</param>
      <param name="index">The index at which to copy the first item</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollectionValue`1.ToArray">
      <summary>
            Create an array with the items of this collection (in the same order as an
            enumerator would output them).
            </summary>
      <returns>The array</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollectionValue`1.Apply(System.Action{`0})">
      <summary>
            Apply a delegate to all items of this collection.
            </summary>
      <param name="action">The delegate to apply</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollectionValue`1.Exists(System.Func{`0,System.Boolean})">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection.
            </summary>
      <param name="predicate">A  delegate 
            (<see cref="T:Func`2" /> with <code>R == bool</code>) defining the predicate</param>
      <returns>True is such an item exists</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollectionValue`1.Find(System.Func{`0,System.Boolean},`0@)">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
      <param name="predicate">A delegate 
            (<see cref="T:Func`2" /> with <code>R == bool</code>) defining the predicate</param>
      <param name="item">
      </param>
      <returns>True is such an item exists</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollectionValue`1.All(System.Func{`0,System.Boolean})">
      <summary>
            Check if all items in this collection satisfies a specific predicate.
            </summary>
      <param name="predicate">A delegate 
            (<see cref="T:Func`2" /> with <code>R == bool</code>) defining the predicate</param>
      <returns>True if all items satisfies the predicate</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollectionValue`1.Choose">
      <summary>
            Choose some item of this collection. 
            <para>Implementations must assure that the item 
            returned may be efficiently removed.</para><para>Implementors may decide to implement this method in a way such that repeated
            calls do not necessarily give the same result, i.e. so that the result of the following 
            test is undetermined:
            <code>coll.Choose() == coll.Choose()</code></para></summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">if collection is empty.</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollectionValue`1.Filter(System.Func{`0,System.Boolean})">
      <summary>
            Create an enumerable, enumerating the items of this collection that satisfies 
            a certain condition.
            </summary>
      <param name="filter">The T-&gt;bool filter delegate defining the condition</param>
      <returns>The filtered enumerable</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ICollectionValue`1.ListenableEvents">
      <summary>
            A flag bitmap of the events subscribable to by this collection.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ICollectionValue`1.ActiveEvents">
      <summary>
            A flag bitmap of the events currently subscribed to by this collection.
            </summary>
      <value>
      </value>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.ICollectionValue`1.CollectionChanged">
      <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.ICollectionValue`1.CollectionCleared">
      <summary>
            The change event. Will be raised for every clear operation on the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.ICollectionValue`1.ItemsAdded">
      <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.ICollectionValue`1.ItemInserted">
      <summary>
            The item inserted  event. Will be raised for every individual insertion to the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.ICollectionValue`1.ItemsRemoved">
      <summary>
            The item removed event. Will be raised for every individual removal from the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.ICollectionValue`1.ItemRemovedAt">
      <summary>
            The item removed at event. Will be raised for every individual removal at from the collection.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ICollectionValue`1.IsEmpty">
      <summary>
      </summary>
      <value>True if this collection is empty.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ICollectionValue`1.Count">
      <summary>
      </summary>
      <value>The number of items in this collection</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ICollectionValue`1.CountSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
      <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseCollectionChanged">
      <summary>
            Fire the CollectionChanged event
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseCollectionCleared(System.Boolean,System.Int32)">
      <summary>
            Fire the CollectionCleared event
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseCollectionCleared(System.Boolean,System.Int32,System.Nullable{System.Int32})">
      <summary>
            Fire the CollectionCleared event
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseItemsAdded(`0,System.Int32)">
      <summary>
            Fire the ItemsAdded event
            </summary>
      <param name="item">The item that was added</param>
      <param name="count">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseItemsRemoved(`0,System.Int32)">
      <summary>
            Fire the ItemsRemoved event
            </summary>
      <param name="item">The item that was removed</param>
      <param name="count">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseItemInserted(`0,System.Int32)">
      <summary>
            Fire the ItemInserted event
            </summary>
      <param name="item">The item that was added</param>
      <param name="index">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseItemRemovedAt(`0,System.Int32)">
      <summary> 
            Fire the ItemRemovedAt event
            </summary>
      <param name="item">The item that was removed</param>
      <param name="index">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseForSetThis(System.Int32,`0,`0)">
      <summary>
      </summary>
      <param name="index">
      </param>
      <param name="value">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseForInsert(System.Int32,`0)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseForRemove(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseForRemove(`0,System.Int32)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="count">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseForRemoveAt(System.Int32,`0)">
      <summary>
      </summary>
      <param name="index">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseForUpdate(`0,`0)">
      <summary>
      </summary>
      <param name="newitem">
      </param>
      <param name="olditem">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseForUpdate(`0,`0,System.Int32)">
      <summary>
      </summary>
      <param name="newitem">
      </param>
      <param name="olditem">
      </param>
      <param name="count">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseForAdd(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.raiseForRemoveAll(NSoft.NFramework.Collections.C5.ICollectionValue{`0})">
      <summary>
      </summary>
      <param name="wasRemoved">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copy the items of this collection to part of an array.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException"> if <code>index</code> 
            is not a valid index
            into the array (i.e. negative or greater than the size of the array)
            or the array does not have room for the items.</exception>
      <param name="array">The array to copy to.</param>
      <param name="index">The starting index.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.ToArray">
      <summary>
            Create an array with the items of this collection (in the same order as an
            enumerator would output them).
            </summary>
      <returns>The array</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.Apply(System.Action{`0})">
      <summary>
            Apply an single argument action, <see cref="T:Action`1" /> to this enumerable
            </summary>
      <param name="action">The action delegate</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.Exists(System.Func{`0,System.Boolean})">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection.
            </summary>
      <param name="predicate">A delegate 
            (<see cref="T:Func`2" /> with <code>R = bool</code>) 
            defining the predicate</param>
      <returns>True if such an item exists</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.Find(System.Func{`0,System.Boolean},`0@)">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
      <param name="predicate">A delegate 
            (<see cref="T:Func`2" /> with <code>R == bool</code>) defining the predicate</param>
      <param name="item">
      </param>
      <returns>True is such an item exists</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.All(System.Func{`0,System.Boolean})">
      <summary>
            Check if all items in this collection satisfies a specific predicate.
            </summary>
      <param name="predicate">A delegate 
            (<see cref="T:Func`2" /> with <code>R = bool</code>) 
            defining the predicate</param>
      <returns>True if all items satisfies the predicate</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.Filter(System.Func{`0,System.Boolean})">
      <summary>
            Create an enumerable, enumerating the items of this collection that satisfies 
            a certain condition.
            </summary>
      <param name="predicate">A delegate 
            (<see cref="T:Func`2" /> with <code>R = bool</code>) 
            defining the predicate</param>
      <returns>The filtered enumerable</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.Choose">
      <summary>
            Choose some item of this collection. 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">if collection is empty.</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.GetEnumerator">
      <summary>
            Create an enumerator for this collection.
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="stringbuilder">
      </param>
      <param name="rest">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.ToString(System.String,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="format">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.ToString">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.CollectionValueBase`1.ListenableEvents">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.CollectionValueBase`1.ActiveEvents">
      <summary>
            A flag bitmap of the events currently subscribed to by this collection.
            </summary>
      <value>
      </value>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.CollectionValueBase`1.CollectionChanged">
      <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.CollectionValueBase`1.CollectionCleared">
      <summary>
            The clear event. Will be raised for every Clear operation on the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.CollectionValueBase`1.ItemsAdded">
      <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.CollectionValueBase`1.ItemsRemoved">
      <summary>
            The item removed event. Will be raised for every individual removal from the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.CollectionValueBase`1.ItemInserted">
      <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.CollectionValueBase`1.ItemRemovedAt">
      <summary>
            The item removed event. Will be raised for every individual removal from the collection.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.CollectionValueBase`1.IsEmpty">
      <summary>
            Check if collection is empty.
            </summary>
      <value>True if empty</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.CollectionValueBase`1.Count">
      <summary>
            The number of items in this collection.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.CollectionValueBase`1.CountSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
      <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.CollectionValueBase`1.RaiseForRemoveAllHandler">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.RaiseForRemoveAllHandler.#ctor(NSoft.NFramework.Collections.C5.CollectionValueBase{`0})">
      <summary>
      </summary>
      <param name="collection">
      </param>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.CollectionValueBase`1.RaiseForRemoveAllHandler.MustFire">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.RaiseForRemoveAllHandler.Remove(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionValueBase`1.RaiseForRemoveAllHandler.Raise">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.CollectionBase`1.isReadOnlyBase">
      <summary>
            The underlying field of the ReadOnly property
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.CollectionBase`1.stamp">
      <summary>
            The current stamp value
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.CollectionBase`1.size">
      <summary>
            The number of items in the collection
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.CollectionBase`1.itemequalityComparer">
      <summary>
            The item equalityComparer of the collection
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionBase`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
      </summary>
      <param name="itemequalityComparer">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionBase`1.checkRange(System.Int32,System.Int32)">
      <summary>
            Utility method for range checking.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the start or count is negative or
             if the range does not fit within collection size.</exception>
      <param name="start">start of range</param>
      <param name="count">size of range</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionBase`1.ComputeHashCode(NSoft.NFramework.Collections.C5.ICollectionValue{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Compute the unsequenced hash code of a collection
            </summary>
      <param name="items">The collection to compute hash code for</param>
      <param name="itemequalityComparer">The item equalitySCG.Comparer</param>
      <returns>The hash code</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionBase`1.StaticEquals(NSoft.NFramework.Collections.C5.ICollection{`0},NSoft.NFramework.Collections.C5.ICollection{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Examine if collection1 and collection2 are equal as unsequenced collections
            using the specified item equalityComparer (assumed compatible with the two collections).
            </summary>
      <param name="collection1">The first collection</param>
      <param name="collection2">The second collection</param>
      <param name="itemequalityComparer">The item equalityComparer to use for comparison</param>
      <returns>True if equal</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionBase`1.GetUnsequencedHashCode">
      <summary>
            Get the unsequenced collection hash code of this collection: from the cached 
            value if present and up to date, else (re)compute.
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionBase`1.UnsequencedEquals(NSoft.NFramework.Collections.C5.ICollection{`0})">
      <summary>
            Check if the contents of otherCollection is equal to the contents of this
            in the unsequenced sense.  Uses the item equality comparer of this collection
            </summary>
      <param name="otherCollection">The collection to compare to.</param>
      <returns>True if  equal</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionBase`1.modifycheck(System.Int32)">
      <summary>
            Check if the collection has been modified since a specified time, expressed as a stamp value.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.CollectionModifiedException"> if this collection has been updated 
            since a target time</exception>
      <param name="thestamp">The stamp identifying the target time</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionBase`1.updatecheck">
      <summary>
            Check if it is valid to perform update operations, and if so increment stamp.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException">If colection is read-only</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionBase`1.GetEnumerator">
      <summary>
            Create an enumerator for this collection.
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.CollectionBase`1.IsReadOnly">
      <summary>
      </summary>
      <value>True if this collection is read only</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.CollectionBase`1.Count">
      <summary>
      </summary>
      <value>The size of this collection</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.CollectionBase`1.CountSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
      <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.CollectionBase`1.EqualityComparer">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.CollectionBase`1.IsEmpty">
      <summary>
      </summary>
      <value>True if this collection is empty</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IDirectedCollectionValue`1">
      <summary>
            A sized generic collection, that can be enumerated backwards.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IDirectedEnumerable`1">
      <summary>
            A generic collection, that can be enumerated backwards.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDirectedEnumerable`1.Backwards">
      <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code></summary>
      <returns>The backwards collection.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IDirectedEnumerable`1.Direction">
      <summary>
        <code>Forwards</code> if same, else <code>Backwards</code></summary>
      <value>The enumeration direction relative to the original collection.</value>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDirectedCollectionValue`1.Backwards">
      <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code></summary>
      <returns>The backwards collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDirectedCollectionValue`1.FindLast(System.Func{`0,System.Boolean},`0@)">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
      <param name="predicate">A delegate 
            (<see cref="T:Func`2" /> with <code>R == bool</code>) defining the predicate</param>
      <param name="item">
      </param>
      <returns>True is such an item exists</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DirectedCollectionBase`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
      </summary>
      <param name="itemequalityComparer">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DirectedCollectionBase`1.Backwards">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DirectedCollectionBase`1.FindLast(System.Func{`0,System.Boolean},`0@)">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
      <param name="predicate">A delegate 
            (<see cref="T:Func`2" /> with <code>R == bool</code>) defining the predicate</param>
      <param name="item">
      </param>
      <returns>True is such an item exists</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DirectedCollectionBase`1.Direction">
      <summary>
        <code>Forwards</code> if same, else <code>Backwards</code></summary>
      <value>The enumeration direction relative to the original collection.</value>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SequencedBase`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
      </summary>
      <param name="itemequalityComparer">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SequencedBase`1.ComputeHashCode(NSoft.NFramework.Collections.C5.ISequenced{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Compute the unsequenced hash code of a collection
            </summary>
      <param name="items">The collection to compute hash code for</param>
      <param name="itemequalityComparer">The item equalitySCG.Comparer</param>
      <returns>The hash code</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SequencedBase`1.StaticEquals(NSoft.NFramework.Collections.C5.ISequenced{`0},NSoft.NFramework.Collections.C5.ISequenced{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Examine if tit and tat are equal as sequenced collections
            using the specified item equalityComparer (assumed compatible with the two collections).
            </summary>
      <param name="collection1">The first collection</param>
      <param name="collection2">The second collection</param>
      <param name="itemequalityComparer">The item equalityComparer to use for comparison</param>
      <returns>True if equal</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SequencedBase`1.GetSequencedHashCode">
      <summary>
            Get the sequenced collection hash code of this collection: from the cached 
            value if present and up to date, else (re)compute.
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SequencedBase`1.SequencedEquals(NSoft.NFramework.Collections.C5.ISequenced{`0})">
      <summary>
            Check if the contents of that is equal to the contents of this
            in the sequenced sense. Using the item equalityComparer of this collection.
            </summary>
      <param name="otherCollection">The collection to compare to.</param>
      <returns>True if  equal</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SequencedBase`1.GetEnumerator">
      <summary>
            Create an enumerator for this collection.
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SequencedBase`1.FindIndex(System.Func{`0,System.Boolean})">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the first one.
            </summary>
      <param name="predicate">A delegate defining the predicate</param>
      <returns>the index, if found, a negative value else</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SequencedBase`1.FindLastIndex(System.Func{`0,System.Boolean})">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the last one.
            </summary>
      <param name="predicate">A delegate defining the predicate</param>
      <returns>the index, if found, a negative value else</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.SequencedBase`1.Direction">
      <summary>
        <code>Forwards</code> if same, else <code>Backwards</code></summary>
      <value>The enumeration direction relative to the original collection.</value>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.ArrayBase`1.array">
      <summary>
            The actual internal array container. Will be extended on demand.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.ArrayBase`1.offset">
      <summary>
            The offset into the internal array container of the first item. The offset is 0 for a 
            base dynamic array and may be positive for an updatable view into a base dynamic array.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayBase`1.expand">
      <summary>
            Double the size of the internal array.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayBase`1.expand(System.Int32,System.Int32)">
      <summary>
            Expand the internal array container.
            </summary>
      <param name="newcapacity">The new size of the internal array - 
            will be rounded upwards to a power of 2.</param>
      <param name="newsize">The (new) size of the (base) collection.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayBase`1.insert(System.Int32,`0)">
      <summary>
            Insert an item at a specific index, moving items to the right
            upwards and expanding the array if necessary.
            </summary>
      <param name="i">The index at which to insert.</param>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayBase`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create an empty ArrayBase object.
            </summary>
      <param name="capacity">The initial capacity of the internal array container.
            Will be rounded upwards to the nearest power of 2 greater than or equal to 8.</param>
      <param name="itemequalityComparer">The item equalityComparer to use, primarily for item equality</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayBase`1.Clear">
      <summary>
            Remove all items and reset size of internal array container.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayBase`1.ToArray">
      <summary>
            Create an array containing (copies) of the items of this collection in enumeration order.
            </summary>
      <returns>The new array</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayBase`1.Check">
      <summary>
            Perform an internal consistency (invariant) test on the array base.
            </summary>
      <returns>True if test succeeds.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayBase`1.Backwards">
      <summary>
            Create a directed collection with the same contents as this one, but 
            opposite enumeration sequence.
            </summary>
      <returns>The mirrored collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayBase`1.Choose">
      <summary>
            Choose some item of this collection. The result is the last item in the internal array,
            making it efficient to remove.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">if collection is empty.</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayBase`1.GetEnumerator">
      <summary>
            Create an enumerator for this array based collection.
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayBase`1.Item(System.Int32,System.Int32)">
      <summary>
      </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">If the arguments does not describe a 
            valid range in the indexed collection, cf. <see cref="M:C5.CollectionBase`1.checkRange(System.Int32,System.Int32)" />.</exception>
      <value>The directed collection of items in a specific index interval.</value>
      <param name="start">The low index of the interval (inclusive).</param>
      <param name="count">The size of the range.</param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ArrayBase`1.Range">
      <summary>
            A helper class for defining results of interval queries on array based collections.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.DirectedCollectionValueBase`1">
      <summary>
      </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DirectedCollectionValueBase`1.Backwards">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DirectedCollectionValueBase`1.FindLast(System.Func{`0,System.Boolean},`0@)">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
      <param name="predicate">A delegate 
            (<see cref="T:Func`2" /> with <code>R == bool</code>) defining the predicate</param>
      <param name="item">
      </param>
      <returns>True is such an item exists</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DirectedCollectionValueBase`1.Direction">
      <summary>
        <code>Forwards</code> if same, else <code>Backwards</code></summary>
      <value>The enumeration direction relative to the original collection.</value>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayBase`1.Range.Choose">
      <summary>
            Choose some item of this collection. 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.CollectionModifiedException">if underlying collection has been modified.</exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">if range is empty.</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayBase`1.Range.GetEnumerator">
      <summary>
            Create an enumerator for this range of an array based collection.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.CollectionModifiedException">if underlying collection has been modified.</exception>
      <returns>The enumerator</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayBase`1.Range.Backwards">
      <summary>
            Create a araay collection range with the same contents as this one, but 
            opposite enumeration sequence.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.CollectionModifiedException">if underlying collection has been modified.</exception>
      <returns>The mirrored collection.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayBase`1.Range.IsEmpty">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.CollectionModifiedException">if underlying collection has been modified.</exception>
      <value>True if this collection is empty.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayBase`1.Range.Count">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.CollectionModifiedException">if underlying collection has been modified.</exception>
      <value>The number of items in the range</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayBase`1.Range.CountSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
      <value>A characterization of the speed of the 
            <exception cref="T:NSoft.NFramework.Collections.C5.CollectionModifiedException">if underlying collection has been modified.</exception><code>Count</code> property in this collection.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayBase`1.Range.Direction">
      <summary>
        <code>Forwards</code> if same, else <code>Backwards</code></summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.CollectionModifiedException">if underlying collection has been modified.</exception>
      <value>The enumeration direction relative to the original collection.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IList`1">
      <summary>
             This is an indexed collection, where the item order is chosen by 
             the user at insertion time.
            
             NBNBNB: we need a description of the view functionality here!
             </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IIndexed`1">
      <summary>
            A sequenced collection, where indices of items in the order are maintained
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ISequenced`1">
      <summary>
             An editable collection maintaining a definite sequence order of the items.
            
             <i>Implementations of this interface must compute the hash code and 
             equality exactly as prescribed in the method definitions in order to
             be consistent with other collection classes implementing this interface.</i><i>This interface is usually implemented by explicit interface implementation,
             not as ordinary virtual methods.</i></summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ICollection`1">
      <summary>
            The simplest interface of a main stream generic collection
            with lookup, insertion and removal operations. 
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IExtensible`1">
      <summary>
            A generic collection to which one may add items. This is just the intersection
            of the main stream generic collection interfaces and the priority queue interface,
            <see cref="T:C5.ICollection`1" /> and <see cref="T:C5.IPriorityQueue`1" />.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IExtensible`1.Add(`0)">
      <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
      <param name="item">The item to add.</param>
      <returns>True if item was added.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IExtensible`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
      <param name="items">The items to add</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IExtensible`1.Check">
      <summary>
            Check the integrity of the internal data structures of this collection.
            <i>This is only relevant for developers of the library</i></summary>
      <returns>True if check was passed.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IExtensible`1.IsReadOnly">
      <summary>
            If true any call of an updating operation will throw an
            <code>ReadOnlyCollectionException</code></summary>
      <value>True if this collection is read-only.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IExtensible`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>False if this collection has set semantics, true if bag semantics.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IExtensible`1.EqualityComparer">
      <summary>
            (Here should be a discussion of the role of equalityComparers. Any ). 
            </summary>
      <value>The equalityComparer used by this collection to check equality of items. 
            Or null (????) if collection does not check equality at all or uses a comparer.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IExtensible`1.DuplicatesByCounting">
      <summary>
            By convention this is true for any collection with set semantics.
            </summary>
      <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.Add(`0)">
      <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
      <param name="item">The item to add.</param>
      <returns>True if item was added.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copy the items of this collection to a contiguous part of an array.
            </summary>
      <param name="array">The array to copy to</param>
      <param name="index">The index at which to copy the first item</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.GetUnsequencedHashCode">
      <summary>
            The unordered collection hashcode is defined as the sum of 
            <code>h(hashcode(item))</code> over the items
            of the collection, where the function <code>h</code> is a function from 
            int to int of the form <code> t -&gt; (a0*t+b0)^(a1*t+b1)^(a2*t+b2)</code>, where 
            the ax and bx are the same for all collection classes. 
            <para>The current implementation uses fixed values for the ax and bx, 
            specified as constants in the code.</para></summary>
      <returns>The unordered hashcode of this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.UnsequencedEquals(NSoft.NFramework.Collections.C5.ICollection{`0})">
      <summary>
            Compare the contents of this collection to another one without regards to
            the sequence order. The comparison will use this collection's itemequalityComparer
            to compare individual items.
            </summary>
      <param name="otherCollection">The collection to compare to.</param>
      <returns>True if this collection and that contains the same items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.Contains(`0)">
      <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
      <param name="item">The value to check for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.ContainsCount(`0)">
      <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
      <param name="item">The value to count.</param>
      <returns>The number of copies found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.UniqueItems">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.ItemMultiplicities">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Check whether this collection contains all the values in another collection.
            If this collection has bag semantics (<code>AllowsDuplicates==true</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
      <param name="items">The </param>
      <returns>True if all values in <code>items</code>is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.Find(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.FindOrAdd(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the item was found (hence not added).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.Update(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            with a (binary copy of) the supplied value. If the collection has bag semantics,
            it depends on the value of DuplicatesByCounting if this updates all equivalent copies in
            the collection or just one.
            </summary>
      <param name="item">Value to update.</param>
      <returns>True if the item was found and hence updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.Update(`0,`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            with a (binary copy of) the supplied value. If the collection has bag semantics,
            it depends on the value of DuplicatesByCounting if this updates all equivalent copies in
            the collection or just one.
            </summary>
      <param name="item">Value to update.</param>
      <param name="olditem">On output the olditem, if found.</param>
      <returns>True if the item was found and hence updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.UpdateOrAdd(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
      <param name="item">Value to add or update.</param>
      <returns>True if the item was found and updated (hence not added).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.UpdateOrAdd(`0,`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
      <param name="item">Value to add or update.</param>
      <param name="olditem">On output the olditem, if found.</param>
      <returns>True if the item was found and updated (hence not added).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.Remove(`0)">
      <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
      <param name="item">The value to remove.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.Remove(`0,`0@)">
      <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
      <param name="item">The value to remove.</param>
      <param name="removeditem">The value removed if any.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.RemoveAllCopies(`0)">
      <summary>
            Remove all items equivalent to a given value.
            </summary>
      <param name="item">The value to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items in another collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
      <param name="items">The items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.Clear">
      <summary>
            Remove all items from this collection.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ICollection`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items not in some other collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
      <param name="items">The items to retain.</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ICollection`1.ContainsSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant). 
            <para>See <see cref="T:C5.Speed" /> for the set of symbols.</para></summary>
      <value>A characterization of the speed of lookup operations
            (<code>Contains()</code> etc.) of the implementation of this collection.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ICollection`1.Count">
      <summary>
      </summary>
      <value>The number of items in this collection</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ICollection`1.IsReadOnly">
      <summary>
            If true any call of an updating operation will throw an
            <code>ReadOnlyCollectionException</code></summary>
      <value>True if this collection is read-only.</value>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISequenced`1.GetSequencedHashCode">
      <summary>
            The hashcode is defined as <code>h(...h(h(h(x1),x2),x3),...,xn)</code> for
            <code>h(a,b)=CONSTANT*a+b</code> and the x's the hash codes of the items of 
            this collection.
            </summary>
      <returns>The sequence order hashcode of this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISequenced`1.SequencedEquals(NSoft.NFramework.Collections.C5.ISequenced{`0})">
      <summary>
            Compare this sequenced collection to another one in sequence order.
            </summary>
      <param name="otherCollection">The sequenced collection to compare to.</param>
      <returns>True if this collection and that contains equal (according to
            this collection's itemequalityComparer) in the same sequence order.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexed`1.IndexOf(`0)">
      <summary>
            Searches for an item in the list going forwards from the start. 
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of item from start. A negative number if item not found, 
            namely the one's complement of the index at which the Add operation would put the item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexed`1.LastIndexOf(`0)">
      <summary>
            Searches for an item in the list going backwards from the end.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of of item from the end. A negative number if item not found, 
            namely the two-complement of the index at which the Add operation would put the item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexed`1.FindIndex(System.Func{`0,System.Boolean})">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the first one.
            </summary>
      <param name="predicate">A delegate 
            (<see cref="T:Func`2" /> with <code>R == bool</code>) defining the predicate</param>
      <returns>the index, if found, a negative value else</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexed`1.FindLastIndex(System.Func{`0,System.Boolean})">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the last one.
            </summary>
      <param name="predicate">A delegate 
            (<see cref="T:Func`2" /> with <code>R == bool</code>) defining the predicate</param>
      <returns>the index, if found, a negative value else</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexed`1.RemoveAt(System.Int32)">
      <summary>
            Remove the item at a specific position of the list.
            </summary>
      <exception cref="T:System.IndexOutOfRangeException"> if <code>index</code> is negative or
            &gt;= the size of the collection.</exception>
      <param name="index">The index of the item to remove.</param>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexed`1.RemoveInterval(System.Int32,System.Int32)">
      <summary>
            Remove all items in an index interval.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException"> if start or count 
            is negative or start+count &gt; the size of the collection.</exception>
      <param name="start">The index of the first item to remove.</param>
      <param name="count">The number of items to remove.</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IIndexed`1.Item(System.Int32)">
      <summary>
      </summary>
      <exception cref="T:System.IndexOutOfRangeException"> if <code>index</code> is negative or
            &gt;= the size of the collection.</exception>
      <value>The <code>index</code>'th item of this list.</value>
      <param name="index">the index to lookup</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IIndexed`1.IndexingSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IIndexed`1.Item(System.Int32,System.Int32)">
      <summary>
      </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">
      </exception>
      <value>The directed collection of items in a specific index interval.</value>
      <param name="start">The low index of the interval (inclusive).</param>
      <param name="count">The size of the range.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Add(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Clear">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Contains(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.CopyTo(`0[],System.Int32)">
      <summary>
      </summary>
      <param name="array">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Remove(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.IndexOf(`0)">
      <summary>
            Searches for an item in the list going forwards from the start. 
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of item from start. A negative number if item not found, 
            namely the one's complement of the index at which the Add operation would put the item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.RemoveAt(System.Int32)">
      <summary>
            Remove the item at a specific position of the list.
            </summary>
      <exception cref="T:System.IndexOutOfRangeException"> if <code>index</code> is negative or
            &gt;= the size of the collection.</exception>
      <param name="index">The index of the item to remove.</param>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Insert(NSoft.NFramework.Collections.C5.IList{`0},`0)">
      <summary>
            Insert an item at the end of a compatible view, used as a pointer.
            <para>The <code>pointer</code> must be a view on the same list as
            <code>this</code> and the endpoitn of <code>pointer</code> must be
            a valid insertion point of <code>this</code></para></summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.IncompatibleViewException">If <code>pointer</code> 
            is not a view on the same list as <code>this</code></exception>
      <exception cref="T:System.IndexOutOfRangeException">
        <b>??????</b> if the endpoint of 
             <code>pointer</code> is not inside <code>this</code></exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.</exception>
      <param name="pointer">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.InsertFirst(`0)">
      <summary>
            Insert an item at the front of this list.
            <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException" /> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.
            </summary>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.InsertLast(`0)">
      <summary>
            Insert an item at the back of this list.
            <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException" /> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.
            </summary>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            </summary>
      <exception cref="T:System.IndexOutOfRangeException"> if <code>index</code> is negative or
            &gt; the size of the collection.</exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> if the list has 
            <code>AllowsDuplicates==false</code> and one of the items to insert is
            already in the list.</exception>
      <param name="index">Index to start inserting at</param>
      <param name="items">Items to insert</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            </summary>
      <param name="filter">The filter delegate defining the predicate.</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Map``1(System.Func{`0,``0})">
      <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use the default equalityComparer for the item type V.
            </summary>
      <typeparam name="V">The type of items of the new list</typeparam>
      <param name="mapper">The delegate defining the map.</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified equalityComparer for the item type.
            </summary>
      <typeparam name="V">The type of items of the new list</typeparam>
      <param name="mapper">The delegate defining the map.</param>
      <param name="equalityComparer">The equalityComparer to use for the new list</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Remove">
      <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if this list is empty.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.RemoveFirst">
      <summary>
            Remove one item from the front of the list.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if this list is empty.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.RemoveLast">
      <summary>
            Remove one item from the back of the list.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if this list is empty.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.View(System.Int32,System.Int32)">
      <summary>
            Create a list view on this list. 
            <exception cref="T:System.ArgumentOutOfRangeException" /> if the view would not fit into
            this list.
            </summary>
      <param name="start">The index in this list of the start of the view.</param>
      <param name="count">The size of the view.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.ViewOf(`0)">
      <summary>
            Create a list view on this list containing the (first) occurrence of a particular item. 
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if the item is not in this list.
            </summary>
      <param name="item">The item to find.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.LastViewOf(`0)">
      <summary>
            Create a list view on this list containing the last occurrence of a particular item. 
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if the item is not in this list.
            </summary>
      <param name="item">The item to find.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Slide(System.Int32)">
      <summary>
            Slide this list view along the underlying list.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
      <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Slide(System.Int32,System.Int32)">
      <summary>
            Slide this list view along the underlying list, changing its size.
            
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
      <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
      <param name="size">The new size of the view.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.TrySlide(System.Int32)">
      <summary>
      </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.TrySlide(System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="offset">
      </param>
      <param name="size">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Span(NSoft.NFramework.Collections.C5.IList{`0})">
      <summary>
        <para>Returns null if <code>otherView</code> is strictly to the left of this view</para>
      </summary>
      <param name="otherView">
      </param>
      <exception cref="T:NSoft.NFramework.Collections.C5.IncompatibleViewException">If otherView does not have the same underlying list as this</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">If <code>otherView</code> is strictly to the left of this view</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Reverse">
      <summary>
            Reverse the list so the items are in the opposite sequence order.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.IsSorted">
      <summary>
            Check if this list is sorted according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1" /> class 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotComparableException">if T is not comparable</exception>
      <returns>True if the list is sorted, else false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.IsSorted(System.Collections.Generic.IComparer{`0})">
      <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
      <param name="comparer">The comparer defining the sorting order.</param>
      <returns>True if the list is sorted, else false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Sort">
      <summary>
            Sort the items of the list according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1" /> class 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotComparableException">if T is not comparable</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Sort(System.Collections.Generic.IComparer{`0})">
      <summary>
            Sort the items of the list according to a specified sorting order.
            <para>The sorting does not perform duplicate elimination or identify items
            according to the comparer or itemequalityComparer. I.e. the list as an 
            unsequenced collection with binary equality, will not change.
            </para></summary>
      <param name="comparer">The comparer defining the sorting order.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Shuffle">
      <summary>
            Randomly shuffle the items of this list. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IList`1.Shuffle(System.Random)">
      <summary>
            Shuffle the items of this list according to a specific random source.
            </summary>
      <param name="rnd">The random source.</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IList`1.First">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <value>The first item in this list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IList`1.Last">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <value>The last item in this list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IList`1.FIFO">
      <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
      <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IList`1.IsFixedSize">
      <summary>
      </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IList`1.Item(System.Int32)">
      <summary>
            On this list, this indexer is read/write.
            </summary>
      <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt;= the size of the collection.</exception>
      <value>The index'th item of this list.</value>
      <param name="index">The index of the item to fetch or store.</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IList`1.Count">
      <summary>
      </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IList`1.IsReadOnly">
      <summary>
      </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IList`1.Underlying">
      <summary>
            Null if this list is not a view.
            </summary>
      <value>Underlying list for view.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IList`1.Offset">
      <summary>
      </summary>
      <value>Offset for this list view or 0 for an underlying list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IList`1.IsValid">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IStack`1">
      <summary>
            The interface describing the operations of a LIFO stack data structure.
            </summary>
      <typeparam name="T">The item type</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IStack`1.Push(`0)">
      <summary>
            Push an item to the top of the stack.
            </summary>
      <param name="item">The item</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IStack`1.Pop">
      <summary>
            Pop the item at the top of the stack from the stack.
            </summary>
      <returns>The popped item.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IStack`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IStack`1.Item(System.Int32)">
      <summary>
            Get the <code>index</code>'th element of the stack.  The bottom of the stack has index 0.
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IQueue`1">
      <summary>
            The interface describing the operations of a FIFO queue data structure.
            </summary>
      <typeparam name="T">The item type</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IQueue`1.Enqueue(`0)">
      <summary>
            Enqueue an item at the back of the queue. 
            </summary>
      <param name="item">The item</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IQueue`1.Dequeue">
      <summary>
            Dequeue an item from the front of the queue.
            </summary>
      <returns>The item</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IQueue`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IQueue`1.Item(System.Int32)">
      <summary>
            Get the <code>index</code>'th element of the queue.  The front of the queue has index 0.
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.expand">
      <summary>
            Double the size of the internal array.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.expand(System.Int32,System.Int32)">
      <summary>
            Expand the internal array, resetting the index of the first unused element.
            </summary>
      <param name="newcapacity">The new capacity (will be rouded upwards to a power of 2).</param>
      <param name="newsize">The new count of </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.updatecheck">
      <summary>
            Check if it is valid to perform updates and increment stamp if so.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ViewDisposedException"> If check fails by this list being a disposed view.</exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> If check fails by this being a read only list.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.modifycheck(System.Int32)">
      <summary>
            Check that the list has not been updated since a particular time.
            <para>To be used by enumerators and range </para></summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ViewDisposedException"> If check fails by this list being a disposed view.</exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.CollectionModifiedException">If the list *has* beeen updated since that  time..</exception>
      <param name="stamp">The stamp indicating the time.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.insert(System.Int32,`0)">
      <summary>
            Internal version of Insert with no modification checks.
            </summary>
      <param name="i">Index to insert at</param>
      <param name="item">Item to insert</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.#ctor">
      <summary>
            Create an array list with default item equalityComparer and initial capacity 8 items.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create an array list with external item equalityComparer and initial capacity 8 items.
            </summary>
      <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.#ctor(System.Int32)">
      <summary>
            Create an array list with default item equalityComparer and prescribed initial capacity.
            </summary>
      <param name="capacity">The prescribed capacity</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create an array list with external item equalityComparer and prescribed initial capacity.
            </summary>
      <param name="capacity">The prescribed capacity</param>
      <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Insert(System.Int32,`0)">
      <summary>
             Insert an item at a specific index location in this list. 
            </summary>
      <exception cref="T:System.IndexOutOfRangeException"> if i is negative or
             &gt; the size of the collection. </exception>
      <param name="index">The index at which to insert.</param>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Insert(NSoft.NFramework.Collections.C5.IList{`0},`0)">
      <summary>
            Insert an item at the end of a compatible view, used as a pointer.
            <para>The <code>pointer</code> must be a view on the same list as
            <code>this</code> and the endpoitn of <code>pointer</code> must be
            a valid insertion point of <code>this</code></para></summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.IncompatibleViewException">If <code>pointer</code> 
            is not a view on or the same list as <code>this</code></exception>
      <exception cref="T:System.IndexOutOfRangeException">
        <b>??????</b> if the endpoint of 
             <code>pointer</code> is not inside <code>this</code></exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.</exception>
      <param name="pointer">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            </summary>
      <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt; the size of the collection.</exception>
      <param name="index">Index to start inserting at</param>
      <param name="items">Items to insert</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.InsertFirst(`0)">
      <summary>
            Insert an item at the front of this list;
            </summary>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.InsertLast(`0)">
      <summary>
            Insert an item at the back of this list.
            </summary>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            <para>The new list will be of type ArrayList</para></summary>
      <param name="filter">The filter delegate defining the predicate.</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Map``1(System.Func{`0,``0})">
      <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use the default item equalityComparer for the item type V.
            <para>The new list will be of type ArrayList</para></summary>
      <typeparam name="V">The type of items of the new list</typeparam>
      <param name="mapper">The delegate defining the map.</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified item equalityComparer for the item type.
            <para>The new list will be of type ArrayList</para></summary>
      <typeparam name="V">The type of items of the new list</typeparam>
      <param name="mapper">The delegate defining the map.</param>
      <param name="itemequalityComparer">The item equalityComparer to use for the new list</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Remove">
      <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.RemoveFirst">
      <summary>
            Remove one item from the fromnt of the list.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.RemoveLast">
      <summary>
            Remove one item from the back of the list.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.View(System.Int32,System.Int32)">
      <summary>
            Create a list view on this list. 
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the start or count is negative
            or the range does not fit within list.</exception>
      <param name="start">The index in this list of the start of the view.</param>
      <param name="count">The size of the view.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.ViewOf(`0)">
      <summary>
            Create a list view on this list containing the (first) occurrence of a particular item.
            <para>Returns <code>null</code> if the item is not in this list.</para></summary>
      <param name="item">The item to find.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.LastViewOf(`0)">
      <summary>
            Create a list view on this list containing the last occurrence of a particular item. 
            <para>Returns <code>null</code> if the item is not in this list.</para></summary>
      <param name="item">The item to find.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Slide(System.Int32)">
      <summary>
            Slide this list view along the underlying list.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
      <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Slide(System.Int32,System.Int32)">
      <summary>
            Slide this list view along the underlying list, changing its size.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
      <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
      <param name="size">The new size of the view.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.TrySlide(System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.TrySlide(System.Int32,System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <param name="offset">
      </param>
      <param name="size">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Span(NSoft.NFramework.Collections.C5.IList{`0})">
      <summary>
        <para>Returns null if <code>otherView</code> is strictly to the left of this view</para>
      </summary>
      <param name="otherView">
      </param>
      <exception cref="T:NSoft.NFramework.Collections.C5.IncompatibleViewException">If otherView does not have the same underlying list as this</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Reverse">
      <summary>
            Reverst the list so the items are in the opposite sequence order.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.IsSorted">
      <summary>
            Check if this list is sorted according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1" /> class 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotComparableException">if T is not comparable</exception>
      <returns>True if the list is sorted, else false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.IsSorted(System.Collections.Generic.IComparer{`0})">
      <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
      <param name="c">The comparer defining the sorting order.</param>
      <returns>True if the list is sorted, else false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Sort">
      <summary>
            Sort the items of the list according to the default sorting order
            for the item type T, as defined by the Comparer[T] class 
            (<see cref="T:C5.Comparer`1" />).
            </summary>
      <exception cref="T:System.InvalidOperationException">if T is not comparable</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Sort(System.Collections.Generic.IComparer{`0})">
      <summary>
            Sort the items of the list according to a specific sorting order.
            </summary>
      <param name="comparer">The comparer defining the sorting order.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Shuffle">
      <summary>
            Randomly shuffle the items of this list. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Shuffle(System.Random)">
      <summary>
            Shuffle the items of this list according to a specific random source.
            </summary>
      <param name="rnd">The random source.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.IndexOf(`0)">
      <summary>
            Search for an item in the list going forwrds from the start.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of item from start.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.LastIndexOf(`0)">
      <summary>
            Search for an item in the list going backwords from the end.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of item from the end.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.RemoveAt(System.Int32)">
      <summary>
            Remove the item at a specific position of the list.
            </summary>
      <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt;= the size of the collection.</exception>
      <param name="index">The index of the item to remove.</param>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.RemoveInterval(System.Int32,System.Int32)">
      <summary>
            Remove all items in an index interval.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">If <code>start</code>
            and <code>count</code> does not describe a valid interval in the list</exception>
      <param name="start">The index of the first item to remove.</param>
      <param name="count">The number of items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.GetUnsequencedHashCode">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.UnsequencedEquals(NSoft.NFramework.Collections.C5.ICollection{`0})">
      <summary>
      </summary>
      <param name="that">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Contains(`0)">
      <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
      <param name="item">The value to check for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Find(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Update(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. This will only update the first 
            mathching item.
            </summary>
      <param name="item">Value to update.</param>
      <returns>True if the item was found and hence updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Update(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.FindOrAdd(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the item was found (hence not added).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.UpdateOrAdd(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. This will only update the first 
            mathching item.
            </summary>
      <param name="item">Value to update.</param>
      <returns>True if the item was found and hence updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.UpdateOrAdd(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Remove(`0)">
      <summary>
            Remove a particular item from this list. The item will be searched 
            for from the end of the list if <code>FIFO == false</code> (the default), 
            else from the start.
            </summary>
      <param name="item">The value to remove.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Remove(`0,`0@)">
      <summary>
            Remove the first copy of a particular item from this collection if found.
            If an item was removed, report a binary copy of the actual item removed in 
            the argument. The item will be searched 
            for from the end of the list if <code>FIFO == false</code> (the default), 
            else from the start.
            </summary>
      <param name="item">The value to remove.</param>
      <param name="removeditem">The removed value.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items in another collection from this one, taking multiplicities into account.
            Matching items will be removed from the front. Current implementation is not optimal.
            </summary>
      <param name="items">The items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Clear">
      <summary>
            Remove all items from this collection, resetting internal array size.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items not in some other collection from this one, taking multiplicities into account.
            Items are retained front first.  
            </summary>
      <param name="items">The items to retain.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Check if this collection contains all the values in another collection,
            taking multiplicities into account.
            Current implementation is not optimal.
            </summary>
      <param name="items">The </param>
      <returns>True if all values in <code>items</code>is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.ContainsCount(`0)">
      <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
      <param name="item">The value to count.</param>
      <returns>The number of copies found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.UniqueItems">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.ItemMultiplicities">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.RemoveAllCopies(`0)">
      <summary>
            Remove all items equal to a given one.
            </summary>
      <param name="item">The value to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Check">
      <summary>
            Check the integrity of the internal data structures of this array list.
            </summary>
      <returns>True if check does not fail.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Add(`0)">
      <summary>
            Add an item to end of this list.
            </summary>
      <param name="item">The item to add.</param>
      <returns>True</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add the elements from another collection to this collection.
            </summary>
      <param name="items">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.GetEnumerator">
      <summary>
            Create an enumerator for the collection
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Push(`0)">
      <summary>
            Push an item to the top of the stack.
            </summary>
      <param name="item">The item</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Pop">
      <summary>
            Pop the item at the top of the stack from the stack.
            </summary>
      <returns>The popped item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Enqueue(`0)">
      <summary>
            Enqueue an item at the back of the queue. 
            </summary>
      <param name="item">The item</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Dequeue">
      <summary>
            Dequeue an item from the front of the queue.
            </summary>
      <returns>The item</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ArrayList`1.Dispose">
      <summary>
            Invalidate this list. If a view, just invalidate the view. 
            If not a view, invalidate the list and all views on it.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.ListenableEvents">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.First">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <value>The first item in this list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.Last">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <value>The last item in this list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.FIFO">
      <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
      <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end. The default for a new array list is false.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.IsFixedSize">
      <summary>
      </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.Item(System.Int32)">
      <summary>
            On this list, this indexer is read/write.
            </summary>
      <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt;= the size of the collection.</exception>
      <value>The index'th item of this list.</value>
      <param name="index">The index of the item to fetch or store.</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.IndexingSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.Underlying">
      <summary>
            Null if this list is not a view.
            </summary>
      <value>Underlying list for view.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.Offset">
      <summary>
      </summary>
      <value>Offset for this list view or 0 for an underlying list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.IsValid">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.ContainsSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
      <value>Speed.Linear</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>True, indicating array list has bag semantics.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.DuplicatesByCounting">
      <summary>
            By convention this is true for any collection with set semantics.
            </summary>
      <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ArrayList`1.Count">
      <summary>
      </summary>
      <value>The number of items in this collection</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.CircularQueue`1">
      <summary>
      </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CircularQueue`1.#ctor">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CircularQueue`1.#ctor(System.Int32)">
      <summary>
      </summary>
      <param name="capacity">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CircularQueue`1.Enqueue(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CircularQueue`1.Dequeue">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CircularQueue`1.Push(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CircularQueue`1.Pop">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CircularQueue`1.Choose">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CircularQueue`1.GetEnumerator">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CircularQueue`1.Backwards">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CircularQueue`1.Check">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.CircularQueue`1.ListenableEvents">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.CircularQueue`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.CircularQueue`1.Item(System.Int32)">
      <summary>
            Get the i'th item in the queue. The front of the queue is at index 0.
            </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.HashedArrayList`1">
      <summary>
             A list collection based on a plain dynamic array data structure.
             Expansion of the internal array is performed by doubling on demand. 
             The internal array is only shrinked by the Clear method. 
            
             <i>When the FIFO property is set to false this class works fine as a stack of T.
             When the FIFO property is set to true the class will function as a (FIFO) queue
             but very inefficiently, use a LinkedList (<see cref="T:C5.LinkedList`1" />) instead.</i></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.expand">
      <summary>
            Double the size of the internal array.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.expand(System.Int32,System.Int32)">
      <summary>
            Expand the internal array, resetting the index of the first unused element.
            </summary>
      <param name="newcapacity">The new capacity (will be rouded upwards to a power of 2).</param>
      <param name="newsize">The new count of </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.updatecheck">
      <summary>
            Check if it is valid to perform updates and increment stamp if so.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ViewDisposedException"> If check fails by this list being a disposed view.</exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> If check fails by this being a read only list.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.modifycheck(System.Int32)">
      <summary>
            Check that the list has not been updated since a particular time.
            <para>To be used by enumerators and range </para></summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ViewDisposedException"> If check fails by this list being a disposed view.</exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.CollectionModifiedException">If the list *has* beeen updated since that  time..</exception>
      <param name="stamp">The stamp indicating the time.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.insert(System.Int32,`0)">
      <summary>
            Internal version of Insert with no modification checks.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> if item already in list.</exception>
      <param name="i">Index to insert at</param>
      <param name="item">Item to insert</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.#ctor">
      <summary>
            Create an array list with default item equalityComparer and initial capacity 8 items.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create an array list with external item equalityComparer and initial capacity 8 items.
            </summary>
      <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.#ctor(System.Int32)">
      <summary>
            Create an array list with default item equalityComparer and prescribed initial capacity.
            </summary>
      <param name="capacity">The prescribed capacity</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create an array list with external item equalityComparer and prescribed initial capacity.
            </summary>
      <param name="capacity">The prescribed capacity</param>
      <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Insert(System.Int32,`0)">
      <summary>
             Insert an item at a specific index location in this list. 
            </summary>
      <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
             &gt; the size of the collection. </exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> 
             If the item is already present in the list.</exception>
      <param name="index">The index at which to insert.</param>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Insert(NSoft.NFramework.Collections.C5.IList{`0},`0)">
      <summary>
            Insert an item at the end of a compatible view, used as a pointer.
            <para>The <code>pointer</code> must be a view on the same list as
            <code>this</code> and the endpoitn of <code>pointer</code> must be
            a valid insertion point of <code>this</code></para></summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.IncompatibleViewException">If <code>pointer</code> 
            is not a view on or the same list as <code>this</code></exception>
      <exception cref="T:System.IndexOutOfRangeException">
        <b>??????</b> if the endpoint of 
             <code>pointer</code> is not inside <code>this</code></exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.</exception>
      <param name="pointer">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            </summary>
      <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt; the size of the collection.</exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> If <code>items</code> 
            contains duplicates or some item already  present in the list.</exception>
      <param name="index">Index to start inserting at</param>
      <param name="items">Items to insert</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.InsertFirst(`0)">
      <summary>
            Insert an item at the front of this list;
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException">If the item is already in the list</exception>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.InsertLast(`0)">
      <summary>
            Insert an item at the back of this list.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException">If the item is already in the list</exception>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            <para>The new list will be of type HashedArrayList</para></summary>
      <param name="filter">The filter delegate defining the predicate.</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Map``1(System.Func{`0,``0})">
      <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use the default item equalityComparer for the item type V.
            <para>The new list will be of type HashedArrayList</para></summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException">If <code>mapper</code>
            creates duplicates</exception>
      <typeparam name="V">The type of items of the new list</typeparam>
      <param name="mapper">The delegate defining the map.</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified item equalityComparer for the item type.
            <para>The new list will be of type HashedArrayList</para></summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException">If <code>mapper</code>
            creates duplicates</exception>
      <typeparam name="V">The type of items of the new list</typeparam>
      <param name="mapper">The delegate defining the map.</param>
      <param name="itemequalityComparer">The item equalityComparer to use for the new list</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Remove">
      <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.RemoveFirst">
      <summary>
            Remove one item from the fromnt of the list.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.RemoveLast">
      <summary>
            Remove one item from the back of the list.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.View(System.Int32,System.Int32)">
      <summary>
            Create a list view on this list. 
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the start or count is negative
            or the range does not fit within list.</exception>
      <param name="start">The index in this list of the start of the view.</param>
      <param name="count">The size of the view.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.ViewOf(`0)">
      <summary>
            Create a list view on this list containing the (first) occurrence of a particular item.
            <para>Returns <code>null</code> if the item is not in this list.</para></summary>
      <param name="item">The item to find.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.LastViewOf(`0)">
      <summary>
            Create a list view on this list containing the last occurrence of a particular item. 
            <para>Returns <code>null</code> if the item is not in this list.</para></summary>
      <param name="item">The item to find.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Slide(System.Int32)">
      <summary>
            Slide this list view along the underlying list.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
      <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Slide(System.Int32,System.Int32)">
      <summary>
            Slide this list view along the underlying list, changing its size.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
      <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
      <param name="size">The new size of the view.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.TrySlide(System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.TrySlide(System.Int32,System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <param name="offset">
      </param>
      <param name="size">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Span(NSoft.NFramework.Collections.C5.IList{`0})">
      <summary>
        <para>Returns null if <code>otherView</code> is strictly to the left of this view</para>
      </summary>
      <param name="otherView">
      </param>
      <exception cref="T:NSoft.NFramework.Collections.C5.IncompatibleViewException">If otherView does not have the same underlying list as this</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Reverse">
      <summary>
            Reverst the list so the items are in the opposite sequence order.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.IsSorted">
      <summary>
            Check if this list is sorted according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1" /> class 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotComparableException">if T is not comparable</exception>
      <returns>True if the list is sorted, else false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.IsSorted(System.Collections.Generic.IComparer{`0})">
      <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
      <param name="c">The comparer defining the sorting order.</param>
      <returns>True if the list is sorted, else false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Sort">
      <summary>
            Sort the items of the list according to the default sorting order
            for the item type T, as defined by the Comparer[T] class 
            (<see cref="T:C5.Comparer`1" />).
            </summary>
      <exception cref="T:System.InvalidOperationException">if T is not comparable</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Sort(System.Collections.Generic.IComparer{`0})">
      <summary>
            Sort the items of the list according to a specific sorting order.
            </summary>
      <param name="comparer">The comparer defining the sorting order.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Shuffle">
      <summary>
            Randomly shuffle the items of this list. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Shuffle(System.Random)">
      <summary>
            Shuffle the items of this list according to a specific random source.
            </summary>
      <param name="rnd">The random source.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.IndexOf(`0)">
      <summary>
            Search for an item in the list going forwrds from the start.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of item from start.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.LastIndexOf(`0)">
      <summary>
            Search for an item in the list going backwords from the end.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of item from the end.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.RemoveAt(System.Int32)">
      <summary>
            Remove the item at a specific position of the list.
            </summary>
      <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt;= the size of the collection.</exception>
      <param name="index">The index of the item to remove.</param>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.RemoveInterval(System.Int32,System.Int32)">
      <summary>
            Remove all items in an index interval.
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">If <code>start</code>
            and <code>count</code> does not describe a valid interval in the list</exception>
      <param name="start">The index of the first item to remove.</param>
      <param name="count">The number of items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.GetUnsequencedHashCode">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.UnsequencedEquals(NSoft.NFramework.Collections.C5.ICollection{`0})">
      <summary>
      </summary>
      <param name="that">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Contains(`0)">
      <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
      <param name="item">The value to check for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Find(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Update(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. This will only update the first 
            mathching item.
            </summary>
      <param name="item">Value to update.</param>
      <returns>True if the item was found and hence updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Update(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.FindOrAdd(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the item was found (hence not added).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.UpdateOrAdd(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. This will only update the first 
            mathching item.
            </summary>
      <param name="item">Value to update.</param>
      <returns>True if the item was found and hence updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.UpdateOrAdd(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Remove(`0)">
      <summary>
            Remove a particular item from this list. The item will be searched 
            for from the end of the list if <code>FIFO == false</code> (the default), 
            else from the start.
            </summary>
      <param name="item">The value to remove.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Remove(`0,`0@)">
      <summary>
            Remove the first copy of a particular item from this collection if found.
            If an item was removed, report a binary copy of the actual item removed in 
            the argument. The item will be searched 
            for from the end of the list if <code>FIFO == false</code> (the default), 
            else from the start.
            </summary>
      <param name="item">The value to remove.</param>
      <param name="removeditem">The removed value.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items in another collection from this one, taking multiplicities into account.
            Matching items will be removed from the front. Current implementation is not optimal.
            </summary>
      <param name="items">The items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Clear">
      <summary>
            Remove all items from this collection, resetting internal array size.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items not in some other collection from this one, taking multiplicities into account.
            Items are retained front first.  
            </summary>
      <param name="items">The items to retain.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Check if this collection contains all the values in another collection,
            taking multiplicities into account.
            Current implementation is not optimal.
            </summary>
      <param name="items">The </param>
      <returns>True if all values in <code>items</code>is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.ContainsCount(`0)">
      <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
      <param name="item">The value to count.</param>
      <returns>The number of copies found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.UniqueItems">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.ItemMultiplicities">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.RemoveAllCopies(`0)">
      <summary>
            Remove all items equal to a given one.
            </summary>
      <param name="item">The value to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Check">
      <summary>
            Check the integrity of the internal data structures of this array list.
            </summary>
      <returns>True if check does not fail.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Add(`0)">
      <summary>
            Add an item to end of this list.
            </summary>
      <param name="item">The item to add.</param>
      <returns>True</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add the elements from another collection to this collection.
            </summary>
      <param name="items">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.GetEnumerator">
      <summary>
            Create an enumerator for the collection
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedArrayList`1.Dispose">
      <summary>
            Invalidate this list. If a view, just invalidate the view. 
            If not a view, invalidate the list and all views on it.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.ListenableEvents">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.First">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <value>The first item in this list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.Last">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <value>The last item in this list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.FIFO">
      <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
      <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end. The default for a new array list is false.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.IsFixedSize">
      <summary>
      </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.Item(System.Int32)">
      <summary>
            On this list, this indexer is read/write.
            </summary>
      <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt;= the size of the collection.</exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> By the get operation
            if the item already is present somewhere else in the list.</exception>
      <value>The index'th item of this list.</value>
      <param name="index">The index of the item to fetch or store.</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.IndexingSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.Underlying">
      <summary>
            Null if this list is not a view.
            </summary>
      <value>Underlying list for view.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.Offset">
      <summary>
      </summary>
      <value>Offset for this list view or 0 for an underlying list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.IsValid">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.ContainsSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
      <value>Speed.Linear</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>True, indicating array list has bag semantics.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.DuplicatesByCounting">
      <summary>
            By convention this is true for any collection with set semantics.
            </summary>
      <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedArrayList`1.Count">
      <summary>
      </summary>
      <value>The number of items in this collection</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.SortedArray`1">
      <summary>
            A collection class implementing a sorted dynamic array data structure.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IIndexedSorted`1">
      <summary>
            A collection where items are maintained in sorted order together
            with their indexes in that order.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ISorted`1">
      <summary>
            A sorted collection, i.e. a collection where items are maintained and can be searched for in sorted order.
            Thus the sequence order is given as a sorting order.
            
            <para>The sorting order is defined by a comparer, an object of type IComparer&lt;T&gt; 
            (<see cref="T:C5.IComparer`1" />). Implementors of this interface will normally let the user 
            define the comparer as an argument to a constructor. 
            Usually there will also be constructors without a comparer argument, in which case the 
            comparer should be the defalt comparer for the item type, <see cref="P:C5.Comparer`1.Default" />.</para><para>The comparer of the sorted collection is available as the <code>SCG.Comparer</code> property 
            (<see cref="P:C5.ISorted`1.Comparer" />).</para><para>The methods are grouped according to
            <list><item>Extrema: report or report and delete an extremal item. This is reminiscent of simplified priority queues.</item><item>Nearest neighbor: report predecessor or successor in the collection of an item. Cut belongs to this group.</item><item>Range: report a view of a range of elements or remove all elements in a range.</item><item>AddSorted: add a collection of items known to be sorted in the same order (should be faster) (to be removed?)</item></list></para><para>Since this interface extends ISequenced&lt;T&gt;, sorted collections will also have an 
            item equalityComparer (<see cref="P:C5.IExtensible`1.EqualityComparer" />). This equalityComparer will not be used in connection with 
            the inner workings of the sorted collection, but will be used if the sorted collection is used as 
            an item in a collection of unsequenced or sequenced collections, 
            (<see cref="T:C5.ICollection`1" /> and <see cref="T:C5.ISequenced`1" />)</para><para>Note that code may check if two sorted collections has the same sorting order 
            by checking if the Comparer properties are equal. This is done a few places in this library
            for optimization purposes.</para></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.FindMin">
      <summary>
            Find the current least item of this sorted collection.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if the collection is empty.</exception>
      <returns>The least item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.DeleteMin">
      <summary>
            Remove the least item from this sorted collection.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if the collection is empty.</exception>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.FindMax">
      <summary>
            Find the current largest item of this sorted collection.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if the collection is empty.</exception>
      <returns>The largest item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.DeleteMax">
      <summary>
            Remove the largest item from this sorted collection.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if the collection is empty.</exception>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.TryPredecessor(`0,`0@)">
      <summary>
            Find the strict predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than the item.
            </summary>
      <param name="item">The item to find the predecessor for.</param>
      <param name="res">The predecessor, if any; otherwise the default value for T.</param>
      <returns>True if item has a predecessor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.TrySuccessor(`0,`0@)">
      <summary>
            Find the strict successor of item in the sorted collection,
            that is, the least item in the collection greater than the supplied value.
            </summary>
      <param name="item">The item to find the successor for.</param>
      <param name="res">The successor, if any; otherwise the default value for T.</param>
      <returns>True if item has a successor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.TryWeakPredecessor(`0,`0@)">
      <summary>
            Find the weak predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than or equal to the item.
            </summary>
      <param name="item">The item to find the weak predecessor for.</param>
      <param name="res">The weak predecessor, if any; otherwise the default value for T.</param>
      <returns>True if item has a weak predecessor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.TryWeakSuccessor(`0,`0@)">
      <summary>
            Find the weak successor of item in the sorted collection,
            that is, the least item in the collection greater than or equal to the supplied value.
            </summary>
      <param name="item">The item to find the weak successor for.</param>
      <param name="res">The weak successor, if any; otherwise the default value for T.</param>
      <returns>True if item has a weak successor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.Predecessor(`0)">
      <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            that is, the largest item in the collection less than the supplied value.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)</exception>
      <param name="item">The item to find the predecessor for.</param>
      <returns>The predecessor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.Successor(`0)">
      <summary>
            Find the strict successor in the sorted collection of a particular value,
            that is, the least item in the collection greater than the supplied value.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)</exception>
      <param name="item">The item to find the successor for.</param>
      <returns>The successor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.WeakPredecessor(`0)">
      <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            that is, the largest item in the collection less than or equal to the supplied value.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than the minimum of this collection.)</exception>
      <param name="item">The item to find the weak predecessor for.</param>
      <returns>The weak predecessor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.WeakSuccessor(`0)">
      <summary>
             Find the weak successor in the sorted collection of a particular value,
             that is, the least item in the collection greater than or equal to the supplied value.
             </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
             supplied  value is greater than the maximum of this collection.)</exception>
      <param name="item">The item to find the weak successor for.</param>
      <returns>The weak successor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
      <summary>
            Given a "cut" function from the items of the sorted collection to <code>int</code>
            whose only sign changes when going through items in increasing order
            can be 
            <list><item>from positive to zero</item><item>from positive to negative</item><item>from zero to negative</item></list>
            The "cut" function is supplied as the <code>CompareTo</code> method 
            of an object <code>c</code> implementing 
            <code>IComparable&lt;T&gt;</code>. 
            A typical example is the case where <code>T</code> is comparable and 
            <code>cutFunction</code> is itself of type <code>T</code>.
            <para>This method performs a search in the sorted collection for the ranges in which the
            "cut" function is negative, zero respectively positive. If <code>T</code> is comparable
            and <code>c</code> is of type <code>T</code>, this is a safe way (no exceptions thrown) 
            to find predecessor and successor of <code>c</code>.
            </para><para> If the supplied cut function does not satisfy the sign-change condition, 
            the result of this call is undefined.
            </para></summary>
      <param name="cutFunction">The cut function <code>T</code> to <code>int</code>, given
            by the <code>CompareTo</code> method of an object implementing 
            <code>IComparable&lt;T&gt;</code>.</param>
      <param name="low">Returns the largest item in the collection, where the
            cut function is positive (if any).</param>
      <param name="lowIsValid">Returns true if the cut function is positive somewhere
            on this collection.</param>
      <param name="high">Returns the least item in the collection, where the
            cut function is negative (if any).</param>
      <param name="highIsValid">Returns true if the cut function is negative somewhere
            on this collection.</param>
      <returns>True if the cut function is zero somewhere
            on this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.RangeFrom(`0)">
      <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            <para>The returned collection is not a copy but a view into the collection.</para><para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para></summary>
      <param name="bot">The lower bound (inclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.RangeFromTo(`0,`0)">
      <summary>
            Query this sorted collection for items between two supplied values.
            <para>The returned collection is not a copy but a view into the collection.</para><para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para></summary>
      <param name="bot">The lower bound (inclusive).</param>
      <param name="top">The upper bound (exclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.RangeTo(`0)">
      <summary>
            Query this sorted collection for items less than a supplied value.
            <para>The returned collection is not a copy but a view into the collection.</para><para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para></summary>
      <param name="top">The upper bound (exclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.RangeAll">
      <summary>
            Create a directed collection with the same items as this collection.
            <para>The returned collection is not a copy but a view into the collection.</para><para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para></summary>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items.
            </summary>
      <exception cref="T:System.ArgumentException"> if the enumerated items turns out
            not to be in increasing order.</exception>
      <param name="items">The collection to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.RemoveRangeFrom(`0)">
      <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
      <param name="low">The lower threshold (inclusive).</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.RemoveRangeFromTo(`0,`0)">
      <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
      <param name="low">The lower threshold (inclusive).</param>
      <param name="hi">The upper threshold (exclusive).</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISorted`1.RemoveRangeTo(`0)">
      <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
      <param name="hi">The upper threshold (exclusive).</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ISorted`1.Comparer">
      <summary>
            The comparer object supplied at creation time for this sorted collection.
            </summary>
      <value>The comparer</value>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexedSorted`1.CountFrom(`0)">
      <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
      <param name="bot">The lower bound (inclusive)</param>
      <returns>The number of matcing items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexedSorted`1.CountFromTo(`0,`0)">
      <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
      <param name="bot">The lower bound (inclusive)</param>
      <param name="top">The upper bound (exclusive)</param>
      <returns>The number of matcing items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexedSorted`1.CountTo(`0)">
      <summary>
            Determine the number of items below a supplied threshold.
            </summary>
      <param name="top">The upper bound (exclusive)</param>
      <returns>The number of matcing items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexedSorted`1.RangeFrom(`0)">
      <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
      <param name="bot">The lower bound (inclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexedSorted`1.RangeFromTo(`0,`0)">
      <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
      <param name="bot">The lower bound (inclusive).</param>
      <param name="top">The upper bound (exclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexedSorted`1.RangeTo(`0)">
      <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
      <param name="top">The upper bound (exclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexedSorted`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
      <param name="predicate">The filter delegate defining the predicate.</param>
      <returns>The new indexed sorted collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IIndexedSorted`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException" /> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
      <param name="mapper">The delegate definging the map.</param>
      <param name="comparer">The comparion relation to use for the result.</param>
      <returns>The new sorted collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.#ctor">
      <summary>
            Create a dynamic sorted array with a natural comparer
            (and item equalityComparer,  assumed compatible)
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotComparableException">If <code>T</code> is not comparable.
            </exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.#ctor(System.Int32)">
      <summary>
            Create a dynamic sorted array with a natural comparer 
            (and item equalityComparer,  assumed compatible)
            and prescribed initial capacity.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotComparableException">If <code>T</code> is not comparable.
            </exception>
      <param name="capacity">The capacity</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Create a dynamic sorted array with an external comparer.
            <para>The itemequalityComparer will be compatible 
            <see cref="T:C5.ComparerZeroHashCodeEqualityComparer`1" /> since the 
            default equalityComparer for T (<see cref="P:C5.EqualityComparer`1.Default" />)
            is unlikely to be compatible with the external comparer. This makes the
            array inadequate for use as item in a collection of unsequenced or sequenced sets or bags
            (<see cref="T:C5.ICollection`1" /> and <see cref="T:C5.ISequenced`1" />)
            </para></summary>
      <param name="comparer">The comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
      <summary>
            Create a dynamic sorted array with an external comparer
            and prescribed initial capacity.
            <para>The itemequalityComparer will be a compatible 
            <see cref="T:C5.ComparerZeroHashCodeEqualityComparer`1" /> since the 
            default equalityComparer for T (<see cref="P:C5.EqualityComparer`1.Default" />)
            is unlikely to be compatible with the external comparer. This makes the
            sorted array inadequate for use as item in a collection of unsequenced or sequenced sets or bags
            (<see cref="T:C5.ICollection`1" /> and <see cref="T:C5.ISequenced`1" />)
            </para></summary>
      <param name="capacity">The capacity</param>
      <param name="comparer">The comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a dynamic sorted array with an external comparer, an external item equalityComparer
            and prescribed initial capacity. This is the constructor to use if the collection 
            will be used as item in a hash table based collection.
            </summary>
      <param name="capacity">The capacity</param>
      <param name="comparer">The item comparer</param>
      <param name="equalityComparer">The item equalityComparer (assumed compatible)</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.CountFrom(`0)">
      <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
      <param name="bot">The lower bound (inclusive)</param>
      <returns>The number of matcing items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.CountFromTo(`0,`0)">
      <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
      <param name="bot">The lower bound (inclusive)</param>
      <param name="top">The upper bound (exclusive)</param>
      <returns>The number of matcing items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.CountTo(`0)">
      <summary>
            Determine the number of items below a supplied threshold.
            </summary>
      <param name="top">The upper bound (exclusive)</param>
      <returns>The number of matcing items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.RangeFrom(`0)">
      <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
      <param name="bot">The lower bound (inclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.RangeFromTo(`0,`0)">
      <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
      <param name="bot">The lower bound (inclusive).</param>
      <param name="top">The upper bound (exclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.RangeTo(`0)">
      <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
      <param name="top">The upper bound (exclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
      <param name="f">The filter delegate defining the predicate.</param>
      <returns>The new indexed sorted collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException" /> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
      <param name="m">The delegate definging the map.</param>
      <param name="c">The comparion relation to use for the result.</param>
      <returns>The new sorted collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.TryPredecessor(`0,`0@)">
      <summary>
            Find the strict predecessor of item in the sorted array,
            that is, the greatest item in the collection smaller than the item.
            </summary>
      <param name="item">The item to find the predecessor for.</param>
      <param name="res">The predecessor, if any; otherwise the default value for T.</param>
      <returns>True if item has a predecessor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.TrySuccessor(`0,`0@)">
      <summary>
            Find the strict successor of item in the sorted array,
            that is, the least item in the collection greater than the supplied value.
            </summary>
      <param name="item">The item to find the successor for.</param>
      <param name="res">The successor, if any; otherwise the default value for T.</param>
      <returns>True if item has a successor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.TryWeakPredecessor(`0,`0@)">
      <summary>
            Find the weak predecessor of item in the sorted array,
            that is, the greatest item in the collection smaller than or equal to the item.
            </summary>
      <param name="item">The item to find the weak predecessor for.</param>
      <param name="res">The weak predecessor, if any; otherwise the default value for T.</param>
      <returns>True if item has a weak predecessor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.TryWeakSuccessor(`0,`0@)">
      <summary>
            Find the weak successor of item in the sorted array,
            that is, the least item in the collection greater than or equal to the supplied value.
            </summary>
      <param name="item">The item to find the weak successor for.</param>
      <param name="res">The weak successor, if any; otherwise the default value for T.</param>
      <returns>True if item has a weak successor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.Predecessor(`0)">
      <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than the supplied value.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)</exception>
      <param name="item">The item to find the predecessor for.</param>
      <returns>The predecessor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.Successor(`0)">
      <summary>
            Find the strict successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than the supplied value.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)</exception>
      <param name="item">The item to find the successor for.</param>
      <returns>The successor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.WeakPredecessor(`0)">
      <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than or equal to the supplied value.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if no such element exists (the
            supplied  value is less than the minimum of this collection.)
            </summary>
      <param name="item">The item to find the weak predecessor for.</param>
      <returns>The weak predecessor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.WeakSuccessor(`0)">
      <summary>
            Find the weak successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than or equal to the supplied value.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than the maximum of this collection.)</exception>
      <param name="item">The item to find the weak successor for.</param>
      <returns>The weak successor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
      <summary>
            Perform a search in the sorted collection for the ranges in which a
            non-increasing (i.e. weakly decrerasing) function from the item type to 
            <code>int</code> is
            negative, zero respectively positive. If the supplied cut function is
            not non-increasing, the result of this call is undefined.
            </summary>
      <param name="c">The cut function <code>T</code> to <code>int</code>, given
            as an <code>IComparable&lt;T&gt;</code> object, where the cut function is
            the <code>c.CompareTo(T that)</code> method.</param>
      <param name="low">Returns the largest item in the collection, where the
            cut function is positive (if any).</param>
      <param name="lowIsValid">True if the cut function is positive somewhere
            on this collection.</param>
      <param name="high">Returns the least item in the collection, where the
            cut function is negative (if any).</param>
      <param name="highIsValid">True if the cut function is negative somewhere
            on this collection.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.RangeAll">
      <summary>
            Create a directed collection with the same items as this collection.
            </summary>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items.
            <exception cref="T:System.ArgumentException" /> if the enumerated items turns out
            not to be in increasing order.
            </summary>
      <param name="items">The collection to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.RemoveRangeFrom(`0)">
      <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
      <param name="low">The lower threshold (inclusive).</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.RemoveRangeFromTo(`0,`0)">
      <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
      <param name="low">The lower threshold (inclusive).</param>
      <param name="hi">The upper threshold (exclusive).</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.RemoveRangeTo(`0)">
      <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
      <param name="hi">The upper threshold (exclusive).</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.Clear">
      <summary>
            Remove all items from this collection, resetting internal array size.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.Contains(`0)">
      <summary>
            Check if this collection contains (an item equivalent according to the
            itemequalityComparer) to a particular value.
            </summary>
      <param name="item">The value to check for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.Find(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.FindOrAdd(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the item was added (hence not found).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.Update(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. If the collection has bag semantics,
            it is implementation dependent if this updates all equivalent copies in
            the collection or just one.
            </summary>
      <param name="item">Value to update.</param>
      <returns>True if the item was found and hence updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.Update(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.UpdateOrAdd(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
      <param name="item">Value to add or update.</param>
      <returns>True if the item was found and updated (hence not added).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.UpdateOrAdd(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.Remove(`0)">
      <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
      <param name="item">The value to remove.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.Remove(`0,`0@)">
      <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
      <param name="item">The value to remove.</param>
      <param name="removeditem">The removed value.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items in another collection from this one. 
            </summary>
      <param name="items">The items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items not in some other collection from this one. 
            </summary>
      <param name="items">The items to retain.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Check if this collection contains all the values in another collection.
            Multiplicities are not taken into account.
            </summary>
      <param name="items">The </param>
      <returns>True if all values in <code>items</code>is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.ContainsCount(`0)">
      <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
      <param name="item">The value to count.</param>
      <returns>The number of copies found (0 or 1).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.UniqueItems">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.ItemMultiplicities">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.RemoveAllCopies(`0)">
      <summary>
            Remove all (0 or 1) items equivalent to a given value.
            </summary>
      <param name="item">The value to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.Check">
      <summary>
            Check the integrity of the internal data structures of this collection.
            Only avaliable in DEBUG builds???
            </summary>
      <returns>True if check does not fail.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.Add(`0)">
      <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
      <param name="item">The item to add.</param>
      <returns>True if item was added.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. Since this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
      <param name="items">The items to add</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.FindMin">
      <summary>
            Find the current least item of this priority queue.
            </summary>
      <returns>The least item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.DeleteMin">
      <summary>
            Remove the least item from this  priority queue.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.FindMax">
      <summary>
            Find the current largest item of this priority queue.
            </summary>
      <returns>The largest item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.DeleteMax">
      <summary>
            Remove the largest item from this  priority queue.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.IndexOf(`0)">
      <summary>
            Searches for an item in the list going forwrds from the start.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of item from start.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.LastIndexOf(`0)">
      <summary>
            Searches for an item in the list going backwords from the end.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of of item from the end.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.RemoveAt(System.Int32)">
      <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt;= the size of the collection.
            </summary>
      <param name="i">The index of the item to remove.</param>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedArray`1.RemoveInterval(System.Int32,System.Int32)">
      <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException" />???. 
            </summary>
      <param name="start">The index of the first item to remove.</param>
      <param name="count">The number of items to remove.</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.SortedArray`1.ListenableEvents">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.SortedArray`1.ContainsSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case).
            </summary>
      <value>Speed.Log</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.SortedArray`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>False since this collection has set semantics</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.SortedArray`1.DuplicatesByCounting">
      <summary>
            By convention this is true for any collection with set semantics.
            </summary>
      <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.SortedArray`1.Comparer">
      <summary>
            The comparer object supplied at creation time for this collection
            </summary>
      <value>The comparer</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.SortedArray`1.Item(System.Int32)">
      <summary>
        <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt;= the size of the collection.
            </summary>
      <value>The i'th item of this list.</value>
      <param name="i">the index to lookup</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.SortedArray`1.IndexingSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.Comparers.ComparerFactory`1">
      <summary>
            Factory class to create comparers and equality comparers using Func delegates
            </summary>
      <typeparam name="T">The type to compare</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Comparers.ComparerFactory`1.CreateComparer(System.Func{`0,`0,System.Int32})">
      <summary>
            Create a new comparer.
            </summary>
      <param name="comparer">The compare function.</param>
      <returns>The comparer</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Comparers.ComparerFactory`1.CreateEqualityComparer(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
      <summary>
            Creates a new equality comparer.
            </summary>
      <param name="equals">The equals function.</param>
      <param name="getHashCode">The getHashCode function.</param>
      <returns>The equality comparer.</returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.HashBag`1">
      <summary>
            A bag collection based on a hash table of (item,count) pairs. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.#ctor">
      <summary>
            Create a hash bag with the deafult item equalityComparer.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a hash bag with an external item equalityComparer.
            </summary>
      <param name="itemequalityComparer">The external item equalityComparer.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a hash bag with external item equalityComparer, prescribed initial table size and default fill threshold (66%)
            </summary>
      <param name="capacity">Initial table size (rounded to power of 2, at least 16)</param>
      <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.#ctor(System.Int32,System.Double,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a hash bag with external item equalityComparer, prescribed initial table size and fill threshold.
            </summary>
      <param name="capacity">Initial table size (rounded to power of 2, at least 16)</param>
      <param name="fill">Fill threshold (valid range 10% to 90%)</param>
      <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.Contains(`0)">
      <summary>
            Check if an item is in the bag 
            </summary>
      <param name="item">The item to look for</param>
      <returns>True if bag contains item</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.Find(`0@)">
      <summary>
            Check if an item (collection equal to a given one) is in the bag and
            if so report the actual item object found.
            </summary>
      <param name="item">On entry, the item to look for.
            On exit the item found, if any</param>
      <returns>True if bag contains item</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.Update(`0)">
      <summary>
            Check if an item (collection equal to a given one) is in the bag and
            if so replace the item object in the bag with the supplied one.
            </summary>
      <param name="item">The item object to update with</param>
      <returns>True if item was found (and updated)</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.Update(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.FindOrAdd(`0@)">
      <summary>
            Check if an item (collection equal to a given one) is in the bag.
            If found, report the actual item object in the bag,
            else add the supplied one.
            </summary>
      <param name="item">On entry, the item to look for or add.
            On exit the actual object found, if any.</param>
      <returns>True if item was found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.UpdateOrAdd(`0)">
      <summary>
            Check if an item (collection equal to a supplied one) is in the bag and
            if so replace the item object in the set with the supplied one; else
            add the supplied one.
            </summary>
      <param name="item">The item to look for and update or add</param>
      <returns>True if item was updated</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.UpdateOrAdd(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.Remove(`0)">
      <summary>
            Remove one copy af an item from the bag
            </summary>
      <param name="item">The item to remove</param>
      <returns>True if item was (found and) removed </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.Remove(`0,`0@)">
      <summary>
            Remove one copy of an item from the bag, reporting the actual matching item object.
            </summary>
      <param name="item">The value to remove.</param>
      <param name="removeditem">The removed value.</param>
      <returns>True if item was found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items in a supplied collection from this bag, counting multiplicities.
            </summary>
      <param name="items">The items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.Clear">
      <summary>
            Remove all items from the bag, resetting internal table to initial size.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items *not* in a supplied collection from this bag,
            counting multiplicities.
            </summary>
      <param name="items">The items to retain</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Check if all items in a supplied collection is in this bag
            (counting multiplicities). 
            </summary>
      <param name="items">The items to look for.</param>
      <returns>True if all items are found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.ToArray">
      <summary>
            Create an array containing all items in this bag (in enumeration order).
            </summary>
      <returns>The array</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.ContainsCount(`0)">
      <summary>
            Count the number of times an item is in this set.
            </summary>
      <param name="item">The item to look for.</param>
      <returns>The count</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.UniqueItems">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.ItemMultiplicities">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.RemoveAllCopies(`0)">
      <summary>
            Remove all copies of item from this set.
            </summary>
      <param name="item">The item to remove</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copy the items of this bag to part of an array.
            <exception cref="T:System.ArgumentOutOfRangeException" /> if i is negative.
            <exception cref="T:System.ArgumentException" /> if the array does not have room for the items.
            </summary>
      <param name="array">The array to copy to</param>
      <param name="index">The starting index.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.Add(`0)">
      <summary>
            Add an item to this bag.
            </summary>
      <param name="item">The item to add.</param>
      <returns>Always true</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. 
            </summary>
      <param name="items">The items to add</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.Choose">
      <summary>
            Choose some item of this collection. 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">if collection is empty.</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.GetEnumerator">
      <summary>
            Create an enumerator for this bag.
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashBag`1.Check">
      <summary>
            Test internal structure of data (invariants)
            </summary>
      <returns>True if pass</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashBag`1.ListenableEvents">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashBag`1.ContainsSpeed">
      <summary>
            The complexity of the Contains operation
            </summary>
      <value>Always returns Speed.Constant</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashBag`1.AllowsDuplicates">
      <summary>
            Report if this is a set collection.
            </summary>
      <value>Always true</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashBag`1.DuplicatesByCounting">
      <summary>
            By convention this is true for any collection with set semantics.
            </summary>
      <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.HashDictionary`2">
      <summary>
            A generic dictionary class based on a hash set class <see cref="T:C5.HashSet`1" />. 
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.DictionaryBase`2">
      <summary>
            A base class for implementing a dictionary based on a set collection implementation.
            <i>See the source code for <see cref="T:C5.HashDictionary`2" /> for an example</i></summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IDictionary`2">
      <summary>
            A dictionary with keys of type K and values of type V. Equivalent to a
            finite partial map from K to V.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.Add(`0,`1)">
      <summary>
            Add a new (key, value) pair (a mapping) to the dictionary.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> if there already is an entry with the same key. </exception>&gt;
            <param name="key">Key to add</param><param name="val">Value to add</param></member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.AddAll``2(System.Collections.Generic.IEnumerable{NSoft.NFramework.Collections.C5.KeyValuePair{``0,``1}})">
      <summary>
            Add the entries from a collection of <see cref="T:C5.KeyValuePair`2" /> pairs to this dictionary.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> 
            If the input contains duplicate keys or a key already present in this dictionary.</exception>
      <param name="entries">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.ContainsAll``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Check whether this collection contains all the values in another collection.
            If this collection has bag semantics (<code>AllowsDuplicates==true</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
      <param name="items">The </param>
      <returns>True if all values in <code>items</code>is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.Remove(`0)">
      <summary>
            Remove an entry with a given key from the dictionary
            </summary>
      <param name="key">The key of the entry to remove</param>
      <returns>True if an entry was found (and removed)</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.Remove(`0,`1@)">
      <summary>
            Remove an entry with a given key from the dictionary and report its value.
            </summary>
      <param name="key">The key of the entry to remove</param>
      <param name="val">On exit, the value of the removed entry</param>
      <returns>True if an entry was found (and removed)</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.Clear">
      <summary>
            Remove all entries from the dictionary
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.Contains(`0)">
      <summary>
            Check if there is an entry with a specified key
            </summary>
      <param name="key">The key to look for</param>
      <returns>True if key was found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.Find(`0@,`1@)">
      <summary>
            Check if there is an entry with a specified key and report the corresponding
            value if found. This can be seen as a safe form of "val = this[key]".
            </summary>
      <param name="key">The key to look for</param>
      <param name="val">On exit, the value of the entry</param>
      <returns>True if key was found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.Update(`0,`1)">
      <summary>
            Look for a specific key in the dictionary and if found replace the value with a new one.
            This can be seen as a non-adding version of "this[key] = val".
            </summary>
      <param name="key">The key to look for</param>
      <param name="val">The new value</param>
      <returns>True if key was found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.Update(`0,`1,`1@)">
      <summary>
            Look for a specific key in the dictionary and if found replace the value with a new one.
            This can be seen as a non-adding version of "this[key] = val" reporting the old value.
            </summary>
      <param name="key">The key to look for</param>
      <param name="val">The new value</param>
      <param name="oldval">The old value if any</param>
      <returns>True if key was found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.FindOrAdd(`0,`1@)">
      <summary>
            Look for a specific key in the dictionary. If found, report the corresponding value,
            else add an entry with the key and the supplied value.
            </summary>
      <param name="key">The key to look for</param>
      <param name="val">On entry the value to add if the key is not found.
            On exit the value found if any.</param>
      <returns>True if key was found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.UpdateOrAdd(`0,`1)">
      <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found.
            </summary>
      <param name="key">The key to look for</param>
      <param name="val">The value to add or replace with.</param>
      <returns>True if key was found and value updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.UpdateOrAdd(`0,`1,`1@)">
      <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found.
            </summary>
      <param name="key">The key to look for</param>
      <param name="val">The value to add or replace with.</param>
      <param name="oldval">The old value if any</param>
      <returns>True if key was found and value updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IDictionary`2.Check">
      <summary>
            Check the integrity of the internal data structures of this dictionary.
            Only avaliable in DEBUG builds???
            </summary>
      <returns>True if check does not fail.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IDictionary`2.EqualityComparer">
      <summary>
            The key equalityComparer.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IDictionary`2.Item(`0)">
      <summary>
            Indexer for dictionary.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no entry is found. </exception>
      <value>The value corresponding to the key</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IDictionary`2.IsReadOnly">
      <summary>
      </summary>
      <value>True if dictionary is read-only</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IDictionary`2.Keys">
      <summary>
      </summary>
      <value>A collection containg the all the keys of the dictionary</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IDictionary`2.Values">
      <summary>
      </summary>
      <value>A collection containing all the values of the dictionary</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IDictionary`2.Func">
      <summary>
      </summary>
      <value>A delegate of type <see cref="T:Func`2" /> defining the partial function from K to V give by the dictionary.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IDictionary`2.ContainsSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant). 
            <para>See <see cref="T:C5.Speed" /> for the set of symbols.</para></summary>
      <value>A characterization of the speed of lookup operations
            (<code>Contains()</code> etc.) of the implementation of this dictionary.</value>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.DictionaryBase`2.pairs">
      <summary>
            The set collection of entries underlying this dictionary implementation
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
      </summary>
      <param name="keyequalityComparer">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.Add(`0,`1)">
      <summary>
            Add a new (key, value) pair (a mapping) to the dictionary.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> if there already is an entry with the same key. </exception>
      <param name="key">Key to add</param>
      <param name="value">Value to add</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.AddAll``2(System.Collections.Generic.IEnumerable{NSoft.NFramework.Collections.C5.KeyValuePair{``0,``1}})">
      <summary>
            Add the entries from a collection of <see cref="T:C5.KeyValuePair`2" /> pairs to this dictionary.
            <para><b>TODO: add restrictions L:K and W:V when the .Net SDK allows it </b></para></summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> 
            If the input contains duplicate keys or a key already present in this dictionary.</exception>
      <param name="entries">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.Remove(`0)">
      <summary>
            Remove an entry with a given key from the dictionary
            </summary>
      <param name="key">The key of the entry to remove</param>
      <returns>True if an entry was found (and removed)</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.Remove(`0,`1@)">
      <summary>
            Remove an entry with a given key from the dictionary and report its value.
            </summary>
      <param name="key">The key of the entry to remove</param>
      <param name="value">On exit, the value of the removed entry</param>
      <returns>True if an entry was found (and removed)</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.Clear">
      <summary>
            Remove all entries from the dictionary
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.Contains(`0)">
      <summary>
            Check if there is an entry with a specified key
            </summary>
      <param name="key">The key to look for</param>
      <returns>True if key was found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.ContainsAll``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
      </summary>
      <param name="keys">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.Find(`0@,`1@)">
      <summary>
            Check if there is an entry with a specified key and report the corresponding
            value if found. This can be seen as a safe form of "val = this[key]".
            </summary>
      <param name="key">The key to look for</param>
      <param name="value">On exit, the value of the entry</param>
      <returns>True if key was found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.Update(`0,`1)">
      <summary>
            Look for a specific key in the dictionary and if found replace the value with a new one.
            This can be seen as a non-adding version of "this[key] = val".
            </summary>
      <param name="key">The key to look for</param>
      <param name="value">The new value</param>
      <returns>True if key was found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.Update(`0,`1,`1@)">
      <summary>
      </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <param name="oldvalue">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.FindOrAdd(`0,`1@)">
      <summary>
            Look for a specific key in the dictionary. If found, report the corresponding value,
            else add an entry with the key and the supplied value.
            </summary>
      <param name="key">On entry the key to look for</param>
      <param name="value">On entry the value to add if the key is not found.
            On exit the value found if any.</param>
      <returns>True if key was found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.UpdateOrAdd(`0,`1)">
      <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found.
            </summary>
      <param name="key">The key to look for</param>
      <param name="value">The value to add or replace with.</param>
      <returns>True if entry was updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.UpdateOrAdd(`0,`1,`1@)">
      <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found and the old value if any.
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <param name="oldvalue">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.Check">
      <summary>
            Check the integrity of the internal data structures of this dictionary.
            </summary>
      <returns>True if check does not fail.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.Choose">
      <summary>
            Choose some entry in this Dictionary. 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">if collection is empty.</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.GetEnumerator">
      <summary>
            Create an enumerator for the collection of entries of the dictionary
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DictionaryBase`2.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="stringbuilder">
      </param>
      <param name="rest">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.DictionaryBase`2.CollectionChanged">
      <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.DictionaryBase`2.CollectionCleared">
      <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.DictionaryBase`2.ItemsAdded">
      <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.DictionaryBase`2.ItemsRemoved">
      <summary>
            The item added  event. Will be raised for every individual removal from the collection.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DictionaryBase`2.ListenableEvents">
      <summary>
      </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DictionaryBase`2.ActiveEvents">
      <summary>
      </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DictionaryBase`2.EqualityComparer">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DictionaryBase`2.ContainsSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DictionaryBase`2.Keys">
      <summary>
      </summary>
      <value>A collection containg the all the keys of the dictionary</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DictionaryBase`2.Values">
      <summary>
      </summary>
      <value>A collection containing all the values of the dictionary</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DictionaryBase`2.Func">
      <summary>
      </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DictionaryBase`2.Item(`0)">
      <summary>
            Indexer by key for dictionary. 
            <para>The get method will throw an exception if no entry is found. </para><para>The set method behaves like <see cref="M:C5.DictionaryBase`2.UpdateOrAdd(`0,`1)" />.</para></summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> On get if no entry is found. </exception>
      <value>The value corresponding to the key</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DictionaryBase`2.IsReadOnly">
      <summary>
      </summary>
      <value>True if dictionary is read  only</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DictionaryBase`2.IsEmpty">
      <summary>
      </summary>
      <value>True if this collection is empty.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DictionaryBase`2.Count">
      <summary>
      </summary>
      <value>The number of entrues in the dictionary</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.DictionaryBase`2.CountSpeed">
      <summary>
      </summary>
      <value>The number of entrues in the dictionary</value>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashDictionary`2.#ctor">
      <summary>
            Create a hash dictionary using a default equalityComparer for the keys.
            Initial capacity of internal table will be 16 entries and threshold for 
            expansion is 66% fill.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a hash dictionary using a custom equalityComparer for the keys.
            Initial capacity of internal table will be 16 entries and threshold for 
            expansion is 66% fill.
            </summary>
      <param name="keyequalityComparer">The external key equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashDictionary`2.#ctor(System.Int32,System.Double,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a hash dictionary using a custom equalityComparer and prescribing the 
            initial size of the dictionary and a non-default threshold for internal table expansion.
            </summary>
      <param name="capacity">The initial capacity. Will be rounded upwards to nearest
            power of 2, at least 16.</param>
      <param name="fill">The expansion threshold. Must be between 10% and 90%.</param>
      <param name="keyequalityComparer">The external key equalitySCG.Comparer</param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.HashSet`1">
      <summary>
            A set collection class based on linear hashing
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.#ctor">
      <summary>
            Create a hash set with natural item equalityComparer and default fill threshold (66%)
            and initial table size (16).
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a hash set with external item equalityComparer and default fill threshold (66%)
            and initial table size (16).
            </summary>
      <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a hash set with external item equalityComparer and default fill threshold (66%)
            </summary>
      <param name="capacity">Initial table size (rounded to power of 2, at least 16)</param>
      <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.#ctor(System.Int32,System.Double,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a hash set with external item equalityComparer.
            </summary>
      <param name="capacity">Initial table size (rounded to power of 2, at least 16)</param>
      <param name="fill">Fill threshold (in range 10% to 90%)</param>
      <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.Contains(`0)">
      <summary>
            Check if an item is in the set 
            </summary>
      <param name="item">The item to look for</param>
      <returns>True if set contains item</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.Find(`0@)">
      <summary>
            Check if an item (collection equal to a given one) is in the set and
            if so report the actual item object found.
            </summary>
      <param name="item">On entry, the item to look for.
            On exit the item found, if any</param>
      <returns>True if set contains item</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.Update(`0)">
      <summary>
            Check if an item (collection equal to a given one) is in the set and
            if so replace the item object in the set with the supplied one.
            </summary>
      <param name="item">The item object to update with</param>
      <returns>True if item was found (and updated)</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.Update(`0,`0@)">
      <summary>
            Check if an item (collection equal to a given one) is in the set and
            if so replace the item object in the set with the supplied one.
            </summary>
      <param name="item">The item object to update with</param>
      <param name="olditem">
      </param>
      <returns>True if item was found (and updated)</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.FindOrAdd(`0@)">
      <summary>
            Check if an item (collection equal to a given one) is in the set.
            If found, report the actual item object in the set,
            else add the supplied one.
            </summary>
      <param name="item">On entry, the item to look for or add.
            On exit the actual object found, if any.</param>
      <returns>True if item was found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.UpdateOrAdd(`0)">
      <summary>
            Check if an item (collection equal to a supplied one) is in the set and
            if so replace the item object in the set with the supplied one; else
            add the supplied one.
            </summary>
      <param name="item">The item to look for and update or add</param>
      <returns>True if item was updated</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.UpdateOrAdd(`0,`0@)">
      <summary>
            Check if an item (collection equal to a supplied one) is in the set and
            if so replace the item object in the set with the supplied one; else
            add the supplied one.
            </summary>
      <param name="item">The item to look for and update or add</param>
      <param name="olditem">
      </param>
      <returns>True if item was updated</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.Remove(`0)">
      <summary>
            Remove an item from the set
            </summary>
      <param name="item">The item to remove</param>
      <returns>True if item was (found and) removed </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.Remove(`0,`0@)">
      <summary>
            Remove an item from the set, reporting the actual matching item object.
            </summary>
      <param name="item">The value to remove.</param>
      <param name="removeditem">The removed value.</param>
      <returns>True if item was found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items in a supplied collection from this set.
            </summary>
      <param name="items">The items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.Clear">
      <summary>
            Remove all items from the set, resetting internal table to initial size.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items *not* in a supplied collection from this set.
            </summary>
      <param name="items">The items to retain</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Check if all items in a supplied collection is in this set
            (ignoring multiplicities). 
            </summary>
      <param name="items">The items to look for.</param>
      <returns>True if all items are found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.ToArray">
      <summary>
            Create an array containing all items in this set (in enumeration order).
            </summary>
      <returns>The array</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.ContainsCount(`0)">
      <summary>
            Count the number of times an item is in this set (either 0 or 1).
            </summary>
      <param name="item">The item to look for.</param>
      <returns>1 if item is in set, 0 else</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.UniqueItems">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.ItemMultiplicities">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.RemoveAllCopies(`0)">
      <summary>
            Remove all (at most 1) copies of item from this set.
            </summary>
      <param name="item">The item to remove</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.Choose">
      <summary>
            Choose some item of this collection. 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">if collection is empty.</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.GetEnumerator">
      <summary>
            Create an enumerator for this set.
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.Add(`0)">
      <summary>
            Add an item to this set.
            </summary>
      <param name="item">The item to add.</param>
      <returns>True if item was added (i.e. not found)</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. Since this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
      <param name="items">The items to add</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.Check">
      <summary>
            Test internal structure of data (invariants)
            </summary>
      <returns>True if pass</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashSet`1.BucketCostDistribution">
      <summary>
            Produce statistics on distribution of bucket sizes. Current implementation is incomplete.
            </summary>
      <returns>Histogram data.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashSet`1.Features">
      <summary>
            Show which implementation features was chosen at compilation time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashSet`1.ListenableEvents">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashSet`1.ContainsSpeed">
      <summary>
            The complexity of the Contains operation
            </summary>
      <value>Always returns Speed.Constant</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashSet`1.AllowsDuplicates">
      <summary>
            Report if this is a set collection.
            </summary>
      <value>Always false</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashSet`1.DuplicatesByCounting">
      <summary>
            By convention this is true for any collection with set semantics.
            </summary>
      <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.HashSet`1.Feature">
      <summary>
            Enum class to assist printing of compilation alternatives.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.HashSet`1.Feature.Dummy">
      <summary>
            Nothing
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.HashSet`1.Feature.RefTypeBucket">
      <summary>
            Buckets are of reference type
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.HashSet`1.Feature.ValueTypeBucket">
      <summary>
            Primary buckets are of value type
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.HashSet`1.Feature.LinearProbing">
      <summary>
            Using linear probing to resolve index clashes
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.HashSet`1.Feature.ShrinkTable">
      <summary>
            Shrink table when very sparsely filled
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.HashSet`1.Feature.Chaining">
      <summary>
            Use chaining to resolve index clashes
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.HashSet`1.Feature.InterHashing">
      <summary>
            Use hash function on item hash code
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.HashSet`1.Feature.RandomInterHashing">
      <summary>
            Use a universal family of hash functions on item hash code
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IntervalHeap`1">
      <summary>
            A priority queue class based on an interval heap data structure.
            </summary>
      <typeparam name="T">The item type</typeparam>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IPriorityQueue`1">
      <summary>
            A generic collection of items prioritized by a comparison (order) relation.
            Supports adding items and reporting or removing extremal elements. 
            <para></para>
            When adding an item, the user may choose to have a handle allocated for this item in the queue. 
            The resulting handle may be used for deleting the item even if not extremal, and for replacing the item.
            A priority queue typically only holds numeric priorities associated with some objects
            maintained separately in other collection objects.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IPriorityQueue`1.FindMin">
      <summary>
            Find the current least item of this priority queue.
            </summary>
      <returns>The least item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IPriorityQueue`1.DeleteMin">
      <summary>
            Remove the least item from this  priority queue.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IPriorityQueue`1.FindMax">
      <summary>
            Find the current largest item of this priority queue.
            </summary>
      <returns>The largest item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IPriorityQueue`1.DeleteMax">
      <summary>
            Remove the largest item from this priority queue.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IPriorityQueue`1.Find(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0},`0@)">
      <summary>
            Check if the entry corresponding to a handle is in the priority queue.
            </summary>
      <param name="handle">
      </param>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IPriorityQueue`1.Add(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0}@,`0)">
      <summary>
            Add an item to the priority queue, receiving a 
            handle for the item in the queue, 
            or reusing an existing unused handle.
            </summary>
      <param name="handle">On output: a handle for the added item. 
            On input: null for allocating a new handle, or a currently unused handle for reuse. 
            A handle for reuse must be compatible with this priority queue, 
            by being created by a priority queue of the same runtime type, but not 
            necessarily the same priority queue object.</param>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IPriorityQueue`1.Delete(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0})">
      <summary>
            Delete an item with a handle from a priority queue
            </summary>
      <param name="handle">The handle for the item. The handle will be invalidated, but reusable.</param>
      <returns>The deleted item</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IPriorityQueue`1.Replace(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0},`0)">
      <summary>
            Replace an item with a handle in a priority queue with a new item. 
            Typically used for changing the priority of some queued object.
            </summary>
      <param name="handle">The handle for the old item</param>
      <param name="item">The new item</param>
      <returns>The old item</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IPriorityQueue`1.FindMin(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0}@)">
      <summary>
            Find the current least item of this priority queue.
            </summary>
      <param name="handle">On return: the handle of the item.</param>
      <returns>The least item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IPriorityQueue`1.FindMax(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0}@)">
      <summary>
            Find the current largest item of this priority queue.
            </summary>
      <param name="handle">On return: the handle of the item.</param>
      <returns>The largest item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IPriorityQueue`1.DeleteMin(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0}@)">
      <summary>
            Remove the least item from this  priority queue.
            </summary>
      <param name="handle">On return: the handle of the removed item.</param>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IPriorityQueue`1.DeleteMax(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0}@)">
      <summary>
            Remove the largest item from this  priority queue.
            </summary>
      <param name="handle">On return: the handle of the removed item.</param>
      <returns>The removed item.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IPriorityQueue`1.Comparer">
      <summary>
            The comparer object supplied at creation time for this collection
            </summary>
      <value>The comparer</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IPriorityQueue`1.Item(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0})">
      <summary>
            Get or set the item corresponding to a handle. Throws exceptions on 
            invalid handles.
            </summary>
      <param name="handle">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.#ctor">
      <summary>
            Create an interval heap with natural item comparer and default initial capacity (16)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Create an interval heap with external item comparer and default initial capacity (16)
            </summary>
      <param name="comparer">The external comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.#ctor(System.Int32)">
      <summary>
            Create an interval heap with natural item comparer and prescribed initial capacity
            </summary>
      <param name="capacity">The initial capacity</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
      <summary>
            Create an interval heap with external item comparer and prescribed initial capacity
            </summary>
      <param name="comparer">The external comparer</param>
      <param name="capacity">The initial capacity</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.FindMin">
      <summary>
            Find the current least item of this priority queue.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if queue is empty
            </summary>
      <returns>The least item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.DeleteMin">
      <summary>
            Remove the least item from this  priority queue.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if queue is empty
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.FindMax">
      <summary>
            Find the current largest item of this priority queue.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if queue is empty
            </summary>
      <returns>The largest item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.DeleteMax">
      <summary>
            Remove the largest item from this  priority queue.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if queue is empty
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.Add(`0)">
      <summary>
            Add an item to this priority queue.
            </summary>
      <param name="item">The item to add.</param>
      <returns>True</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. 
            </summary>
      <param name="items">The items to add</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.Choose">
      <summary>
            Choose some item of this collection. 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">if collection is empty.</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.GetEnumerator">
      <summary>
            Create an enumerator for the collection
            <para>Note: the enumerator does *not* enumerate the items in sorted order, 
            but in the internal table order.</para></summary>
      <returns>The enumerator(SIC)</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.Check">
      <summary>
            Check the integrity of the internal data structures of this collection.
            Only avaliable in DEBUG builds???
            </summary>
      <returns>True if check does not fail.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.Find(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0},`0@)">
      <summary>
            Check safely if a handle is valid for this queue and if so, report the corresponding queue item.
            </summary>
      <param name="handle">The handle to check</param>
      <param name="item">If the handle is valid this will contain the corresponding item on output.</param>
      <returns>True if the handle is valid.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.Add(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0}@,`0)">
      <summary>
            Add an item to the priority queue, receiving a 
            handle for the item in the queue, 
            or reusing an already existing handle.
            </summary>
      <param name="handle">On output: a handle for the added item. 
            On input: null for allocating a new handle, an invalid handle for reuse. 
            A handle for reuse must be compatible with this priority queue, 
            by being created by a priority queue of the same runtime type, but not 
            necessarily the same priority queue object.</param>
      <param name="item">The item to add.</param>
      <returns>True since item will always be added unless the call throws an exception.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.Delete(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0})">
      <summary>
            Delete an item with a handle from a priority queue.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.InvalidPriorityQueueHandleException">if the handle is invalid</exception>
      <param name="handle">The handle for the item. The handle will be invalidated, but reusable.</param>
      <returns>The deleted item</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.Replace(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0},`0)">
      <summary>
            Replace an item with a handle in a priority queue with a new item. 
            Typically used for changing the priority of some queued object.
            </summary>
      <param name="handle">The handle for the old item</param>
      <param name="item">The new item</param>
      <returns>The old item</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.FindMin(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0}@)">
      <summary>
            Find the current least item of this priority queue.
            </summary>
      <param name="handle">On return: the handle of the item.</param>
      <returns>The least item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.FindMax(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0}@)">
      <summary>
            Find the current largest item of this priority queue.
            </summary>
      <param name="handle">On return: the handle of the item.</param>
      <returns>The largest item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.DeleteMin(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0}@)">
      <summary>
            Remove the least item from this priority queue.
            </summary>
      <param name="handle">On return: the handle of the removed item.</param>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IntervalHeap`1.DeleteMax(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0}@)">
      <summary>
            Remove the largest item from this priority queue.
            </summary>
      <param name="handle">On return: the handle of the removed item.</param>
      <returns>The removed item.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IntervalHeap`1.ListenableEvents">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IntervalHeap`1.Comparer">
      <summary>
            The comparer object supplied at creation time for this collection
            </summary>
      <value>The comparer</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IntervalHeap`1.IsReadOnly">
      <summary>
            If true any call of an updating operation will throw an
            <code>ReadOnlyCollectionException</code></summary>
      <value>True if this collection is read-only.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IntervalHeap`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>True since this collection has bag semantics</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IntervalHeap`1.EqualityComparer">
      <summary>
            Value is null since this collection has no equality concept for its items. 
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IntervalHeap`1.DuplicatesByCounting">
      <summary>
            By convention this is true for any collection with set semantics.
            </summary>
      <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IntervalHeap`1.IsEmpty">
      <summary>
      </summary>
      <value>True if this collection is empty.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IntervalHeap`1.Count">
      <summary>
      </summary>
      <value>The size of this collection</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IntervalHeap`1.CountSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
      <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.IntervalHeap`1.Item(NSoft.NFramework.Collections.C5.IPriorityQueueHandle{`0})">
      <summary>
            Get or set the item corresponding to a handle. 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.InvalidPriorityQueueHandleException">if the handle is invalid for this queue</exception>
      <param name="handle">The reference into the heap</param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IPriorityQueueHandle`1">
      <summary>
            The base type of a priority queue handle
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.HashedLinkedList`1">
      <summary>
            A list collection class based on a doubly linked list data structure.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.updatecheck">
      <summary>
            Check if it is valid to perform updates and increment stamp of 
            underlying if this is a view.
            <para>This method should be called in every public modifying 
            methods before any modifications are performed.
            </para></summary>
      <exception cref="T:System.InvalidOperationException"> if check fails.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.modifycheck(System.Int32)">
      <summary>
            Check that the list has not been updated since a particular time.
            </summary>
      <param name="stamp">The stamp indicating the time.</param>
      <exception cref="T:NSoft.NFramework.Collections.C5.CollectionModifiedException"> if check fails.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a linked list with en external item equalityComparer
            </summary>
      <param name="itemequalityComparer">The external equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.#ctor">
      <summary>
            Create a linked list with the natural item equalityComparer
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Dispose">
      <summary>
            Invalidate this list. If a view, just invalidate the view. 
            If not a view, invalidate the list and all views on it.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Insert(System.Int32,`0)">
      <summary>
            Insert an item at a specific index location in this list. 
            <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt; the size of the collection.</summary>
      <param name="i">The index at which to insert.</param>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Insert(NSoft.NFramework.Collections.C5.IList{`0},`0)">
      <summary>
            Insert an item at the end of a compatible view, used as a pointer.
            <para>The <code>pointer</code> must be a view on the same list as
            <code>this</code> and the endpoitn of <code>pointer</code> must be
            a valid insertion point of <code>this</code></para></summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.IncompatibleViewException">If <code>pointer</code> 
            is not a view on the same list as <code>this</code></exception>
      <exception cref="T:System.IndexOutOfRangeException">
        <b>??????</b> if the endpoint of 
             <code>pointer</code> is not inside <code>this</code></exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.</exception>
      <param name="pointer">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt; the size of the collection.
            </summary>
      <param name="i">Index to start inserting at</param>
      <param name="items">Items to insert</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.InsertFirst(`0)">
      <summary>
            Insert an item at the front of this list.
            </summary>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.InsertLast(`0)">
      <summary>
            Insert an item at the back of this list.
            </summary>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Map``1(System.Func{`0,``0})">
      <summary>
            Create a new list consisting of the results of mapping all items of this
            list.
            </summary>
      <param name="mapper">The delegate defining the map.</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified equalityComparer for the item type.
            </summary>
      <typeparam name="V">The type of items of the new list</typeparam>
      <param name="mapper">The delegate defining the map.</param>
      <param name="equalityComparer">The equalityComparer to use for the new list</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Remove">
      <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if this list is empty.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.RemoveFirst">
      <summary>
            Remove one item from the front of the list.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if this list is empty.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.RemoveLast">
      <summary>
            Remove one item from the back of the list.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if this list is empty.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.View(System.Int32,System.Int32)">
      <summary>
            Create a list view on this list. 
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the start or count is negative</exception>
      <exception cref="T:System.ArgumentException"> if the range does not fit within list.</exception>
      <param name="start">The index in this list of the start of the view.</param>
      <param name="count">The size of the view.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.ViewOf(`0)">
      <summary>
            Create a list view on this list containing the (first) occurrence of a particular item. 
            </summary>
      <exception cref="T:System.ArgumentException"> if the item is not in this list.</exception>
      <param name="item">The item to find.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.LastViewOf(`0)">
      <summary>
            Create a list view on this list containing the last occurrence of a particular item. 
            <exception cref="T:System.ArgumentException" /> if the item is not in this list.
            </summary>
      <param name="item">The item to find.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Slide(System.Int32)">
      <summary>
            Slide this list view along the underlying list.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
      <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Slide(System.Int32,System.Int32)">
      <summary>
            Slide this list view along the underlying list, perhaps changing its size.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
      <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
      <param name="size">The new size of the view.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.TrySlide(System.Int32)">
      <summary>
      </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.TrySlide(System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="offset">
      </param>
      <param name="size">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Span(NSoft.NFramework.Collections.C5.IList{`0})">
      <summary>
        <para>Returns null if <code>otherView</code> is strictly to the left of this view</para>
      </summary>
      <param name="otherView">
      </param>
      <exception cref="T:NSoft.NFramework.Collections.C5.IncompatibleViewException">If otherView does not have the same underlying list as this</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Reverse">
      <summary>
            Reverse the list so the items are in the opposite sequence order.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.IsSorted">
      <summary>
            Check if this list is sorted according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1" /> class 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotComparableException">if T is not comparable</exception>
      <returns>True if the list is sorted, else false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.IsSorted(System.Collections.Generic.IComparer{`0})">
      <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
      <param name="c">The comparer defining the sorting order.</param>
      <returns>True if the list is sorted, else false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Sort">
      <summary>
            Sort the items of the list according to the default sorting order
            for the item type T, as defined by the Comparer[T] class. 
            (<see cref="T:C5.Comparer`1" />).
            The sorting is stable.
            </summary>
      <exception cref="T:System.InvalidOperationException">if T is not comparable</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Sort(System.Collections.Generic.IComparer{`0})">
      <summary>
            Sort the items of the list according to a specific sorting order.
            The sorting is stable.
            </summary>
      <param name="c">The comparer defining the sorting order.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Shuffle">
      <summary>
            Randomly shuffle the items of this list. 
            <para>Will invalidate overlapping views???</para></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Shuffle(System.Random)">
      <summary>
            Shuffle the items of this list according to a specific random source.
            <para>Will invalidate overlapping views???</para></summary>
      <param name="rnd">The random source.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.IndexOf(`0)">
      <summary>
            Searches for an item in the list going forwrds from the start.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of item from start.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.LastIndexOf(`0)">
      <summary>
            Searches for an item in the list going backwords from the end.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of of item from the end.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.RemoveAt(System.Int32)">
      <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt;= the size of the collection.
            </summary>
      <param name="i">The index of the item to remove.</param>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.RemoveInterval(System.Int32,System.Int32)">
      <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException" />???. 
            </summary>
      <param name="start">The index of the first item to remove.</param>
      <param name="count">The number of items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.GetSequencedHashCode">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.SequencedEquals(NSoft.NFramework.Collections.C5.ISequenced{`0})">
      <summary>
      </summary>
      <param name="that">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Backwards">
      <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typicaly used as in
            <code>foreach (T x in coll.Backwards()) {...}</code></summary>
      <returns>The backwards collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.GetUnsequencedHashCode">
      <summary>
            Performs a check for view validity before calling base.GetUnsequencedHashCode()
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.UnsequencedEquals(NSoft.NFramework.Collections.C5.ICollection{`0})">
      <summary>
      </summary>
      <param name="that">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Contains(`0)">
      <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
      <param name="item">The value to check for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Find(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Update(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. Will update a single item.
            </summary>
      <param name="item">Value to update.</param>
      <returns>True if the item was found and hence updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Update(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.FindOrAdd(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the item was found (hence not added).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.UpdateOrAdd(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
      <param name="item">Value to add or update.</param>
      <returns>True if the item was found and updated (hence not added).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.UpdateOrAdd(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Remove(`0)">
      <summary>
            Remove a particular item from this collection. Since the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
      <param name="item">The value to remove.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Remove(`0,`0@)">
      <summary>
            Remove a particular item from this collection if found (only one copy). 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
      <param name="item">The value to remove on input.</param>
      <param name="removeditem">The value removed.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items in another collection from this one, taking multiplicities into account.
            <para>Always removes from the front of the list.
            </para><para>The asymptotic running time complexity of this method is <code>O(n+m+v*log(v))</code>, 
            where <code>n</code> is the size of this list, <code>m</code> is the size of the
            <code>items</code> collection and <code>v</code> is the number of views. 
            The method will temporarily allocate memory of size <code>O(m+v)</code>.
            </para></summary>
      <param name="items">The items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Clear">
      <summary>
            Remove all items from this collection.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items not in some other collection from this one, taking multiplicities into account.
            <para>The asymptotic running time complexity of this method is <code>O(n+m+v*log(v))</code>, 
            where <code>n</code> is the size of this collection, <code>m</code> is the size of the
            <code>items</code> collection and <code>v</code> is the number of views. 
            The method will temporarily allocate memory of size <code>O(m+v)</code>. The stated complexitiy 
            holds under the assumption that the itemequalityComparer of this list is well-behaved.
            </para></summary>
      <param name="items">The items to retain.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Check if this collection contains all the values in another collection
            with respect to multiplicities.
            </summary>
      <param name="items">The </param>
      <returns>True if all values in <code>items</code>is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            </summary>
      <param name="filter">The filter delegate defining the predicate.</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.ContainsCount(`0)">
      <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
      <param name="item">The value to count.</param>
      <returns>The number of copies found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.UniqueItems">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.ItemMultiplicities">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.RemoveAllCopies(`0)">
      <summary>
            Remove all items equivalent to a given value.
            <para>The asymptotic complexity of this method is <code>O(n+v*log(v))</code>, 
            where <code>n</code> is the size of the collection and <code>v</code> 
            is the number of views.
            </para></summary>
      <param name="item">The value to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Choose">
      <summary>
            Choose some item of this collection. 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">if collection is empty.</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Filter(System.Func{`0,System.Boolean})">
      <summary>
            Create an enumerable, enumerating the items of this collection that satisfies 
            a certain condition.
            </summary>
      <param name="filter">The T-&gt;bool filter delegate defining the condition</param>
      <returns>The filtered enumerable</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.GetEnumerator">
      <summary>
            Create an enumerator for the collection
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Add(`0)">
      <summary>
            Add an item to this collection if possible. 
            </summary>
      <param name="item">The item to add.</param>
      <returns>True.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. 
            </summary>
      <param name="items">The items to add</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Check">
      <summary>
            Check the sanity of this list
            </summary>
      <returns>true if sane</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.ListenableEvents">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.First">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <value>The first item in this list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Last">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <value>The last item in this list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.FIFO">
      <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
      <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end. THe default for a new linked list is true.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.IsFixedSize">
      <summary>
      </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Item(System.Int32)">
      <summary>
            On this list, this indexer is read/write.
            <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt;= the size of the collection.
            </summary>
      <value>The i'th item of this list.</value>
      <param name="index">The index of the item to fetch or store.</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.IndexingSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Underlying">
      <summary>
            Null if this list is not a view.
            </summary>
      <value>Underlying list for view.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.IsValid">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Offset">
      <summary>
      </summary>
      <value>Offset for this list view or 0 for a underlying list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Item(System.Int32,System.Int32)">
      <summary>
        <exception cref="T:System.IndexOutOfRangeException" />.
            </summary>
      <value>The directed collection of items in a specific index interval.</value>
      <param name="start">The low index of the interval (inclusive).</param>
      <param name="count">The size of the range.</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.ContainsSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
      <value>Speed.Linear</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.Count">
      <summary>
      </summary>
      <value>The number of items in this collection</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>True since this collection has bag semantics.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.HashedLinkedList`1.DuplicatesByCounting">
      <summary>
            By convention this is true for any collection with set semantics.
            </summary>
      <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.LinkedList`1">
      <summary>
            A list collection class based on a doubly linked list data structure.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.updatecheck">
      <summary>
            Check if it is valid to perform updates and increment stamp of 
            underlying if this is a view.
            <para>This method should be called in every public modifying 
            methods before any modifications are performed.
            </para></summary>
      <exception cref="T:System.InvalidOperationException"> if check fails.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.modifycheck(System.Int32)">
      <summary>
            Check that the list has not been updated since a particular time.
            </summary>
      <param name="stamp">The stamp indicating the time.</param>
      <exception cref="T:NSoft.NFramework.Collections.C5.CollectionModifiedException"> if check fails.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a linked list with en external item equalityComparer
            </summary>
      <param name="itemequalityComparer">The external equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.#ctor">
      <summary>
            Create a linked list with the natural item equalityComparer
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Dispose">
      <summary>
            Invalidate this list. If a view, just invalidate the view. 
            If not a view, invalidate the list and all views on it.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Insert(System.Int32,`0)">
      <summary>
            Insert an item at a specific index location in this list. 
            <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt; the size of the collection.</summary>
      <param name="i">The index at which to insert.</param>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Insert(NSoft.NFramework.Collections.C5.IList{`0},`0)">
      <summary>
            Insert an item at the end of a compatible view, used as a pointer.
            <para>The <code>pointer</code> must be a view on the same list as
            <code>this</code> and the endpoitn of <code>pointer</code> must be
            a valid insertion point of <code>this</code></para></summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.IncompatibleViewException">If <code>pointer</code> 
            is not a view on the same list as <code>this</code></exception>
      <exception cref="T:System.IndexOutOfRangeException">
        <b>??????</b> if the endpoint of 
             <code>pointer</code> is not inside <code>this</code></exception>
      <exception cref="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException"> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.</exception>
      <param name="pointer">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt; the size of the collection.
            </summary>
      <param name="i">Index to start inserting at</param>
      <param name="items">Items to insert</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.InsertFirst(`0)">
      <summary>
            Insert an item at the front of this list.
            </summary>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.InsertLast(`0)">
      <summary>
            Insert an item at the back of this list.
            </summary>
      <param name="item">The item to insert.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Map``1(System.Func{`0,``0})">
      <summary>
            Create a new list consisting of the results of mapping all items of this
            list.
            </summary>
      <param name="mapper">The delegate defining the map.</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified equalityComparer for the item type.
            </summary>
      <typeparam name="V">The type of items of the new list</typeparam>
      <param name="mapper">The delegate defining the map.</param>
      <param name="equalityComparer">The equalityComparer to use for the new list</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Remove">
      <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if this list is empty.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.RemoveFirst">
      <summary>
            Remove one item from the front of the list.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if this list is empty.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.RemoveLast">
      <summary>
            Remove one item from the back of the list.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException" /> if this list is empty.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.View(System.Int32,System.Int32)">
      <summary>
            Create a list view on this list. 
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the start or count is negative</exception>
      <exception cref="T:System.ArgumentException"> if the range does not fit within list.</exception>
      <param name="start">The index in this list of the start of the view.</param>
      <param name="count">The size of the view.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.ViewOf(`0)">
      <summary>
            Create a list view on this list containing the (first) occurrence of a particular item. 
            </summary>
      <exception cref="T:System.ArgumentException"> if the item is not in this list.</exception>
      <param name="item">The item to find.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.LastViewOf(`0)">
      <summary>
            Create a list view on this list containing the last occurrence of a particular item. 
            <exception cref="T:System.ArgumentException" /> if the item is not in this list.
            </summary>
      <param name="item">The item to find.</param>
      <returns>The new list view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Slide(System.Int32)">
      <summary>
            Slide this list view along the underlying list.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
      <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Slide(System.Int32,System.Int32)">
      <summary>
            Slide this list view along the underlying list, perhaps changing its size.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotAViewException"> if this list is not a view.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
      <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
      <param name="size">The new size of the view.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.TrySlide(System.Int32)">
      <summary>
      </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.TrySlide(System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="offset">
      </param>
      <param name="size">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Span(NSoft.NFramework.Collections.C5.IList{`0})">
      <summary>
        <para>Returns null if <code>otherView</code> is strictly to the left of this view</para>
      </summary>
      <param name="otherView">
      </param>
      <exception cref="T:NSoft.NFramework.Collections.C5.IncompatibleViewException">If otherView does not have the same underlying list as this</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Reverse">
      <summary>
            Reverse the list so the items are in the opposite sequence order.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.IsSorted">
      <summary>
            Check if this list is sorted according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1" /> class 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotComparableException">if T is not comparable</exception>
      <returns>True if the list is sorted, else false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.IsSorted(System.Collections.Generic.IComparer{`0})">
      <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
      <param name="c">The comparer defining the sorting order.</param>
      <returns>True if the list is sorted, else false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Sort">
      <summary>
            Sort the items of the list according to the default sorting order
            for the item type T, as defined by the Comparer[T] class. 
            (<see cref="T:C5.Comparer`1" />).
            The sorting is stable.
            </summary>
      <exception cref="T:System.InvalidOperationException">if T is not comparable</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Sort(System.Collections.Generic.IComparer{`0})">
      <summary>
            Sort the items of the list according to a specific sorting order.
            The sorting is stable.
            </summary>
      <param name="c">The comparer defining the sorting order.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Shuffle">
      <summary>
            Randomly shuffle the items of this list. 
            <para>Will invalidate overlapping views???</para></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Shuffle(System.Random)">
      <summary>
            Shuffle the items of this list according to a specific random source.
            <para>Will invalidate overlapping views???</para></summary>
      <param name="rnd">The random source.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.IndexOf(`0)">
      <summary>
            Searches for an item in the list going forwrds from the start.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of item from start.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.LastIndexOf(`0)">
      <summary>
            Searches for an item in the list going backwords from the end.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of of item from the end.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.RemoveAt(System.Int32)">
      <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt;= the size of the collection.
            </summary>
      <param name="i">The index of the item to remove.</param>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.RemoveInterval(System.Int32,System.Int32)">
      <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException" />???. 
            </summary>
      <param name="start">The index of the first item to remove.</param>
      <param name="count">The number of items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.GetSequencedHashCode">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.SequencedEquals(NSoft.NFramework.Collections.C5.ISequenced{`0})">
      <summary>
      </summary>
      <param name="that">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Backwards">
      <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typicaly used as in
            <code>foreach (T x in coll.Backwards()) {...}</code></summary>
      <returns>The backwards collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.GetUnsequencedHashCode">
      <summary>
            Performs a check for view validity before calling base.GetUnsequencedHashCode()
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.UnsequencedEquals(NSoft.NFramework.Collections.C5.ICollection{`0})">
      <summary>
      </summary>
      <param name="that">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Contains(`0)">
      <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
      <param name="item">The value to check for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Find(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Update(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. Will update a single item.
            </summary>
      <param name="item">Value to update.</param>
      <returns>True if the item was found and hence updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Update(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.FindOrAdd(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the item was found (hence not added).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.UpdateOrAdd(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
      <param name="item">Value to add or update.</param>
      <returns>True if the item was found and updated (hence not added).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.UpdateOrAdd(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Remove(`0)">
      <summary>
            Remove a particular item from this collection. Since the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
      <param name="item">The value to remove.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Remove(`0,`0@)">
      <summary>
            Remove a particular item from this collection if found (only one copy). 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
      <param name="item">The value to remove on input.</param>
      <param name="removeditem">The value removed.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items in another collection from this one, taking multiplicities into account.
            <para>Always removes from the front of the list.
            </para><para>The asymptotic running time complexity of this method is <code>O(n+m+v*log(v))</code>, 
            where <code>n</code> is the size of this list, <code>m</code> is the size of the
            <code>items</code> collection and <code>v</code> is the number of views. 
            The method will temporarily allocate memory of size <code>O(m+v)</code>.
            </para></summary>
      <param name="items">The items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Clear">
      <summary>
            Remove all items from this collection.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items not in some other collection from this one, taking multiplicities into account.
            <para>The asymptotic running time complexity of this method is <code>O(n+m+v*log(v))</code>, 
            where <code>n</code> is the size of this collection, <code>m</code> is the size of the
            <code>items</code> collection and <code>v</code> is the number of views. 
            The method will temporarily allocate memory of size <code>O(m+v)</code>. The stated complexitiy 
            holds under the assumption that the itemequalityComparer of this list is well-behaved.
            </para></summary>
      <param name="items">The items to retain.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Check if this collection contains all the values in another collection
            with respect to multiplicities.
            </summary>
      <param name="items">The </param>
      <returns>True if all values in <code>items</code>is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            </summary>
      <param name="filter">The filter delegate defining the predicate.</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.ContainsCount(`0)">
      <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
      <param name="item">The value to count.</param>
      <returns>The number of copies found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.UniqueItems">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.ItemMultiplicities">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.RemoveAllCopies(`0)">
      <summary>
            Remove all items equivalent to a given value.
            <para>The asymptotic complexity of this method is <code>O(n+v*log(v))</code>, 
            where <code>n</code> is the size of the collection and <code>v</code> 
            is the number of views.
            </para></summary>
      <param name="item">The value to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Choose">
      <summary>
            Choose some item of this collection. 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">if collection is empty.</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Filter(System.Func{`0,System.Boolean})">
      <summary>
            Create an enumerable, enumerating the items of this collection that satisfies 
            a certain condition.
            </summary>
      <param name="filter">The T-&gt;bool filter delegate defining the condition</param>
      <returns>The filtered enumerable</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.GetEnumerator">
      <summary>
            Create an enumerator for the collection
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Add(`0)">
      <summary>
            Add an item to this collection if possible. 
            </summary>
      <param name="item">The item to add.</param>
      <returns>True.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. 
            </summary>
      <param name="items">The items to add</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Push(`0)">
      <summary>
            Push an item to the top of the stack.
            </summary>
      <param name="item">The item</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Pop">
      <summary>
            Pop the item at the top of the stack from the stack.
            </summary>
      <returns>The popped item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Enqueue(`0)">
      <summary>
            Enqueue an item at the back of the queue. 
            </summary>
      <param name="item">The item</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Dequeue">
      <summary>
            Dequeue an item from the front of the queue.
            </summary>
      <returns>The item</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.LinkedList`1.Check">
      <summary>
            Check the sanity of this list
            </summary>
      <returns>true if sane</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.ListenableEvents">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.First">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <value>The first item in this list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.Last">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if this list is empty.</exception>
      <value>The last item in this list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.FIFO">
      <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
      <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end. THe default for a new linked list is true.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.IsFixedSize">
      <summary>
      </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.Item(System.Int32)">
      <summary>
            On this list, this indexer is read/write.
            <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt;= the size of the collection.
            </summary>
      <value>The i'th item of this list.</value>
      <param name="index">The index of the item to fetch or store.</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.IndexingSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.Underlying">
      <summary>
            Null if this list is not a view.
            </summary>
      <value>Underlying list for view.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.IsValid">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.Offset">
      <summary>
      </summary>
      <value>Offset for this list view or 0 for a underlying list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.Item(System.Int32,System.Int32)">
      <summary>
        <exception cref="T:System.IndexOutOfRangeException" />.
            </summary>
      <value>The directed collection of items in a specific index interval.</value>
      <param name="start">The low index of the interval (inclusive).</param>
      <param name="count">The size of the range.</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.ContainsSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
      <value>Speed.Linear</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.Count">
      <summary>
      </summary>
      <value>The number of items in this collection</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>True since this collection has bag semantics.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.LinkedList`1.DuplicatesByCounting">
      <summary>
            By convention this is true for any collection with set semantics.
            </summary>
      <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.TreeBag`1">
      <summary>
            An implementation of Red-Black trees as an indexed, sorted collection with bag semantics,
            cf. <a href="litterature.htm#CLRS">CLRS</a>. (<see cref="T:C5.TreeBag`1" /> for an 
            implementation with set semantics).
            <br />
            The comparer (sorting order) may be either natural, because the item type is comparable 
            (generic: <see cref="T:C5.IComparable`1" /> or non-generic: System.IComparable) or it can
            be external and supplied by the user in the constructor.
            <br />
            Each distinct item is only kept in one place in the tree - together with the number
            of times it is a member of the bag. Thus, if two items that are equal according
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IPersistentSorted`1">
      <summary>
            The type of a sorted collection with persistence
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IPersistentSorted`1.Snapshot">
      <summary>
            Make a (read-only) snap shot of this collection.
            </summary>
      <returns>The snap shot.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.#ctor">
      <summary>
            Create a red-black tree collection with natural comparer and item equalityComparer.
            We assume that if <code>T</code> is comparable, its default equalityComparer 
            will be compatible with the comparer.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotComparableException">If <code>T</code> is not comparable.
            </exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Create a red-black tree collection with an external comparer. 
            <para>The itemequalityComparer will be a compatible 
            <see cref="T:C5.ComparerZeroHashCodeEqualityComparer`1" /> since the 
            default equalityComparer for T (<see cref="P:C5.EqualityComparer`1.Default" />)
            is unlikely to be compatible with the external comparer. This makes the
            tree inadequate for use as item in a collection of unsequenced or sequenced sets or bags
            (<see cref="T:C5.ICollection`1" /> and <see cref="T:C5.ISequenced`1" />)
            </para></summary>
      <param name="comparer">The external comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a red-black tree collection with an external comparer and an external
            item equalityComparer, assumed consistent.
            </summary>
      <param name="comparer">The external comparer</param>
      <param name="equalityComparer">The external item equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Choose">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">If tree is empty</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.GetEnumerator">
      <summary>
            Create an enumerator for this tree
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Add(`0)">
      <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
      <param name="item">The item to add.</param>
      <returns>True if item was added.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
      <param name="items">The items to add</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items. <para>The idea is that the implementation may use
            a faster algorithm to merge the two collections.</para><exception cref="T:System.ArgumentException" /> if the enumerated items turns out
            not to be in increasing order.
            </summary>
      <param name="items">The collection to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Contains(`0)">
      <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
      <param name="item">The value to check for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Find(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.FindOrAdd(`0@)">
      <summary>
             Find or add the item to the tree. If the tree does not contain
             an item equivalent to this item add it, else return the exisiting
             one in the ref argument. 
            
             </summary>
      <param name="item">
      </param>
      <returns>True if item was found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Update(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. If the collection has bag semantics,
            this updates all equivalent copies in
            the collection.
            </summary>
      <param name="item">Value to update.</param>
      <returns>True if the item was found and hence updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Update(`0,`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            with a binary copy of the supplied value. If the collection has bag semantics,
            this updates all equivalent copies in
            the collection.
            </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.UpdateOrAdd(`0)">
      <summary>
             Check if this collection contains an item equivalent according to the
             itemequalityComparer to a particular value. If so, update the item in the collection 
             with a binary copy of the supplied value; else add the value to the collection. 
            
             <i>NOTE: the bag implementation is currently wrong! ?????</i></summary>
      <param name="item">Value to add or update.</param>
      <returns>True if the item was found and updated (hence not added).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.UpdateOrAdd(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Remove(`0)">
      <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
      <param name="item">The value to remove.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Remove(`0,`0@)">
      <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
      <param name="item">The value to remove.</param>
      <param name="removeditem">The removed value.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Clear">
      <summary>
            Remove all items from this collection.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items in another collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
      <param name="items">The items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items not in some other collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
      <param name="items">The items to retain.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Check if this collection contains all the values in another collection.
            If this collection has bag semantics (<code>AllowsDuplicates==true</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
      <param name="items">The </param>
      <returns>True if all values in <code>items</code>is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
      <param name="filter">The filter delegate defining the predicate.</param>
      <returns>The new indexed sorted collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException" /> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
      <param name="mapper">The delegate definging the map.</param>
      <param name="c">The comparion relation to use for the result.</param>
      <returns>The new sorted collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.ContainsCount(`0)">
      <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
      <param name="item">The value to count.</param>
      <returns>The number of copies found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.UniqueItems">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.ItemMultiplicities">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.RemoveAllCopies(`0)">
      <summary>
            Remove all items equivalent to a given value.
            </summary>
      <param name="item">The value to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.IndexOf(`0)">
      <summary>
            Searches for an item in this indexed collection going forwards from the start.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of first occurrence from start of the item
            if found, else the two-complement 
            (always negative) of the index at which the item would be put if it was added.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.LastIndexOf(`0)">
      <summary>
            Searches for an item in the tree going backwords from the end.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of last occurrence from the end of item if found, 
            else the two-complement (always negative) of the index at which 
            the item would be put if it was added.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.RemoveAt(System.Int32)">
      <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt;= the size of the collection.
            </summary>
      <param name="i">The index of the item to remove.</param>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.RemoveInterval(System.Int32,System.Int32)">
      <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException" />???. 
            </summary>
      <param name="start">The index of the first item to remove.</param>
      <param name="count">The number of items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Backwards">
      <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typicaly used as in
            <code>foreach (T x in coll.Backwards()) {...}</code></summary>
      <returns>The backwards collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.FindMin">
      <summary>
            Find the current least item of this priority queue.
            </summary>
      <returns>The least item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.DeleteMin">
      <summary>
            Remove the least item from this  priority queue.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.FindMax">
      <summary>
            Find the current largest item of this priority queue.
            </summary>
      <returns>The largest item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.DeleteMax">
      <summary>
            Remove the largest item from this  priority queue.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.TryPredecessor(`0,`0@)">
      <summary>
            Find the strict predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than the item.
            </summary>
      <param name="item">The item to find the predecessor for.</param>
      <param name="res">The predecessor, if any; otherwise the default value for T.</param>
      <returns>True if item has a predecessor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.TrySuccessor(`0,`0@)">
      <summary>
            Find the strict successor of item in the sorted collection,
            that is, the least item in the collection greater than the supplied value.
            </summary>
      <param name="item">The item to find the successor for.</param>
      <param name="res">The successor, if any; otherwise the default value for T.</param>
      <returns>True if item has a successor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.TryWeakPredecessor(`0,`0@)">
      <summary>
            Find the weak predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than or equal to the item.
            </summary>
      <param name="item">The item to find the weak predecessor for.</param>
      <param name="res">The weak predecessor, if any; otherwise the default value for T.</param>
      <returns>True if item has a weak predecessor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.TryWeakSuccessor(`0,`0@)">
      <summary>
            Find the weak successor of item in the sorted collection,
            that is, the least item in the collection greater than or equal to the supplied value.
            </summary>
      <param name="item">The item to find the weak successor for.</param>
      <param name="res">The weak successor, if any; otherwise the default value for T.</param>
      <returns>True if item has a weak successor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Predecessor(`0)">
      <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than the supplied value.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)</exception>
      <param name="item">The item to find the predecessor for.</param>
      <returns>The predecessor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.WeakPredecessor(`0)">
      <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than or equal to the supplied value.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than the minimum of this collection.)</exception>
      <param name="item">The item to find the weak predecessor for.</param>
      <returns>The weak predecessor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Successor(`0)">
      <summary>
            Find the strict successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than the supplied value.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)</exception>
      <param name="item">The item to find the successor for.</param>
      <returns>The successor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.WeakSuccessor(`0)">
      <summary>
            Find the weak successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than or equal to the supplied value.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than the maximum of this collection.)</exception></summary>
      <param name="item">The item to find the weak successor for.</param>
      <returns>The weak successor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.RangeFrom(`0)">
      <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
      <param name="bot">The lower bound (inclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.RangeFromTo(`0,`0)">
      <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
      <param name="bot">The lower bound (inclusive).</param>
      <param name="top">The upper bound (exclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.RangeTo(`0)">
      <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
      <param name="top">The upper bound (exclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.RangeAll">
      <summary>
            Create a directed collection with the same items as this collection.
            </summary>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
      <summary>
            Perform a search in the sorted collection for the ranges in which a
            non-increasing (i.e. weakly decrerasing) function from the item type to 
            <code>int</code> is
            negative, zero respectively positive. If the supplied cut function is
            not non-increasing, the result of this call is undefined.
            </summary>
      <param name="c">The cut function <code>T</code> to <code>int</code>, given
            as an <code>IComparable&lt;T&gt;</code> object, where the cut function is
            the <code>c.CompareTo(T that)</code> method.</param>
      <param name="low">Returns the largest item in the collection, where the
            cut function is positive (if any).</param>
      <param name="lowIsValid">True if the cut function is positive somewhere
            on this collection.</param>
      <param name="high">Returns the least item in the collection, where the
            cut function is negative (if any).</param>
      <param name="highIsValid">True if the cut function is negative somewhere
            on this collection.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.CountFrom(`0)">
      <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
      <param name="bot">The lower bound (inclusive)</param>
      <returns>The number of matcing items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.CountFromTo(`0,`0)">
      <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
      <param name="bot">The lower bound (inclusive)</param>
      <param name="top">The upper bound (exclusive)</param>
      <returns>The number of matcing items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.CountTo(`0)">
      <summary>
            Determine the number of items below a supplied threshold.
            </summary>
      <param name="top">The upper bound (exclusive)</param>
      <returns>The number of matcing items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.RemoveRangeFrom(`0)">
      <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
      <param name="low">The lower threshold (inclusive).</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.RemoveRangeFromTo(`0,`0)">
      <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
      <param name="low">The lower threshold (inclusive).</param>
      <param name="hi">The upper threshold (exclusive).</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.RemoveRangeTo(`0)">
      <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
      <param name="hi">The upper threshold (exclusive).</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Dispose">
      <summary>
            If this tree is a snapshot, remove registration in base tree
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Snapshot">
      <summary>
            Make a (read-only) snapshot of this collection.
            </summary>
      <returns>The snapshot.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.dump">
      <summary>
            Print the tree structure to the console stdout.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.dump(System.String)">
      <summary>
            Print the tree structure to the console stdout.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Check(System.String)">
      <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
      <param name="name">Title of dump</param>
      <returns>false if invariant violation</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeBag`1.Check">
      <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
      <returns>false if invariant violation</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeBag`1.ListenableEvents">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeBag`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>True since this collection has bag semantics.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeBag`1.DuplicatesByCounting">
      <summary>
            By convention this is true for any collection with set semantics.
            </summary>
      <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeBag`1.ContainsSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
      <value>Speed.Log</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeBag`1.Item(System.Int32)">
      <summary>
        <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt;= the size of the collection.
            </summary>
      <value>The i'th item of this list.</value>
      <param name="i">the index to lookup</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeBag`1.IndexingSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeBag`1.Item(System.Int32,System.Int32)">
      <summary>
        <exception cref="T:System.IndexOutOfRangeException" />.
            </summary>
      <value>The directed collection of items in a specific index interval.</value>
      <param name="start">The starting index of the interval (inclusive).</param>
      <param name="count">The length of the interval.</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeBag`1.Comparer">
      <summary>
            The comparer object supplied at creation time for this collection
            </summary>
      <value>The comparer</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.TreeDictionary`2">
      <summary>
            A sorted generic dictionary based on a red-black tree set.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2">
      <summary>
            A base class for implementing a sorted dictionary based on a sorted set collection implementation.
            <i>See the source code for <see cref="T:C5.TreeDictionary`2" /> for an example</i></summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ISortedDictionary`2">
      <summary>
            A dictionary with sorted keys.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.FindMin">
      <summary>
            Find the current least item of this sorted collection.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if the collection is empty.</exception>
      <returns>The least item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.DeleteMin">
      <summary>
            Remove the least item from this sorted collection.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if the collection is empty.</exception>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.FindMax">
      <summary>
            Find the current largest item of this sorted collection.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if the collection is empty.</exception>
      <returns>The largest item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.DeleteMax">
      <summary>
            Remove the largest item from this sorted collection.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if the collection is empty.</exception>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.TryPredecessor(`0,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@)">
      <summary>
            Find the entry in the dictionary whose key is the
            predecessor of the specified key.
            </summary>
      <param name="key">The key</param>
      <param name="res">The predecessor, if any</param>
      <returns>True if key has a predecessor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.TrySuccessor(`0,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@)">
      <summary>
            Find the entry in the dictionary whose key is the
            successor of the specified key.
            </summary>
      <param name="key">The key</param>
      <param name="res">The successor, if any</param>
      <returns>True if the key has a successor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.TryWeakPredecessor(`0,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@)">
      <summary>
            Find the entry in the dictionary whose key is the
            weak predecessor of the specified key.
            </summary>
      <param name="key">The key</param>
      <param name="res">The predecessor, if any</param>
      <returns>True if key has a weak predecessor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.TryWeakSuccessor(`0,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@)">
      <summary>
            Find the entry in the dictionary whose key is the
            weak successor of the specified key.
            </summary>
      <param name="key">The key</param>
      <param name="res">The weak successor, if any</param>
      <returns>True if the key has a weak successor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.Predecessor(`0)">
      <summary>
            Find the entry with the largest key less than a given key.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if there is no such entry. </exception>
      <param name="key">The key to compare to</param>
      <returns>The entry</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.Successor(`0)">
      <summary>
            Find the entry with the least key greater than a given key.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if there is no such entry. </exception>
      <param name="key">The key to compare to</param>
      <returns>The entry</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.WeakPredecessor(`0)">
      <summary>
            Find the entry with the largest key less than or equal to a given key.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if there is no such entry. </exception>
      <param name="key">The key to compare to</param>
      <returns>The entry</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.WeakSuccessor(`0)">
      <summary>
            Find the entry with the least key greater than or equal to a given key.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if there is no such entry. </exception>
      <param name="key">The key to compare to</param>
      <returns>The entry</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.Cut(System.IComparable{`0},NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@,System.Boolean@,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@,System.Boolean@)">
      <summary>
            Given a "cut" function from the items of the sorted collection to <code>int</code>
            whose only sign changes when going through items in increasing order
            can be 
            <list><item>from positive to zero</item><item>from positive to negative</item><item>from zero to negative</item></list>
            The "cut" function is supplied as the <code>CompareTo</code> method 
            of an object <code>c</code> implementing 
            <code>IComparable&lt;K&gt;</code>. 
            A typical example is the case where <code>K</code> is comparable and 
            <code>c</code> is itself of type <code>K</code>.
            <para>This method performs a search in the sorted collection for the ranges in which the
            "cut" function is negative, zero respectively positive. If <code>K</code> is comparable
            and <code>c</code> is of type <code>K</code>, this is a safe way (no exceptions thrown) 
            to find predecessor and successor of <code>c</code>.
            </para><para> If the supplied cut function does not satisfy the sign-change condition, 
            the result of this call is undefined.
            </para></summary>
      <param name="cutFunction">The cut function <code>K</code> to <code>int</code>, given
            by the <code>CompareTo</code> method of an object implementing 
            <code>IComparable&lt;K&gt;</code>.</param>
      <param name="lowEntry">Returns the largest item in the collection, where the
            cut function is positive (if any).</param>
      <param name="lowIsValid">Returns true if the cut function is positive somewhere
            on this collection.</param>
      <param name="highEntry">Returns the least item in the collection, where the
            cut function is negative (if any).</param>
      <param name="highIsValid">Returns true if the cut function is negative somewhere
            on this collection.</param>
      <returns>True if the cut function is zero somewhere
            on this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.RangeFrom(`0)">
      <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            <para>The returned collection is not a copy but a view into the collection.</para><para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para></summary>
      <param name="bot">The lower bound (inclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.RangeFromTo(`0,`0)">
      <summary>
            Query this sorted collection for items between two supplied values.
            <para>The returned collection is not a copy but a view into the collection.</para><para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para></summary>
      <param name="lowerBound">The lower bound (inclusive).</param>
      <param name="upperBound">The upper bound (exclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.RangeTo(`0)">
      <summary>
            Query this sorted collection for items less than a supplied value.
            <para>The returned collection is not a copy but a view into the collection.</para><para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para></summary>
      <param name="top">The upper bound (exclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.RangeAll">
      <summary>
            Create a directed collection with the same items as this collection.
            <para>The returned collection is not a copy but a view into the collection.</para><para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para></summary>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.AddSorted(System.Collections.Generic.IEnumerable{NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}})">
      <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items.
            </summary>
      <exception cref="T:System.ArgumentException"> if the enumerated items turns out
            not to be in increasing order.</exception>
      <param name="items">The collection to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.RemoveRangeFrom(`0)">
      <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
      <param name="low">The lower threshold (inclusive).</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.RemoveRangeFromTo(`0,`0)">
      <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
      <param name="low">The lower threshold (inclusive).</param>
      <param name="hi">The upper threshold (exclusive).</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ISortedDictionary`2.RemoveRangeTo(`0)">
      <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
      <param name="hi">The upper threshold (exclusive).</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ISortedDictionary`2.Keys">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.ISortedDictionary`2.Comparer">
      <summary>
            The key comparer used by this dictionary.
            </summary>
      <value>
      </value>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.sortedpairs">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
      </summary>
      <param name="keycomparer">
      </param>
      <param name="keyequalityComparer">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.TryPredecessor(`0,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@)">
      <summary>
            Find the entry in the dictionary whose key is the
            predecessor of the specified key.
            </summary>
      <param name="key">The key</param>
      <param name="res">The predecessor, if any</param>
      <returns>True if key has a predecessor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.TrySuccessor(`0,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@)">
      <summary>
            Find the entry in the dictionary whose key is the
            successor of the specified key.
            </summary>
      <param name="key">The key</param>
      <param name="res">The successor, if any</param>
      <returns>True if the key has a successor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.TryWeakPredecessor(`0,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@)">
      <summary>
            Find the entry in the dictionary whose key is the
            weak predecessor of the specified key.
            </summary>
      <param name="key">The key</param>
      <param name="res">The predecessor, if any</param>
      <returns>True if key has a weak predecessor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.TryWeakSuccessor(`0,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@)">
      <summary>
            Find the entry in the dictionary whose key is the
            weak successor of the specified key.
            </summary>
      <param name="key">The key</param>
      <param name="res">The weak successor, if any</param>
      <returns>True if the key has a weak successor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.Predecessor(`0)">
      <summary>
            Get the entry in the dictionary whose key is the
            predecessor of the specified key.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">
      </exception>
      <param name="key">The key</param>
      <returns>The entry</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.Successor(`0)">
      <summary>
            Get the entry in the dictionary whose key is the
            successor of the specified key.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">
      </exception>
      <param name="key">The key</param>
      <returns>The entry</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.WeakPredecessor(`0)">
      <summary>
            Get the entry in the dictionary whose key is the
            weak predecessor of the specified key.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">
      </exception>
      <param name="key">The key</param>
      <returns>The entry</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.WeakSuccessor(`0)">
      <summary>
            Get the entry in the dictionary whose key is the
            weak successor of the specified key.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">
      </exception>
      <param name="key">The key</param>
      <returns>The entry</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.FindMin">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.DeleteMin">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.FindMax">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.DeleteMax">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.Cut(System.IComparable{`0},NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@,System.Boolean@,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@,System.Boolean@)">
      <summary>
      </summary>
      <param name="cutter">
      </param>
      <param name="lowEntry">
      </param>
      <param name="lowIsValid">
      </param>
      <param name="highEntry">
      </param>
      <param name="highIsValid">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.RangeFrom(`0)">
      <summary>
      </summary>
      <param name="bot">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.RangeFromTo(`0,`0)">
      <summary>
      </summary>
      <param name="bot">
      </param>
      <param name="top">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.RangeTo(`0)">
      <summary>
      </summary>
      <param name="top">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.RangeAll">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.AddSorted(System.Collections.Generic.IEnumerable{NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}})">
      <summary>
      </summary>
      <param name="items">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.RemoveRangeFrom(`0)">
      <summary>
      </summary>
      <param name="lowKey">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.RemoveRangeFromTo(`0,`0)">
      <summary>
      </summary>
      <param name="lowKey">
      </param>
      <param name="highKey">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.RemoveRangeTo(`0)">
      <summary>
      </summary>
      <param name="highKey">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="stringbuilder">
      </param>
      <param name="rest">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.Comparer">
      <summary>
            The key comparer used by this dictionary.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.SortedDictionaryBase`2.Keys">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeDictionary`2.#ctor">
      <summary>
            Create a red-black tree dictionary using the natural comparer for keys.
            <exception cref="T:System.ArgumentException" /> if the key type K is not comparable.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Create a red-black tree dictionary using an external comparer for keys.
            </summary>
      <param name="comparer">The external comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeDictionary`2.Snapshot">
      <summary>
            Make a snapshot of the current state of this dictionary
            </summary>
      <returns>The snapshot</returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.TreeSet`1">
      <summary>
             An implementation of Red-Black trees as an indexed, sorted collection with set semantics,
             cf. <a href="litterature.htm#CLRS">CLRS</a>. <see cref="T:C5.TreeBag`1" /> for a version 
             with bag semantics. <see cref="T:C5.TreeDictionary`2" /> for a sorted dictionary 
             based on this tree implementation.
             <i>
             The comparer (sorting order) may be either natural, because the item type is comparable 
             (generic: <see cref="T:C5.IComparable`1" /> or non-generic: System.IComparable) or it can
             be external and supplied by the user in the constructor.</i><i>TODO: describe performance here</i><i>TODO: discuss persistence and its useful usage modes. Warn about the space
             leak possible with other usage modes.</i></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.#ctor">
      <summary>
            Create a red-black tree collection with natural comparer and item equalityComparer.
            We assume that if <code>T</code> is comparable, its default equalityComparer 
            will be compatible with the comparer.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotComparableException">If <code>T</code> is not comparable.
            </exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Create a red-black tree collection with an external comparer. 
            <para>The itemequalityComparer will be a compatible 
            <see cref="T:C5.ComparerZeroHashCodeEqualityComparer`1" /> since the 
            default equalityComparer for T (<see cref="P:C5.EqualityComparer`1.Default" />)
            is unlikely to be compatible with the external comparer. This makes the
            tree inadequate for use as item in a collection of unsequenced or sequenced sets or bags
            (<see cref="T:C5.ICollection`1" /> and <see cref="T:C5.ISequenced`1" />)
            </para></summary>
      <param name="comparer">The external comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a red-black tree collection with an external comparer and an external
            item equalityComparer, assumed consistent.
            </summary>
      <param name="comparer">The external comparer</param>
      <param name="equalityComparer">The external item equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Choose">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">If tree is empty</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.GetEnumerator">
      <summary>
            Create an enumerator for this tree
            </summary>
      <returns>The enumerator</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Add(`0)">
      <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
      <param name="item">The item to add.</param>
      <returns>True if item was added.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
      <param name="items">The items to add</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items. <para>The idea is that the implementation may use
            a faster algorithm to merge the two collections.</para><exception cref="T:System.ArgumentException" /> if the enumerated items turns out
            not to be in increasing order.
            </summary>
      <param name="items">The collection to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Contains(`0)">
      <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
      <param name="item">The value to check for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Find(`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
      <param name="item">The value to look for.</param>
      <returns>True if the items is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.FindOrAdd(`0@)">
      <summary>
             Find or add the item to the tree. If the tree does not contain
             an item equivalent to this item add it, else return the exisiting
             one in the ref argument. 
            
             </summary>
      <param name="item">
      </param>
      <returns>True if item was found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Update(`0)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. If the collection has bag semantics,
            this updates all equivalent copies in
            the collection.
            </summary>
      <param name="item">Value to update.</param>
      <returns>True if the item was found and hence updated.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Update(`0,`0@)">
      <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            with a binary copy of the supplied value. If the collection has bag semantics,
            this updates all equivalent copies in
            the collection.
            </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.UpdateOrAdd(`0)">
      <summary>
             Check if this collection contains an item equivalent according to the
             itemequalityComparer to a particular value. If so, update the item in the collection 
             with a binary copy of the supplied value; else add the value to the collection. 
            
             <i>NOTE: the bag implementation is currently wrong! ?????</i></summary>
      <param name="item">Value to add or update.</param>
      <returns>True if the item was found and updated (hence not added).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.UpdateOrAdd(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Remove(`0)">
      <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
      <param name="item">The value to remove.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Remove(`0,`0@)">
      <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
      <param name="item">The value to remove.</param>
      <param name="removeditem">The removed value.</param>
      <returns>True if the item was found (and removed).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Clear">
      <summary>
            Remove all items from this collection.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items in another collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
      <param name="items">The items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all items not in some other collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
      <param name="items">The items to retain.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Check if this collection contains all the values in another collection.
            If this collection has bag semantics (<code>AllowsDuplicates==true</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
      <param name="items">The </param>
      <returns>True if all values in <code>items</code>is in this collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
      <param name="filter">The filter delegate defining the predicate.</param>
      <returns>The new indexed sorted collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException" /> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
      <param name="mapper">The delegate definging the map.</param>
      <param name="c">The comparion relation to use for the result.</param>
      <returns>The new sorted collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.ContainsCount(`0)">
      <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
      <param name="item">The value to count.</param>
      <returns>The number of copies found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.UniqueItems">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.ItemMultiplicities">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.RemoveAllCopies(`0)">
      <summary>
            Remove all items equivalent to a given value.
            </summary>
      <param name="item">The value to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.IndexOf(`0)">
      <summary>
            Searches for an item in this indexed collection going forwards from the start.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of first occurrence from start of the item
            if found, else the two-complement 
            (always negative) of the index at which the item would be put if it was added.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.LastIndexOf(`0)">
      <summary>
            Searches for an item in the tree going backwords from the end.
            </summary>
      <param name="item">Item to search for.</param>
      <returns>Index of last occurrence from the end of item if found, 
            else the two-complement (always negative) of the index at which 
            the item would be put if it was added.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.RemoveAt(System.Int32)">
      <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt;= the size of the collection.
            </summary>
      <param name="i">The index of the item to remove.</param>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.RemoveInterval(System.Int32,System.Int32)">
      <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException" />???. 
            </summary>
      <param name="start">The index of the first item to remove.</param>
      <param name="count">The number of items to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Backwards">
      <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typicaly used as in
            <code>foreach (T x in coll.Backwards()) {...}</code></summary>
      <returns>The backwards collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.FindMin">
      <summary>
            Find the current least item of this priority queue.
            </summary>
      <returns>The least item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.DeleteMin">
      <summary>
            Remove the least item from this  priority queue.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.FindMax">
      <summary>
            Find the current largest item of this priority queue.
            </summary>
      <returns>The largest item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.DeleteMax">
      <summary>
            Remove the largest item from this  priority queue.
            </summary>
      <returns>The removed item.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.TryPredecessor(`0,`0@)">
      <summary>
            Find the strict predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than the item.
            </summary>
      <param name="item">The item to find the predecessor for.</param>
      <param name="res">The predecessor, if any; otherwise the default value for T.</param>
      <returns>True if item has a predecessor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.TrySuccessor(`0,`0@)">
      <summary>
            Find the strict successor of item in the sorted collection,
            that is, the least item in the collection greater than the supplied value.
            </summary>
      <param name="item">The item to find the successor for.</param>
      <param name="res">The successor, if any; otherwise the default value for T.</param>
      <returns>True if item has a successor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.TryWeakPredecessor(`0,`0@)">
      <summary>
            Find the weak predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than or equal to the item.
            </summary>
      <param name="item">The item to find the weak predecessor for.</param>
      <param name="res">The weak predecessor, if any; otherwise the default value for T.</param>
      <returns>True if item has a weak predecessor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.TryWeakSuccessor(`0,`0@)">
      <summary>
            Find the weak successor of item in the sorted collection,
            that is, the least item in the collection greater than or equal to the supplied value.
            </summary>
      <param name="item">The item to find the weak successor for.</param>
      <param name="res">The weak successor, if any; otherwise the default value for T.</param>
      <returns>True if item has a weak successor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Predecessor(`0)">
      <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than the supplied value.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)</exception>
      <param name="item">The item to find the predecessor for.</param>
      <returns>The predecessor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.WeakPredecessor(`0)">
      <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than or equal to the supplied value.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than the minimum of this collection.)</exception>
      <param name="item">The item to find the weak predecessor for.</param>
      <returns>The weak predecessor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Successor(`0)">
      <summary>
            Find the strict successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than the supplied value.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)</exception>
      <param name="item">The item to find the successor for.</param>
      <returns>The successor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.WeakSuccessor(`0)">
      <summary>
            Find the weak successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than or equal to the supplied value.
            <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than the maximum of this collection.)</exception></summary>
      <param name="item">The item to find the weak successor for.</param>
      <returns>The weak successor.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.RangeFrom(`0)">
      <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
      <param name="bot">The lower bound (inclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.RangeFromTo(`0,`0)">
      <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
      <param name="bot">The lower bound (inclusive).</param>
      <param name="top">The upper bound (exclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.RangeTo(`0)">
      <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
      <param name="top">The upper bound (exclusive).</param>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.RangeAll">
      <summary>
            Create a directed collection with the same items as this collection.
            </summary>
      <returns>The result directed collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
      <summary>
            Perform a search in the sorted collection for the ranges in which a
            non-increasing (i.e. weakly decrerasing) function from the item type to 
            <code>int</code> is
            negative, zero respectively positive. If the supplied cut function is
            not non-increasing, the result of this call is undefined.
            </summary>
      <param name="c">The cut function <code>T</code> to <code>int</code>, given
            as an <code>IComparable&lt;T&gt;</code> object, where the cut function is
            the <code>c.CompareTo(T that)</code> method.</param>
      <param name="low">Returns the largest item in the collection, where the
            cut function is positive (if any).</param>
      <param name="lowIsValid">True if the cut function is positive somewhere
            on this collection.</param>
      <param name="high">Returns the least item in the collection, where the
            cut function is negative (if any).</param>
      <param name="highIsValid">True if the cut function is negative somewhere
            on this collection.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.CountFrom(`0)">
      <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
      <param name="bot">The lower bound (inclusive)</param>
      <returns>The number of matcing items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.CountFromTo(`0,`0)">
      <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
      <param name="bot">The lower bound (inclusive)</param>
      <param name="top">The upper bound (exclusive)</param>
      <returns>The number of matcing items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.CountTo(`0)">
      <summary>
            Determine the number of items below a supplied threshold.
            </summary>
      <param name="top">The upper bound (exclusive)</param>
      <returns>The number of matcing items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.RemoveRangeFrom(`0)">
      <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
      <param name="low">The lower threshold (inclusive).</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.RemoveRangeFromTo(`0,`0)">
      <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
      <param name="low">The lower threshold (inclusive).</param>
      <param name="hi">The upper threshold (exclusive).</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.RemoveRangeTo(`0)">
      <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
      <param name="hi">The upper threshold (exclusive).</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Dispose">
      <summary>
            If this tree is a snapshot, remove registration in base tree
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Snapshot">
      <summary>
            Make a (read-only) snapshot of this collection.
            </summary>
      <returns>The snapshot.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.dump">
      <summary>
            Print the tree structure to the console stdout.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.dump(System.String)">
      <summary>
            Print the tree structure to the console stdout.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Check(System.String)">
      <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
      <param name="name">Title of dump</param>
      <returns>false if invariant violation</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.TreeSet`1.Check">
      <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
      <returns>false if invariant violation</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeSet`1.ListenableEvents">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeSet`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>False since this tree has set semantics.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeSet`1.DuplicatesByCounting">
      <summary>
            By convention this is true for any collection with set semantics.
            </summary>
      <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeSet`1.ContainsSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
      <value>Speed.Log</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeSet`1.Item(System.Int32)">
      <summary>
        <exception cref="T:System.IndexOutOfRangeException" /> if i is negative or
            &gt;= the size of the collection.
            </summary>
      <value>The i'th item of this list.</value>
      <param name="i">the index to lookup</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeSet`1.IndexingSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeSet`1.Item(System.Int32,System.Int32)">
      <summary>
        <exception cref="T:System.IndexOutOfRangeException" />.
            </summary>
      <value>The directed collection of items in a specific index interval.</value>
      <param name="start">The starting index of the interval (inclusive).</param>
      <param name="count">The length of the interval.</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.TreeSet`1.Comparer">
      <summary>
            The comparer object supplied at creation time for this collection
            </summary>
      <value>The comparer</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.Debug">
      <summary>
            Class containing debugging symbols - to eliminate preprocessor directives
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.Debug.UseDeterministicHashing">
      <summary>
            Flag used to test hashing. Set to true when unit testing hash functions.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.KeyValuePair`2">
      <summary>
            An entry in a dictionary from K to V.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.KeyValuePair`2.Key">
      <summary>
            The key field of the entry
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.KeyValuePair`2.Value">
      <summary>
            The value field of the entry
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePair`2.#ctor(`0,`1)">
      <summary>
            Create an entry with specified key and value
            </summary>
      <param name="key">The key</param>
      <param name="value">The value</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePair`2.#ctor(`0)">
      <summary>
            Create an entry with a specified key. The value will be the default value of type <code>V</code>.
            </summary>
      <param name="key">The key</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePair`2.ToString">
      <summary>
            Pretty print an entry
            </summary>
      <returns>(key, value)</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePair`2.Equals(System.Object)">
      <summary>
            Check equality of entries. 
            </summary>
      <param name="obj">The other object</param>
      <returns>True if obj is an entry of the same type and has the same key and value</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePair`2.GetHashCode">
      <summary>
            Get the hash code of the pair.
            </summary>
      <returns>The hash code</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePair`2.Equals(NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1})">
      <summary>
      </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePair`2.op_Equality(NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1},NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1})">
      <summary>
      </summary>
      <param name="pair1">
      </param>
      <param name="pair2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePair`2.op_Inequality(NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1},NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1})">
      <summary>
      </summary>
      <param name="pair1">
      </param>
      <param name="pair2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePair`2.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="stringbuilder">
      </param>
      <param name="formatProvider">
      </param>
      <param name="rest">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePair`2.ToString(System.String,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="format">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.KeyValuePairComparer`2">
      <summary>
            Default comparer for dictionary entries in a sorted dictionary.
            Entry comparisons only look at keys and uses an externally defined comparer for that.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePairComparer`2.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Create an entry comparer for a item comparer of the keys
            </summary>
      <param name="comparer">Comparer of keys</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePairComparer`2.Compare(NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1},NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1})">
      <summary>
            Compare two entries
            </summary>
      <param name="entry1">First entry</param>
      <param name="entry2">Second entry</param>
      <returns>The result of comparing the keys</returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.KeyValuePairEqualityComparer`2">
      <summary>
            Default equalityComparer for dictionary entries.
            Operations only look at keys and uses an externaly defined equalityComparer for that.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePairEqualityComparer`2.#ctor">
      <summary>
            Create an entry equalityComparer using the default equalityComparer for keys
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePairEqualityComparer`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create an entry equalityComparer from a specified item equalityComparer for the keys
            </summary>
      <param name="keyequalityComparer">The key equalitySCG.Comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePairEqualityComparer`2.GetHashCode(NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1})">
      <summary>
            Get the hash code of the entry
            </summary>
      <param name="entry">The entry</param>
      <returns>The hash code of the key</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.KeyValuePairEqualityComparer`2.Equals(NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1},NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1})">
      <summary>
            Test two entries for equality
            </summary>
      <param name="entry1">First entry</param>
      <param name="entry2">Second entry</param>
      <returns>True if keys are equal</returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.Speed">
      <summary>
            The symbolic characterization of the speed of lookups for a collection.
            The values may refer to worst-case, amortized and/or expected asymtotic 
            complexity wrt. the collection size.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.Speed.PotentiallyInfinite">
      <summary>
            Counting the collection with the <code>Count property</code> may not return
            (for a synthetic and potentially infinite collection).
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.Speed.Linear">
      <summary>
            Lookup operations like <code>Contains(T item)</code> or the <code>Count</code>
            property may take time O(n),
            where n is the size of the collection.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.Speed.Log">
      <summary>
            Lookup operations like <code>Contains(T item)</code> or the <code>Count</code>
            property  takes time O(log n),
            where n is the size of the collection.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.Speed.Constant">
      <summary>
            Lookup operations like <code>Contains(T item)</code> or the <code>Count</code>
            property  takes time O(1),
            where n is the size of the collection.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.EnumerationDirection">
      <summary>
            Direction of enumeration order relative to original collection.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.EnumerationDirection.Forwards">
      <summary>
            Same direction
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.EnumerationDirection.Backwards">
      <summary>
            Opposite direction
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.EventTypeEnum">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.EventTypeEnum.None">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.EventTypeEnum.Changed">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.EventTypeEnum.Cleared">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.EventTypeEnum.Added">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.EventTypeEnum.Removed">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.EventTypeEnum.Basic">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.EventTypeEnum.Inserted">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.EventTypeEnum.RemovedAt">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.EventTypeEnum.All">
      <summary>
      </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ItemAtEventArgs`1">
      <summary>
      </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.ItemAtEventArgs`1.Item">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.ItemAtEventArgs`1.Index">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ItemAtEventArgs`1.#ctor(`0,System.Int32)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ItemAtEventArgs`1.ToString">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ItemCountEventArgs`1">
      <summary>
      </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.ItemCountEventArgs`1.Item">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.ItemCountEventArgs`1.Count">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ItemCountEventArgs`1.#ctor(`0,System.Int32)">
      <summary>
      </summary>
      <param name="count">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ItemCountEventArgs`1.ToString">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ClearedEventArgs">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.ClearedEventArgs.Full">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.ClearedEventArgs.Count">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ClearedEventArgs.#ctor(System.Boolean,System.Int32)">
      <summary>
      </summary>
      <param name="full">True if the operation cleared all of the collection</param>
      <param name="count">The number of items removed by the clear.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ClearedEventArgs.ToString">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ClearedRangeEventArgs">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.ClearedRangeEventArgs.Start">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ClearedRangeEventArgs.#ctor(System.Boolean,System.Int32,System.Nullable{System.Int32})">
      <summary>
      </summary>
      <param name="full">
      </param>
      <param name="count">
      </param>
      <param name="start">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ClearedRangeEventArgs.ToString">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.CollectionChangedHandler`1">
      <summary>
            The type of event raised after an operation on a collection has changed its contents.
            Normally, a multioperation like AddAll, 
            <see cref="M:C5.IExtensible`1.AddAll(System.Collections.Generic.IEnumerable{`0})" /> 
            will only fire one CollectionChanged event. Any operation that changes the collection
            must fire CollectionChanged as its last event.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.CollectionClearedHandler`1">
      <summary>
            The type of event raised after the Clear() operation on a collection.
            <para />
            Note: The Clear() operation will not fire ItemsRemoved events. 
            </summary>
      <param name="sender">
      </param>
      <param name="eventArgs">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ItemsAddedHandler`1">
      <summary>
            The type of event raised after an item has been added to a collection.
            The event will be raised at a point of time, where the collection object is 
            in an internally consistent state and before the corresponding CollectionChanged 
            event is raised.
            <para />
            Note: an Update operation will fire an ItemsRemoved and an ItemsAdded event.
            <para />
            Note: When an item is inserted into a list (<see cref="T:C5.IList`1" />), both
            ItemInserted and ItemsAdded events will be fired.
            </summary>
      <param name="sender">
      </param>
      <param name="eventArgs">An object with the item that was added</param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ItemsRemovedHandler`1">
      <summary>
            The type of event raised after an item has been removed from a collection.
            The event will be raised at a point of time, where the collection object is 
            in an internally consistent state and before the corresponding CollectionChanged 
            event is raised.
            <para />
            Note: The Clear() operation will not fire ItemsRemoved events. 
            <para />
            Note: an Update operation will fire an ItemsRemoved and an ItemsAdded event.
            <para />
            Note: When an item is removed from a list by the RemoveAt operation, both an 
            ItemsRemoved and an ItemRemovedAt event will be fired.
            </summary>
      <param name="sender">
      </param>
      <param name="eventArgs">An object with the item that was removed</param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ItemInsertedHandler`1">
      <summary>
            The type of event raised after an item has been inserted into a list by an Insert, 
            InsertFirst or InsertLast operation.
            The event will be raised at a point of time, where the collection object is 
            in an internally consistent state and before the corresponding CollectionChanged 
            event is raised.
            <para />
            Note: an ItemsAdded event will also be fired.
            </summary>
      <param name="sender">
      </param>
      <param name="eventArgs">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ItemRemovedAtHandler`1">
      <summary>
            The type of event raised after an item has been removed from a list by a RemoveAt(int i)
            operation (or RemoveFirst(), RemoveLast(), Remove() operation).
            The event will be raised at a point of time, where the collection object is 
            in an internally consistent state and before the corresponding CollectionChanged 
            event is raised.
            <para />
            Note: an ItemRemoved event will also be fired.
            </summary>
      <param name="sender">
      </param>
      <param name="eventArgs">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.InternalException">
      <summary>
            An exception to throw from library code when an internal inconsistency is encountered.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException">
      <summary>
            An exception thrown by an update operation on a Read-Only collection or dictionary.
            <para>This exception will be thrown unconditionally when an update operation 
            (method or set property) is called. No check is made to see if the update operation, 
            if allowed, would actually change the collection. </para></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException.#ctor">
      <summary>
            Create a simple exception with no further explanation.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException.#ctor(System.String)">
      <summary>
            Create the exception with an explanation of the reason.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.FixedSizeCollectionException">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.FixedSizeCollectionException.#ctor">
      <summary>
            Create a simple exception with no further explanation.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.FixedSizeCollectionException.#ctor(System.String)">
      <summary>
            Create the exception with an explanation of the reason.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.UnlistenableEventException">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.UnlistenableEventException.#ctor">
      <summary>
            Create a simple exception with no further explanation.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.UnlistenableEventException.#ctor(System.String)">
      <summary>
            Create the exception with an explanation of the reason.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.CollectionModifiedException">
      <summary>
            An exception thrown by enumerators, range views etc. when accessed after 
            the underlying collection has been modified.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionModifiedException.#ctor">
      <summary>
            Create a simple exception with no further explanation.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.CollectionModifiedException.#ctor(System.String)">
      <summary>
            Create the exception with an explanation of the reason.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.ViewDisposedException">
      <summary>
            An excption thrown when trying to access a view (a list view on a <see cref="T:C5.IList`1" /> or 
            a snapshot on a <see cref="T:C5.IPersistentSorted`1" />)
            that has been invalidated by some earlier operation.
            <para>
            The typical scenario is a view on a list that hash been invalidated by a call to 
            Sort, Reverse or Shuffle on some other, overlapping view or the whole list.
            </para></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ViewDisposedException.#ctor">
      <summary>
            Create a simple exception with no further explanation.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.ViewDisposedException.#ctor(System.String)">
      <summary>
            Create the exception with an explanation of the reason.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.NoSuchItemException">
      <summary>
            An exception thrown by a lookup or lookup with update operation that does not 
            find the lookup item and has no other means to communicate failure.
            <para>The typical scenario is a lookup by key in a dictionary with an indexer,
            see e.g. <see cref="P:C5.IDictionary`2.Item(`0)" /></para></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.NoSuchItemException.#ctor">
      <summary>
            Create a simple exception with no further explanation.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.NoSuchItemException.#ctor(System.String)">
      <summary>
            Create the exception with an explanation of the reason.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.NotAViewException">
      <summary>
            An exception thrown by an operation on a list (<see cref="T:C5.IList`1" />)
            that only makes sense for a view, not for an underlying list.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.NotAViewException.#ctor">
      <summary>
            Create a simple exception with no further explanation.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.NotAViewException.#ctor(System.String)">
      <summary>
            Create the exception with an explanation of the reason.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException">
      <summary>
            An exception thrown when an operation attempts to create a duplicate in a collection with set semantics 
            (<see cref="P:C5.IExtensible`1.AllowsDuplicates" /> is false) or attempts to create a duplicate key in a dictionary.
            <para>With collections this can only happen with Insert operations on lists, since the Add operations will
            not try to create duplictes and either ignore the failure or report it in a bool return value.
            </para><para>With dictionaries this can happen with the <see cref="M:C5.IDictionary`2.Add(`0,`1)" /> metod.</para></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException.#ctor">
      <summary>
            Create a simple exception with no further explanation.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.DuplicateNotAllowedException.#ctor(System.String)">
      <summary>
            Create the exception with an explanation of the reason.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.InvalidPriorityQueueHandleException">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.InvalidPriorityQueueHandleException.#ctor">
      <summary>
            Create a simple exception with no further explanation.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.InvalidPriorityQueueHandleException.#ctor(System.String)">
      <summary>
            Create the exception with an explanation of the reason.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.NotComparableException">
      <summary>
            An exception thrown by an operation that need to construct a natural
            comparer for a type.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.NotComparableException.#ctor">
      <summary>
            Create a simple exception with no further explanation.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.NotComparableException.#ctor(System.String)">
      <summary>
            Create the exception with an explanation of the reason.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.IncompatibleViewException">
      <summary>
            An exception thrown by operations on a list that expects an argument
            that is a view on the same underlying list.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IncompatibleViewException.#ctor">
      <summary>
            Create a simple exception with no further explanation.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.IncompatibleViewException.#ctor(System.String)">
      <summary>
            Create the exception with an explanation of the reason.
            </summary>
      <param name="message">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.Showing">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Showing.Show(System.Object,System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
      <summary>
            Show  <code>Object obj</code> by appending it to <code>stringbuilder</code></summary>
      <param name="obj">
      </param>
      <param name="stringbuilder">
      </param>
      <param name="rest">
      </param>
      <param name="formatProvider">
      </param>
      <returns>True if <code>obj</code> was shown completely.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Showing.ShowString(NSoft.NFramework.Collections.C5.IShowable,System.String,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="showable">
      </param>
      <param name="format">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Showing.ShowCollectionValue``1(NSoft.NFramework.Collections.C5.ICollectionValue{``0},System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
      <summary>
      </summary>
      <typeparam name="T">
      </typeparam>
      <param name="items">
      </param>
      <param name="stringbuilder">
      </param>
      <param name="rest">
      </param>
      <param name="formatProvider">
      </param>
      <returns>True if collection was shown completely</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Showing.ShowDictionary``2(NSoft.NFramework.Collections.C5.IDictionary{``0,``1},System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
      <summary>
      </summary>
      <typeparam name="K">
      </typeparam>
      <typeparam name="V">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="stringbuilder">
      </param>
      <param name="formatProvider">
      </param>
      <param name="rest">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.EqualityComparer`1">
      <summary>
            Utility class for building default generic equality comparers.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.EqualityComparer`1.Default">
      <summary>
            A default generic equality comparer for type T. The procedure is as follows:
            <list><item>If the actual generic argument T implements the generic interface
            <see cref="T:C5.ISequenced`1" /> for some value W of its generic parameter T,
            the equalityComparer will be <see cref="T:C5.SequencedCollectionEqualityComparer`2" /></item><item>If the actual generic argument T implements 
            <see cref="T:C5.ICollection`1" /> for some value W of its generic parameter T,
            the equalityComparer will be <see cref="T:C5.UnsequencedCollectionEqualityComparer`2" /></item><item>Otherwise the SCG.EqualityComparer&lt;T&gt;.Default is returned</item></list></summary>
      <value>The comparer</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.SequencedCollectionEqualityComparer`2">
      <summary>
            Prototype for a sequenced equalityComparer for something (T) that implements ISequenced[W].
            This will use ISequenced[W] specific implementations of the equality comparer operations.
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="W">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SequencedCollectionEqualityComparer`2.GetHashCode(`0)">
      <summary>
            Get the hash code with respect to this sequenced equalityComparer
            </summary>
      <param name="collection">The collection</param>
      <returns>The hash code</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.SequencedCollectionEqualityComparer`2.Equals(`0,`0)">
      <summary>
            Check if two items are equal with respect to this sequenced equalityComparer
            </summary>
      <param name="collection1">first collection</param>
      <param name="collection2">second collection</param>
      <returns>True if equal</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.SequencedCollectionEqualityComparer`2.Default">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.UnsequencedCollectionEqualityComparer`2">
      <summary>
            Prototype for an unsequenced equalityComparer for something (T) that implements ICollection[W]
            This will use ICollection[W] specific implementations of the equalityComparer operations
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="W">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.UnsequencedCollectionEqualityComparer`2.GetHashCode(`0)">
      <summary>
            Get the hash code with respect to this unsequenced equalityComparer
            </summary>
      <param name="collection">The collection</param>
      <returns>The hash code</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.UnsequencedCollectionEqualityComparer`2.Equals(`0,`0)">
      <summary>
            Check if two collections are equal with respect to this unsequenced equalityComparer
            </summary>
      <param name="collection1">first collection</param>
      <param name="collection2">second collection</param>
      <returns>True if equal</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.UnsequencedCollectionEqualityComparer`2.Default">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.Logger">
      <summary>
            Logging module
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.Logger.Log">
      <summary>
            Gets or sets the log.
            </summary>
      <example>The following is an example of assigning a observer to the logging module:
              <code>
                Logger.Log = x =&gt; Console.WriteLine(x);
              </code></example>
      <remarks>
            If Log is not set it will return a dummy action
            <c>x =&gt; { return; })</c>
            eliminating the need for null-reference checks.
            </remarks>
      <value>
            The log.
            </value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.C5Random">
      <summary>
            A modern random number generator based on G. Marsaglia: 
            Seeds for Random Number Generators, Communications of the
            ACM 46, 5 (May 2003) 90-93; and a posting by Marsaglia to 
            comp.lang.c on 2003-04-03.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.C5Random.NextDouble">
      <summary>
            Get a new random System.Double value
            </summary>
      <returns>The random double</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.C5Random.Sample">
      <summary>
            Get a new random System.Double value
            </summary>
      <returns>The random double</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.C5Random.Next">
      <summary>
            Get a new random System.Int32 value
            </summary>
      <returns>The random int</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.C5Random.Next(System.Int32)">
      <summary>
            Get a random non-negative integer less than a given upper bound
            </summary>
      <exception cref="T:System.ArgumentException">If max is negative</exception>
      <param name="max">The upper bound (exclusive)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.C5Random.Next(System.Int32,System.Int32)">
      <summary>
            Get a random integer between two given bounds
            </summary>
      <exception cref="T:System.ArgumentException">If max is less than min</exception>
      <param name="min">The lower bound (inclusive)</param>
      <param name="max">The upper bound (exclusive)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.C5Random.NextBytes(System.Byte[])">
      <summary>
            Fill a array of byte with random bytes
            </summary>
      <param name="buffer">The array to fill</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.C5Random.#ctor">
      <summary>
            Create a random number generator seed by system time.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.C5Random.#ctor(System.Int64)">
      <summary>
            Create a random number generator with a given seed
            </summary>
      <exception cref="T:System.ArgumentException">If seed is zero</exception>
      <param name="seed">The seed</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.C5Random.#ctor(System.UInt32[])">
      <summary>
            Create a random number generator with a specified internal start state.
            </summary>
      <exception cref="T:System.ArgumentException">If Q is not of length exactly 16</exception>
      <param name="Q">The start state. Must be a collection of random bits given by an array of exactly 16 uints.</param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.Rec`2">
      <summary>
            A generic record type with two fields. 
            <para>
            Equality is defined field by field, using the <code>Equals</code> method 
            inherited from <code>System.Object</code> (i.e. using <see cref="T:C5.NaturalEqualityComparer`1" />).
            </para><para>
            This type is similar to <see cref="T:C5.KeyValuePair`2" />, but the latter
            uses <see cref="P:C5.EqualityComparer`1.Default" /> to define field equality instead of <see cref="T:C5.NaturalEqualityComparer`1" />.
            </para></summary>
      <typeparam name="T1">
      </typeparam>
      <typeparam name="T2">
      </typeparam>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.Rec`2.X1">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.Rec`2.X2">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`2.#ctor(`0,`1)">
      <summary>
      </summary>
      <param name="x1">
      </param>
      <param name="x2">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`2.Equals(NSoft.NFramework.Collections.C5.Rec{`0,`1})">
      <summary>
      </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`2.Equals(System.Object)">
      <summary>
      </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`2.op_Equality(NSoft.NFramework.Collections.C5.Rec{`0,`1},NSoft.NFramework.Collections.C5.Rec{`0,`1})">
      <summary>
      </summary>
      <param name="record1">
      </param>
      <param name="record2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`2.op_Inequality(NSoft.NFramework.Collections.C5.Rec{`0,`1},NSoft.NFramework.Collections.C5.Rec{`0,`1})">
      <summary>
      </summary>
      <param name="record1">
      </param>
      <param name="record2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`2.GetHashCode">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`2.ToString">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`2.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="stringbuilder">
      </param>
      <param name="rest">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`2.ToString(System.String,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="format">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.Rec`3">
      <summary>
      </summary>
      <typeparam name="T1">
      </typeparam>
      <typeparam name="T2">
      </typeparam>
      <typeparam name="T3">
      </typeparam>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.Rec`3.X1">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.Rec`3.X2">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.Rec`3.X3">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`3.#ctor(`0,`1,`2)">
      <summary>
      </summary>
      <param name="x1">
      </param>
      <param name="x2">
      </param>
      <param name="x3">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`3.Equals(NSoft.NFramework.Collections.C5.Rec{`0,`1,`2})">
      <summary>
      </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`3.Equals(System.Object)">
      <summary>
      </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`3.op_Equality(NSoft.NFramework.Collections.C5.Rec{`0,`1,`2},NSoft.NFramework.Collections.C5.Rec{`0,`1,`2})">
      <summary>
      </summary>
      <param name="record1">
      </param>
      <param name="record2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`3.op_Inequality(NSoft.NFramework.Collections.C5.Rec{`0,`1,`2},NSoft.NFramework.Collections.C5.Rec{`0,`1,`2})">
      <summary>
      </summary>
      <param name="record1">
      </param>
      <param name="record2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`3.GetHashCode">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`3.ToString">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`3.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="stringbuilder">
      </param>
      <param name="rest">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`3.ToString(System.String,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="format">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.Rec`4">
      <summary>
      </summary>
      <typeparam name="T1">
      </typeparam>
      <typeparam name="T2">
      </typeparam>
      <typeparam name="T3">
      </typeparam>
      <typeparam name="T4">
      </typeparam>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.Rec`4.X1">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.Rec`4.X2">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.Rec`4.X3">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.C5.Rec`4.X4">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`4.#ctor(`0,`1,`2,`3)">
      <summary>
      </summary>
      <param name="x1">
      </param>
      <param name="x2">
      </param>
      <param name="x3">
      </param>
      <param name="x4">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`4.Equals(NSoft.NFramework.Collections.C5.Rec{`0,`1,`2,`3})">
      <summary>
      </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`4.Equals(System.Object)">
      <summary>
      </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`4.op_Equality(NSoft.NFramework.Collections.C5.Rec{`0,`1,`2,`3},NSoft.NFramework.Collections.C5.Rec{`0,`1,`2,`3})">
      <summary>
      </summary>
      <param name="record1">
      </param>
      <param name="record2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`4.op_Inequality(NSoft.NFramework.Collections.C5.Rec{`0,`1,`2,`3},NSoft.NFramework.Collections.C5.Rec{`0,`1,`2,`3})">
      <summary>
      </summary>
      <param name="record1">
      </param>
      <param name="record2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`4.GetHashCode">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`4.ToString">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`4.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="stringbuilder">
      </param>
      <param name="rest">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Rec`4.ToString(System.String,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="format">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.Sorting">
      <summary>
            A utility class with functions for sorting arrays with respect to an IComparer&lt;T&gt;
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Sorting.IntroSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
      <summary>
            Sort part of array in place using IntroSort
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">If the <code>start</code>
            and <code>count</code> arguments does not describe a valid range.</exception>
      <param name="array">Array to sort</param>
      <param name="start">Index of first position to sort</param>
      <param name="count">Number of elements to sort</param>
      <param name="comparer">IComparer&lt;T&gt; to sort by</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Sorting.IntroSort``1(``0[])">
      <summary>
            Sort an array in place using IntroSort and default comparer
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotComparableException">If T is not comparable</exception>
      <param name="array">Array to sort</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Sorting.InsertionSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
      <summary>
            Sort part of array in place using Insertion Sort
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">If the <code>start</code>
            and <code>count</code> arguments does not describe a valid range.</exception>
      <param name="array">Array to sort</param>
      <param name="start">Index of first position to sort</param>
      <param name="count">Number of elements to sort</param>
      <param name="comparer">IComparer&lt;T&gt; to sort by</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.Sorting.HeapSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
      <summary>
            Sort part of array in place using Heap Sort
            </summary>
      <exception cref="T:System.ArgumentOutOfRangeException">If the <code>start</code>
            and <code>count</code> arguments does not describe a valid range.</exception>
      <param name="array">Array to sort</param>
      <param name="start">Index of first position to sort</param>
      <param name="count">Number of elements to sort</param>
      <param name="comparer">IComparer&lt;T&gt; to sort by</param>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.WrappedArray`1">
      <summary>
            An advanced interface to operations on an array. The array is viewed as an 
            <see cref="T:C5.IList`1" /> of fixed size, and so all operations that would change the
            size of the array will be invalid (and throw <see cref="T:C5.FixedSizeCollectionException" /></summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
      </summary>
      <param name="filter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Map``1(System.Func{`0,``0})">
      <summary>
      </summary>
      <typeparam name="V">
      </typeparam>
      <param name="mapper">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
      </summary>
      <typeparam name="V">
      </typeparam>
      <param name="mapper">
      </param>
      <param name="equalityComparer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Insert(System.Int32,`0)">
      <summary>
      </summary>
      <param name="index">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Insert(NSoft.NFramework.Collections.C5.IList{`0},`0)">
      <summary>
      </summary>
      <param name="pointer">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.InsertFirst(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.InsertLast(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>
      </summary>
      <param name="i">
      </param>
      <param name="items">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Remove">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.RemoveFirst">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.RemoveLast">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.View(System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="start">
      </param>
      <param name="count">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.ViewOf(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.LastViewOf(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Slide(System.Int32)">
      <summary>
      </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Slide(System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="offset">
      </param>
      <param name="size">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.TrySlide(System.Int32)">
      <summary>
      </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.TrySlide(System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="offset">
      </param>
      <param name="size">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Span(NSoft.NFramework.Collections.C5.IList{`0})">
      <summary>
      </summary>
      <param name="otherView">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Reverse">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.IsSorted">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.IsSorted(System.Collections.Generic.IComparer{`0})">
      <summary>
      </summary>
      <param name="comparer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Sort">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Sort(System.Collections.Generic.IComparer{`0})">
      <summary>
      </summary>
      <param name="comparer">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Shuffle">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Shuffle(System.Random)">
      <summary>
      </summary>
      <param name="rnd">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.IndexOf(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.LastIndexOf(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.FindIndex(System.Func{`0,System.Boolean})">
      <summary>
      </summary>
      <param name="predicate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.FindLastIndex(System.Func{`0,System.Boolean})">
      <summary>
      </summary>
      <param name="predicate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.RemoveAt(System.Int32)">
      <summary>
      </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.RemoveInterval(System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="start">
      </param>
      <param name="count">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.GetSequencedHashCode">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.SequencedEquals(NSoft.NFramework.Collections.C5.ISequenced{`0})">
      <summary>
      </summary>
      <param name="that">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.GetUnsequencedHashCode">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.UnsequencedEquals(NSoft.NFramework.Collections.C5.ICollection{`0})">
      <summary>
      </summary>
      <param name="that">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Contains(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.ContainsCount(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.UniqueItems">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.ItemMultiplicities">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
      </summary>
      <param name="items">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Find(`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.FindOrAdd(`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Update(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Update(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.UpdateOrAdd(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.UpdateOrAdd(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Remove(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Remove(`0,`0@)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <param name="removeditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.RemoveAllCopies(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
      </summary>
      <param name="items">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Clear">
      <summary>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
      </summary>
      <param name="items">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Add(`0)">
      <summary>
      </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
      </summary>
      <param name="items">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Check">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.CopyTo(`0[],System.Int32)">
      <summary>
      </summary>
      <param name="array">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.ToArray">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Apply(System.Action{`0})">
      <summary>
      </summary>
      <param name="action">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Exists(System.Func{`0,System.Boolean})">
      <summary>
      </summary>
      <param name="predicate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Find(System.Func{`0,System.Boolean},`0@)">
      <summary>
      </summary>
      <param name="predicate">
      </param>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.All(System.Func{`0,System.Boolean})">
      <summary>
      </summary>
      <param name="predicate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Choose">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Filter(System.Func{`0,System.Boolean})">
      <summary>
      </summary>
      <param name="filter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.GetEnumerator">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="stringbuilder">
      </param>
      <param name="rest">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.ToString">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.ToString(System.String,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="format">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Backwards">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.FindLast(System.Func{`0,System.Boolean},`0@)">
      <summary>
      </summary>
      <param name="predicate">
      </param>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.WrappedArray`1.Dispose">
      <summary>
            Dispose this if a view else operation is illegal 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.FixedSizeCollectionException">If not a view</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.First">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.Last">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.Item(System.Int32)">
      <summary>
      </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.FIFO">
      <summary>
            ???? should we throw NotRelevantException
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.IsFixedSize">
      <summary>
      </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.Underlying">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.Offset">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.IsValid">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.IndexingSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.Item(System.Int32,System.Int32)">
      <summary>
      </summary>
      <param name="start">
      </param>
      <param name="count">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.ContainsSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.IsReadOnly">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.EqualityComparer">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.DuplicatesByCounting">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.ListenableEvents">
      <summary>
            No listeners may be installed
            </summary>
      <value>0</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.ActiveEvents">
      <summary>
            No listeners ever installed
            </summary>
      <value>0</value>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.WrappedArray`1.CollectionChanged">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.WrappedArray`1.CollectionCleared">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.WrappedArray`1.ItemsAdded">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.WrappedArray`1.ItemInserted">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.WrappedArray`1.ItemsRemoved">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.WrappedArray`1.ItemRemovedAt">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.IsEmpty">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.Count">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.CountSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.WrappedArray`1.Direction">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.GuardedEnumerator`1">
      <summary>
            A read-only wrapper class for a generic enumerator
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
      <summary>
            Create a wrapper around a generic enumerator
            </summary>
      <param name="enumerator">The enumerator to wrap</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedEnumerator`1.MoveNext">
      <summary>
            Move wrapped enumerator to next item, or the first item if
            this is the first call to MoveNext. 
            </summary>
      <returns>True if enumerator is valid now</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedEnumerator`1.Dispose">
      <summary>
            Dispose wrapped enumerator.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedEnumerator`1.Current">
      <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
      <value>The current item of the wrapped enumerator.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.GuardedEnumerable`1">
      <summary>
             A read-only wrapper class for a generic enumerable
            
             <i>This is mainly interesting as a base of other guard classes</i></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Wrap an enumerable in a read-only wrapper
            </summary>
      <param name="enumerable">The enumerable to wrap</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedEnumerable`1.GetEnumerator">
      <summary>
            Get an enumerator from the wrapped enumerable
            </summary>
      <returns>The enumerator (itself wrapped)</returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.GuardedDirectedEnumerable`1">
      <summary>
             A read-only wrapper for a generic directed enumerable
            
             <i>This is mainly interesting as a base of other guard classes</i></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDirectedEnumerable`1.#ctor(NSoft.NFramework.Collections.C5.IDirectedEnumerable{`0})">
      <summary>
            Wrap a directed enumerable in a read-only wrapper
            </summary>
      <param name="directedenumerable">the collection to wrap</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDirectedEnumerable`1.Backwards">
      <summary>
            Get a enumerable that enumerates the wrapped collection in the opposite direction
            </summary>
      <returns>The mirrored enumerable</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedDirectedEnumerable`1.Direction">
      <summary>
        <code>Forwards</code> if same, else <code>Backwards</code></summary>
      <value>The enumeration direction relative to the original collection.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1">
      <summary>
             A read-only wrapper for an ICollectionValue&lt;T&gt;
            
             <i>This is mainly interesting as a base of other guard classes</i></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.#ctor(NSoft.NFramework.Collections.C5.ICollectionValue{`0})">
      <summary>
            Wrap a ICollectionValue&lt;T&gt; in a read-only wrapper
            </summary>
      <param name="collectionvalue">the collection to wrap</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copy the items of the wrapped collection to an array
            </summary>
      <param name="a">The array</param>
      <param name="i">Starting offset</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.ToArray">
      <summary>
            Create an array from the items of the wrapped collection
            </summary>
      <returns>The array</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.Apply(System.Action{`0})">
      <summary>
            Apply a delegate to all items of the wrapped enumerable.
            </summary>
      <param name="a">The delegate to apply</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.Exists(System.Func{`0,System.Boolean})">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in the wrapped enumerable.
            </summary>
      <param name="filter">A filter delegate 
            (<see cref="T:C5.Filter`1" />) defining the predicate</param>
      <returns>True is such an item exists</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.Find(System.Func{`0,System.Boolean},`0@)">
      <summary>
      </summary>
      <param name="filter">
      </param>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.All(System.Func{`0,System.Boolean})">
      <summary>
            Check if all items in the wrapped enumerable satisfies a specific predicate.
            </summary>
      <param name="filter">A filter delegate 
            (<see cref="T:C5.Filter`1" />) defining the predicate</param>
      <returns>True if all items satisfies the predicate</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.Filter(System.Func{`0,System.Boolean})">
      <summary>
            Create an enumerable, enumerating the items of this collection that satisfies 
            a certain condition.
            </summary>
      <param name="filter">The T-&gt;bool filter delegate defining the condition</param>
      <returns>The filtered enumerable</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.Choose">
      <summary>
            Choose some item of this collection. 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException">if collection is empty.</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="stringbuilder">
      </param>
      <param name="formatProvider">
      </param>
      <param name="rest">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.ToString(System.String,System.IFormatProvider)">
      <summary>
      </summary>
      <param name="format">
      </param>
      <param name="formatProvider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.ListenableEvents">
      <summary>
            The ListenableEvents value of the wrapped collection
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.ActiveEvents">
      <summary>
            The ActiveEvents value of the wrapped collection
            </summary>
      <value>
      </value>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.CollectionChanged">
      <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.CollectionCleared">
      <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.ItemsAdded">
      <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.ItemInserted">
      <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.ItemsRemoved">
      <summary>
            The item removed event. Will be raised for every individual removal from the collection.
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.ItemRemovedAt">
      <summary>
            The item removed event. Will be raised for every individual removal from the collection.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.IsEmpty">
      <summary>
            Get the size of the wrapped collection
            </summary>
      <value>The size</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.Count">
      <summary>
            Get the size of the wrapped collection
            </summary>
      <value>The size</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedCollectionValue`1.CountSpeed">
      <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
      <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.GuardedDirectedCollectionValue`1">
      <summary>
             A read-only wrapper for a directed collection
            
             <i>This is mainly interesting as a base of other guard classes</i></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDirectedCollectionValue`1.#ctor(NSoft.NFramework.Collections.C5.IDirectedCollectionValue{`0})">
      <summary>
            Wrap a directed collection in a read-only wrapper
            </summary>
      <param name="directedcollection">the collection to wrap</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDirectedCollectionValue`1.Backwards">
      <summary>
            Get a collection that enumerates the wrapped collection in the opposite direction
            </summary>
      <returns>The mirrored collection</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDirectedCollectionValue`1.FindLast(System.Func{`0,System.Boolean},`0@)">
      <summary>
      </summary>
      <param name="predicate">
      </param>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedDirectedCollectionValue`1.Direction">
      <summary>
        <code>Forwards</code> if same, else <code>Backwards</code></summary>
      <value>The enumeration direction relative to the original collection.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.GuardedCollection`1">
      <summary>
            A read-only wrapper for an <see cref="T:C5.ICollection`1" />,
            <para><i>Suitable for wrapping hash tables, <see cref="T:C5.HashSet`1" />
            and <see cref="T:C5.HashBag`1" /></i></para></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.#ctor(NSoft.NFramework.Collections.C5.ICollection{`0})">
      <summary>
            Wrap an ICollection&lt;T&gt; in a read-only wrapper
            </summary>
      <param name="collection">the collection to wrap</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.GetUnsequencedHashCode">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.UnsequencedEquals(NSoft.NFramework.Collections.C5.ICollection{`0})">
      <summary>
      </summary>
      <param name="that">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.Contains(`0)">
      <summary>
            Check if an item is in the wrapped collection
            </summary>
      <param name="item">The item</param>
      <returns>True if found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.ContainsCount(`0)">
      <summary>
            Count the number of times an item appears in the wrapped collection
            </summary>
      <param name="item">The item</param>
      <returns>The number of copies</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.UniqueItems">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.ItemMultiplicities">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Check if all items in the argument is in the wrapped collection
            </summary>
      <param name="items">The items</param>
      <returns>True if so</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.Find(`0@)">
      <summary> 
            Search for an item in the wrapped collection
            </summary>
      <param name="item">On entry the item to look for, on exit the equivalent item found (if any)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.FindOrAdd(`0@)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.Update(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.Update(`0,`0@)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.UpdateOrAdd(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.UpdateOrAdd(`0,`0@)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="item">
      </param>
      <param name="olditem">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.Remove(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.Remove(`0,`0@)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="item">The value to remove.</param>
      <param name="removeditem">The removed value.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.RemoveAllCopies(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="items">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.Clear">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="items">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.Check">
      <summary>
            Check  wrapped collection for internal consistency
            </summary>
      <returns>True if check passed</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.Add(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedCollection`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="items">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedCollection`1.IsReadOnly">
      <summary>
            (This is a read-only wrapper)
            </summary>
      <value>True</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedCollection`1.ContainsSpeed">
      <summary>
      </summary>
      <value>Speed of wrapped collection</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedCollection`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>False if wrapped collection has set semantics</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedCollection`1.EqualityComparer">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedCollection`1.DuplicatesByCounting">
      <summary>
            By convention this is true for any collection with set semantics.
            </summary>
      <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedCollection`1.IsEmpty">
      <summary>
      </summary>
      <value>True if wrapped collection is empty</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.GuardedSequenced`1">
      <summary>
             A read-only wrapper for a sequenced collection
            
             <i>This is mainly interesting as a base of other guard classes</i></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSequenced`1.#ctor(NSoft.NFramework.Collections.C5.ISequenced{`0})">
      <summary>
            Wrap a sequenced collection in a read-only wrapper
            </summary>
      <param name="sorted">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSequenced`1.FindIndex(System.Func{`0,System.Boolean})">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the first one.
            </summary>
      <param name="predicate">A delegate 
            (<see cref="T:Func`2" /> with <code>R == bool</code>) defining the predicate</param>
      <returns>the index, if found, a negative value else</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSequenced`1.FindLastIndex(System.Func{`0,System.Boolean})">
      <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the last one.
            </summary>
      <param name="predicate">A delegate 
            (<see cref="T:Func`2" /> with <code>R == bool</code>) defining the predicate</param>
      <returns>the index, if found, a negative value else</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSequenced`1.GetSequencedHashCode">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSequenced`1.SequencedEquals(NSoft.NFramework.Collections.C5.ISequenced{`0})">
      <summary>
      </summary>
      <param name="that">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSequenced`1.Backwards">
      <summary>
            Get a collection that enumerates the wrapped collection in the opposite direction
            </summary>
      <returns>The mirrored collection</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSequenced`1.FindLast(System.Func{`0,System.Boolean},`0@)">
      <summary>
      </summary>
      <param name="predicate">
      </param>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedSequenced`1.Direction">
      <summary>
        <code>Forwards</code> if same, else <code>Backwards</code></summary>
      <value>The enumeration direction relative to the original collection.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.GuardedSorted`1">
      <summary>
             A read-only wrapper for a sorted collection
            
             <i>This is mainly interesting as a base of other guard classes</i></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.#ctor(NSoft.NFramework.Collections.C5.ISorted{`0})">
      <summary>
            Wrap a sorted collection in a read-only wrapper
            </summary>
      <param name="sorted">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.TryPredecessor(`0,`0@)">
      <summary>
            Find the strict predecessor of item in the guarded sorted collection,
            that is, the greatest item in the collection smaller than the item.
            </summary>
      <param name="item">The item to find the predecessor for.</param>
      <param name="res">The predecessor, if any; otherwise the default value for T.</param>
      <returns>True if item has a predecessor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.TrySuccessor(`0,`0@)">
      <summary>
            Find the strict successor of item in the guarded sorted collection,
            that is, the least item in the collection greater than the supplied value.
            </summary>
      <param name="item">The item to find the successor for.</param>
      <param name="res">The successor, if any; otherwise the default value for T.</param>
      <returns>True if item has a successor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.TryWeakPredecessor(`0,`0@)">
      <summary>
            Find the weak predecessor of item in the guarded sorted collection,
            that is, the greatest item in the collection smaller than or equal to the item.
            </summary>
      <param name="item">The item to find the weak predecessor for.</param>
      <param name="res">The weak predecessor, if any; otherwise the default value for T.</param>
      <returns>True if item has a weak predecessor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.TryWeakSuccessor(`0,`0@)">
      <summary>
            Find the weak successor of item in the sorted collection,
            that is, the least item in the collection greater than or equal to the supplied value.
            </summary>
      <param name="item">The item to find the weak successor for.</param>
      <param name="res">The weak successor, if any; otherwise the default value for T.</param>
      <returns>True if item has a weak successor; otherwise false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.Predecessor(`0)">
      <summary>
            Find the predecessor of the item in the wrapped sorted collection
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists </exception>
      <param name="item">The item</param>
      <returns>The predecessor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.Successor(`0)">
      <summary>
            Find the Successor of the item in the wrapped sorted collection
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists </exception>
      <param name="item">The item</param>
      <returns>The Successor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.WeakPredecessor(`0)">
      <summary>
            Find the weak predecessor of the item in the wrapped sorted collection
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists </exception>
      <param name="item">The item</param>
      <returns>The weak predecessor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.WeakSuccessor(`0)">
      <summary>
            Find the weak Successor of the item in the wrapped sorted collection
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such element exists </exception>
      <param name="item">The item</param>
      <returns>The weak Successor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
      <summary>
            Run Cut on the wrapped sorted collection
            </summary>
      <param name="c">
      </param>
      <param name="low">
      </param>
      <param name="lval">
      </param>
      <param name="high">
      </param>
      <param name="hval">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.RangeFrom(`0)">
      <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
      <param name="bot">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.RangeFromTo(`0,`0)">
      <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
      <param name="bot">
      </param>
      <param name="top">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.RangeTo(`0)">
      <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
      <param name="top">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.RangeAll">
      <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="items">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.RemoveRangeFrom(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="low">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.RemoveRangeFromTo(`0,`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="low">
      </param>
      <param name="hi">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.RemoveRangeTo(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="hi">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.FindMin">
      <summary>
            Find the minimum of the wrapped collection
            </summary>
      <returns>The minimum</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.DeleteMin">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.FindMax">
      <summary>
            Find the maximum of the wrapped collection
            </summary>
      <returns>The maximum</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSorted`1.DeleteMax">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedSorted`1.Comparer">
      <summary>
            The comparer object supplied at creation time for the underlying collection
            </summary>
      <value>The comparer</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1">
      <summary>
             Read-only wrapper for indexed sorted collections
            
             <i>Suitable for wrapping TreeSet, TreeBag and SortedArray</i></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.#ctor(NSoft.NFramework.Collections.C5.IIndexedSorted{`0})">
      <summary>
            Wrap an indexed sorted collection in a read-only wrapper
            </summary>
      <param name="list">the indexed sorted collection</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.RangeFrom(`0)">
      <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
      <param name="bot">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.RangeFromTo(`0,`0)">
      <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
      <param name="bot">
      </param>
      <param name="top">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.RangeTo(`0)">
      <summary>
            Get the specified range from the wrapped collection. 
            (The current implementation erroneously does not wrap the result.)
            </summary>
      <param name="top">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.CountFrom(`0)">
      <summary>
            Report the number of items in the specified range of the wrapped collection
            </summary>
      <param name="bot">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.CountFromTo(`0,`0)">
      <summary>
            Report the number of items in the specified range of the wrapped collection
            </summary>
      <param name="bot">
      </param>
      <param name="top">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.CountTo(`0)">
      <summary>
            Report the number of items in the specified range of the wrapped collection
            </summary>
      <param name="top">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
            Run FindAll on the wrapped collection with the indicated filter.
            The result will <b>not</b> be read-only.
            </summary>
      <param name="f">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Run Map on the wrapped collection with the indicated mapper.
            The result will <b>not</b> be read-only.
            </summary>
      <param name="m">
      </param>
      <param name="c">The comparer to use in the result</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.IndexOf(`0)">
      <summary>
            Find the (first) index of an item in the wrapped collection
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.LastIndexOf(`0)">
      <summary>
            Find the last index of an item in the wrapped collection
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.RemoveAt(System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.RemoveInterval(System.Int32,System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="start">
      </param>
      <param name="count">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.Item(System.Int32)">
      <summary>
      </summary>
      <value>The i'th item of the wrapped sorted collection</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.IndexingSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedIndexedSorted`1.Item(System.Int32,System.Int32)">
      <summary>
      </summary>
      <value>A directed collection of the items in the indicated interval of the wrapped collection</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.GuardedList`1">
      <summary>
            A read-only wrapper for a generic list collection
            <i>Suitable as a wrapper for LinkedList, HashedLinkedList, ArrayList and HashedArray.
            <see cref="T:C5.LinkedList`1" />, 
            <see cref="T:C5.HashedLinkedList`1" />, 
            <see cref="T:C5.ArrayList`1" /> or
            <see cref="T:C5.HashedArray`1" />.
            </i></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.#ctor(NSoft.NFramework.Collections.C5.IList{`0})">
      <summary>
            Wrap a list in a read-only wrapper.  A list gets wrapped as read-only,
            a list view gets wrapped as read-only and non-slidable.
            </summary>
      <param name="list">The list</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Insert(System.Int32,`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="index">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Insert(NSoft.NFramework.Collections.C5.IList{`0},`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="pointer">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.InsertFirst(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.InsertLast(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.InsertBefore(`0,`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="item">
      </param>
      <param name="target">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.InsertAfter(`0,`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="item">
      </param>
      <param name="target">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="i">
      </param>
      <param name="items">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
            Perform FindAll on the wrapped list. The result is <b>not</b> necessarily read-only.
            </summary>
      <param name="filter">The filter to use</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Map``1(System.Func{`0,``0})">
      <summary>
            Perform Map on the wrapped list. The result is <b>not</b> necessarily read-only.
            </summary>
      <typeparam name="V">The type of items of the new list</typeparam>
      <param name="mapper">The mapper to use.</param>
      <returns>The mapped list</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Perform Map on the wrapped list. The result is <b>not</b> necessarily read-only.
            </summary>
      <typeparam name="V">The type of items of the new list</typeparam>
      <param name="mapper">The delegate defining the map.</param>
      <param name="itemequalityComparer">The itemequalityComparer to use for the new list</param>
      <returns>The new list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Remove">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.RemoveFirst">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.RemoveLast">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.View(System.Int32,System.Int32)">
      <summary>
            Create the indicated view on the wrapped list and wrap it read-only.
            </summary>
      <param name="start">
      </param>
      <param name="count">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.ViewOf(`0)">
      <summary>
            Create the indicated view on the wrapped list and wrap it read-only.
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.LastViewOf(`0)">
      <summary>
            Create the indicated view on the wrapped list and wrap it read-only.
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Slide(System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> if this is a wrapped view and not a view that was made on a wrapper</exception>
      <param name="offset">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Slide(System.Int32,System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="offset">
      </param>
      <param name="size">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.TrySlide(System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.TrySlide(System.Int32,System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="offset">
      </param>
      <param name="size">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Span(NSoft.NFramework.Collections.C5.IList{`0})">
      <summary>
      </summary>
      <param name="otherView">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Reverse">
      <summary>
        <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Reverse(System.Int32,System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="start">
      </param>
      <param name="count">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.IsSorted">
      <summary>
            Check if wrapped list is sorted according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1" /> class 
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NotComparableException">if T is not comparable</exception>
      <returns>True if the list is sorted, else false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.IsSorted(System.Collections.Generic.IComparer{`0})">
      <summary>
            Check if wrapped list is sorted
            </summary>
      <param name="c">The sorting order to use</param>
      <returns>True if sorted</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Sort">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Sort(System.Collections.Generic.IComparer{`0})">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="c">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Shuffle">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Shuffle(System.Random)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="rnd">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.IndexOf(`0)">
      <summary>
            Find the (first) index of an item in the wrapped collection
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.LastIndexOf(`0)">
      <summary>
            Find the last index of an item in the wrapped collection
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.RemoveAt(System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.RemoveInterval(System.Int32,System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="start">
      </param>
      <param name="count">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Push(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <returns>-</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Pop">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <returns>-</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Enqueue(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <returns>-</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Dequeue">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <returns>-</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedList`1.Dispose">
      <summary>
            Ignore: this may be called by a foreach or using statement.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedList`1.First">
      <summary>
      </summary>
      <value>The first item of the wrapped list</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedList`1.Last">
      <summary>
      </summary>
      <value>The last item of the wrapped list</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedList`1.FIFO">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> if used as setter</exception>
      <value>True if wrapped list has FIFO semantics for the Add(T item) and Remove() methods</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedList`1.IsFixedSize">
      <summary>
      </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedList`1.Item(System.Int32)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> if used as setter</exception>
      <value>The i'th item of the wrapped list</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedList`1.IndexingSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedList`1.Underlying">
      <summary>
      </summary>
      <value>The wrapped underlying list of the wrapped view </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedList`1.Offset">
      <summary>
      </summary>
      <value>The offset of the wrapped list as a view.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedList`1.IsValid">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedList`1.Item(System.Int32,System.Int32)">
      <summary>
      </summary>
      <value>A directed collection of the items in the indicated interval of the wrapped collection</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.GuardedQueue`1">
      <summary>
            A read-only wrapper for a generic indexable queue (allows indexing).
            
            <para>Suitable for wrapping a <see cref="T:C5.CircularQueue`1" /></para></summary>
      <typeparam name="T">The item type.</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedQueue`1.#ctor(NSoft.NFramework.Collections.C5.IQueue{`0})">
      <summary>
            Wrap a queue in a read-only wrapper
            </summary>
      <param name="queue">The queue</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedQueue`1.Enqueue(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <returns>-</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedQueue`1.Dequeue">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <returns>-</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedQueue`1.AllowsDuplicates">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedQueue`1.Item(System.Int32)">
      <summary>
            Index into the wrapped queue
            </summary>
      <param name="i">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.GuardedDictionary`2">
      <summary>
             A read-only wrapper for a dictionary.
            
             <i>Suitable for wrapping a HashDictionary. <see cref="T:C5.HashDictionary`2" /></i></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.#ctor(NSoft.NFramework.Collections.C5.IDictionary{`0,`1})">
      <summary>
            Wrap a dictionary in a read-only wrapper
            </summary>
      <param name="dict">the dictionary</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.Add(`0,`1)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="key">
      </param>
      <param name="val">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.AddAll``2(System.Collections.Generic.IEnumerable{NSoft.NFramework.Collections.C5.KeyValuePair{``0,``1}})">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="items">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.Remove(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.Remove(`0,`1@)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="key">
      </param>
      <param name="val">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.Clear">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.Contains(`0)">
      <summary>
            Check if the wrapped dictionary contains a specific key
            </summary>
      <param name="key">The key</param>
      <returns>True if it does</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.ContainsAll``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
      </summary>
      <param name="keys">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.Find(`0@,`1@)">
      <summary>
            Search for a key in the wrapped dictionary, reporting the value if found
            </summary>
      <param name="key">The key</param>
      <param name="val">On exit: the value if found</param>
      <returns>True if found</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.Update(`0,`1)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="key">
      </param>
      <param name="val">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.Update(`0,`1,`1@)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="key">
      </param>
      <param name="val">
      </param>
      <param name="oldval">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.FindOrAdd(`0,`1@)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="key">
      </param>
      <param name="val">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.UpdateOrAdd(`0,`1)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="key">
      </param>
      <param name="val">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.UpdateOrAdd(`0,`1,`1@)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="key">
      </param>
      <param name="val">
      </param>
      <param name="oldval">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedDictionary`2.Check">
      <summary>
            Check the internal consistency of the wrapped dictionary
            </summary>
      <returns>True if check passed</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedDictionary`2.EqualityComparer">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedDictionary`2.Item(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a
            read-only wrappper if used as a setter</exception>
      <value>Get the value corresponding to a key in the wrapped dictionary</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedDictionary`2.IsReadOnly">
      <summary>
            (This is a read-only wrapper)
            </summary>
      <value>True</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedDictionary`2.Keys">
      <summary>
      </summary>
      <value>The collection of keys of the wrapped dictionary</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedDictionary`2.Values">
      <summary>
      </summary>
      <value>The collection of values of the wrapped dictionary</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedDictionary`2.Func">
      <summary>
      </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedDictionary`2.ContainsSpeed">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="T:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2">
      <summary>
             A read-only wrapper for a sorted dictionary.
            
             <i>Suitable for wrapping a Dictionary. <see cref="T:C5.Dictionary`2" /></i></summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.#ctor(NSoft.NFramework.Collections.C5.ISortedDictionary{`0,`1})">
      <summary>
            Wrap a sorted dictionary in a read-only wrapper
            </summary>
      <param name="sorteddict">the dictionary</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.TryPredecessor(`0,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@)">
      <summary>
            Find the entry in the dictionary whose key is the
            predecessor of the specified key.
            </summary>
      <param name="key">The key</param>
      <param name="res">The predecessor, if any</param>
      <returns>True if key has a predecessor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.TrySuccessor(`0,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@)">
      <summary>
            Find the entry in the dictionary whose key is the
            successor of the specified key.
            </summary>
      <param name="key">The key</param>
      <param name="res">The successor, if any</param>
      <returns>True if the key has a successor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.TryWeakPredecessor(`0,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@)">
      <summary>
            Find the entry in the dictionary whose key is the
            weak predecessor of the specified key.
            </summary>
      <param name="key">The key</param>
      <param name="res">The predecessor, if any</param>
      <returns>True if key has a weak predecessor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.TryWeakSuccessor(`0,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@)">
      <summary>
            Find the entry in the dictionary whose key is the
            weak successor of the specified key.
            </summary>
      <param name="key">The key</param>
      <param name="res">The weak successor, if any</param>
      <returns>True if the key has a weak successor</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.Predecessor(`0)">
      <summary>
            Get the entry in the wrapped dictionary whose key is the
            predecessor of a specified key.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such entry exists </exception>
      <param name="key">The key</param>
      <returns>The entry</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.Successor(`0)">
      <summary>
            Get the entry in the wrapped dictionary whose key is the
            successor of a specified key.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such entry exists </exception>
      <param name="key">The key</param>
      <returns>The entry</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.WeakPredecessor(`0)">
      <summary>
            Get the entry in the wrapped dictionary whose key is the
            weak predecessor of a specified key.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such entry exists </exception>
      <param name="key">The key</param>
      <returns>The entry</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.WeakSuccessor(`0)">
      <summary>
            Get the entry in the wrapped dictionary whose key is the
            weak successor of a specified key.
            </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.NoSuchItemException"> if no such entry exists </exception>
      <param name="key">The key</param>
      <returns>The entry</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.FindMin">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.DeleteMin">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.FindMax">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.DeleteMax">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.Cut(System.IComparable{`0},NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@,System.Boolean@,NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}@,System.Boolean@)">
      <summary>
      </summary>
      <param name="c">
      </param>
      <param name="lowEntry">
      </param>
      <param name="lowIsValid">
      </param>
      <param name="highEntry">
      </param>
      <param name="highIsValid">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.RangeFrom(`0)">
      <summary>
      </summary>
      <param name="bot">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.RangeFromTo(`0,`0)">
      <summary>
      </summary>
      <param name="bot">
      </param>
      <param name="top">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.RangeTo(`0)">
      <summary>
      </summary>
      <param name="top">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.RangeAll">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.AddSorted(System.Collections.Generic.IEnumerable{NSoft.NFramework.Collections.C5.KeyValuePair{`0,`1}})">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="items">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.RemoveRangeFrom(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="low">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.RemoveRangeFromTo(`0,`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="low">
      </param>
      <param name="hi">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.RemoveRangeTo(`0)">
      <summary>
      </summary>
      <exception cref="T:NSoft.NFramework.Collections.C5.ReadOnlyCollectionException"> since this is a read-only wrappper</exception>
      <param name="hi">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.Comparer">
      <summary>
            The key comparer used by this dictionary.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.C5.GuardedSortedDictionary`2.Keys">
      <summary>
      </summary>
      <value>
      </value>
    </member>
    <member name="T:NSoft.NFramework.Collections.Concurrent.BlockingCollectionTool">
      <summary>
            생산자-소비자의 중간 버퍼 역할을 수행하는 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />에 대한 Extension Methods
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.BlockingCollectionTool.GetConsumingPartitioner``1(System.Collections.Concurrent.BlockingCollection{``0})">
      <summary>
        <paramref name="collection" />의 GetConsumingEnumerable()의 열거자를 배분하는 Partitioner를 빌드합니다.
            </summary>
      <seealso cref="T:NSoft.NFramework.Parallelism.Partitioners.BlockingCollectionPartitioner`1" />
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.BlockingCollectionTool.AddFromEnumerable``1(System.Collections.Concurrent.BlockingCollection{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean)">
      <summary>
        <paramref name="target" />에 <paramref name="source" />의 요소들을 추가합니다.
            </summary>
      <typeparam name="T">요소의 수형</typeparam>
      <param name="target">요소를 추가할 BlockingCollection</param>
      <param name="source">추가할 요소를 가진 소스</param>
      <param name="completeAddingWhenDone">
        <paramref name="source" />의 요소 추가가 완료되면, BlockingCollection인 target의 Add 작업이 완료되었다고 설정한다 (더 이상 추가작업이 없음을 알린다)
            </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.BlockingCollectionTool.AddFromObservable``1(System.Collections.Concurrent.BlockingCollection{``0},System.IObservable{``0},System.Boolean)">
      <summary>
            지정된 Observable로부터 얻은 요소를 target 컬렉션에 추가합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="target">요소를 추가할 BlockingCollection</param>
      <param name="source">추가할 요소를 가진 소스</param>
      <param name="completeAddingWhenDone">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.BlockingCollectionTool.ToProducerConsumerCollection``1(System.Collections.Concurrent.BlockingCollection{``0})">
      <summary>
            BlockingCollection 인스턴스에 대한 IProducerConsumerCollection Wapping을 통한 Facade를 생성해 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.BlockingCollectionTool.ToProducerConsumerCollection``1(System.Collections.Concurrent.BlockingCollection{``0},System.Int32)">
      <summary>
            BlockingCollection 인스턴스에 대한 IProducerConsumerCollection Wapping을 통한 Facade를 생성해 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.BlockingCollectionTool.ToProducerConsumerCollection``1(System.Collections.Concurrent.BlockingCollection{``0},System.Threading.CancellationToken,System.Int32)">
      <summary>
            BlockingCollection 인스턴스에 대한 IProducerConsumerCollection Wapping을 통한 Facade를 생성해 제공합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.Concurrent.BlockingQueue`1">
      <summary>
            차단 큐
            참고 사이트 : http://msdn.microsoft.com/ko-kr/magazine/cc163427.aspx
            </summary>
      <typeparam name="T">
      </typeparam>
      <remarks>
            공유 메모리 아키텍처에서는 둘 이상 작업 간에 유일한 동기화 지점이 중앙의 공유 컬렉션 데이터 구조인 경우가 많습니다. 
            한 개 이상의 작업이 한 개 이상의 다른 작업에서 소비할 "업무" 생성을 담당하는 구조를 생산자/소비자 관계라고 합니다. 
            이러한 데이터 구조를 위한 간단한 동기화는 일반적으로 복잡하지 않으며 Monitor 또는 ReaderWriterLock을 사용하면 해결되지만 
            버퍼가 비게 되는 경우의 조율이 까다롭습니다. 이러한 문제는 일반적으로 차단 큐를 통해 해결됩니다.
            실제로 차단 큐에는 큐가 비었을 때만 소비자가 차단되는 간단한 것에서부터 
            각 생산자가 정확히 한 개의 소비자와 "짝을 이루어" 소비자가 큐에 저장된 항목을 처리하기 전까지 생산자가 차단되고 
            비슷하게 생산자가 항목을 제공하기 전까지 소비자가 차단되는 복잡한 것까지 몇 가지 변형이 존재합니다. 
            
            처음 들어간 것부터 사용(FIFO)하는 순서가 일반적이지만 필수적인 것은 아닙니다. 
            이를 구현하려면 동기화로 간단한 Queue{T}를 래핑하면 됩니다. 어떤 종류의 동기화일까요? 
            스레드는 큐에 요소를 추가할 때마다 소비자가 큐에서 요소를 제거할 때까지 대기하고 반환합니다. 
            큐에서 요소를 제거할 때 버퍼가 비어 있으면 스레드는 새 요소가 추가될 때까지 대기해야 합니다. 
            그리고 물론 큐에서 항목을 제거할 때 소비자는 생산자에게 생산자의 항목을 가져갔다는 신호를 보내야 합니다
            </remarks>
    </member>
    <member name="T:NSoft.NFramework.Collections.IQueue`1">
      <summary>
            큐형태의 저장소를 위한 기능을 제공하는 인터페이스
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.IQueue`1.Enqueue(`0)">
      <summary>
            요소를 큐에 넣는다.
            </summary>
      <param name="item">큐에 추가할 요소</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.IQueue`1.Dequeue">
      <summary>
            큐에서 요소를 꺼낸다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.BlockingQueue`1.Enqueue(`0)">
      <summary>
            큐에 새로운 요소를 추가하고, 요소를 꺼내려고 대기하는 쓰레드에게 신호를 보냅니다.
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.BlockingQueue`1.Dequeue">
      <summary>
            큐에서 요소를 꺼냅니다. 없으면 큐에 요소가 채워질때까지 기다립니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.Concurrent.BoundedBuffer`1">
      <summary>
            요소의 수가 제한된 버퍼이고, Producer-Consumer 패턴을 구현한 버퍼입니다.
            참고 사이트 : http://msdn.microsoft.com/ko-kr/magazine/cc163427.aspx
            </summary>
      <typeparam name="T">요소의 수형</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.BoundedBuffer`1.#ctor(System.Int32)">
      <summary>
            생성자
            </summary>
      <param name="bufferSize">버퍼의 최대 크기</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.BoundedBuffer`1.Enqueue(`0)">
      <summary>
            버퍼에 새로운 요소를 추가합니다. 버퍼가 꽊 찼다면 비워질 때까지 기다립니다.
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.BoundedBuffer`1.Dequeue">
      <summary>
            버퍼에서 요소를 꺼냅니다. 없으면, 요소가 채워질때까지 기다립니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.BoundedBuffer`1.TryDequeue(`0@)">
      <summary>
            버퍼에서 요소 꺼내기를 시도합니다. 요소가 꺼냈으면 True를 반환하고, 요소가 없으면 False를 반환합니다.
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.BoundedBuffer`1.BufferSize">
      <summary>
            버퍼의 최대 크기
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.Concurrent.ConcurrentBlockingQueue`1">
      <summary>
            큐 방식의 내부저장소를 가진 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />입니다.
            </summary>
      <typeparam name="T">큐 항목의 수형</typeparam>
    </member>
    <member name="T:NSoft.NFramework.Collections.Concurrent.ConcurrentBlockingStack`1">
      <summary>
            스택 방식의 내부저장소를 가진 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />입니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2">
      <summary>
            Thread-Safe 한 Multi-Map 자료구조입니다. (TKey - ICollection{TValue}) 형태를 가집니다.
            </summary>
      <typeparam name="TKey">키의 수형</typeparam>
      <typeparam name="TValue">값의 수형</typeparam>
      <seealso cref="T:NSoft.NFramework.Collections.MultiMap`2" />
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}}})">
      <summary>
            생성자
            </summary>
      <param name="collection">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            생성자
            </summary>
      <param name="comparer">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.GetEnumerator">
      <summary>
            컬렉션을 반복하는 열거자를 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.Add(`0,`1)">
      <summary>
            요소를 추가합니다.
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            요소를 추가합니다.
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.ContainsValue(`1)">
      <summary>
            지정한 값을 가지고 있는지 확인합니다.
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.Clear">
      <summary>
            요소를 모두 삭제합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            지정한 요소를 가지고 있는지 확인합니다.
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}}[],System.Int32)">
      <summary>
            요소를 지정한 배열에 복사합니다.
            </summary>
      <param name="array">
      </param>
      <param name="arrayIndex">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            지정한 요소가 있다면, 삭제합니다.
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.ContainsKey(`0)">
      <summary>
            지정한 키를 가지고 있는가?
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.Remove(`0)">
      <summary>
            해당 키를 삭제합니다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.TryGetValue(`0,System.Collections.Generic.ICollection{`1}@)">
      <summary>
            해당 키의 값을 조회합니다. 있으면 true를 반환하고, 없으면 false를 반환합니다.
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.GetOrAdd(`0,System.Func{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            해당 키에 값이 없다면 값을 넣고, 반환합니다.
            </summary>
      <param name="key">
      </param>
      <param name="valueFactory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.GetOrAdd(`0,System.Collections.Generic.ICollection{`1})">
      <summary>
            해당 키에 값이 없다면 값을 넣고, 반환합니다.
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.AsString">
      <summary>
            항목을 문자열로 표현합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.InnerMap">
      <summary>
            내부 저장소
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.KeyCount">
      <summary>
            요소 키의 갯수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.ValueCount">
      <summary>
            전체 Value의 갯수 (하나의 키에 여러개의 Value가 매핑되어 있으므로 실제 Value는 Key의 갯수보다 같거나 크다)
            </summary>
      <remarks>전체 Value 갯수를 계산하는데 시간이 걸리므로, 한번 호출해서 변수로 사용해야 한다.</remarks>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.Count">
      <summary>
            요소 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.IsReadOnly">
      <summary>
            읽기 전용 ?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.Item(`0)">
      <summary>
            Indexer
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.Keys">
      <summary>
            Key collection
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.Values">
      <summary>
            Value collection
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.IsEmpty">
      <summary>
            저장소가 비었는지 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiMap`2.IsValueEmpty">
      <summary>
            저장소에 값이 없는지 파악
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2">
      <summary>
            Thread-Safe 한 Multi-Set 자료구조입니다. (Key-Set{TValue}) 형태입니다.
            </summary>
      <typeparam name="TKey">키의 수형</typeparam>
      <typeparam name="TValue">값의 수형</typeparam>
      <seealso cref="T:NSoft.NFramework.Collections.MultiMap`2" />
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IEnumerable{`1}}})">
      <summary>
            생성자
            </summary>
      <param name="collection">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.Add(`0,`1)">
      <summary>
            요소를 추가합니다.
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.GetEnumerator">
      <summary>
            컬렉션을 반복하는 열거자를 반환합니다.
            </summary>
      <returns>
            컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.Generic.IEnumerator`1" />입니다.
            </returns>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ISet{`1}})">
      <summary>
        <see cref="T:System.Collections.Generic.ICollection`1" />에 항목을 추가합니다.
            </summary>
      <param name="item">
        <see cref="T:System.Collections.Generic.ICollection`1" />에 추가할 개체입니다.</param>
      <exception cref="T:System.NotSupportedException">
        <see cref="T:System.Collections.Generic.ICollection`1" />가 읽기 전용인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.Clear">
      <summary>
        <see cref="T:System.Collections.Generic.ICollection`1" />에서 항목을 모두 제거합니다.
            </summary>
      <exception cref="T:System.NotSupportedException">
        <see cref="T:System.Collections.Generic.ICollection`1" />가 읽기 전용인 경우 </exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ISet{`1}})">
      <summary>
        <see cref="T:System.Collections.Generic.ICollection`1" />에 특정 값이 들어 있는지 여부를 확인합니다.
            </summary>
      <returns>
        <paramref name="item" />이 <see cref="T:System.Collections.Generic.ICollection`1" />에 있으면 true이고, 그렇지 않으면 false입니다.
            </returns>
      <param name="item">
        <see cref="T:System.Collections.Generic.ICollection`1" />에서 찾을 개체입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.ContainsValue(`1)">
      <summary>
        <paramref name="value" />를 값으로 가지고 있는지 검사합니다.
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ISet{`1}}[],System.Int32)">
      <summary>
            특정 <see cref="T:System.Array" /> 인덱스부터 시작하여 <see cref="T:System.Collections.Generic.ICollection`1" />의 요소를 <see cref="T:System.Array" />에 복사합니다.
            </summary>
      <param name="array">
        <see cref="T:System.Collections.Generic.ICollection`1" />에서 복사한 요소의 대상인 일차원 <see cref="T:System.Array" />입니다. <see cref="T:System.Array" />의 인덱스는 0부터 시작해야 합니다.</param>
      <param name="arrayIndex">
        <paramref name="array" />에서 복사가 시작되는 인덱스(0부터 시작)입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" />가 null인 경우</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="arrayIndex" />가 0보다 작은 경우</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" />가 다차원인 경우-또는-소스 <see cref="T:System.Collections.Generic.ICollection`1" />의 요소 수가 
            <paramref name="arrayIndex" />에서 대상 <paramref name="array" /> 끝까지 사용 가능한 공간보다 큰 경우-또는-<paramref name="T" /> 형식을 대상 <paramref name="array" />의 형식으로 자동 캐스팅할 수 없는 경우
            </exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ISet{`1}})">
      <summary>
        <see cref="T:System.Collections.Generic.ICollection`1" />에서 맨 처음 발견되는 특정 개체를 제거합니다.
            </summary>
      <returns>
        <paramref name="item" />이 <see cref="T:System.Collections.Generic.ICollection`1" />에서 성공적으로 제거되었으면 true이고, 그렇지 않으면 false입니다.이 메서드는 <paramref name="item" />이 원래 <see cref="T:System.Collections.Generic.ICollection`1" />에 없는 경우에도 false를 반환합니다.
            </returns>
      <param name="item">
        <see cref="T:System.Collections.Generic.ICollection`1" />에서 제거할 개체입니다.</param>
      <exception cref="T:System.NotSupportedException">
        <see cref="T:System.Collections.Generic.ICollection`1" />가 읽기 전용인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.ContainsKey(`0)">
      <summary>
        <see cref="T:System.Collections.Generic.IDictionary`2" />에 지정된 키가 있는 요소가 포함되어 있는지 여부를 확인합니다.
            </summary>
      <returns>
        <see cref="T:System.Collections.Generic.IDictionary`2" />에 해당 키가 있는 요소가 포함되어 있으면 true이고, 그렇지 않으면 false입니다.
            </returns>
      <param name="key">
        <see cref="T:System.Collections.Generic.IDictionary`2" />에서 찾을 수 있는 키입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" />가 null인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.Remove(`0)">
      <summary>
        <see cref="T:System.Collections.Generic.IDictionary`2" />에서 지정한 키를 가지는 요소를 제거합니다.
            </summary>
      <returns>
            요소가 성공적으로 제거되었으면 true이고, 그렇지 않으면 false입니다.이 메서드는 <paramref name="key" />가 원래 <see cref="T:System.Collections.Generic.IDictionary`2" />에 없는 경우에도 false를 반환합니다.
            </returns>
      <param name="key">제거할 요소의 키입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" />가 null인 경우</exception>
      <exception cref="T:System.NotSupportedException">
        <see cref="T:System.Collections.Generic.IDictionary`2" />가 읽기 전용인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.TryGetValue(`0,System.Collections.Generic.ISet{`1}@)">
      <summary>
            지정된 키와 연결된 값을 가져옵니다.
            </summary>
      <returns>
        <see cref="T:System.Collections.Generic.IDictionary`2" />를 구현하는 개체에 지정한 키가 있는 요소가 포함되어 있으면 true이고, 그렇지 않으면 false입니다.
            </returns>
      <param name="key">가져올 값이 있는 키입니다.</param>
      <param name="value">이 메서드가 반환될 때 지정된 키가 있으면 해당 키와 연결된 값이고, 그렇지 않으면 <paramref name="value" /> 매개 변수의 형식에 대한 기본값입니다.이 매개 변수는 초기화되지 않은 상태로 전달됩니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" />가 null인 경우</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.KeyCount">
      <summary>
            키의 갯수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.ValueCount">
      <summary>
            전체 Value의 갯수 (하나의 키에 여러 개의 Value가 매핑되어 있으므로 실제 Value는 Key의 갯수 이상이다.) 단 여기서 다른 Key에 존재하는 중복된 값도 Counting 한다.
            </summary>
      <remarks>전체 Value 갯수를 계산하는데 시간이 걸리므로, 한번 호출해서 변수에 할당하여 사용하세요.</remarks>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.Count">
      <summary>
            요소의 수 (Key 의 수)
            </summary>
      <returns>
        <see cref="T:System.Collections.Generic.ICollection`1" />에 포함된 요소 수입니다.
            </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.IsReadOnly">
      <summary>
        <see cref="T:System.Collections.Generic.ICollection`1" />이 읽기 전용인지 여부를 나타내는 값을 가져옵니다.
            </summary>
      <returns>
        <see cref="T:System.Collections.Generic.ICollection`1" />이 읽기 전용이면 true이고, 그렇지 않으면 false입니다.
            </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.Item(`0)">
      <summary>
            지정된 키가 있는 요소를 가져오거나 설정합니다.
            </summary>
      <returns>
            지정한 키가 있는 요소입니다.
            </returns>
      <param name="key">가져오거나 설정할 요소의 키입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" />가 null인 경우</exception>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">속성이 검색되었지만 <paramref name="key" />가 없는 경우</exception>
      <exception cref="T:System.NotSupportedException">속성이 설정되어 있으며 <see cref="T:System.Collections.Generic.IDictionary`2" />가 읽기 전용인 경우</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.Keys">
      <summary>
        <see cref="T:System.Collections.Generic.IDictionary`2" />의 키를 포함하는 <see cref="T:System.Collections.Generic.ICollection`1" />을 가져옵니다.
            </summary>
      <returns>
        <see cref="T:System.Collections.Generic.IDictionary`2" />를 구현하는 개체의 키를 포함하는 <see cref="T:System.Collections.Generic.ICollection`1" />입니다.
            </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ConcurrentMultiSet`2.Values">
      <summary>
        <see cref="T:System.Collections.Generic.IDictionary`2" />의 값을 포함하는 <see cref="T:System.Collections.Generic.ICollection`1" />을 가져옵니다.
            </summary>
      <returns>
        <see cref="T:System.Collections.Generic.IDictionary`2" />를 구현하는 개체의 값을 포함하는 <see cref="T:System.Collections.Generic.ICollection`1" />입니다.
            </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.Concurrent.ConcurrentSkipList`1">
      <summary>
             SkipList 방식의 내부저장소를 가진 <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />입니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.Collections.Concurrent.LockFreeStack`1">
      <summary>
            Thread-Safe 하면서, Lock을 사용하지 않고, Stack을 구현한다.
            참고 사이트 : http://msdn.microsoft.com/ko-kr/magazine/cc163427.aspx
            </summary>
      <remarks>
            제한과 차단에 의해 복잡해지기는 하지만 잠금을 사용하여 스레드로부터 보호되는 컬렉션을 만들기는 상당히 쉽습니다. 
            그러나 간단히 마지막에 들어간 것부터 사용(LIFO)하는 스택 데이터 구조를 통해 모든 조율이 이루어지는 경우 잠금을 사용하는 데 따르는 비용이 필요 이상으로 높아질 수 있습니다. 
            스레드의 중요 영역인 잠금이 유지되는 동안에는 시작과 끝이 있으며 이 시간은 여러 명령이 실행되는 동안에 해당합니다. 
            잠금을 유지하면 다른 스레드가 동시에 읽고 쓸 수 없습니다. 이를 통해 원하던 직렬화를 이룰 수 있지만 이것은 필요 이상으로 엄격하게 강력합니다. 
            여기에서는 단순히 스택에 대해 요소를 푸시 및 팝하는 것이며 두 작업 모두 일반적인 읽기와 단일 compare-and-swap 쓰기를 통해 수행할 수 있습니다.
            이러한 사실을 활용하여 확장성이 더 우수하며 스레드가 불필요하게 대기하도록 요구하지 않는 잠금 해제 스택을 작성할 수 있습니다.
            이 알고리즘은 다음과 같이 작동합니다.
            스택을 나타내는 데는 연결된 목록이 사용되며 목록의 헤드는 스택의 맨 위를 나타내고 m_head 필드에 저장됩니다.
            스택에 새 항목을 푸시할 때는 스택에 푸시할 값으로 새 노드를 구성하고, m_head 필드 값을 로컬로 읽으며, 
            이 값을 새 노드의 m_next 필드에 저장한 다음 원자성 Interlocked.CompareExchange를 수행하여 스택의 현재 헤드를 대체합니다. 
            처음 읽은 이후에 이 시퀀스의 어떤 시점에서라도 헤드가 변경된 경우 CompareExchange는 실패하며 스레드는 루프 백을 수행하고 전체 시퀀스를 다시 시도해야 합니다. 
            팝 역시 비슷하며 간단합니다. m_head를 읽고 로컬 복사본의 m_next 참조로 교환을 시도합니다.
             실패하는 경우 그림 8에 서 보여 주고 있는 것처럼 계속 시도합니다. Win32에서는 비슷한 알고리즘을 사용하여 작성한 SList라는 유사 데이터 구조를 제공합니다.
            </remarks>
      <typeparam name="T">Stack에 저장될 요소의 수형</typeparam>
    </member>
    <member name="T:NSoft.NFramework.Collections.IStack`1">
      <summary>
            Stack을 표현하는 인터페이스
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.IStack`1.Push(`0)">
      <summary>
            Stack에 요소 추가
            </summary>
      <param name="item">추가할 요소</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.IStack`1.Pop">
      <summary>
            Stack에서 요소 제거
            </summary>
      <returns>제거한 요소</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.IStack`1.Peek">
      <summary>
            Stack의 가장 위에 있는 요소를 조회
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.LockFreeStack`1.Push(`0)">
      <summary>
            새로운 요소를 Stack에 추가합니다. 
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.LockFreeStack`1.Pop">
      <summary>
            최상위 요소를 스택에서 꺼냅니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.LockFreeStack`1.Peek">
      <summary>
            스택에서 가장 최상위 요소를 조회합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.Concurrent.ProducerConsumerCollectionTool">
      <summary>
        <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />를 위한 확장 메소드 들입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ProducerConsumerCollectionTool.Clear``1(System.Collections.Concurrent.IProducerConsumerCollection{``0})">
      <summary>
            지정된 컬렉션의 모든 요소를 제거합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ProducerConsumerCollectionTool.GetConsumingEnumerable``1(System.Collections.Concurrent.IProducerConsumerCollection{``0})">
      <summary>
            컬렉션의 요소들을 소비자용의 열거자로 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ProducerConsumerCollectionTool.AddFromEnumerable``1(System.Collections.Concurrent.IProducerConsumerCollection{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
        <paramref name="source" /> 시퀀스의 요소를 <paramref name="target" /> 컬렉션에 요소로 추가합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ProducerConsumerCollectionTool.AddFromObservable``1(System.Collections.Concurrent.IProducerConsumerCollection{``0},System.IObservable{``0})">
      <summary>
        <paramref name="source" />의 요소를 <paramref name="target" /> 컬렉션에 추가합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ProducerConsumerCollectionTool.ToProducerOnlyCollection``1(System.Collections.Concurrent.IProducerConsumerCollection{``0})">
      <summary>
            Producer만 있는 (Add 만 가능한) collection을 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ProducerConsumerCollectionTool.ToConsumerOnlyCollection``1(System.Collections.Concurrent.IProducerConsumerCollection{``0})">
      <summary>
            Consumer만 있는 (Take 만 가능한) collection을 반환합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.Concurrent.ThreadSafeQueue`1">
      <summary>
            Thread-safety Queue
            </summary>
      <typeparam name="T">큐에 저장할 항목의 수형</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ThreadSafeQueue`1.#ctor">
      <summary>
            Default Constructor
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ThreadSafeQueue`1.#ctor(System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="capacity">initial capacity of buffer in Queue</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ThreadSafeQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Constructor
            </summary>
      <param name="collection">큐에 추가할 요소들</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ThreadSafeQueue`1.Enqueue(`0)">
      <summary>
            요소를 큐에 넣는다.
            </summary>
      <param name="item">큐에 추가할 요소</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ThreadSafeQueue`1.Dequeue">
      <summary>
            큐에서 요소를 꺼냅니다. 꺼낼 요소가 없으면 기다립니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ThreadSafeQueue`1.TryDequeue(`0@)">
      <summary>
            큐에서 요소를 꺼내기를 시도한다. 실패시에는 False를 반환하고, item은 default(T)값을 갖는다.
            </summary>
      <param name="item">꺼낸 요소</param>
      <returns>큐에서 요소를 꺼낸지 결과</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ThreadSafeQueue`1.InnerQueue">
      <summary>
            내부 큐
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.Concurrent.ThreadSafeStack`1">
      <summary>
            Multi-thread에 안정된 Stack
            </summary>
      <typeparam name="T">Stack에 저장할 항목의 수형</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ThreadSafeStack`1.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ThreadSafeStack`1.#ctor(System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="capacity">initial capacity of stack buffer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ThreadSafeStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Constructor
            </summary>
      <param name="collection">initial elements to pushed internal stack</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ThreadSafeStack`1.Push(`0)">
      <summary>
            요소를 스택에 추가
            </summary>
      <param name="item">추가할 요소</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ThreadSafeStack`1.Pop">
      <summary>
            스택에서 요소를 꺼냄, 꺼낼 요소가 없으면 기다립니다.
            </summary>
      <returns>요소</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ThreadSafeStack`1.Peek">
      <summary>
            Stack에서 최상위 요소를 조회합니다. Stack이 비었으면 default(T)를 반환합니다.
            </summary>
      <returns>요소</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Concurrent.ThreadSafeStack`1.TryPop(`0@)">
      <summary>
            스텍에서 요소를 꺼내본다. 꺼낼 요소가 없으면 False를 반환하고, item 은 default(T)가 설정된다.
            </summary>
      <param name="item">꺼낼 요소</param>
      <returns>꺼낼 요소가 없으면 False를 반환하고, item 은 default(T)가 설정된다.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ThreadSafeStack`1.InnerStack">
      <summary>
            Inner stack buffer
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.Concurrent.ThreadSafeStack`1.Count">
      <summary>
            스택에 있는 항목의 갯수
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.Algorithms">
      <summary>
            Algorithms contains a number of static methods that implement
            algorithms that work on collections. Most of the methods deal with
            the standard generic collection interfaces such as IEnumerable&lt;T&gt;,
            ICollection&lt;T&gt; and IList&lt;T&gt;.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Range``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of a list. Items from <paramref name="list" /> are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to <paramref name="list" />
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
      <remarks>This method can be used to apply an algorithm to a portion of a list. For example:
            <code>Algorithms.ReverseInPlace(Algorithms.Range(list, 3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
      <typeparam name="T">The type of the items in the list.</typeparam>
      <param name="list">The list to view.</param>
      <param name="start">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-list. </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> + <paramref name="count" /> is greater than the
            size of <paramref name="list" />.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.ReadOnly``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Returns a read-only view onto a collection. The returned ICollection&lt;T&gt; interface
            only allows operations that do not change the collection: GetEnumerator, Contains, CopyTo,
            Count. The ReadOnly property returns false, indicating that the collection is read-only. All other
            methods on the interface throw a InvalidOperationException.
            </summary>
      <remarks>The data in the underlying collection is not copied. If the underlying
            collection is changed, then the read-only view also changes accordingly.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to wrap.</param>
      <returns>A read-only view onto <paramref name="collection" />. If <paramref name="collection" /> is null, then null is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.ReadOnly``1(System.Collections.Generic.IList{``0})">
      <summary>
            Returns a read-only view onto a list. The returned IList&lt;T&gt; interface
            only allows operations that do not change the list: GetEnumerator, Contains, CopyTo,
            Count, IndexOf, and the get accessor of the indexer. 
            The IsReadOnly property returns true, indicating that the list is read-only. All other
            methods on the interface throw a InvalidOperationException.
            </summary>
      <remarks>The data in the underlying list is not copied. If the underlying
            list is changed, then the read-only view also changes accordingly.</remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to wrap.</param>
      <returns>A read-only view onto <paramref name="list" />. Returns null if <paramref name="list" /> is null. 
            If <paramref name="list" /> is already read-only, returns <paramref name="list" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.ReadOnly``2(System.Collections.Generic.IDictionary{``0,``1})">
      <summary>
            Returns a read-only view onto a dictionary. The returned IDictionary&lt;TKey,TValue&gt; interface
            only allows operations that do not change the dictionary. 
            The IsReadOnly property returns true, indicating that the dictionary is read-only. All other
            methods on the interface throw a NotSupportedException.
            </summary>
      <remarks>The data in the underlying dictionary is not copied. If the underlying
            dictionary is changed, then the read-only view also changes accordingly.</remarks>
      <param name="dictionary">The dictionary to wrap.</param>
      <returns>A read-only view onto <paramref name="dictionary" />. Returns null if <paramref name="dictionary" /> is null. 
            If <paramref name="dictionary" /> is already read-only, returns <paramref name="dictionary" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.TypedAs``1(System.Collections.IEnumerable)">
      <summary>
            Given a non-generic IEnumerable interface, wrap a generic IEnumerable&lt;T&gt;
            interface around it. The generic interface will enumerate the same objects as the 
            underlying non-generic collection, but can be used in places that require a generic interface.
            The underlying non-generic collection must contain only items that
            are of type <typeparamref name="T" /> or a type derived from it. This method is useful
            when interfacing older, non-generic collections to newer code that uses generic interfaces.
            </summary>
      <remarks>Some collections implement both generic and non-generic interfaces. For efficiency,
            this method will first attempt to cast <paramref name="untypedCollection" /> to IEnumerable&lt;T&gt;. 
            If that succeeds, it is returned; otherwise, a wrapper object is created.</remarks>
      <typeparam name="T">The item type of the wrapper collection.</typeparam>
      <param name="untypedCollection">An untyped collection. This collection should only contain
            items of type <typeparamref name="T" /> or a type derived from it. </param>
      <returns>A generic IEnumerable&lt;T&gt; wrapper around <paramref name="untypedCollection" />. 
            If <paramref name="untypedCollection" /> is null, then null is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.TypedAs``1(System.Collections.ICollection)">
      <summary>
            Given a non-generic ICollection interface, wrap a generic ICollection&lt;T&gt;
            interface around it. The generic interface will enumerate the same objects as the 
            underlying non-generic collection, but can be used in places that require a generic interface.
            The underlying non-generic collection must contain only items that
            are of type <typeparamref name="T" /> or a type derived from it. This method is useful
            when interfacing older, non-generic collections to newer code that uses generic interfaces.
            </summary>
      <remarks>
        <para>Some collections implement both generic and non-generic interfaces. For efficiency,
            this method will first attempt to cast <paramref name="untypedCollection" /> to ICollection&lt;T&gt;. 
            If that succeeds, it is returned; otherwise, a wrapper object is created.</para>
        <para>Unlike the generic interface, the non-generic ICollection interfaces does
            not contain methods for adding or removing items from the collection. For this reason,
            the returned ICollection&lt;T&gt; will be read-only.</para>
      </remarks>
      <typeparam name="T">The item type of the wrapper collection.</typeparam>
      <param name="untypedCollection">An untyped collection. This collection should only contain
            items of type <typeparamref name="T" /> or a type derived from it. </param>
      <returns>A generic ICollection&lt;T&gt; wrapper around <paramref name="untypedCollection" />.
            If <paramref name="untypedCollection" /> is null, then null is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.TypedAs``1(System.Collections.IList)">
      <summary>
            Given a non-generic IList interface, wrap a generic IList&lt;T&gt;
            interface around it. The generic interface will enumerate the same objects as the 
            underlying non-generic list, but can be used in places that require a generic interface.
            The underlying non-generic list must contain only items that
            are of type <typeparamref name="T" /> or a type derived from it. This method is useful
            when interfacing older, non-generic lists to newer code that uses generic interfaces.
            </summary>
      <remarks>Some collections implement both generic and non-generic interfaces. For efficiency,
            this method will first attempt to cast <paramref name="untypedList" /> to IList&lt;T&gt;. 
            If that succeeds, it is returned; otherwise, a wrapper object is created.</remarks>
      <typeparam name="T">The item type of the wrapper list.</typeparam>
      <param name="untypedList">An untyped list. This list should only contain
            items of type <typeparamref name="T" /> or a type derived from it. </param>
      <returns>A generic IList&lt;T&gt; wrapper around <paramref name="untypedList" />.
            If <paramref name="untypedList" /> is null, then null is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Untyped``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Given a generic ICollection&lt;T&gt; interface, wrap a non-generic (untyped)
            ICollection interface around it. The non-generic interface will contain the same objects as the 
            underlying generic collection, but can be used in places that require a non-generic interface.
            This method is useful when interfacing generic interfaces with older code that uses non-generic interfaces.
            </summary>
      <remarks>Many generic collections already implement the non-generic interfaces directly. This
            method will first attempt to simply cast <paramref name="typedCollection" /> to ICollection. If that
            succeeds, it is returned; if it fails, then a wrapper object is created.</remarks>
      <typeparam name="T">The item type of the underlying collection.</typeparam>
      <param name="typedCollection">A typed collection to wrap.</param>
      <returns>A non-generic ICollection wrapper around <paramref name="typedCollection" />.
            If <paramref name="typedCollection" /> is null, then null is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Untyped``1(System.Collections.Generic.IList{``0})">
      <summary>
            Given a generic IList&lt;T&gt; interface, wrap a non-generic (untyped)
            IList interface around it. The non-generic interface will contain the same objects as the 
            underlying generic list, but can be used in places that require a non-generic interface.
            This method is useful when interfacing generic interfaces with older code that uses non-generic interfaces.
            </summary>
      <remarks>Many generic collections already implement the non-generic interfaces directly. This
            method will first attempt to simply cast <paramref name="typedList" /> to IList. If that
            succeeds, it is returned; if it fails, then a wrapper object is created.</remarks>
      <typeparam name="T">The item type of the underlying list.</typeparam>
      <param name="typedList">A typed list to wrap.</param>
      <returns>A non-generic IList wrapper around <paramref name="typedList" />.
            If <paramref name="typedList" /> is null, then null is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.ReadWriteList``1(``0[])">
      <summary>
        <para>Creates a read-write IList&lt;T&gt; wrapper around an array. When an array is
            implicitely converted to an IList&lt;T&gt;, changes to the items in the array cannot
            be made through the interface. This method creates a read-write IList&lt;T&gt; wrapper
            on an array that can be used to make changes to the array. </para>
        <para>Use this method when you need to pass an array to an algorithms that takes an 
            IList&lt;T&gt; and that tries to modify items in the list. Algorithms in this class generally do not
            need this method, since they have been design to operate on arrays even when they
            are passed as an IList&lt;T&gt;.</para>
      </summary>
      <remarks>Since arrays cannot be resized, inserting an item causes the last item in the array to be automatically
            removed. Removing an item causes the last item in the array to be replaced with a default value (0 or null). Clearing
            the list causes all the items to be replaced with a default value.</remarks>
      <param name="array">The array to wrap.</param>
      <returns>An IList&lt;T&gt; wrapper onto <paramref name="array" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Replace``1(System.Collections.Generic.IEnumerable{``0},``0,``0)">
      <summary>
            Replace all items in a collection equal to a particular value with another values, yielding another collection.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="collection">The collection to process.</param>
      <param name="itemFind">The value to find and replace within <paramref name="collection" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with the appropriate replacements made.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Replace``1(System.Collections.Generic.IEnumerable{``0},``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Replace all items in a collection equal to a particular value with another values, yielding another collection. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="collection">The collection to process.</param>
      <param name="itemFind">The value to find and replace within <paramref name="collection" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with the appropriate replacements made.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Replace``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0)">
      <summary>
            Replace all items in a collection that a predicate evalues at true with a value, yielding another collection. .
            </summary>
      <param name="collection">The collection to process.</param>
      <param name="predicate">The predicate used to evaluate items with the collection. If the predicate returns true for a particular
            item, the item is replaces with <paramref name="replaceWith" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with the appropriate replacements made.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.ReplaceInPlace``1(System.Collections.Generic.IList{``0},``0,``0)">
      <summary>
            Replace all items in a list or array equal to a particular value with another value. The replacement is done in-place, changing
            the list.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to process.</param>
      <param name="itemFind">The value to find and replace within <paramref name="list" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.ReplaceInPlace``1(System.Collections.Generic.IList{``0},``0,``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Replace all items in a list or array equal to a particular value with another values.
            The replacement is done in-place, changing
            the list. A passed IEqualityComparer is used to determine equality.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to process.</param>
      <param name="itemFind">The value to find and replace within <paramref name="list" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.ReplaceInPlace``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean},``0)">
      <summary>
            Replace all items in a list or array that a predicate evaluates at true with a value. The replacement is done in-place, changing
            the list.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to process.</param>
      <param name="predicate">The predicate used to evaluate items with the collection. If the predicate returns true for a particular
            item, the item is replaces with <paramref name="replaceWith" />.</param>
      <param name="replaceWith">The new value to replace with.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RemoveDuplicates``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Remove consecutive equal items from a collection, yielding another collection. In each run of consecutive equal items
            in the collection, all items after the first item in the run are removed. 
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="collection">The collection to process.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with consecutive duplicates removed.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RemoveDuplicates``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Remove consecutive equal items from a collection, yielding another collection. In each run of consecutive equal items
            in the collection, all items after the first item in the run are removed. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="collection">The collection to process.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with consecutive duplicates removed.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="equalityComparer" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RemoveDuplicates``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
      <summary>
            Remove consecutive "equal" items from a collection, yielding another collection. In each run of consecutive equal items
            in the collection, all items after the first item in the run are removed. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. </remarks>
      <param name="collection">The collection to process.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". An item <c>current</c> is removed if <c>predicate(first, current)==true</c>, where
            <c>first</c> is the first item in the group of "duplicate" items.</param>
      <returns>An new collection with the items from <paramref name="collection" />, in the same order, 
            with consecutive "duplicates" removed.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RemoveDuplicatesInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Remove consecutive equal items from a list or array. In each run of consecutive equal items
            in the list, all items after the first item in the run are removed. The removal is done in-place, changing
            the list. 
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to process.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RemoveDuplicatesInPlace``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Remove subsequent consecutive equal items from a list or array. In each run of consecutive equal items
            in the list, all items after the first item in the run are removed.
            The replacement is done in-place, changing
            the list. A passed IEqualityComparer is used to determine equality.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to process.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RemoveDuplicatesInPlace``1(System.Collections.Generic.IList{``0},System.Func{``0,``0,System.Boolean})">
      <summary>
            Remove consecutive "equal" items from a list or array. In each run of consecutive equal items
            in the list, all items after the first item in the run are removed. The replacement is done in-place, changing
            the list. The passed BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>
        <para>Since an arbitrary BinaryPredicate is passed to this function, what is being tested for need not be true equality. </para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to process.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FirstConsecutiveEqual``1(System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Finds the first occurence of <paramref name="count" /> consecutive equal items in the
            list.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to examine.</param>
      <param name="count">The number of consecutive equal items to look for. The count must be at least 1.</param>
      <returns>The index of the first item in the first run of <paramref name="count" /> consecutive equal items, or -1 if no such run exists..</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FirstConsecutiveEqual``1(System.Collections.Generic.IList{``0},System.Int32,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the first occurence of <paramref name="count" /> consecutive equal items in the
            list. A passed IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to examine.</param>
      <param name="count">The number of consecutive equal items to look for. The count must be at least 1.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>The index of the first item in the first run of <paramref name="count" /> consecutive equal items, or -1 if no such run exists.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FirstConsecutiveEqual``1(System.Collections.Generic.IList{``0},System.Int32,System.Func{``0,``0,System.Boolean})">
      <summary>
            Finds the first occurence of <paramref name="count" /> consecutive "equal" items in the
            list. The passed BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being tested for need not be true equality. </remarks>
      <param name="list">The list to examine.</param>
      <param name="count">The number of consecutive equal items to look for. The count must be at least 1.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>The index of the first item in the first run of <paramref name="count" /> consecutive equal items, or -1 if no such run exists.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FirstConsecutiveWhere``1(System.Collections.Generic.IList{``0},System.Int32,System.Func{``0,System.Boolean})">
      <summary>
            Finds the first occurence of <paramref name="count" /> consecutive items in the
            list for which a given predicate returns true.
            </summary>
      <param name="list">The list to examine.</param>
      <param name="count">The number of consecutive items to look for. The count must be at least 1.</param>
      <param name="predicate">The predicate used to test each item.</param>
      <returns>The index of the first item in the first run of <paramref name="count" /> items where <paramref name="predicate" />
            returns true for all items in the run, or -1 if no such run exists.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            Finds the first item in a collection that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <remarks>If the default value for T could be present in the collection, and 
            would be matched by the predicate, then this method is inappropriate, because
            you cannot disguish whether the default value for T was actually present in the collection,
            or no items matched the predicate. In this case, use TryFindFirstWhere.</remarks>
      <param name="collection">The collection to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The first item in the collection that matches the condition, or the default value for T (0 or null) if no
            item that matches the condition is found.</returns>
      <seealso cref="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.TryFindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.TryFindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)">
      <summary>
            Finds the first item in a collection that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="foundItem">Outputs the first item in the collection that matches the condition, if the method returns true.</param>
      <returns>True if an item satisfying the condition was found. False if no such item exists in the collection.</returns>
      <seealso cref="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FindFirstWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            Finds the last item in a collection that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <remarks>
        <para>If the collection implements IList&lt;T&gt;, then the list is scanned in reverse until a 
            matching item is found. Otherwise, the entire collection is iterated in the forward direction.</para>
        <para>If the default value for T could be present in the collection, and 
            would be matched by the predicate, then this method is inappropriate, because
            you cannot disguish whether the default value for T was actually present in the collection,
            or no items matched the predicate. In this case, use TryFindFirstWhere.</para>
      </remarks>
      <param name="collection">The collection to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The last item in the collection that matches the condition, or the default value for T (0 or null) if no
            item that matches the condition is found.</returns>
      <seealso cref="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.TryFindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.TryFindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)">
      <summary>
            Finds the last item in a collection that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <remarks>If the collection implements IList&lt;T&gt;, then the list is scanned in reverse until a 
            matching item is found. Otherwise, the entire collection is iterated in the forward direction.</remarks>
      <param name="collection">The collection to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="foundItem">Outputs the last item in the collection that matches the condition, if the method returns true.</param>
      <returns>True if an item satisfying the condition was found. False if no such item exists in the collection.</returns>
      <seealso cref="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FindLastWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FindWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            Enumerates all the items in <paramref name="collection" /> that satisfy the condition defined
            by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the items that satisfy the condition.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FindFirstIndexWhere``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
      <summary>
            Finds the index of the first item in a list that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="list">The list to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the first item satisfying the condition. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FindLastIndexWhere``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
      <summary>
            Finds the index of the last item in a list that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="list">The list to search.</param>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the last item satisfying the condition. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FindIndicesWhere``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
      <summary>
            Enumerates the indices of all the items in <paramref name="list" /> that satisfy the condition defined
            by <paramref name="predicate" />.
            </summary>
      <param name="list">The list to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items that satisfy the condition.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FirstIndexOf``1(System.Collections.Generic.IList{``0},``0)">
      <summary>
            Finds the index of the first item in a list equal to a given item.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <returns>The index of the first item equal to <paramref name="item" />. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FirstIndexOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the index of the first item in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>The index of the first item equal to <paramref name="item" />. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.LastIndexOf``1(System.Collections.Generic.IList{``0},``0)">
      <summary>
            Finds the index of the last item in a list equal to a given item.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <returns>The index of the last item equal to <paramref name="item" />. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.LastIndexOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the index of the last item in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>The index of the last item equal to <paramref name="item" />. -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IndicesOf``1(System.Collections.Generic.IList{``0},``0)">
      <summary>
            Enumerates the indices of all the items in a list equal to a given item.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to <paramref name="item" />. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IndicesOf``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Enumerates the indices of all the items in a list equal to a given item. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to <paramref name="item" />. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FirstIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds the index of the first item in a list equal to one of several given items.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <returns>The index of the first item equal to any of the items in the collection <paramref name="itemsToLookFor" />. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FirstIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the index of the first item in a list equal to one of several given items. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode methods will be called.</param>
      <returns>The index of the first item equal to any of the items in the collection <paramref name="itemsToLookFor" />. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FirstIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
      <summary>
            Finds the index of the first item in a list "equal" to one of several given items. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. This methods finds 
            first item X which satisfies BinaryPredicate(X,Y), where Y is one of the items in <paramref name="itemsToLookFor" /></remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>The index of the first item "equal" to any of the items in the collection <paramref name="itemsToLookFor" />, using 
            <paramref name="predicate" /> as the test for equality. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.LastIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds the index of the last item in a list equal to one of several given items.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <returns>The index of the last item equal to any of the items in the collection <paramref name="itemsToLookFor" />. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.LastIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Finds the index of the last item in a list equal to one of several given items. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality.</param>
      <returns>The index of the last item equal to any of the items in the collection <paramref name="itemsToLookFor" />. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.LastIndexOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
      <summary>
            Finds the index of the last item in a list "equal" to one of several given items. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. This methods finds 
            last item X which satisfies BinaryPredicate(X,Y), where Y is one of the items in <paramref name="itemsToLookFor" /></remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">The items to search for.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>The index of the last item "equal" to any of the items in the collection <paramref name="itemsToLookFor" />, using 
            <paramref name="predicate" /> as the test for equality. 
            -1 if no such item exists in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IndicesOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Enumerates the indices of all the items in a list equal to one of several given items. 
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">A collection of items to search for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to
            any of the items in the collection <paramref name="itemsToLookFor" />. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IndicesOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Enumerates the indices of all the items in a list equal to one of several given items. A passed
            IEqualityComparer is used to determine equality.
            </summary>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">A collection of items to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. </param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items equal to
            any of the items in the collection <paramref name="itemsToLookFor" />. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IndicesOfMany``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
      <summary>
            Enumerates the indices of all the items in a list equal to one of several given items. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being removed need not be true equality. This methods finds 
            last item X which satisfies BinaryPredicate(X,Y), where Y is one of the items in <paramref name="itemsToLookFor" /></remarks>
      <param name="list">The list to search.</param>
      <param name="itemsToLookFor">A collection of items to search for.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the indices of items "equal" to any of the items 
            in the collection <paramref name="itemsToLookFor" />, using 
            <paramref name="predicate" /> as the test for equality. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SearchForSubsequence``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Searchs a list for a sub-sequence of items that match a particular pattern. A subsequence 
            of <paramref name="list" /> matches pattern at index i if list[i] is equal to the first item
            in <paramref name="pattern" />, list[i+1] is equal to the second item in <paramref name="pattern" />,
            and so forth for all the items in <paramref name="pattern" />.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="pattern">The sequence of items to search for.</param>
      <returns>The first index with <paramref name="list" /> that matches the items in <paramref name="pattern" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SearchForSubsequence``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
      <summary>
            Searchs a list for a sub-sequence of items that match a particular pattern. A subsequence 
            of <paramref name="list" /> matches pattern at index i if list[i] is "equal" to the first item
            in <paramref name="pattern" />, list[i+1] is "equal" to the second item in <paramref name="pattern" />,
            and so forth for all the items in <paramref name="pattern" />. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being tested
            for in the pattern need not be equality. </remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="pattern">The sequence of items to search for.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". </param>
      <returns>The first index with <paramref name="list" /> that matches the items in <paramref name="pattern" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SearchForSubsequence``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Searchs a list for a sub-sequence of items that match a particular pattern. A subsequence 
            of <paramref name="list" /> matches pattern at index i if list[i] is equal to the first item
            in <paramref name="pattern" />, list[i+1] is equal to the second item in <paramref name="pattern" />,
            and so forth for all the items in <paramref name="pattern" />. The passed 
            instance of IEqualityComparer&lt;T&gt; is used for determining if two items are equal.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="pattern">The sequence of items to search for.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. Only the Equals method will be called.</param>
      <returns>The first index with <paramref name="list" /> that matches the items in <paramref name="pattern" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if one collection is a subset of another, considered as sets. The first set is a subset
            of the second set if every item in the first set also occurs in the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <returns>True if <paramref name="collection1" /> is a subset of <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IsSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if one collection is a subset of another, considered as sets. The first set is a subset
            of the second set if every item in the first set also occurs in the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
      <remarks>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality.</param>
      <returns>True if <paramref name="collection1" /> is a subset of <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IsProperSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if one collection is a proper subset of another, considered as sets. The first set is a proper subset
            of the second set if every item in the first set also occurs in the second set, and the first set is strictly smaller than
            the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <returns>True if <paramref name="collection1" /> is a subset of <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IsProperSubsetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if one collection is a proper subset of another, considered as sets. The first set is a proper subset
            of the second set if every item in the first set also occurs in the second set, and the first set is strictly smaller than
            the second set. If an item appears X times in the first set,
            it must appear at least X times in the second set.
            </summary>
      <remarks>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsSubsetOf method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>True if <paramref name="collection1" /> is a proper subset of <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.DisjointSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if two collections are disjoint, considered as sets. Two sets are disjoint if they
            have no common items.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsDisjoint method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <returns>True if <paramref name="collection1" /> are <paramref name="collection2" /> are disjoint, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.DisjointSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if two collections are disjoint, considered as sets. Two sets are disjoint if they
            have no common items.
            </summary>
      <remarks>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the IsDisjoint method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <param name="equalityComparer">The IEqualityComparerComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>True if <paramref name="collection1" /> are <paramref name="collection2" /> are disjoint, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if two collections are equal, considered as sets. Two sets are equal if they
            have have the same items, with order not being significant.
            </summary>
      <remarks>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the EqualTo method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <returns>True if <paramref name="collection1" /> are <paramref name="collection2" /> are equal, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if two collections are equal, considered as sets. Two sets are equal if they
            have have the same items, with order not being significant.
            </summary>
      <remarks>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the EqualTo method on that class.</para>
      </remarks>
      <param name="collection1">The first collection.</param>
      <param name="collection2">The second collection.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>True if <paramref name="collection1" /> are <paramref name="collection2" /> are equal, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SetIntersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Computes the set-theoretic intersection of two collections. The intersection of two sets
            is all items that appear in both of the sets. If an item appears X times in one set,
            and Y times in the other set, the intersection contains the item Minimum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the intersection of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Intersection or IntersectionWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to intersect.</param>
      <param name="collection2">The second collection to intersect.</param>
      <returns>The intersection of the two collections, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SetIntersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Computes the set-theoretic intersection of two collections. The intersection of two sets
            is all items that appear in both of the sets. If an item appears X times in one set,
            and Y times in the other set, the intersection contains the item Minimum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the intersection of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Intersection or IntersectionWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to intersect.</param>
      <param name="collection2">The second collection to intersect.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>The intersection of the two collections, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SetUnion``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Computes the set-theoretic union of two collections. The union of two sets
            is all items that appear in either of the sets. If an item appears X times in one set,
            and Y times in the other set, the union contains the item Maximum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the union of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Union or UnionWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to union.</param>
      <param name="collection2">The second collection to union.</param>
      <returns>The union of the two collections, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SetUnion``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Computes the set-theoretic union of two collections. The union of two sets
            is all items that appear in either of the sets. If an item appears X times in one set,
            and Y times in the other set, the union contains the item Maximum(X,Y) times. 
            The source collections are not changed.
            A new collection is created with the union of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the union or unionWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to union.</param>
      <param name="collection2">The second collection to union.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>The union of the two collections, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SetDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Computes the set-theoretic difference of two collections. The difference of two sets
            is all items that appear in the first set, but not in the second. If an item appears X times in the first set,
            and Y times in the second set, the difference contains the item X - Y times (0 times if X &lt; Y). 
            The source collections are not changed.
            A new collection is created with the difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the Difference or DifferenceWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to difference.</param>
      <param name="collection2">The second collection to difference.</param>
      <returns>The difference of <paramref name="collection1" /> and <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SetDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Computes the set-theoretic difference of two collections. The difference of two sets
            is all items that appear in the first set, but not in the second. If an item appears X times in the first set,
            and Y times in the second set, the difference contains the item X - Y times (0 times if X &lt; Y). 
            The source collections are not changed.
            A new collection is created with the difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the difference or differenceWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to difference.</param>
      <param name="collection2">The second collection to difference.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>The difference of <paramref name="collection1" /> and <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SetSymmetricDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Computes the set-theoretic symmetric difference of two collections. The symmetric difference of two sets
            is all items that appear in the one of the sets, but not in the other. If an item appears X times in the one set,
            and Y times in the other set, the symmetric difference contains the item AbsoluteValue(X - Y) times. 
            The source collections are not changed.
            A new collection is created with the symmetric difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the SymmetricDifference or SymmetricDifferenceWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to symmetric difference.</param>
      <param name="collection2">The second collection to symmetric difference.</param>
      <returns>The symmetric difference of <paramref name="collection1" /> and <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SetSymmetricDifference``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Computes the set-theoretic symmetric difference of two collections. The symmetric difference of two sets
            is all items that appear in the one of the sets, but not in the other. If an item appears X times in the one set,
            and Y times in the other set, the symmetric difference contains the item AbsoluteValue(X - Y) times. 
            The source collections are not changed.
            A new collection is created with the symmetric difference of the collections; the order of the
            items in this collection is undefined.
            </summary>
      <remarks>
        <para>When equal items appear in both collections, the returned collection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>If both collections are Set, Bag, OrderedSet, or OrderedBag
            collections, it is more efficient to use the symmetric difference or symmetric differenceWith methods on that class.</para>
      </remarks>
      <param name="collection1">The first collection to symmetric difference.</param>
      <param name="collection2">The second collection to symmetric difference.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals and GetHashCode member functions of this interface are called.</param>
      <returns>The symmetric difference of <paramref name="collection1" /> and <paramref name="collection2" />, considered as sets.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" /> or <paramref name="collection2" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.CartesianProduct``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
      <summary>
            Computes the cartestian product of two collections: all possible pairs of items, with the first item taken from the first collection and 
            the second item taken from the second collection. If the first collection has N items, and the second collection has M items, the cartesian
            product will have N * M pairs.
            </summary>
      <typeparam name="TFirst">The type of items in the first collection.</typeparam>
      <typeparam name="TSecond">The type of items in the second collection.</typeparam>
      <param name="first">The first collection.</param>
      <param name="second">The second collection.</param>
      <returns>An IEnumerable&lt;Pair&lt;TFirst, TSecond&gt;&gt; that enumerates the cartesian product of the two collections.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.ToString``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Gets a string representation of the elements in the collection.
            The string representation starts with "{", has a list of items separated
            by commas (","), and ends with "}". Each item in the collection is 
            converted to a string by calling its ToString method (null is represented by "null").
            Contained collections (except strings) are recursively converted to strings by this method.
            </summary>
      <param name="collection">A collection to get the string representation of.</param>
      <returns>The string representation of the collection. If <paramref name="collection" /> is null, then the string "null" is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.ToString``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,System.String,System.String,System.String)">
      <summary>
            Gets a string representation of the elements in the collection.
            The string to used at the beginning and end, and to separate items,
            and supplied by parameters. Each item in the collection is 
            converted to a string by calling its ToString method (null is represented by "null").
            </summary>
      <param name="collection">A collection to get the string representation of.</param>
      <param name="recursive">If true, contained collections (except strings) are converted to strings by a recursive call to this method, instead
            of by calling ToString.</param>
      <param name="start">The string to appear at the beginning of the output string.</param>
      <param name="separator">The string to appear between each item in the string.</param>
      <param name="end">The string to appear at the end of the output string.</param>
      <returns>The string representation of the collection. If <paramref name="collection" /> is null, then the string "null" is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="start" />, <paramref name="separator" />, or <paramref name="end" />
             is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.ToString``2(System.Collections.Generic.IDictionary{``0,``1})">
      <summary>
            Gets a string representation of the mappings in a dictionary.
            The string representation starts with "{", has a list of mappings separated
            by commas (", "), and ends with "}". Each mapping is represented
            by "key-&gt;value". Each key and value in the dictionary is 
            converted to a string by calling its ToString method (null is represented by "null").
            Contained collections (except strings) are recursively converted to strings by this method.
            </summary>
      <param name="dictionary">A dictionary to get the string representation of.</param>
      <returns>The string representation of the collection, or "null" 
            if <paramref name="dictionary" /> is null.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RandomShuffle``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Randomly shuffles the items in a collection, yielding a new collection.
            </summary>
      <typeparam name="T">The type of the items in the collection.</typeparam>
      <param name="collection">The collection to shuffle.</param>
      <returns>An array with the same size and items as <paramref name="collection" />, but the items in a randomly chosen order.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RandomShuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
      <summary>
            Randomly shuffles the items in a collection, yielding a new collection.
            </summary>
      <typeparam name="T">The type of the items in the collection.</typeparam>
      <param name="collection">The collection to shuffle.</param>
      <param name="randomGenerator">The random number generator to use to select the random order.</param>
      <returns>An array with the same size and items as <paramref name="collection" />, but the items in a randomly chosen order.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RandomShuffleInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Randomly shuffles the items in a list or array, in place.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to shuffle.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RandomShuffleInPlace``1(System.Collections.Generic.IList{``0},System.Random)">
      <summary>
            Randomly shuffles the items in a list or array, in place.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to shuffle.</param>
      <param name="randomGenerator">The random number generator to use to select the random order.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RandomSubset``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
            Picks a random subset of <paramref name="count" /> items from <paramref name="collection" />, and places
            those items into a random order. No item is selected more than once.
            </summary>
      <remarks>If the collection implements IList&lt;T&gt;, then this method takes time O(<paramref name="count" />).
            Otherwise, this method takes time O(N), where N is the number of items in the collection.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection of items to select from. This collection is not changed.</param>
      <param name="count">The number of items in the subset to choose.</param>
      <returns>An array of <paramref name="count" /> items, selected at random from <paramref name="collection" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative or greater than <paramref name="collection" />.Count.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RandomSubset``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Random)">
      <summary>
            Picks a random subset of <paramref name="count" /> items from <paramref name="collection" />, and places
            those items into a random order. No item is selected more than once.
            </summary>
      <remarks>If the collection implements IList&lt;T&gt;, then this method takes time O(<paramref name="count" />).
            Otherwise, this method takes time O(N), where N is the number of items in the collection.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection of items to select from. This collection is not changed.</param>
      <param name="count">The number of items in the subset to choose.</param>
      <param name="randomGenerator">The random number generates used to make the selection.</param>
      <returns>An array of <paramref name="count" /> items, selected at random from <paramref name="collection" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative or greater than <paramref name="collection" />.Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="randomGenerator" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GeneratePermutations``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Generates all the possible permutations of the items in <paramref name="collection" />. If <paramref name="collection" />
            has N items, then N factorial permutations will be generated. This method does not compare the items to determine if
            any of them are equal. If some items are equal, the same permutation may be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate the six permutations, AAB, AAB,
            ABA, ABA, BAA, BAA (not necessarily in that order). To take equal items into account, use the GenerateSortedPermutations
            method.
            </summary>
      <typeparam name="T">The type of items to permute.</typeparam>
      <param name="collection">The collection of items to permute.</param>
      <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection" />. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GenerateSortedPermutations``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Generates all the possible permutations of the items in <paramref name="collection" />, in lexicographical order. 
            Even if some items are equal, the same permutation will not be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate only the three permutations, AAB, ABA,
            BAA. 
            </summary>
      <typeparam name="T">The type of items to permute.</typeparam>
      <param name="collection">The collection of items to permute.</param>
      <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection" />. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GenerateSortedPermutations``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Generates all the possible permutations of the items in <paramref name="collection" />, in lexicographical order. A
            supplied IComparer&lt;T&gt; instance is used to compare the items.
            Even if some items are equal, the same permutation will not be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate only the three permutations, AAB, ABA,
            BAA. 
            </summary>
      <typeparam name="T">The type of items to permute.</typeparam>
      <param name="collection">The collection of items to permute.</param>
      <param name="comparer">The IComparer&lt;T&gt; used to compare the items.</param>
      <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection" />. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GenerateSortedPermutations``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Generates all the possible permutations of the items in <paramref name="collection" />, in lexicographical order. A
            supplied Comparison&lt;T&gt; delegate is used to compare the items.
            Even if some items are equal, the same permutation will not be generated more than once. For example,
            if the collections contains the three items A, A, and B, then this method will generate only the three permutations, AAB, ABA,
            BAA. 
            </summary>
      <typeparam name="T">The type of items to permute.</typeparam>
      <param name="collection">The collection of items to permute.</param>
      <param name="comparison">The Comparison&lt;T&gt; delegate used to compare the items.</param>
      <returns>An IEnumerable&lt;T[]&gt; that enumerations all the possible permutations of the 
            items in <paramref name="collection" />. Each permutations is returned as an array. The items in the array
            should be copied if they need to be used after the next permutation is generated; each permutation may
            reuse the same array instance.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Maximum``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds the maximum value in a collection.
            </summary>
      <remarks>Values in the collection are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <returns>The largest item in the collection. </returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Maximum``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the maximum value in a collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <param name="comparer">The comparer instance used to compare items in the collection.</param>
      <returns>The largest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Maximum``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Finds the maximum value in a collection. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <param name="comparison">The comparison used to compare items in the collection.</param>
      <returns>The largest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Minimum``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Finds the minimum value in a collection.
            </summary>
      <remarks>Values in the collection are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <returns>The smallest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Minimum``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the minimum value in a collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <param name="comparer">The comparer instance used to compare items in the collection.</param>
      <returns>The smallest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Minimum``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Finds the minimum value in a collection. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the collection.</typeparam>
      <param name="collection">The collection to search.</param>
      <param name="comparison">The comparison used to compare items in the collection.</param>
      <returns>The smallest item in the collection.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> or <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IndexOfMaximum``1(System.Collections.Generic.IList{``0})">
      <summary>
            Finds the index of the maximum value in a list.
            </summary>
      <remarks>Values in the list are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <returns>The index of the largest item in the list. If the maximum value appears
            multiple times, the index of the first appearance is used. If the list is empty, -1 is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IndexOfMaximum``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the index of the maximum value in a list. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="comparer">The comparer instance used to compare items in the collection.</param>
      <returns>The index of the largest item in the list. If the maximum value appears
            multiple times, the index of the first appearance is used. If the list is empty, -1 is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> or <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IndexOfMaximum``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
      <summary>
            Finds the index of the maximum value in a list. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="comparison">The comparison used to compare items in the collection.</param>
      <returns>The index of the largest item in the list. If the maximum value appears
            multiple times, the index of the first appearance is used. If the list is empty, -1 is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> or <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IndexOfMinimum``1(System.Collections.Generic.IList{``0})">
      <summary>
            Finds the index of the minimum value in a list.
            </summary>
      <remarks>Values in the list are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <returns>The index of the smallest item in the list. If the minimum value appears
            multiple times, the index of the first appearance is used.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IndexOfMinimum``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Finds the index of the minimum value in a list. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="comparer">The comparer instance used to compare items in the collection.</param>
      <returns>The index of the smallest item in the list. If the minimum value appears
            multiple times, the index of the first appearance is used.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> or <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.IndexOfMinimum``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
      <summary>
            Finds the index of the minimum value in a list. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to search.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
      <returns>The index of the smallest item in the list. If the minimum value appears
            multiple times, the index of the first appearance is used.</returns>
      <exception cref="T:System.InvalidOperationException">The collection is empty.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> or <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Sort``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Creates a sorted version of a collection.
            </summary>
      <remarks>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <param name="collection">The collection to sort.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Sort``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Creates a sorted version of a collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
      <param name="collection">The collection to sort.</param>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Sort``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Creates a sorted version of a collection. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <param name="collection">The collection to sort.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SortInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Sorts a list or array in place.
            </summary>
      <remarks>
        <para>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
        <para>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to sort.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SortInPlace``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Sorts a list or array in place. A supplied IComparer&lt;T&gt; is used
            to compare the items in the list. 
            </summary>
      <remarks>
        <para>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to sort.</param>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.SortInPlace``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
      <summary>
            Sorts a list or array in place. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the list.
            </summary>
      <remarks>
        <para>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to sort.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.StableSort``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Creates a sorted version of a collection. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection.
            </summary>
      <remarks>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <param name="collection">The collection to sort.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.StableSort``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Creates a sorted version of a collection. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. A supplied IComparer&lt;T&gt; is used
            to compare the items in the collection. 
            </summary>
      <param name="collection">The collection to sort.</param>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.StableSort``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Creates a sorted version of a collection. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the collection.
            </summary>
      <remarks>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</remarks>
      <param name="collection">The collection to sort.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
      <returns>An array containing the sorted version of the collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.StableSortInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Sorts a list or array in place. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            </summary>
      <remarks>
        <para>Values are compared by using the IComparable&lt;T&gt;
            interfaces implementation on the type T.</para>
        <para>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</para>
      </remarks>
      <param name="list">The list or array to sort.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.StableSortInPlace``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Sorts a list or array in place. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            A supplied IComparer&lt;T&gt; is used
            to compare the items in the list. 
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to sort.</param>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.StableSortInPlace``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
      <summary>
            Sorts a list or array in place. The sort is stable, which means that if items X and Y are equal,
            and X precedes Y in the unsorted collection, X will precede Y is the sorted collection. 
            A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the list.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to sort.</param>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Int32@)">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the natural ordering of the type (it's implementation of IComparable&lt;T&gt;).
            </summary>
      <param name="list">The sorted list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="index">Returns the first index at which the item can be found. If the return
            value is zero, indicating that <paramref name="item" /> was not present in the list, then this
            returns the index at which <paramref name="item" /> could be inserted to maintain the sorted
            order of the list.</param>
      <returns>The number of items equal to <paramref name="item" /> that appear in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IComparer{``0},System.Int32@)">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering in the passed instance of IComparer&lt;T&gt;.
            </summary>
      <param name="list">The sorted list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="comparer">The comparer instance used to sort the list. Only
            the Compare method is used.</param>
      <param name="index">Returns the first index at which the item can be found. If the return
            value is zero, indicating that <paramref name="item" /> was not present in the list, then this
            returns the index at which <paramref name="item" /> could be inserted to maintain the sorted
            order of the list.</param>
      <returns>The number of items equal to <paramref name="item" /> that appear in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Comparison{``0},System.Int32@)">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering in the passed Comparison&lt;T&gt; delegate.
            </summary>
      <param name="list">The sorted list to search.</param>
      <param name="item">The item to search for.</param>
      <param name="comparison">The comparison delegate used to sort the list.</param>
      <param name="index">Returns the first index at which the item can be found. If the return
            value is zero, indicating that <paramref name="item" /> was not present in the list, then this
            returns the index at which <paramref name="item" /> could be inserted to maintain the sorted
            order of the list.</param>
      <returns>The number of items equal to <paramref name="item" /> that appear in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.MergeSorted``1(System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
            Merge several sorted collections into a single sorted collection. Each input collection must be sorted
            by the natural ordering of the type (it's implementation of IComparable&lt;T&gt;). The merging
            is stable; equal items maintain their ordering, and equal items in different collections are placed
            in the order of the collections.
            </summary>
      <param name="collections">The set of collections to merge. In many languages, this parameter
            can be specified as several individual parameters.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates all the items in all the collections
            in sorted order. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.LexicographicalCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Performs a lexicographical comparison of two sequences of values. A lexicographical comparison compares corresponding
            pairs of elements from two sequences in order. If the first element of sequence1 is less than the first element of sequence2, 
            then the comparison ends and the first sequence is lexicographically less than the second. If the first elements of each sequence
            are equal, then the comparison proceeds to the second element of each sequence. If one sequence is shorter than the other,
            but corresponding elements are all equal, then the shorter sequence is considered less than the longer one.
            </summary>
      <remarks>T must implement either IComparable&lt;T&gt; and this implementation is used
            to compare the items. </remarks>
      <typeparam name="T">Types of items to compare. This type must implement IComparable&lt;T&gt; to allow 
            items to be compared.</typeparam>
      <param name="sequence1">The first sequence to compare.</param>
      <param name="sequence2">The second sequence to compare.</param>
      <returns>Less than zero if <paramref name="sequence1" /> is lexicographically less than <paramref name="sequence2" />.
            Greater than zero if <paramref name="sequence1" /> is lexicographically greater than <paramref name="sequence2" />.
            Zero if <paramref name="sequence1" /> is equal to <paramref name="sequence2" />.</returns>
      <exception cref="T:System.NotSupportedException">T does not implement IComparable&lt;T&gt; or IComparable.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.LexicographicalCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
      <summary>
            Performs a lexicographical comparison of two sequences of values, using a supplied comparison delegate. A lexicographical comparison compares corresponding
            pairs of elements from two sequences in order. If the first element of sequence1 is less than the first element of sequence2, 
            then the comparison ends and the first sequence is lexicographically less than the second. If the first elements of each sequence
            are equal, then the comparison proceeds to the second element of each sequence. If one sequence is shorter than the other,
            but corresponding elements are all equal, then the shorter sequence is considered less than the longer one.
            </summary>
      <typeparam name="T">Types of items to compare.</typeparam>
      <param name="sequence1">The first sequence to compare.</param>
      <param name="sequence2">The second sequence to compare.</param>
      <param name="comparison">The IComparison&lt;T&gt; delegate to compare items. 
            Only the Compare member function of this interface is called.</param>
      <returns>Less than zero if <paramref name="sequence1" /> is lexicographically less than <paramref name="sequence2" />.
            Greater than zero if <paramref name="sequence1" /> is lexicographically greater than <paramref name="sequence2" />.
            Zero if <paramref name="sequence1" /> is equal to <paramref name="sequence2" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.LexicographicalCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
      <summary>
            Performs a lexicographical comparison of two sequences of values, using a supplied comparer interface. A lexicographical comparison compares corresponding
            pairs of elements from two sequences in order. If the first element of sequence1 is less than the first element of sequence2, 
            then the comparison ends and the first sequence is lexicographically less than the second. If the first elements of each sequence
            are equal, then the comparison proceeds to the second element of each sequence. If one sequence is shorter than the other,
            but corresponding elements are all equal, then the shorter sequence is considered less than the longer one.
            </summary>
      <typeparam name="T">Types of items to compare.</typeparam>
      <param name="sequence1">The first sequence to compare.</param>
      <param name="sequence2">The second sequence to compare.</param>
      <param name="comparer">The IComparer&lt;T&gt; used to compare items. 
            Only the Compare member function of this interface is called.</param>
      <returns>Less than zero if <paramref name="sequence1" /> is lexicographically less than <paramref name="sequence2" />.
            Greater than zero if <paramref name="sequence1" /> is lexicographically greater than <paramref name="sequence2" />.
            Zero if <paramref name="sequence1" /> is equal to <paramref name="sequence2" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sequence1" />, <paramref name="sequence2" />, or 
            <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetLexicographicalComparer``1">
      <summary>
            Creates an IComparer instance that can be used for comparing ordered
            sequences of type T; that is IEnumerable&lt;Tgt;. This comparer can be used
            for collections or algorithms that use sequences of T as an item type. The Lexicographical
            ordered of sequences is for comparison.
            </summary>
      <remarks>T must implement either IComparable&lt;T&gt; and this implementation is used
            to compare the items. </remarks>
      <returns>At IComparer&lt;IEnumerable&lt;T&gt;&gt; that compares sequences of T.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetLexicographicalComparer``1(System.Collections.Generic.IComparer{``0})">
      <summary>
            Creates an IComparer instance that can be used for comparing ordered
            sequences of type T; that is IEnumerable&lt;Tgt;. This comparer can be uses
            for collections or algorithms that use sequences of T as an item type. The Lexicographics
            ordered of sequences is for comparison.
            </summary>
      <param name="comparer">A comparer instance used to compare individual items of type T.</param>
      <returns>At IComparer&lt;IEnumerable&lt;T&gt;&gt; that compares sequences of T.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetLexicographicalComparer``1(System.Comparison{``0})">
      <summary>
            Creates an IComparer instance that can be used for comparing ordered
            sequences of type T; that is IEnumerable&lt;Tgt;. This comparer can be uses
            for collections or algorithms that use sequences of T as an item type. The Lexicographics
            ordered of sequences is for comparison.
            </summary>
      <param name="comparison">A comparison delegate used to compare individual items of type T.</param>
      <returns>At IComparer&lt;IEnumerable&lt;T&gt;&gt; that compares sequences of T.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetReverseComparer``1(System.Collections.Generic.IComparer{``0})">
      <summary>
            Reverses the order of comparison of an IComparer&lt;T&gt;. The resulting comparer can be used,
            for example, to sort a collection in descending order. Equality and hash codes are unchanged.
            </summary>
      <typeparam name="T">The type of items thta are being compared.</typeparam>
      <param name="comparer">The comparer to reverse.</param>
      <returns>An IComparer&lt;T&gt; that compares items in the reverse order of <paramref name="comparer" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparer" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetIdentityComparer``1">
      <summary>
            Gets an IEqualityComparer&lt;T&gt; instance that can be used to compare objects
            of type T for object identity only. Two objects compare equal only if they
            are references to the same object. 
            </summary>
      <returns>An IEqualityComparer&lt;T&gt; instance for identity comparison.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetReverseComparison``1(System.Comparison{``0})">
      <summary>
            Reverses the order of comparison of an Comparison&lt;T&gt;. The resulting comparison can be used,
            for example, to sort a collection in descending order. 
            </summary>
      <typeparam name="T">The type of items that are being compared.</typeparam>
      <param name="comparison">The comparison to reverse.</param>
      <returns>A Comparison&lt;T&gt; that compares items in the reverse order of <paramref name="comparison" />.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="comparison" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetComparerFromComparison``1(System.Comparison{``0})">
      <summary>
            Given a comparison delegate that compares two items of type T, gets an
            IComparer&lt;T&gt; instance that performs the same comparison.
            </summary>
      <param name="comparison">The comparison delegate to use.</param>
      <returns>An IComparer&lt;T&gt; that performs the same comparing operation
            as <paramref name="comparison" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetComparisonFromComparer``1(System.Collections.Generic.IComparer{``0})">
      <summary>
            Given in IComparer&lt;T&gt; instenace that comparers two items from type T, 
            gets a Comparison delegate that performs the same comparison.
            </summary>
      <param name="comparer">The IComparer&lt;T&gt; instance to use.</param>
      <returns>A Comparison&lt;T&gt; delegate that performans the same comparing
            operation as <paramref name="comparer" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetCollectionEqualityComparer``1">
      <summary>
            Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, considered in order. This is the same notion of equality as
            in Algorithms.EqualCollections, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.
            </summary>
      <example>
            The following code creates a Dictionary where the keys are a collection of strings.
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetCollectionEqualityComparer&lt;string&gt;());
            </code></example>
      <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetCollectionEqualityComparer``1(System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
        <para>Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, considered in order. This is the same notion of equality as
            in Algorithms.EqualCollections, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.</para>
        <para>An IEqualityComparer&lt;T&gt; is used to determine if individual T's are equal</para>
      </summary>
      <example>
            The following code creates a Dictionary where the keys are a collection of strings, compared in a case-insensitive way
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetCollectionEqualityComparer&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase));
            </code></example>
      <param name="equalityComparer">An IEqualityComparer&lt;T&gt; implementation used to compare individual T's.</param>
      <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetSetEqualityComparer``1">
      <summary>
        <para>Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, without regard to order. This is the same notion of equality as
            in Algorithms.EqualSets, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.</para>
        <para>An IEqualityComparer&lt;T&gt; is used to determine if individual T's are equal</para>
      </summary>
      <example>
            The following code creates a Dictionary where the keys are a set of strings, without regard to order
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetSetEqualityComparer&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase));
            </code></example>
      <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality, without regard to order.</returns>
      <seealso cref="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetSetEqualityComparer``1(System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Gets an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation 
            that can be used to compare collections of elements (of type T). Two collections
            of T's are equal if they have the same number of items, and corresponding 
            items are equal, without regard to order. This is the same notion of equality as
            in Algorithms.EqualSets, but encapsulated in an IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation.
            </summary>
      <example>
            The following code creates a Dictionary where the keys are a set of strings, without regard to order
            <code>
                Dictionary&lt;IEnumerable&lt;string&gt;, int&gt; = 
                    new Dictionary&lt;IEnumerable&lt;string&gt;, int&gt;(Algorithms.GetSetEqualityComparer&lt;string&gt;());
            </code></example>
      <param name="equalityComparer">An IEqualityComparer&lt;T&gt; implementation used to compare individual T's.</param>
      <returns>IEqualityComparer&lt;IEnumerable&lt;T&gt;&gt; implementation suitable for 
            comparing collections of T for equality, without regard to order.</returns>
      <seealso cref="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.EqualSets``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            Determines if a collection contains any item that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if the collection contains one or more items that satisfy the condition
            defined by <paramref name="predicate" />. False if the collection does not contain
            an item that satisfies <paramref name="predicate" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.TrueForAll``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            Determines if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />, or if the collection is empty. False if one or more items
            in the collection do not satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.CountWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            Counts the number of items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="collection">The collection to count items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>The number of items in the collection that satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RemoveWhere``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.Boolean})">
      <summary>
            Removes all the items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <remarks>If the collection if an array or implements IList&lt;T&gt;, an efficient algorithm that
            compacts items is used. If not, then ICollection&lt;T&gt;.Remove is used
            to remove items from the collection. If the collection is an array or fixed-size list,
            the non-removed elements are placed, in order, at the beginning of
            the list, and the remaining list items are filled with a default value (0 or null).</remarks>
      <param name="collection">The collection to check all the items in.</param>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>Returns a collection of the items that were removed. This collection contains the
            items in the same order that they orginally appeared in <paramref name="collection" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Convert``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
            Convert a collection of items by applying a delegate to each item in the collection. The resulting collection
            contains the result of applying <paramref name="converter" /> to each item in <paramref name="sourceCollection" />, in
            order.
            </summary>
      <typeparam name="TSource">The type of items in the collection to convert.</typeparam>
      <typeparam name="TDest">The type each item is being converted to.</typeparam>
      <param name="sourceCollection">The collection of item being converted.</param>
      <param name="converter">A delegate to the method to call, passing each item in <paramref name="sourceCollection" />.</param>
      <returns>The resulting collection from applying <paramref name="converter" /> to each item in <paramref name="sourceCollection" />, in
            order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="sourceCollection" /> or <paramref name="converter" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetDictionaryConverter``2(System.Collections.Generic.IDictionary{``0,``1})">
      <summary>
            Creates a delegate that converts keys to values by used a dictionary to map values. Keys
            that a not present in the dictionary are converted to the default value (zero or null).
            </summary>
      <remarks>This delegate can be used as a parameter in Convert or ConvertAll methods to convert
            entire collections.</remarks>
      <param name="dictionary">The dictionary used to perform the conversion.</param>
      <returns>A delegate to a method that converts keys to values. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.GetDictionaryConverter``2(System.Collections.Generic.IDictionary{``0,``1},``1)">
      <summary>
            Creates a delegate that converts keys to values by used a dictionary to map values. Keys
            that a not present in the dictionary are converted to a supplied default value.
            </summary>
      <remarks>This delegate can be used as a parameter in Convert or ConvertAll methods to convert
            entire collections.</remarks>
      <param name="dictionary">The dictionary used to perform the conversion.</param>
      <param name="defaultValue">The result of the conversion for keys that are not present in the dictionary.</param>
      <returns>A delegate to a method that converts keys to values. </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="dictionary" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            Performs the specified action on each item in a collection.
            </summary>
      <param name="collection">The collection to process.</param>
      <param name="action">An Action delegate which is invoked for each item in <paramref name="collection" />.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Partition``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
      <summary>
            Partition a list or array based on a predicate. After partitioning, all items for which
            the predicate returned true precede all items for which the predicate returned false.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to partition.</param>
      <param name="predicate">A delegate that defines the partitioning condition.</param>
      <returns>The index of the first item in the second half of the partition; i.e., the first item for
            which <paramref name="predicate" /> returned false. If the predicate was true for all items
            in the list, list.Count is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.StablePartition``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
      <summary>
            Partition a list or array based on a predicate. After partitioning, all items for which
            the predicate returned true precede all items for which the predicate returned false. 
            The partition is stable, which means that if items X and Y have the same result from
            the predicate, and X precedes Y in the original list, X will precede Y in the 
            partitioned list.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to partition.</param>
      <param name="predicate">A delegate that defines the partitioning condition.</param>
      <returns>The index of the first item in the second half of the partition; i.e., the first item for
            which <paramref name="predicate" /> returned false. If the predicate was true for all items
            in the list, list.Count is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Concatenate``1(System.Collections.Generic.IEnumerable{``0}[])">
      <summary>
            Concatenates all the items from several collections. The collections need not be of the same type, but
            must have the same item type.
            </summary>
      <param name="collections">The set of collections to concatenate. In many languages, this parameter
            can be specified as several individual parameters.</param>
      <returns>An IEnumerable that enumerates all the items in each of the collections, in order.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determines if the two collections contain equal items in the same order. The two collections do not need
            to be of the same type; it is permissible to compare an array and an OrderedBag, for instance.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <typeparam name="T">The type of items in the collections.</typeparam>
      <param name="collection1">The first collection to compare.</param>
      <param name="collection2">The second collection to compare.</param>
      <returns>True if the collections have equal items in the same order. If both collections are empty, true is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Determines if the two collections contain equal items in the same order. The passed 
            instance of IEqualityComparer&lt;T&gt; is used for determining if two items are equal.
            </summary>
      <typeparam name="T">The type of items in the collections.</typeparam>
      <param name="collection1">The first collection to compare.</param>
      <param name="collection2">The second collection to compare.</param>
      <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to compare items for equality. 
            Only the Equals member function of this interface is called.</param>
      <returns>True if the collections have equal items in the same order. If both collections are empty, true is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" />, <paramref name="collection2" />, or
            <paramref name="equalityComparer" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.EqualCollections``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
      <summary>
            Determines if the two collections contain "equal" items in the same order. The passed 
            BinaryPredicate is used to determine if two items are "equal".
            </summary>
      <remarks>Since an arbitrary BinaryPredicate is passed to this function, what is being tested
            for need not be equality. For example, the following code determines if each integer in
            list1 is less than or equal to the corresponding integer in list2.
            <code>
            List&lt;int&gt; list1, list2;
            if (EqualCollections(list1, list2, delegate(int x, int y) { return x &lt;= y; }) {
                // the check is true...
            }
            </code></remarks>
      <typeparam name="T">The type of items in the collections.</typeparam>
      <param name="collection1">The first collection to compare.</param>
      <param name="collection2">The second collection to compare.</param>
      <param name="predicate">The BinaryPredicate used to compare items for "equality". 
            This predicate can compute any relation between two items; it need not represent equality or an equivalence relation.</param>
      <returns>True if <paramref name="predicate" />returns true for each corresponding pair of
            items in the two collections. If both collections are empty, true is returned.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection1" />, <paramref name="collection2" />, or
            <paramref name="predicate" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Create an array with the items in a collection.
            </summary>
      <remarks>If <paramref name="collection" /> implements ICollection&lt;T&gt;T, then 
            ICollection&lt;T&gt;.CopyTo() is used to fill the array. Otherwise, the IEnumerable&lt;T&gt;.GetEnumerator()
            is used to fill the array.</remarks>
      <typeparam name="T">Element type of the collection.</typeparam>
      <param name="collection">Collection to create array from.</param>
      <returns>An array with the items from the collection, in enumeration order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Count``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Count the number of items in an IEnumerable&lt;T&gt; collection. If 
            a more specific collection type is being used, it is more efficient to use
            the Count property, if one is provided.
            </summary>
      <remarks>If the collection implements ICollection&lt;T&gt;, this method
            simply returns ICollection&lt;T&gt;.Count. Otherwise, it enumerates all items
            and counts them.</remarks>
      <param name="collection">The collection to count items in.</param>
      <returns>The number of items in the collection.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.CountEqual``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            Counts the number of items in the collection that are equal to <paramref name="find" />.
            </summary>
      <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.</remarks>
      <param name="collection">The collection to count items in.</param>
      <param name="find">The item to compare to.</param>
      <returns>The number of items in the collection that are equal to <paramref name="find" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.CountEqual``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Counts the number of items in the collection that are equal to <paramref name="find" />.
            </summary>
      <param name="collection">The collection to count items in.</param>
      <param name="find">The item to compare to.</param>
      <param name="equalityComparer">The comparer to use to determine if two items are equal. Only the Equals
            member function will be called.</param>
      <returns>The number of items in the collection that are equal to <paramref name="find" />.</returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="collection" /> or <paramref name="equalityComparer" />
            is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.NCopiesOf``1(System.Int32,``0)">
      <summary>
            Creates an IEnumerator that enumerates a given item <paramref name="n" /> times.
            </summary>
      <example>
            The following creates a list consisting of 1000 copies of the double 1.0.
            <code>
            List&lt;double&gt; list = new List&lt;double&gt;(Algorithms.NCopiesOf(1000, 1.0));
            </code></example>
      <param name="n">The number of times to enumerate the item.</param>
      <param name="item">The item that should occur in the enumeration.</param>
      <returns>An IEnumerable&lt;T&gt; that yields <paramref name="n" /> copies
            of <paramref name="item" />.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The argument <paramref name="n" /> is less than zero.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Fill``1(System.Collections.Generic.IList{``0},``0)">
      <summary>
            Replaces each item in a list with a given value. The list does not change in size.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to modify.</param>
      <param name="value">The value to fill with.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="list" /> is a read-only list.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.FillRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,``0)">
      <summary>
            Replaces each item in a part of a list with a given value.
            </summary>
      <typeparam name="T">The type of items in the list.</typeparam>
      <param name="list">The list to modify.</param>
      <param name="start">The index at which to start filling. The first index in the list has index 0.</param>
      <param name="count">The number of items to fill.</param>
      <param name="value">The value to fill with.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="list" /> is a read-only list.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative, or 
            <paramref name="start" /> + <paramref name="count" /> is greater than <paramref name="list" />.Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Copies all of the items from the collection <paramref name="source" /> to the list <paramref name="dest" />, starting
            at the index <paramref name="destIndex" />. If necessary, the size of the destination list is expanded.
            </summary>
      <param name="source">The collection that provide the source items. </param>
      <param name="dest">The list to store the items into.</param>
      <param name="destIndex">The index to begin copying items to.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Copy``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
      <summary>
            Copies at most <paramref name="count" /> items from the collection <paramref name="source" /> to the list <paramref name="dest" />, starting
            at the index <paramref name="destIndex" />. If necessary, the size of the destination list is expanded. The source collection must not be
            the destination list or part thereof.
            </summary>
      <param name="source">The collection that provide the source items. </param>
      <param name="dest">The list to store the items into.</param>
      <param name="destIndex">The index to begin copying items to.</param>
      <param name="count">The maximum number of items to copy.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Count</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Copy``1(System.Collections.Generic.IList{``0},System.Int32,System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
      <summary>
            Copies <paramref name="count" /> items from the list <paramref name="source" />, starting at the index <paramref name="sourceIndex" />, 
            to the list <paramref name="dest" />, starting at the index <paramref name="destIndex" />. If necessary, the size of the destination list is expanded.
            The source and destination lists may be the same.
            </summary>
      <param name="source">The collection that provide the source items. </param>
      <param name="sourceIndex">The index within <paramref name="source" />to begin copying items from.</param>
      <param name="dest">The list to store the items into.</param>
      <param name="destIndex">The index within <paramref name="dest" />to begin copying items to.</param>
      <param name="count">The maximum number of items to copy.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="sourceIndex" /> is negative or 
            greater than <paramref name="source" />.Count</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="destIndex" /> is negative or 
            greater than <paramref name="dest" />.Count</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> is negative or too large.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> or <paramref name="dest" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Reverse``1(System.Collections.Generic.IList{``0})">
      <summary>
            Reverses a list and returns the reversed list, without changing the source list.
            </summary>
      <param name="source">The list to reverse.</param>
      <returns>A collection that contains the items from <paramref name="source" /> in reverse order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.ReverseInPlace``1(System.Collections.Generic.IList{``0})">
      <summary>
            Reverses a list or array in place.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to reverse.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="list" /> is read only.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.Rotate``1(System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Rotates a list and returns the rotated list, without changing the source list.
            </summary>
      <param name="source">The list to rotate.</param>
      <param name="amountToRotate">The number of elements to rotate. This value can be positive or negative. 
            For example, rotating by positive 3 means that source[3] is the first item in the returned collection.
            Rotating by negative 3 means that source[source.Count - 3] is the first item in the returned collection.</param>
      <returns>A collection that contains the items from <paramref name="source" /> in rotated order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="source" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Algorithms.RotateInPlace``1(System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Rotates a list or array in place.
            </summary>
      <remarks>Although arrays cast to IList&lt;T&gt; are normally read-only, this method
            will work correctly and modify an array passed as <paramref name="list" />.</remarks>
      <param name="list">The list or array to rotate.</param>
      <param name="amountToRotate">The number of elements to rotate. This value can be positive or negative. 
            For example, rotating by positive 3 means that list[3] is the first item in the resulting list.
            Rotating by negative 3 means that list[list.Count - 3] is the first item in the resulting list.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.ListBase`1">
      <summary>
            ListBase is an abstract class that can be used as a base class for a read-write collection that needs 
            to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs
            to override the following methods: Count, Clear, Insert, RemoveAt, and the indexer. The implementation
            of all the other methods in IList&lt;T&gt; and IList are handled by ListBase.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1">
      <summary>
            CollectionBase is a base class that can be used to more easily implement the
            generic ICollection&lt;T&gt; and non-generic ICollection interfaces.
            </summary>
      <remarks>
        <para>To use CollectionBase as a base class, the derived class must override
            the Count, GetEnumerator, Add, Clear, and Remove methods. </para>
        <para>ICollection&lt;T&gt;.Contains need not be implemented by the
            derived class, but it should be strongly considered, because the CollectionBase implementation
            may not be very efficient.</para>
      </remarks>
      <typeparam name="T">The item type of the collection.</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.#ctor">
      <summary>
            Creates a new CollectionBase. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.ToString">
      <summary>
            Shows the string representation of the collection. The string representation contains
            a list of the items in the collection. Contained collections (except string) are expanded
            recursively.
            </summary>
      <returns>The string representation of the collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.Add(`0)">
      <summary>
            Must be overridden to allow adding items to this collection.
            </summary>
      <remarks>
        <p>This method is not abstract, although derived classes should always
            override it. It is not abstract because some derived classes may wish to reimplement
            Add with a different return type (typically bool). In C#, this can be accomplished
            with code like the following:</p>
        <code>
                public class MyCollection&lt;T&gt;: CollectionBase&lt;T&gt;, ICollection&lt;T&gt;
                {
                    public new bool Add(T item) {
                        /* Add the item */
                    }
             
                    void ICollection&lt;T&gt;.Add(T item) {
                        Add(item);
                    }
                }
            </code>
      </remarks>
      <param name="item">Item to be added to the collection.</param>
      <exception cref="T:System.NotImplementedException">Always throws this exception to indicated
            that the method must be overridden or re-implemented in the derived class.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.Clear">
      <summary>
            Must be overridden to allow clearing this collection.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.Remove(`0)">
      <summary>
            Must be overridden to allow removing items from this collection.
            </summary>
      <returns>True if <paramref name="item" /> existed in the collection and
            was removed. False if <paramref name="item" /> did not exist in the collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.Contains(`0)">
      <summary>
            Determines if the collection contains a particular item. This default implementation
            iterates all of the items in the collection via GetEnumerator, testing each item
            against <paramref name="item" /> using IComparable&lt;T&gt;.Equals or
            Object.Equals.
            </summary>
      <remarks>You should strongly consider overriding this method to provide
            a more efficient implementation, or if the default equality comparison
            is inappropriate.</remarks>
      <param name="item">The item to check for in the collection.</param>
      <returns>True if the collection contains <paramref name="item" />, false otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
      <param name="array">Array to copy to.</param>
      <param name="arrayIndex">Starting index in <paramref name="array" /> to copy to.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.ToArray">
      <summary>
            Creates an array of the correct size, and copies all the items in the 
            collection into the array, by calling CopyTo.
            </summary>
      <returns>An array containing all the elements in the collection, in order.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.AsReadOnly">
      <summary>
            Provides a read-only view of this collection. The returned ICollection&lt;T&gt; provides
            a view of the collection that prevents modifications to the collection. Use the method to provide
            access to the collection without allowing changes. Since the returned object is just a view,
            changes to the collection will be reflected in the view.
            </summary>
      <returns>An ICollection&lt;T&gt; that provides read-only access to the collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.Exists(System.Func{`0,System.Boolean})">
      <summary>
            Determines if the collection contains any item that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if the collection contains one or more items that satisfy the condition
            defined by <paramref name="predicate" />. False if the collection does not contain
            an item that satisfies <paramref name="predicate" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.TrueForAll(System.Func{`0,System.Boolean})">
      <summary>
            Determines if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />, or if the collection is empty. False if one or more items
            in the collection do not satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.CountWhere(System.Func{`0,System.Boolean})">
      <summary>
            Counts the number of items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>The number of items in the collection that satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
            Enumerates the items in the collection that satisfy the condition defined
            by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the items that satisfy the condition.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.RemoveAll(System.Func{`0,System.Boolean})">
      <summary>
            Removes all the items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>Returns a collection of the items that were removed, in sorted order.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.ForEach(System.Action{`0})">
      <summary>
            Performs the specified action on each item in this collection.
            </summary>
      <param name="action">An Action delegate which is invoked for each item in this collection.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.ConvertAll``1(System.Func{`0,``0})">
      <summary>
            Convert this collection of items by applying a delegate to each item in the collection. The resulting enumeration
            contains the result of applying <paramref name="converter" /> to each item in this collection, in
            order.
            </summary>
      <typeparam name="TOutput">The type each item is being converted to.</typeparam>
      <param name="converter">A delegate to the method to call, passing each item in this collection.</param>
      <returns>An IEnumerable&lt;TOutput^gt; that enumerates the resulting collection from applying <paramref name="converter" /> to each item in this collection in
            order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="converter" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.GetEnumerator">
      <summary>
            Must be overridden to enumerate all the members of the collection.
            </summary>
      <returns>A generic IEnumerator&lt;T&gt; that can be used
            to enumerate all the items in the collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.DebuggerDisplayString">
      <summary>
            Display the contents of the collection in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.CollectionBase`1.Count">
      <summary>
            Must be overridden to provide the number of items in the collection.
            </summary>
      <value>The number of items in the collection.</value>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.#ctor">
      <summary>
            Creates a new ListBase.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.Clear">
      <summary>
            This method must be overridden by the derived class to empty the list
            of all items.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.Insert(System.Int32,`0)">
      <summary>
            This method must be overridden by the derived class to insert a new
            item at the given index. 
            </summary>
      <param name="index">The index in the list to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item in the list has index 0.</param>
      <param name="item">The item to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.RemoveAt(System.Int32)">
      <summary>
            This method must be overridden by the derived class to remove the
            item at the given index. 
            </summary>
      <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.GetEnumerator">
      <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on.
            </summary>
      <remarks>The enumerator does not check for changes made
            to the structure of the list. Thus, changes to the list during
            enumeration may cause incorrect enumeration or out of range
            exceptions. Consider overriding this method and adding checks
            for structural changes.</remarks>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.Contains(`0)">
      <summary>
            Determines if the list contains any item that compares equal to <paramref name="item" />.
            The implementation simply checks whether IndexOf(item) returns a non-negative value.
            </summary>
      <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the list contains an item that compares equal to <paramref name="item" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.Add(`0)">
      <summary>
            Adds an item to the end of the list. This method is equivalent to calling: 
            <code>Insert(Count, item)</code></summary>
      <param name="item">The item to add to the list.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.Remove(`0)">
      <summary>
            Searches the list for the first item that compares equal to <paramref name="item" />.
            If one is found, it is removed. Otherwise, the list is unchanged.
            </summary>
      <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
      <param name="item">The item to remove from the list.</param>
      <returns>True if an item was found and removed that compared equal to
            <paramref name="item" />. False if no such item was in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.CopyTo(`0[])">
      <summary>
            Copies all the items in the list, in order, to <paramref name="array" />,
            starting at index 0.
            </summary>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies all the items in the list, in order, to <paramref name="array" />,
            starting at <paramref name="arrayIndex" />.
            </summary>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
      <param name="arrayIndex">The starting index in <paramref name="array" />
            to copy to.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
      <summary>
            Copies a range of elements from the list to <paramref name="array" />,
            starting at <paramref name="arrayIndex" />.
            </summary>
      <param name="index">The starting index in the source list of the range to copy.</param>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
      <param name="arrayIndex">The starting index in <paramref name="array" />
            to copy to.</param>
      <param name="count">The number of items to copy.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.AsReadOnly">
      <summary>
            Provides a read-only view of this list. The returned IList&lt;T&gt; provides
            a view of the list that prevents modifications to the list. Use the method to provide
            access to the list without allowing changes. Since the returned object is just a view,
            changes to the list will be reflected in the view.
            </summary>
      <returns>An IList&lt;T&gt; that provides read-only access to the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.Find(System.Func{`0,System.Boolean})">
      <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
      <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate" />,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.TryFind(System.Func{`0,System.Boolean},`0@)" />.</remarks>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The first item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, the default value for T is returned.</returns>
      <seealso cref="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.TryFind(System.Func{`0,System.Boolean},`0@)" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.TryFind(System.Func{`0,System.Boolean},`0@)">
      <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. 
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <param name="foundItem">If true is returned, this parameter receives the first item in the list
            that satifies the condition defined by <paramref name="predicate" />.</param>
      <returns>True if an item that  satisfies the condition <paramref name="predicate" /> was found. False 
            if no item in the list satisfies that condition.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.FindLast(System.Func{`0,System.Boolean})">
      <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
      <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate" />,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.TryFindLast(System.Func{`0,System.Boolean},`0@)" />.</remarks>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The last item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, the default value for T is returned.</returns>
      <seealso cref="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.TryFindLast(System.Func{`0,System.Boolean},`0@)" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.TryFindLast(System.Func{`0,System.Boolean},`0@)">
      <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. 
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <param name="foundItem">If true is returned, this parameter receives the last item in the list
            that satifies the condition defined by <paramref name="predicate" />.</param>
      <returns>True if an item that  satisfies the condition <paramref name="predicate" /> was found. False 
            if no item in the list satisfies that condition.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.FindIndex(System.Func{`0,System.Boolean})">
      <summary>
            Finds the index of the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the first item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.FindIndex(System.Int32,System.Func{`0,System.Boolean})">
      <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index" /> to the end, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The starting index of the range to check.</param>
      <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.FindIndex(System.Int32,System.Int32,System.Func{`0,System.Boolean})">
      <summary>
            Finds the index of the first item, in the range of <paramref name="count" /> items starting from <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The starting index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.FindLastIndex(System.Func{`0,System.Boolean})">
      <summary>
            Finds the index of the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the last item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.FindLastIndex(System.Int32,System.Func{`0,System.Boolean})">
      <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The ending index of the range to check.</param>
      <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.FindLastIndex(System.Int32,System.Int32,System.Func{`0,System.Boolean})">
      <summary>
            Finds the index of the last item, in the range of <paramref name="count" /> items ending at <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The ending index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.IndexOf(`0)">
      <summary>
            Finds the index of the first item in the list that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <returns>The index of the first item in the list that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.IndexOf(`0,System.Int32)">
      <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index" /> to the end,  
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The starting index of the range to check.</param>
      <returns>The index of the first item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.IndexOf(`0,System.Int32,System.Int32)">
      <summary>
            Finds the index of the first item, in the range of <paramref name="count" /> items starting from <paramref name="index" />,  
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The starting index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the first item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.LastIndexOf(`0)">
      <summary>
            Finds the index of the last item in the list that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <returns>The index of the last item in the list that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.LastIndexOf(`0,System.Int32)">
      <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index" />, that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The ending index of the range to check.</param>
      <returns>The index of the last item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.LastIndexOf(`0,System.Int32,System.Int32)">
      <summary>
            Finds the index of the last item, in the range of <paramref name="count" /> items ending at <paramref name="index" />, 
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search for.</param>
      <param name="index">The ending index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the last item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ListBase`1.Range(System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
      <remarks>
        <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
        <code>Algorithms.ReverseInPlace(deque.Range(3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
      <param name="start">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-part of this list. </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> + <paramref name="count" /> is greater than the
            size of the list.</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.ListBase`1.Count">
      <summary>
            The property must be overridden by the derived class to return the number of 
            items in the list.
            </summary>
      <value>The number of items in the list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.ListBase`1.Item(System.Int32)">
      <summary>
            The indexer must be overridden by the derived class to get and set
            values of the list at a particular index.
            </summary>
      <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.Bag`1">
      <summary>
             Bag&lt;T&gt; is a collection that contains items of type T. 
             Unlike a Set, duplicate items (items that compare equal to each other) are allowed in an Bag. 
             </summary>
      <remarks>
        <p>The items are compared in one of two ways. If T implements IComparable&lt;T&gt; 
             then the Equals method of that interface will be used to compare items, otherwise the Equals
             method from Object will be used. Alternatively, an instance of IComparer&lt;T&gt; can be passed
             to the constructor to use to compare items.</p>
        <p>Bag is implemented as a hash table. Inserting, deleting, and looking up an
             an element all are done in approximately constant time, regardless of the number of items in the bag.</p>
        <p>When multiple equal items are stored in the bag, they are stored as a representative item and a count. 
             If equal items can be distinguished, this may be noticable. For example, if a case-insensitive
             comparer is used with a Bag&lt;string&gt;, and both "hello", and "HELLO" are added to the bag, then the
             bag will appear to contain two copies of "hello" (the representative item).</p>
        <p>
          <see cref="T:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1" /> is similar, but uses comparison instead of hashing, maintain
             the items in sorted order, and stores distinct copies of items that compare equal.</p>
      </remarks>
      <seealso cref="T:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.#ctor">
      <summary>
             Creates a new Bag. 
             </summary>
      <remarks>
             Items that are null are permitted.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new Bag. The Equals and GetHashCode methods of the passed comparison object
            will be used to compare items in this bag for equality.
            </summary>
      <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Creates a new Bag. The bag is
             initialized with all the items in the given collection.
             </summary>
      <remarks>
             Items that are null are permitted.
            </remarks>
      <param name="collection">A collection with items to be placed into the Bag.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new Bag. The Equals and GetHashCode methods of the passed comparison object
            will be used to compare items in this bag. The bag is
            initialized with all the items in the given collection.
            </summary>
      <param name="collection">A collection with items to be placed into the Bag.</param>
      <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.Clone">
      <summary>
            Makes a shallow clone of this bag; i.e., if items of the
            bag are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the bag takes time O(N), where N is the number of unquie items in the bag.</remarks>
      <returns>The cloned bag.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.CloneContents">
      <summary>
            Makes a deep clone of this bag. A new bag is created with a clone of
            each element of this bag, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the bag takes time O(N log N), where N is the number of items in the bag.</para>
      </remarks>
      <returns>The cloned bag.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.NumberOfCopies(`0)">
      <summary>
            Returns the number of copies of <paramref name="item" /> in the bag. 
            </summary>
      <remarks>NumberOfCopies() takes approximately constant time, no matter how many items
            are stored in the bag.</remarks>
      <param name="item">The item to search for in the bag.</param>
      <returns>The number of items in the bag that compare equal to <paramref name="item" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.GetRepresentativeItem(`0,`0@)">
      <summary>
            Returns the representative item stored in the bag that is equal to
            the provided item. Also returns the number of copies of the item in the bag.
            </summary>
      <param name="item">Item to find in the bag.</param>
      <param name="representative">If one or more items equal to <paramref name="item" /> are present in the
            bag, returns the representative item. If no items equal to <paramref name="item" /> are stored in the bag, 
            returns <paramref name="item" />.</param>
      <returns>The number of items equal to <paramref name="item" /> stored in the bag.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the items in the bag. 
            If an item is present multiple times in the bag, the representative item is yielded by the
            enumerator multiple times. The order of enumeration is haphazard and may change.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
        <p>If an item is added to or deleted from the bag while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumeration all the items in the bag takes time O(N), where N is the number
            of items in the bag.</p>
      </remarks>
      <returns>An enumerator for enumerating all the items in the Bag.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.Contains(`0)">
      <summary>
            Determines if this bag contains an item equal to <paramref name="item" />. The bag
            is not changed.
            </summary>
      <remarks>Searching the bag for an item takes time O(log N), where N is the number of items in the bag.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the bag contains <paramref name="item" />. False if the bag does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.DistinctItems">
      <summary>
            Enumerates all the items in the bag, but enumerates equal items
            just once, even if they occur multiple times in the bag.
            </summary>
      <remarks>If the bag is changed while items are being enumerated, the
            enumeration will terminate with an InvalidOperationException.</remarks>
      <returns>An IEnumerable&lt;T&gt; that enumerates the unique items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.Add(`0)">
      <summary>
            Adds a new item to the bag. Since bags can contain duplicate items, the item 
            is added even if the bag already contains an item equal to <paramref name="item" />. In
            this case, the count of items for the representative item is increased by one, but the existing
            represetative item is unchanged.
            </summary>
      <remarks>
        <para>Adding an item takes approximately constant time, regardless of the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to add to the bag.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.AddRepresentative(`0)">
      <summary>
            Adds a new item to the bag. Since bags can contain duplicate items, the item 
            is added even if the bag already contains an item equal to <paramref name="item" />. In
            this case (unlike Add), the new item becomes the representative item.
            </summary>
      <remarks>
        <para>Adding an item takes approximately constant time, regardless of the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to add to the bag.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.ChangeNumberOfCopies(`0,System.Int32)">
      <summary>
            Changes the number of copies of an existing item in the bag, or adds the indicated number
            of copies of the item to the bag. 
            </summary>
      <remarks>
        <para>Changing the number of copies takes approximately constant time, regardless of the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to change the number of copies of. This may or may not already be present in the bag.</param>
      <param name="numCopies">The new number of copies of the item.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds all the items in <paramref name="collection" /> to the bag. 
            </summary>
      <remarks>
        <para>Adding the collection takes time O(M log N), where N is the number of items in the bag, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to add to the bag.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.Remove(`0)">
      <summary>
            Searches the bag for one item equal to <paramref name="item" />, and if found,
            removes it from the bag. If not found, the bag is unchanged. 
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>Removing an item from the bag takes approximated constant time,
            regardless of the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the bag.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.RemoveAllCopies(`0)">
      <summary>
            Searches the bag for all items equal to <paramref name="item" />, and 
            removes all of them from the bag. If not found, the bag is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparer instance used
            to create the bag.</para>
        <para>RemoveAllCopies() takes time O(M log N), where N is the total number of items in the bag, and M is
            the number of items equal to <paramref name="item" />.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>The number of copies of <paramref name="item" /> that were found and removed. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the items in <paramref name="collection" /> from the bag. Items that
            are not present in the bag are ignored.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparer instance used
            to create the bag.</para>
        <para>Removing the collection takes time O(M), where M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to remove from the bag.</param>
      <returns>The number of items removed from the bag.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.Clear">
      <summary>
            Removes all items from the bag.
            </summary>
      <remarks>Clearing the bag takes a constant amount of time, regardless of the number of items in it.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.IsEqualTo(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Determines if this bag is equal to another bag. This bag is equal to
            <paramref name="otherBag" /> if they contain the same number of 
            of copies of equal elements.
            </summary>
      <remarks>IsSupersetOf is computed in time O(N), where N is the number of unique items in 
            this bag.</remarks>
      <param name="otherBag">Bag to compare to</param>
      <returns>True if this bag is equal to <paramref name="otherBag" />, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.IsSupersetOf(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Determines if this bag is a superset of another bag. Neither bag is modified.
            This bag is a superset of <paramref name="otherBag" /> if every element in
            <paramref name="otherBag" /> is also in this bag, at least the same number of
            times.
            </summary>
      <remarks>IsSupersetOf is computed in time O(M), where M is the number of unique items in 
            <paramref name="otherBag" />.</remarks>
      <param name="otherBag">Bag to compare to.</param>
      <returns>True if this is a superset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.IsProperSupersetOf(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Determines if this bag is a proper superset of another bag. Neither bag is modified.
            This bag is a proper superset of <paramref name="otherBag" /> if every element in
            <paramref name="otherBag" /> is also in this bag, at least the same number of
            times. Additional, this bag must have strictly more items than <paramref name="otherBag" />.
            </summary>
      <remarks>IsProperSupersetOf is computed in time O(M), where M is the number of unique items in 
            <paramref name="otherBag" />.</remarks>
      <param name="otherBag">Set to compare to.</param>
      <returns>True if this is a proper superset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.IsSubsetOf(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Determines if this bag is a subset of another ba11 items in this bag.
            </summary>
      <param name="otherBag">Bag to compare to.</param>
      <returns>True if this is a subset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.IsProperSubsetOf(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Determines if this bag is a proper subset of another bag. Neither bag is modified.
            This bag is a subset of <paramref name="otherBag" /> if every element in this bag
            is also in <paramref name="otherBag" />, at least the same number of
            times. Additional, this bag must have strictly fewer items than <paramref name="otherBag" />.
            </summary>
      <remarks>IsProperSubsetOf is computed in time O(N), where N is the number of unique items in this bag.</remarks>
      <param name="otherBag">Bag to compare to.</param>
      <returns>True if this is a proper subset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.IsDisjointFrom(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Determines if this bag is disjoint from another bag. Two bags are disjoint
            if no item from one set is equal to any item in the other bag.
            </summary>
      <remarks>
        <para>The answer is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherBag">Bag to check disjointness with.</param>
      <returns>True if the two bags are disjoint, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.UnionWith(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. This bag receives
            the union of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>The union of two bags is computed in time O(M+N), where M and N are the size of the 
            two bags.</para>
      </remarks>
      <param name="otherBag">Bag to union with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.Union(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. A new bag is 
            created with the union of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The union of two bags is computed in time O(M+N), where M and N are the size of the two bags.</para>
      </remarks>
      <param name="otherBag">Bag to union with.</param>
      <returns>The union of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.SumWith(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Computes the sum of this bag with another bag. The sum of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. This bag receives
            the sum of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>The sum of two bags is computed in time O(M), where M is the size of the 
            other bag..</para>
      </remarks>
      <param name="otherBag">Bag to sum with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.Sum(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Computes the sum of this bag with another bag. he sum of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. A new bag is 
            created with the sum of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The sum of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to sum with.</param>
      <returns>The sum of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.IntersectionWith(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item Minimum(X,Y) times. This bag receives
            the intersection of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two bags is computed in time O(N), where N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to intersection with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.Intersection(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the intersection contains the item Minimum(X,Y) times. A new bag is 
            created with the intersection of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two bags is computed in time O(N), where N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to intersection with.</param>
      <returns>The intersection of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.DifferenceWith(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag" />. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X). This bag receives
            the difference of the two bags; the other bag is unchanged.
            </summary>
      <remarks>
        <para>The difference of two bags is computed in time O(M), where M is the size of the 
            other bag.</para>
      </remarks>
      <param name="otherBag">Bag to difference with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.Difference(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag" />. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X).  A new bag is 
            created with the difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The difference of two bags is computed in time O(M + N), where M and N are the size
            of the two bags.</para>
      </remarks>
      <param name="otherBag">Bag to difference with.</param>
      <returns>The difference of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.SymmetricDifferenceWith(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y) times. This bag receives
            the symmetric difference of the two bags; the other bag is unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to symmetric difference with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Bag`1.SymmetricDifference(NSoft.NFramework.Collections.PowerCollections.Bag{`0})">
      <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y) times. A new bag is 
            created with the symmetric difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to symmetric difference with.</param>
      <returns>The symmetric difference of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.Bag`1.Comparer">
      <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare items in this bag. 
            </summary>
      <value>If the bag was created using a comparer, that comparer is returned. Otherwise
            the default comparer for T (EqualityComparer&lt;T&gt;.Default) is returned.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.Bag`1.Count">
      <summary>
            Returns the number of items in the bag.
            </summary>
      <remarks>The size of the bag is returned in constant time.</remarks>
      <value>The number of items in the bag.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.BigList`1">
      <summary>
            BigList{T} provides a list of items, in order, with indices of the items ranging from 0 to one less
            than the count of items in the collection. BigList{T} is optimized for efficient operations on large ( &gt; 100 items)
            lists, especially for insertions, deletions, copies, and concatinations.
            </summary>
      <remarks>
        <para>BigList&lt;T&gt; class is similar in functionality to the standard List&lt;T&gt; class. Both classes
            provide a collection that stores an set of items in order, with indices of the items ranging from 0 to one less
            than the count of items in the collection. Both classes provide the ability to add and remove items from any index,
            and the get or set the item at any index.</para>
        <para>BigList&lt;T&gt; differs significantly from List&lt;T&gt; in the performance of various operations, 
            especially when the lists become large (several hundred items or more). With List&lt;T&gt;, inserting or removing
            elements from anywhere in a large list except the end is very inefficient -- every item after the point of inserting
            or deletion has to be moved in the list. The BigList&lt;T&gt; class, however, allows for fast insertions
            and deletions anywhere in the list. Furthermore, BigList&lt;T&gt; allows copies of a list, sub-parts
            of a list, and concatinations of two lists to be very fast. When a copy is made of part or all of a BigList,
            two lists shared storage for the parts of the lists that are the same. Only when one of the lists is changed is additional
            memory allocated to store the distinct parts of the lists.</para>
        <para>Of course, there is a small price to pay for this extra flexibility. Although still quite efficient, using an 
            index to get or change one element of a BigList, while still reasonably efficient, is significantly slower than using
            a plain List. Because of this, if you want to process every element of a BigList, using a foreach loop is a lot
            more efficient than using a for loop and indexing the list.</para>
        <para>In general, use a List when the only operations you are using are Add (to the end), foreach,
            or indexing, or you are very sure the list will always remain small (less than 100 items). For large (&gt;100 items) lists
            that do insertions, removals, copies, concatinations, or sub-ranges, BigList will be more efficient than List. 
            In almost all cases, BigList is more efficient and easier to use than LinkedList.</para>
      </remarks>
      <typeparam name="T">The type of items to store in the BigList.</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.#ctor">
      <summary>
            Creates a new BigList. The BigList is initially empty.
            </summary>
      <remarks>Creating a empty BigList takes constant time and consumes a very small amount of memory.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Creates a new BigList initialized with the items from <paramref name="collection" />, in order.
            </summary>
      <remarks>Initializing the tree list with the elements of collection takes time O(N), where N is the number of
            items in <paramref name="collection" />.</remarks>
      <param name="collection">The collection used to initialize the BigList. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
      <summary>
            Creates a new BigList initialized with a given number of copies of the items from <paramref name="collection" />, in order. 
            </summary>
      <remarks>Initializing the tree list with the elements of collection takes time O(N + log K), where N is the number of
            items in <paramref name="collection" />, and K is the number of copies.</remarks>
      <param name="copies">Number of copies of the collection to use.</param>
      <param name="collection">The collection used to initialize the BigList. </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="copies" /> is negative.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.#ctor(NSoft.NFramework.Collections.PowerCollections.BigList{`0})">
      <summary>
            Creates a new BigList that is a copy of <paramref name="list" />.
            </summary>
      <remarks>Copying a BigList takes constant time, and little 
            additional memory, since the storage for the items of the two lists is shared. However, changing
            either list will take additional time and memory. Portions of the list are copied when they are changed.</remarks>
      <param name="list">The BigList to copy. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.#ctor(NSoft.NFramework.Collections.PowerCollections.BigList{`0},System.Int32)">
      <summary>
            Creates a new BigList that is several copies of <paramref name="list" />.
            </summary>
      <remarks>Creating K copies of a BigList takes time O(log K), and O(log K) 
            additional memory, since the storage for the items of the two lists is shared. However, changing
            either list will take additional time and memory. Portions of the list are copied when they are changed.</remarks>
      <param name="copies">Number of copies of the collection to use.</param>
      <param name="list">The BigList to copy. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.Clear">
      <summary>
            Removes all of the items from the BigList.
            </summary>
      <remarks>Clearing a BigList takes constant time.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.Insert(System.Int32,`0)">
      <summary>
            Inserts a new item at the given index in the BigList. All items at indexes 
            equal to or greater than <paramref name="index" /> move up one index.
            </summary>
      <remarks>The amount of time to insert an item is O(log N), no matter where
            in the list the insertion occurs. Inserting an item at the beginning or end of the 
            list is O(N). 
            </remarks>
      <param name="index">The index to insert the item at. After the
            insertion, the inserted item is located at this index. The
            first item has index 0.</param>
      <param name="item">The item to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Inserts a collection of items at the given index in the BigList. All items at indexes 
            equal to or greater than <paramref name="index" /> increase their indices 
            by the number of items inserted.
            </summary>
      <remarks>The amount of time to insert an arbitrary collection in the BigList is O(M + log N), 
            where M is the number of items inserted, and N is the number of items in the list.
            </remarks>
      <param name="index">The index to insert the collection at. After the
            insertion, the first item of the inserted collection is located at this index. The
            first item has index 0.</param>
      <param name="collection">The collection of items to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.InsertRange(System.Int32,NSoft.NFramework.Collections.PowerCollections.BigList{`0})">
      <summary>
            Inserts a BigList of items at the given index in the BigList. All items at indexes 
            equal to or greater than <paramref name="index" /> increase their indices 
            by the number of items inserted.
            </summary>
      <remarks>The amount of time to insert another BigList is O(log N), 
            where N is the number of items in the list, regardless of the number of items in the 
            inserted list. Storage is shared between the two lists until one of them is changed.
            </remarks>
      <param name="index">The index to insert the collection at. After the
            insertion, the first item of the inserted collection is located at this index. The
            first item has index 0.</param>
      <param name="list">The BigList of items to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.RemoveAt(System.Int32)">
      <summary>
            Removes the item at the given index in the BigList. All items at indexes 
            greater than <paramref name="index" /> move down one index.
            </summary>
      <remarks>The amount of time to delete an item in the BigList is O(log N),
            where N is the number of items in the list. 
            </remarks>
      <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.RemoveRange(System.Int32,System.Int32)">
      <summary>
            Removes a range of items at the given index in the Deque. All items at indexes 
            greater than <paramref name="index" /> move down <paramref name="count" /> indices
            in the Deque.
            </summary>
      <remarks>The amount of time to delete <paramref name="count" /> items in the Deque is proportional
            to the distance of index from the closest end of the Deque, plus <paramref name="count" />: 
            O(count + Min(<paramref name="index" />, Count - 1 - <paramref name="index" />)).
            </remarks>
      <param name="index">The index in the list to remove the range at. The
            first item in the list has index 0.</param>
      <param name="count">The number of items to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count, or <paramref name="count" /> is less than zero
            or too large.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.Add(`0)">
      <summary>
            Adds an item to the end of the BigList. The indices of all existing items
            in the Deque are unchanged. 
            </summary>
      <remarks>Adding an item takes, on average, constant time.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.AddToFront(`0)">
      <summary>
            Adds an item to the beginning of the BigList. The indices of all existing items
            in the Deque are increased by one, and the new item has index zero. 
            </summary>
      <remarks>Adding an item takes, on average, constant time.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a collection of items to the end of BigList. The indices of all existing items
            are unchanged. The last item in the added collection becomes the
            last item in the BigList.
            </summary>
      <remarks>This method takes time O(M + log N), where M is the number of items in the 
            <paramref name="collection" />, and N is the size of the BigList.</remarks>
      <param name="collection">The collection of items to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.AddRangeToFront(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a collection of items to the front of BigList. The indices of all existing items
            in the are increased by the number of items in <paramref name="collection" />. 
            The first item in the added collection becomes the first item in the BigList.
            </summary>
      <remarks>This method takes time O(M + log N), where M is the number of items in the 
            <paramref name="collection" />, and N is the size of the BigList.</remarks>
      <param name="collection">The collection of items to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.Clone">
      <summary>
            Creates a new BigList that is a copy of this list.
            </summary>
      <remarks>Copying a BigList takes constant time, and little 
            additional memory, since the storage for the items of the two lists is shared. However, changing
            either list will take additional time and memory. Portions of the list are copied when they are changed.</remarks>
      <returns>A copy of the current list</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.CloneContents">
      <summary>
            Makes a deep clone of this BigList. A new BigList is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then this method is the same as Clone.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>If T is a reference type, cloning the list takes time approximate O(N), where N is the number of items in the list.</para>
      </remarks>
      <returns>The cloned set.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.AddRange(NSoft.NFramework.Collections.PowerCollections.BigList{`0})">
      <summary>
            Adds a BigList of items to the end of BigList. The indices of all existing items
            are unchanged. The last item in <paramref name="list" /> becomes the
            last item in this list. The added list <paramref name="list" /> is unchanged.
            </summary>
      <remarks>This method takes, on average, constant time, regardless of the size
            of either list. Although conceptually all of the items in <paramref name="list" /> are
            copied, storage is shared between the two lists until changes are made to the 
            shared sections.</remarks>
      <param name="list">The list of items to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.AddRangeToFront(NSoft.NFramework.Collections.PowerCollections.BigList{`0})">
      <summary>
            Adds a BigList of items to the front of BigList. The indices of all existing items
            are increased by the number of items in <paramref name="list" />. The first item in <paramref name="list" /> 
            becomes the first item in this list. The added list <paramref name="list" /> is unchanged.
            </summary>
      <remarks>This method takes, on average, constant time, regardless of the size
            of either list. Although conceptually all of the items in <paramref name="list" /> are
            copied, storage is shared between the two lists until changes are made to the 
            shared sections.</remarks>
      <param name="list">The list of items to add.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="list" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.op_Addition(NSoft.NFramework.Collections.PowerCollections.BigList{`0},NSoft.NFramework.Collections.PowerCollections.BigList{`0})">
      <summary>
            Concatenates two lists together to create a new list. Both lists being concatenated
            are unchanged. The resulting list contains all the items in <paramref name="first" />, followed
            by all the items in <paramref name="second" />.
            </summary>
      <remarks>This method takes, on average, constant time, regardless of the size
            of either list. Although conceptually all of the items in both lists are
            copied, storage is shared until changes are made to the 
            shared sections.</remarks>
      <param name="first">The first list to concatenate.</param>
      <param name="second">The second list to concatenate.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="first" /> or <paramref name="second" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.GetRange(System.Int32,System.Int32)">
      <summary>
            Creates a new list that contains a subrange of elements from this list. The
            current list is unchanged.
            </summary>
      <remarks>This method takes take O(log N), where N is the size of the current list. Although
            the sub-range is conceptually copied, storage is shared between the two lists until a change
            is made to the shared items.</remarks>
      <remarks>If a view of a sub-range is desired, instead of a copy, use the
            more efficient <see cref="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.Range(System.Int32,System.Int32)" /> method, which provides a view onto a sub-range of items.</remarks>
      <param name="index">The starting index of the sub-range.</param>
      <param name="count">The number of items in the sub-range. If this is zero,
            the returned list is empty.</param>
      <returns>A new list with the <paramref name="count" /> items that start at <paramref name="index" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.Range(System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list
            are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the 
            view, but insertions and deletions in the underlying list do not.
            </summary>
      <remarks>
        <para>If a copy of the sub-range is desired, use the <see cref="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.GetRange(System.Int32,System.Int32)" /> method instead.</para>
        <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
        <code>Algorithms.ReverseInPlace(list.Range(3, 6))</code>
            will reverse the 6 items beginning at index 3.</remarks>
      <param name="index">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-list. </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> + <paramref name="count" /> is greater than the
            size of this list.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.GetEnumerator">
      <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on. Usually, the
            foreach statement is used to call this method implicitly.
            </summary>
      <remarks>Enumerating all of the items in the list take time O(N), where
            N is the number of items in the list. Using GetEnumerator() or foreach
            is much more efficient than accessing all items by index.</remarks>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.ConvertAll``1(System.Func{`0,``0})">
      <summary>
            Convert the list to a new list by applying a delegate to each item in the collection. The resulting list
            contains the result of applying <paramref name="converter" /> to each item in the list, in
            order. The current list is unchanged.
            </summary>
      <typeparam name="TDest">The type each item is being converted to.</typeparam>
      <param name="converter">A delegate to the method to call, passing each item in this list.</param>
      <returns>The resulting BigList from applying <paramref name="converter" /> to each item in this list.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="converter" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.Reverse">
      <summary>
            Reverses the current list in place.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.Reverse(System.Int32,System.Int32)">
      <summary>
            Reverses the items in the range of <paramref name="count" /> items starting from <paramref name="start" />, in place.
            </summary>
      <param name="start">The starting index of the range to reverse.</param>
      <param name="count">The number of items in range to reverse.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.Sort">
      <summary>
            Sorts the list in place.
            </summary>
      <remarks>
        <para>The Quicksort algorithm is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</para>
        <para>Values are compared by using the IComparable or IComparable&lt;T&gt;
            interface implementation on the type T.</para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">The type T does not implement either the IComparable or
            IComparable&lt;T&gt; interfaces.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.Sort(System.Collections.Generic.IComparer{`0})">
      <summary>
            Sorts the list in place. A supplied IComparer&lt;T&gt; is used
            to compare the items in the list. 
            </summary>
      <remarks>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</remarks>
      <param name="comparer">The comparer instance used to compare items in the collection. Only
            the Compare method is used.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.Sort(System.Comparison{`0})">
      <summary>
            Sorts the list in place. A supplied Comparison&lt;T&gt; delegate is used
            to compare the items in the list.
            </summary>
      <remarks>The Quicksort algorithms is used to sort the items. In virtually all cases,
            this takes time O(N log N), where N is the number of items in the list.</remarks>
      <param name="comparison">The comparison delegate used to compare items in the collection.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.BinarySearch(`0)">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            in the order defined by the default ordering of the item type; otherwise, 
            incorrect results will be returned.
            </summary>
      <param name="item">The item to search for.</param>
      <returns>Returns the index of the first occurence of <paramref name="item" /> in the list. If the item does not occur
            in the list, the bitwise complement of the first item larger than <paramref name="item" /> in the list is returned. If no item is 
            larger than <paramref name="item" />, the bitwise complement of Count is returned.</returns>
      <exception cref="T:System.InvalidOperationException">The type T does not implement either the IComparable or
            IComparable&lt;T&gt; interfaces.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering defined by the passed IComparer&lt;T&gt; interface; otherwise, 
            incorrect results will be returned.
            </summary>
      <param name="item">The item to search for.</param>
      <param name="comparer">The IComparer&lt;T&gt; interface used to sort the list.</param>
      <returns>Returns the index of the first occurence of <paramref name="item" /> in the list. If the item does not occur
            in the list, the bitwise complement of the first item larger than <paramref name="item" /> in the list is returned. If no item is 
            larger than <paramref name="item" />, the bitwise complement of Count is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.BinarySearch(`0,System.Comparison{`0})">
      <summary>
            Searches a sorted list for an item via binary search. The list must be sorted
            by the ordering defined by the passed Comparison&lt;T&gt; delegate; otherwise, 
            incorrect results will be returned.
            </summary>
      <param name="item">The item to search for.</param>
      <param name="comparison">The comparison delegate used to sort the list.</param>
      <returns>Returns the index of the first occurence of <paramref name="item" /> in the list. If the item does not occur
            in the list, the bitwise complement of the first item larger than <paramref name="item" /> in the list is returned. If no item is 
            larger than <paramref name="item" />, the bitwise complement of Count is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.Validate">
      <summary>
            Attempts to validate the internal consistency of the tree.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.BigList`1.Print">
      <summary>
            Prints out the internal structure of the tree, for debugging purposes.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.BigList`1.Count">
      <summary>
            Gets the number of items stored in the BigList. The indices of the items
            range from 0 to Count-1.
            </summary>
      <remarks>Getting the number of items in the BigList takes constant time.</remarks>
      <value>The number of items in the BigList.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.BigList`1.Item(System.Int32)">
      <summary>
            Gets or sets an item in the list, by index.
            </summary>
      <remarks>
        <para> Gettingor setting an item takes time O(log N), where N is the number of items
            in the list.</para>
        <para>To process each of the items in the list, using GetEnumerator() or a foreach loop is more efficient
            that accessing each of the elements by index.</para>
      </remarks>
      <param name="index">The index of the item to get or set. The first item in the list
            has index 0, the last item has index Count-1.</param>
      <returns>The value of the item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is less than zero or 
            greater than or equal to Count.</exception>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.Comparers">
      <summary>
            A collection of methods to create IComparer and IEqualityComparer instances in various ways.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Comparers.ComparerFromComparison``1(System.Comparison{``0})">
      <summary>
            Given an Comparison on a type, returns an IComparer on that type. 
            </summary>
      <typeparam name="T">T to compare.</typeparam>
      <param name="comparison">Comparison delegate on T</param>
      <returns>IComparer that uses the comparison.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Comparers.ComparerKeyValueFromComparerKey``2(System.Collections.Generic.IComparer{``0})">
      <summary>
            Given an IComparer on TKey, returns an IComparer on
            key-value Pairs. 
            </summary>
      <typeparam name="TKey">TKey of the pairs</typeparam>
      <typeparam name="TValue">TValue of the apris</typeparam>
      <param name="keyComparer">IComparer on TKey</param>
      <returns>IComparer for comparing key-value pairs.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Comparers.EqualityComparerKeyValueFromComparerKey``2(System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Given an IEqualityComparer on TKey, returns an IEqualityComparer on
            key-value Pairs. 
            </summary>
      <typeparam name="TKey">TKey of the pairs</typeparam>
      <typeparam name="TValue">TValue of the apris</typeparam>
      <param name="keyEqualityComparer">IComparer on TKey</param>
      <returns>IEqualityComparer for comparing key-value pairs.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Comparers.ComparerPairFromKeyValueComparers``2(System.Collections.Generic.IComparer{``0},System.Collections.Generic.IComparer{``1})">
      <summary>
            Given an IComparer on TKey and TValue, returns an IComparer on
            key-value Pairs of TKey and TValue, comparing first keys, then values. 
            </summary>
      <typeparam name="TKey">TKey of the pairs</typeparam>
      <typeparam name="TValue">TValue of the apris</typeparam>
      <param name="keyComparer">IComparer on TKey</param>
      <param name="valueComparer">IComparer on TValue</param>
      <returns>IComparer for comparing key-value pairs.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Comparers.ComparerKeyValueFromComparisonKey``2(System.Comparison{``0})">
      <summary>
            Given an Comparison on TKey, returns an IComparer on
            key-value Pairs. 
            </summary>
      <typeparam name="TKey">TKey of the pairs</typeparam>
      <typeparam name="TValue">TValue of the apris</typeparam>
      <param name="keyComparison">Comparison delegate on TKey</param>
      <returns>IComparer for comparing key-value pairs.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Comparers.DefaultComparer``1">
      <summary>
            Given an element type, check that it implements IComparable&lt;T&gt; or IComparable, then returns
            a IComparer that can be used to compare elements of that type.
            </summary>
      <returns>The IComparer&lt;T&gt; instance.</returns>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;T&gt;.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Comparers.DefaultKeyValueComparer``2">
      <summary>
            Given an key and value type, check that TKey implements IComparable&lt;T&gt; or IComparable, then returns
            a IComparer that can be used to compare KeyValuePairs of those types.
            </summary>
      <returns>The IComparer&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; instance.</returns>
      <exception cref="T:System.InvalidOperationException">TKey does not implement IComparable&lt;T&gt;.</exception>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.Deque`1">
      <summary>
        <para>The Deque class implements a type of list known as a Double Ended Queue. A Deque
            is quite similar to a List, in that items have indices (starting at 0), and the item at any
            index can be efficiently retrieved. The difference between a List and a Deque lies in the
            efficiency of inserting elements at the beginning. In a List, items can be efficiently added
            to the end, but inserting an item at the beginning of the List is slow, taking time 
            proportional to the size of the List. In a Deque, items can be added to the beginning 
            or end equally efficiently, regardless of the number of items in the Deque. As a trade-off
            for this increased flexibility, Deque is somewhat slower than List (but still constant time) when
            being indexed to get or retrieve elements. </para>
      </summary>
      <remarks>
        <para>The Deque class can also be used as a more flexible alternative to the Queue 
            and Stack classes. Deque is as efficient as Queue and Stack for adding or removing items, 
            but is more flexible: it allows access
            to all items in the queue, and allows adding or removing from either end.</para>
        <para>Deque is implemented as a ring buffer, which is grown as necessary. The size
            of the buffer is doubled whenever the existing capacity is too small to hold all the
            elements.</para>
      </remarks>
      <typeparam name="T">The type of items stored in the Deque.</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.#ctor">
      <summary>
            Create a new Deque that is initially empty.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Create a new Deque initialized with the items from the passed collection,
            in order.
            </summary>
      <param name="collection">A collection of items to initialize the Deque with.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies all the items in the Deque into an array.
            </summary>
      <param name="array">Array to copy to.</param>
      <param name="arrayIndex">Starting index in <paramref name="array" /> to copy to.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.TrimToSize">
      <summary>
            Trims the amount of memory used by the Deque by changing
            the Capacity to be equal to Count. If no more items will be added
            to the Deque, calling TrimToSize will reduce the amount of memory
            used by the Deque.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.Clear">
      <summary>
            Removes all items from the Deque.
            </summary>
      <remarks>Clearing the Deque takes a small constant amount of time, regardless of
            how many items are currently in the Deque.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.GetEnumerator">
      <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on. If the items
            are added to or removed from the Deque during enumeration, the 
            enumeration ends with an InvalidOperationException.
            </summary>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
      <exception cref="T:System.InvalidOperationException">The Deque has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.Insert(System.Int32,`0)">
      <summary>
            Inserts a new item at the given index in the Deque. All items at indexes 
            equal to or greater than <paramref name="index" /> move up one index
            in the Deque.
            </summary>
      <remarks>The amount of time to insert an item in the Deque is proportional
            to the distance of index from the closest end of the Deque: 
            O(Min(<paramref name="index" />, Count - <paramref name="index" />)).
            Thus, inserting an item at the front or end of the Deque is always fast; the middle of
            of the Deque is the slowest place to insert.
            </remarks>
      <param name="index">The index in the Deque to insert the item at. After the
            insertion, the inserted item is located at this index. The
            front item in the Deque has index 0.</param>
      <param name="item">The item to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Inserts a collection of items at the given index in the Deque. All items at indexes 
            equal to or greater than <paramref name="index" /> increase their indices in the Deque
            by the number of items inserted.
            </summary>
      <remarks>The amount of time to insert a collection in the Deque is proportional
            to the distance of index from the closest end of the Deque, plus the number of items
            inserted (M): 
            O(M + Min(<paramref name="index" />, Count - <paramref name="index" />)).
            </remarks>
      <param name="index">The index in the Deque to insert the collection at. After the
            insertion, the first item of the inserted collection is located at this index. The
            front item in the Deque has index 0.</param>
      <param name="collection">The collection of items to insert at the given index.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than Count.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.RemoveAt(System.Int32)">
      <summary>
            Removes the item at the given index in the Deque. All items at indexes 
            greater than <paramref name="index" /> move down one index
            in the Deque.
            </summary>
      <remarks>The amount of time to delete an item in the Deque is proportional
            to the distance of index from the closest end of the Deque: 
            O(Min(<paramref name="index" />, Count - 1 - <paramref name="index" />)).
            Thus, deleting an item at the front or end of the Deque is always fast; the middle of
            of the Deque is the slowest place to delete.
            </remarks>
      <param name="index">The index in the list to remove the item at. The
            first item in the list has index 0.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.RemoveRange(System.Int32,System.Int32)">
      <summary>
            Removes a range of items at the given index in the Deque. All items at indexes 
            greater than <paramref name="index" /> move down <paramref name="count" /> indices
            in the Deque.
            </summary>
      <remarks>The amount of time to delete <paramref name="count" /> items in the Deque is proportional
            to the distance to the closest end of the Deque: 
            O(Min(<paramref name="index" />, Count - <paramref name="index" /> - <paramref name="count" />)).
            </remarks>
      <param name="index">The index in the list to remove the range at. The
            first item in the list has index 0.</param>
      <param name="count">The number of items to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count, or <paramref name="count" /> is less than zero
            or too large.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.AddToFront(`0)">
      <summary>
            Adds an item to the front of the Deque. The indices of all existing items
            in the Deque are increased by 1. This method is 
            equivalent to <c>Insert(0, item)</c> but is a little more
            efficient.
            </summary>
      <remarks>Adding an item to the front of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.AddManyToFront(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a collection of items to the front of the Deque. The indices of all existing items
            in the Deque are increased by the number of items inserted. The first item in the added collection becomes the
            first item in the Deque. 
            </summary>
      <remarks>This method takes time O(M), where M is the number of items in the 
            <paramref name="collection" />.</remarks>
      <param name="collection">The collection of items to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.AddToBack(`0)">
      <summary>
            Adds an item to the back of the Deque. The indices of all existing items
            in the Deque are unchanged. This method is 
            equivalent to <c>Insert(Count, item)</c> but is a little more
            efficient.
            </summary>
      <remarks>Adding an item to the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.Add(`0)">
      <summary>
            Adds an item to the back of the Deque. The indices of all existing items
            in the Deque are unchanged. This method is 
            equivalent to <c>AddToBack(item)</c>.
            </summary>
      <remarks>Adding an item to the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <param name="item">The item to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.AddManyToBack(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds a collection of items to the back of the Deque. The indices of all existing items
            in the Deque are unchanged. The last item in the added collection becomes the
            last item in the Deque.
            </summary>
      <remarks>This method takes time O(M), where M is the number of items in the 
            <paramref name="collection" />.</remarks>
      <param name="collection">The collection of item to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.RemoveFromFront">
      <summary>
            Removes an item from the front of the Deque. The indices of all existing items
            in the Deque are decreased by 1. This method is 
            equivalent to <c>RemoveAt(0)</c> but is a little more
            efficient.
            </summary>
      <remarks>Removing an item from the front of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <returns>The item that was removed.</returns>
      <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.RemoveFromBack">
      <summary>
            Removes an item from the back of the Deque. The indices of all existing items
            in the Deque are unchanged. This method is 
            equivalent to <c>RemoveAt(Count-1)</c> but is a little more
            efficient.
            </summary>
      <remarks>Removing an item from the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.GetAtFront">
      <summary>
            Retreives the item currently at the front of the Deque. The Deque is 
            unchanged. This method is 
            equivalent to <c>deque[0]</c> (except that a different exception is thrown).
            </summary>
      <remarks>Retreiving the item at the front of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <returns>The item at the front of the Deque.</returns>
      <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.GetAtBack">
      <summary>
            Retreives the item currently at the back of the Deque. The Deque is 
            unchanged. This method is 
            equivalent to <c>deque[deque.Count - 1]</c> (except that a different exception is thrown).
            </summary>
      <remarks>Retreiving the item at the back of the Deque takes
            a small constant amount of time, regardless of how many items are in the Deque.</remarks>
      <returns>The item at the back of the Deque.</returns>
      <exception cref="T:System.InvalidOperationException">The Deque is empty.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.Clone">
      <summary>
            Creates a new Deque that is a copy of this one.
            </summary>
      <remarks>Copying a Deque takes O(N) time, where N is the number of items in this Deque..</remarks>
      <returns>A copy of the current deque.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Deque`1.CloneContents">
      <summary>
            Makes a deep clone of this Deque. A new Deque is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the Deque takes time O(N), where N is the number of items in the Deque.</para>
      </remarks>
      <returns>The cloned Deque.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.Deque`1.Count">
      <summary>
            Gets the number of items currently stored in the Deque. The last item
            in the Deque has index Count-1.
            </summary>
      <remarks>Getting the count of items in the Deque takes a small constant
            amount of time.</remarks>
      <value>The number of items stored in this Deque.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.Deque`1.Capacity">
      <summary>
            Gets or sets the capacity of the Deque. The Capacity is the number of
            items that this Deque can hold without expanding its internal buffer. Since
            Deque will automatically expand its buffer when necessary, in almost all cases
            it is unnecessary to worry about the capacity. However, if it is known that a
            Deque will contain exactly 1000 items eventually, it can slightly improve 
            efficiency to set the capacity to 1000 up front, so that the Deque does not
            have to expand automatically.
            </summary>
      <value>The number of items that this Deque can hold without expanding its
            internal buffer.</value>
      <exception cref="T:System.ArgumentOutOfRangeException">The capacity is being set
            to less than Count, or to too large a value.</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.Deque`1.Item(System.Int32)">
      <summary>
            Gets or sets an item at a particular index in the Deque. 
            </summary>
      <remarks>Getting or setting the item at a particular index takes a small constant amount
            of time, no matter what index is used.</remarks>
      <param name="index">The index of the item to retrieve or change. The front item has index 0, and
            the back item has index Count-1.</param>
      <returns>The value at the indicated index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">The index is less than zero or greater than or equal
            to Count.</exception>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2">
      <summary>
            DictionaryBase is a base class that can be used to more easily implement the
            generic IDictionary&lt;T&gt; and non-generic IDictionary interfaces.
            </summary>
      <remarks>
        <para>To use DictionaryBase as a base class, the derived class must override
            Count, GetEnumerator, TryGetValue, Clear, Remove, and the indexer set accessor. </para>
      </remarks>
      <typeparam name="TKey">The key type of the dictionary.</typeparam>
      <typeparam name="TValue">The value type of the dictionary.</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.#ctor">
      <summary>
            Creates a new DictionaryBase. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.Clear">
      <summary>
            Clears the dictionary. This method must be overridden in the derived class.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.Remove(`0)">
      <summary>
            Removes a key from the dictionary. This method must be overridden in the derived class.
            </summary>
      <param name="key">Key to remove from the dictionary.</param>
      <returns>True if the key was found, false otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.TryGetValue(`0,`1@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, the value
            associated with that key is returned through the value parameter. This method must be
            overridden by the derived class.
            </summary>
      <param name="key">The key to search for.</param>
      <param name="value">Returns the value associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.Add(`0,`1)">
      <summary>
            Adds a new key-value pair to the dictionary. 
            </summary>
      <remarks>The default implementation of this method
            checks to see if the key already exists using 
            ContainsKey, then calls the indexer setter if the key doesn't
            already exist. </remarks>
      <param name="key">Key to add.</param>
      <param name="value">Value to associated with the key.</param>
      <exception cref="T:System.ArgumentException">key is already present in the dictionary</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.ContainsKey(`0)">
      <summary>
            Determines whether a given key is found
            in the dictionary.
            </summary>
      <remarks>The default implementation simply calls TryGetValue and returns
            what it returns.</remarks>
      <param name="key">Key to look for in the dictionary.</param>
      <returns>True if the key is present in the dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.ToString">
      <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
      <returns>The string representation of the dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.AsReadOnly">
      <summary>
            Provides a read-only view of this dictionary. The returned IDictionary&lt;TKey,TValue&gt; provides
            a view of the dictionary that prevents modifications to the dictionary. Use the method to provide
            access to the dictionary without allowing changes. Since the returned object is just a view,
            changes to the dictionary will be reflected in the view.
            </summary>
      <returns>An IIDictionary&lt;TKey,TValue&gt; that provides read-only access to the dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Adds a key-value pair to the collection. This implementation calls the Add method
            with the Key and Value from the item.
            </summary>
      <param name="item">A KeyValuePair contains the Key and Value to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Determines if a dictionary contains a given KeyValuePair. This implementation checks to see if the
            dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals)
            the value.
            </summary>
      <param name="item">A KeyValuePair containing the Key and Value to check for.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Determines if a dictionary contains a given KeyValuePair, and if so, removes it. This implementation checks to see if the
            dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals)
            the value. If so, the key-value pair is removed.
            </summary>
      <param name="item">A KeyValuePair containing the Key and Value to check for.</param>
      <returns>True if the item was found and removed. False otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.DebuggerDisplayString">
      <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.Item(`0)">
      <summary>
            The indexer of the dictionary. This is used to store keys and values and
            retrieve values from the dictionary. The setter
            accessor must be overridden in the derived class.
            </summary>
      <param name="key">Key to find in the dictionary.</param>
      <returns>The value associated with the key.</returns>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown from the get accessor if the key
            was not found in the dictionary.</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.Keys">
      <summary>
            Returns a collection of the keys in this dictionary. 
            </summary>
      <value>A read-only collection of the keys in this dictionary.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.DictionaryBase`2.Values">
      <summary>
            Returns a collection of the values in this dictionary. The ordering of 
            values in this collection is the same as that in the Keys collection.
            </summary>
      <value>A read-only collection of the values in this dictionary.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1">
      <summary>
            ReadOnlyCollectionBase is a base class that can be used to more easily implement the
            generic ICollection&lt;T&gt; and non-generic ICollection interfaces for a read-only collection:
            a collection that does not allow adding or removing elements.
            </summary>
      <remarks>
        <para>To use ReadOnlyCollectionBase as a base class, the derived class must override
            the Count and GetEnumerator methods. </para>
        <para>ICollection&lt;T&gt;.Contains need not be implemented by the
            derived class, but it should be strongly considered, because the ReadOnlyCollectionBase implementation
            may not be very efficient.</para>
      </remarks>
      <typeparam name="T">The item type of the collection.</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.#ctor">
      <summary>
            Creates a new ReadOnlyCollectionBase. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.ToString">
      <summary>
            Shows the string representation of the collection. The string representation contains
            a list of the items in the collection.
            </summary>
      <returns>The string representation of the collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.Exists(System.Func{`0,System.Boolean})">
      <summary>
            Determines if the collection contains any item that satisfies the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if the collection contains one or more items that satisfy the condition
            defined by <paramref name="predicate" />. False if the collection does not contain
            an item that satisfies <paramref name="predicate" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.TrueForAll(System.Func{`0,System.Boolean})">
      <summary>
            Determines if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>True if all of the items in the collection satisfy the condition
            defined by <paramref name="predicate" />, or if the collection is empty. False if one or more items
            in the collection do not satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.CountWhere(System.Func{`0,System.Boolean})">
      <summary>
            Counts the number of items in the collection that satisfy the condition
            defined by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>The number of items in the collection that satisfy <paramref name="predicate" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.FindAll(System.Func{`0,System.Boolean})">
      <summary>
            Enumerates the items in the collection that satisfy the condition defined
            by <paramref name="predicate" />.
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the items that satisfy the condition.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.ForEach(System.Action{`0})">
      <summary>
            Performs the specified action on each item in this collection.
            </summary>
      <param name="action">An Action delegate which is invoked for each item in this collection.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.ConvertAll``1(System.Func{`0,``0})">
      <summary>
            Convert this collection of items by applying a delegate to each item in the collection. The resulting enumeration
            contains the result of applying <paramref name="converter" /> to each item in this collection, in
            order.
            </summary>
      <typeparam name="TOutput">The type each item is being converted to.</typeparam>
      <param name="converter">A delegate to the method to call, passing each item in this collection.</param>
      <returns>An IEnumerable&lt;TOutput^gt; that enumerates the resulting collection from applying <paramref name="converter" /> to each item in this collection in
            order.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="converter" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.Contains(`0)">
      <summary>
            Determines if the collection contains a particular item. This default implementation
            iterates all of the items in the collection via GetEnumerator, testing each item
            against <paramref name="item" /> using IComparable&lt;T&gt;.Equals or
            Object.Equals.
            </summary>
      <remarks>You should strongly consider overriding this method to provide
            a more efficient implementation.</remarks>
      <param name="item">The item to check for in the collection.</param>
      <returns>True if the collection contains <paramref name="item" />, false otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies all the items in the collection into an array. Implemented by
            using the enumerator returned from GetEnumerator to get all the items
            and copy them to the provided array.
            </summary>
      <param name="array">Array to copy to.</param>
      <param name="arrayIndex">Starting index in <paramref name="array" /> to copy to.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.ToArray">
      <summary>
            Creates an array of the correct size, and copies all the items in the 
            collection into the array, by calling CopyTo.
            </summary>
      <returns>An array containing all the elements in the collection, in order.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.GetEnumerator">
      <summary>
            Must be overridden to enumerate all the members of the collection.
            </summary>
      <returns>A generic IEnumerator&lt;T&gt; that can be used
            to enumerate all the items in the collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.DebuggerDisplayString">
      <summary>
            Display the contents of the collection in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.ReadOnlyCollectionBase`1.Count">
      <summary>
            Must be overridden to provide the number of items in the collection.
            </summary>
      <value>The number of items in the collection.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.Hash`1">
      <summary>
             The base implementation for various collections classes that use hash tables
             as part of their implementation. This class should not (and can not) be 
             used directly by end users; it's only for internal use by the collections package. The Hash
             does not handle duplicate values.
             </summary>
      <remarks>
             The Hash manages items of type T, and uses a IComparer&lt;ItemTYpe&gt; that
             hashes compares items to hash items into the table.  
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Hash`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Constructor. Create a new hash table.
            </summary>
      <param name="equalityComparer">The comparer to use to compare items. </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Hash`1.Insert(`0,System.Boolean,`0@)">
      <summary>
            Insert a new item into the hash table. If a duplicate item exists, can replace or
            do nothing.
            </summary>
      <param name="item">The item to insert.</param>
      <param name="replaceOnDuplicate">If true, duplicate items are replaced. If false, nothing
            is done if a duplicate already exists.</param>
      <param name="previous">If a duplicate was found, returns it (whether replaced or not).</param>
      <returns>True if no duplicate existed, false if a duplicate was found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Hash`1.Delete(`0,`0@)">
      <summary>
            Deletes an item from the hash table. 
            </summary>
      <param name="item">Item to search for and delete.</param>
      <param name="itemDeleted">If true returned, the actual item stored in the hash table (must be 
            equal to <paramref name="item" />, but may not be identical.</param>
      <returns>True if item was found and deleted, false if item wasn't found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Hash`1.Find(`0,System.Boolean,`0@)">
      <summary>
            Find an item in the hash table. If found, optionally replace it with the
            finding item.
            </summary>
      <param name="find">Item to find.</param>
      <param name="replace">If true, replaces the equal item in the hash table
            with <paramref name="item" />.</param>
      <param name="item">Returns the equal item found in the table, if true was returned.</param>
      <returns>True if the item was found, false otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Hash`1.GetEnumerator">
      <summary>
            Enumerate all of the items in the hash table. The items
            are enumerated in a haphazard, unpredictable order.
            </summary>
      <returns>An IEnumerator&lt;T&gt; that enumerates the items
            in the hash table.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Hash`1.Clone(System.Func{`0,`0})">
      <summary>
            Creates a clone of this hash table.
            </summary>
      <param name="cloneItem">If non-null, this function is applied to each item when cloning. It must be the 
            case that this function does not modify the hash code or equality function.</param>
      <returns>A shallow clone that contains the same items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Hash`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Called on deserialization. We cannot deserialize now, because hash codes
            might not be correct now. We do real deserialization in the OnDeserialization call.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Hash`1.PrintStats">
      <summary>
            Print out basic stats about the hash table.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Hash`1.Print">
      <summary>
            Print out the state of the hash table and each of the slots. Each slot looks like:
                Slot    4: C 4513e41e hello
            where the "C" indicates the collision bit is on
            the next hex number is the hash value
            followed by ToString() on the item.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Hash`1.Validate">
      <summary>
            Check that everything appears to be OK in the hash table.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.Hash`1.ElementCount">
      <summary>
            Get the number of items in the hash table.
            </summary>
      <value>The number of items stored in the hash table.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.Hash`1.SlotCount">
      <summary>
            Get the number of slots in the hash table. Exposed internally
            for testing purposes.
            </summary>
      <value>The number of slots in the hash table.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.Hash`1.LoadFactor">
      <summary>
            Get or change the load factor. Changing the load factor may cause
            the size of the table to grow or shrink accordingly.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2">
      <summary>
        <para>The MultiDictionary class that associates values with a key. Unlike an Dictionary,
             each key can have multiple values associated with it. When indexing an MultiDictionary, instead
             of a single value associated with a key, you retrieve an enumeration of values.</para>
        <para>When constructed, you can chose to allow the same value to be associated with a key multiple
             times, or only one time. </para>
      </summary>
      <typeparam name="TKey">The type of the keys.</typeparam>
      <typeparam name="TValue">The of values associated with the keys.</typeparam>
      <seealso cref="T:System.Collections.Generic.Dictionary`2" />
      <seealso cref="T:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2" />
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2">
      <summary>
            MultiDictionaryBase is a base class that can be used to more easily implement a class
            that associates multiple values to a single key. The class implements the generic
            IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt; interface.
            </summary>
      <remarks>
        <para>To use MultiDictionaryBase as a base class, the derived class must override
            Count, Clear, Add, Remove(TKey), Remove(TKey,TValue), Contains(TKey,TValue), 
            EnumerateKeys, and TryEnumerateValuesForKey. </para>
        <para>It may wish consider overriding CountValues, CountAllValues, ContainsKey,
            and EqualValues, but these are not required.
            </para>
      </remarks>
      <typeparam name="TKey">The key type of the dictionary.</typeparam>
      <typeparam name="TValue">The value type of the dictionary.</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.#ctor">
      <summary>
            Creates a new MultiDictionaryBase. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.Clear">
      <summary>
            Clears the dictionary. This method must be overridden in the derived class.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.EnumerateKeys">
      <summary>
            Enumerate all the keys in the dictionary. This method must be overridden by a derived
            class.
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
      <summary>
            Enumerate all of the values associated with a given key. This method must be overridden
            by the derived class. If the key exists and has values associated with it, an enumerator for those
            values is returned throught <paramref name="values" />. If the key does not exist, false is returned.
            </summary>
      <param name="key">The key to get values for.</param>
      <param name="values">If true is returned, this parameter receives an enumerators that
            enumerates the values associated with that key.</param>
      <returns>True if the key exists and has values associated with it. False otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Adds a key-value pair to the collection. The value part of the pair must be a collection
            of values to associate with the key. If values are already associated with the given
            key, the new values are added to the ones associated with that key.
            </summary>
      <param name="item">A KeyValuePair contains the Key and Value collection to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.AddMany(`0,System.Collections.Generic.IEnumerable{`1})">
      <summary>
        <para>Adds new values to be associated with a key. If duplicate values are permitted, this
            method always adds new key-value pairs to the dictionary.</para>
        <para>If duplicate values are not permitted, and <paramref name="key" /> already has a value
            equal to one of <paramref name="values" /> associated with it, then that value is replaced,
            and the number of values associate with <paramref name="key" /> is unchanged.</para>
      </summary>
      <param name="key">The key to associate with.</param>
      <param name="values">A collection of values to associate with <paramref name="key" />.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.Add(`0,`1)">
      <summary>
            Adds a new key-value pair to the dictionary.  This method must be overridden in the derived class.
            </summary>
      <param name="key">Key to add.</param>
      <param name="value">Value to associated with the key.</param>
      <exception cref="T:System.ArgumentException">key is already present in the dictionary</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.Remove(`0)">
      <summary>
            Removes a key from the dictionary. This method must be overridden in the derived class.
            </summary>
      <param name="key">Key to remove from the dictionary.</param>
      <returns>True if the key was found, false otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.Remove(`0,`1)">
      <summary>
            Removes a key-value pair from the dictionary. This method must be overridden in the derived class.
            </summary>
      <param name="key">Key to remove from the dictionary.</param>
      <param name="value">Associated value to remove from the dictionary.</param>
      <returns>True if the key-value pair was found, false otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Removes a set of values from a given key. If all values associated with a key are
            removed, then the key is removed also.
            </summary>
      <param name="pair">A KeyValuePair contains a key and a set of values to remove from that key.</param>
      <returns>True if at least one values was found and removed.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.RemoveMany(`0,System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Removes a collection of values from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
      <param name="key">A key to remove values from.</param>
      <param name="values">A collection of values to remove.</param>
      <returns>The number of values that were present and removed. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Remove all of the keys (and any associated values) in a collection
            of keys. If a key is not present in the dictionary, nothing happens.
            </summary>
      <param name="keyCollection">A collection of key values to remove.</param>
      <returns>The number of keys from the collection that were present and removed.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.ContainsKey(`0)">
      <summary>
            Determines whether a given key is found in the dictionary.
            </summary>
      <remarks>The default implementation simply calls TryEnumerateValuesForKey.
            It may be appropriate to override this method to 
            provide a more efficient implementation.</remarks>
      <param name="key">Key to look for in the dictionary.</param>
      <returns>True if the key is present in the dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.Contains(`0,`1)">
      <summary>
            Determines if this dictionary contains a key-value pair equal to <paramref name="key" /> and 
            <paramref name="value" />. The dictionary is not changed. This method must be overridden in the derived class.
            </summary>
      <param name="key">The key to search for.</param>
      <param name="value">The value to search for.</param>
      <returns>True if the dictionary has associated <paramref name="value" /> with <paramref name="key" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Determines if this dictionary contains the given key and all of the values associated with that key..
            </summary>
      <param name="pair">A key and collection of values to search for.</param>
      <returns>True if the dictionary has associated all of the values in <paramref name="pair" />.Value with <paramref name="pair" />.Key.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.EqualValues(`1,`1)">
      <summary>
            If the derived class does not use the default comparison for values, this
            methods should be overridden to compare two values for equality. This is
            used for the correct implementation of ICollection.Contains on the Values
            and KeyValuePairs collections.
            </summary>
      <param name="value1">First value to compare.</param>
      <param name="value2">Second value to compare.</param>
      <returns>True if the values are equal.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.CountValues(`0)">
      <summary>
            Gets a count of the number of values associated with a key. The
            default implementation is slow; it enumerators all of the values
            (using TryEnumerateValuesForKey) to count them. A derived class
            may be able to supply a more efficient implementation.
            </summary>
      <param name="key">The key to count values for.</param>
      <returns>The number of values associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.CountAllValues">
      <summary>
            Gets a total count of values in the collection. This default implementation
            is slow; it enumerates all of the keys in the dictionary and calls CountValues on each.
            A derived class may be able to supply a more efficient implementation.
            </summary>
      <returns>The total number of values associated with all keys in the dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.Replace(`0,`1)">
      <summary>
            Replaces all values associated with <paramref name="key" /> with the single value <paramref name="value" />.
            </summary>
      <remarks>This implementation simply calls Remove, followed by Add.</remarks>
      <param name="key">The key to associate with.</param>
      <param name="value">The new values to be associated with <paramref name="key" />.</param>
      <returns>Returns true if some values were removed. Returns false if <paramref name="key" /> was not
            present in the dictionary before Replace was called.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.ReplaceMany(`0,System.Collections.Generic.IEnumerable{`1})">
      <summary>
            Replaces all values associated with <paramref name="key" /> with a new collection
            of values. If the collection does not permit duplicate values, and <paramref name="values" /> has duplicate
            items, then only the last of duplicates is added.
            </summary>
      <param name="key">The key to associate with.</param>
      <param name="values">The new values to be associated with <paramref name="key" />.</param>
      <returns>Returns true if some values were removed. Returns false if <paramref name="key" /> was not
            present in the dictionary before Replace was called.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.ToString">
      <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
      <returns>The string representation of the dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.DebuggerDisplayString">
      <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.GetEnumerator">
      <summary>
            Enumerate all the keys in the dictionary, and for each key, the collection of values for that key.
            </summary>
      <returns>An enumerator to enumerate all the key, ICollection&lt;value&gt; pairs in the dictionary.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.Count">
      <summary>
            Gets the number of keys in the dictionary. This property must be overridden
            in the derived class.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.Keys">
      <summary>
            Gets a read-only collection all the keys in this dictionary.
            </summary>
      <value>An readonly ICollection&lt;TKey&gt; of all the keys in this dictionary.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.Values">
      <summary>
            Gets a read-only collection of all the values in the dictionary. 
            </summary>
      <returns>A read-only ICollection&lt;TValue&gt; of all the values in the dictionary.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.KeyValuePairs">
      <summary>
            Gets a read-only collection of all key-value pairs in the dictionary. If a key has multiple
            values associated with it, then a key-value pair is present for each value associated
            with the key.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.MultiDictionaryBase`2.Item(`0)">
      <summary>
            Returns a collection of all of the values in the dictionary associated with <paramref name="key" />,
            or changes the set of values associated with <paramref name="key" />.
            If the key is not present in the dictionary, an ICollection enumerating no
            values is returned. The returned collection of values is read-write, and can be used to 
            modify the collection of values associated with the key.
            </summary>
      <param name="key">The key to get the values associated with.</param>
      <value>An ICollection&lt;TValue&gt; with all the values associated with <paramref name="key" />.</value>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.#ctor(System.Boolean)">
      <summary>
            Create a new MultiDictionary. The default ordering of keys and values are used. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <remarks>The default ordering of keys and values will be used, as defined by TKey and TValue's implementation
            of IComparable&lt;T&gt; (or IComparable if IComparable&lt;T&gt; is not implemented). If a different ordering should be
            used, other constructors allow a custom Comparer or IComparer to be passed to changed the ordering.</remarks>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <exception cref="T:System.InvalidOperationException">TKey or TValue does not implement either IComparable&lt;T&gt; or IComparable.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Create a new MultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyEqualityComparer">An IEqualityComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
      <summary>
            Create a new MultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyEqualityComparer">An IEqualityComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <param name="valueEqualityComparer">An IEqualityComparer&lt;TValue&gt; instance that will be used to compare values.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.Add(`0,`1)">
      <summary>
        <para>Adds a new value to be associated with a key. If duplicate values are permitted, this
            method always adds a new key-value pair to the dictionary.</para>
        <para>If duplicate values are not permitted, and <paramref name="key" /> already has a value
            equal to <paramref name="value" /> associated with it, then that value is replaced with <paramref name="value" />,
            and the number of values associate with <paramref name="key" /> is unchanged.</para>
      </summary>
      <param name="key">The key to associate with.</param>
      <param name="value">The value to associated with <paramref name="key" />.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.Remove(`0,`1)">
      <summary>
            Removes a given value from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
      <param name="key">A key to remove a value from.</param>
      <param name="value">The value to remove.</param>
      <returns>True if <paramref name="value" /> was associated with <paramref name="key" /> (and was
            therefore removed). False if <paramref name="value" /> was not associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.Remove(`0)">
      <summary>
            Removes a key and all associated values from the dictionary. If the
            key is not present in the dictionary, it is unchanged and false is returned.
            </summary>
      <param name="key">The key to remove.</param>
      <returns>True if the key was present and was removed. Returns 
            false if the key was not present.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.Clear">
      <summary>
            Removes all keys and values from the dictionary.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.EqualValues(`1,`1)">
      <summary>
            Determine if two values are equal.
            </summary>
      <param name="value1">First value to compare.</param>
      <param name="value2">Second value to compare.</param>
      <returns>True if the values are equal.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.Contains(`0,`1)">
      <summary>
            Checks to see if <paramref name="value" /> is associated with <paramref name="key" />
            in the dictionary.
            </summary>
      <param name="key">The key to check.</param>
      <param name="value">The value to check.</param>
      <returns>True if <paramref name="value" /> is associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.ContainsKey(`0)">
      <summary>
            Checks to see if the key is present in the dictionary and has
            at least one value associated with it.
            </summary>
      <param name="key">The key to check.</param>
      <returns>True if <paramref name="key" /> is present and has at least
            one value associated with it. Returns false otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.EnumerateKeys">
      <summary>
            Enumerate all the keys in the dictionary. 
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the dictionary that
            have at least one value associated with them.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, all the values
            associated with that key are returned through the values parameter. 
            </summary>
      <param name="key">The key to search for.</param>
      <param name="values">Returns all values associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.CountValues(`0)">
      <summary>
            Gets the number of values associated with a given key.
            </summary>
      <param name="key">The key to count values of.</param>
      <returns>The number of values associated with <paramref name="key" />. If <paramref name="key" />
            is not present in the dictionary, zero is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.Clone">
      <summary>
            Makes a shallow clone of this dictionary; i.e., if keys or values of the
            dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the dictionary takes time O(N), where N is the number of key-value pairs in the dictionary.</remarks>
      <returns>The cloned dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.CloneContents">
      <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If TKey or TValue is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the dictionary takes time O(N log N), where N is the number of key-value pairs in the dictionary.</para>
      </remarks>
      <returns>The cloned dictionary.</returns>
      <exception cref="T:System.InvalidOperationException">TKey or TValue is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.KeyComparer">
      <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. Otherwise
            the default comparer for TKey (EqualityComparer&lt;TKey&gt;.Default) is returned.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.ValueComparer">
      <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare values in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. Otherwise
            the default comparer for TValue (EqualityComparer&lt;TValue&gt;.Default) is returned.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.MultiDictionary`2.Count">
      <summary>
            Gets the number of key-value pairs in the dictionary. Each value associated
            with a given key is counted. If duplicate values are permitted, each duplicate
            value is included in the count.
            </summary>
      <value>The number of key-value pairs in the dictionary.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1">
      <summary>
             OrderedBag&lt;T&gt; is a collection that contains items of type T. 
             The item are maintained in a sorted order. Unlike a OrderedSet, duplicate items (items that
             compare equal to each other) are allows in an OrderedBag.
             </summary>
      <remarks>
        <p>The items are compared in one of three ways. If T implements IComparable&lt;TKey&gt; or IComparable,
             then the CompareTo method of that interface will be used to compare items. Alternatively, a comparison
             function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
        <p>OrderedBag is implemented as a balanced binary tree. Inserting, deleting, and looking up an
             an element all are done in log(N) + M time, where N is the number of keys in the tree, and M is the current number
             of copies of the element being handled.</p>
        <p>
          <see cref="T:NSoft.NFramework.Collections.PowerCollections.Bag`1" /> is similar, but uses hashing instead of comparison, and does not maintain
             the keys in sorted order.</p>
      </remarks>
      <seealso cref="T:NSoft.NFramework.Collections.PowerCollections.Bag`1" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.#ctor">
      <summary>
             Creates a new OrderedBag. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this bag.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.#ctor(System.Comparison{`0})">
      <summary>
            Creates a new OrderedBag. The passed delegate will be used to compare items in this bag.
            </summary>
      <param name="comparison">A delegate to a method that will be used to compare items.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedBag. The Compare method of the passed comparison object
            will be used to compare items in this bag.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
      <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Creates a new OrderedBag. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this bag. The bag is
             initialized with all the items in the given collection.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
      <param name="collection">A collection with items to be placed into the OrderedBag.</param>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Comparison{`0})">
      <summary>
            Creates a new OrderedBag. The passed delegate will be used to compare items in this bag.
            The bag is initialized with all the items in the given collection.
            </summary>
      <param name="collection">A collection with items to be placed into the OrderedBag.</param>
      <param name="comparison">A delegate to a method that will be used to compare items.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedBag. The Compare method of the passed comparison object
            will be used to compare items in this bag. The bag is
            initialized with all the items in the given collection.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
      <param name="collection">A collection with items to be placed into the OrderedBag.</param>
      <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Clone">
      <summary>
            Makes a shallow clone of this bag; i.e., if items of the
            bag are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the bag takes time O(N), where N is the number of items in the bag.</remarks>
      <returns>The cloned bag.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.CloneContents">
      <summary>
            Makes a deep clone of this bag. A new bag is created with a clone of
            each element of this bag, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the bag takes time O(N log N), where N is the number of items in the bag.</para>
      </remarks>
      <returns>The cloned bag.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.NumberOfCopies(`0)">
      <summary>
            Returns the number of copies of <paramref name="item" /> in the bag. More precisely, returns
            the number of items in the bag that compare equal to <paramref name="item" />.
            </summary>
      <remarks>NumberOfCopies() takes time O(log N + M), where N is the total number of items in the
            bag, and M is the number of copies of <paramref name="item" /> in the bag.</remarks>
      <param name="item">The item to search for in the bag.</param>
      <returns>The number of items in the bag that compare equal to <paramref name="item" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the items in the bag. 
            The items are enumerated in sorted order.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
        <p>If an item is added to or deleted from the bag while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumeration all the items in the bag takes time O(N), where N is the number
            of items in the bag.</p>
      </remarks>
      <returns>An enumerator for enumerating all the items in the OrderedBag.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Contains(`0)">
      <summary>
            Determines if this bag contains an item equal to <paramref name="item" />. The bag
            is not changed.
            </summary>
      <remarks>Searching the bag for an item takes time O(log N), where N is the number of items in the bag.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the bag contains <paramref name="item" />. False if the bag does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.GetEqualItems(`0)">
      <summary>
        <para>Enumerates all of the items in this bag that are equal to <paramref name="item" />, according to the 
            comparison mechanism that was used when the bag was created. The bag
            is not changed.</para>
        <para>If the bag does contain an item equal to <paramref name="item" />, then the enumeration contains
            no items.</para>
      </summary>
      <remarks>Enumeration the items in the bag equal to <paramref name="item" /> takes time O(log N + M), where N 
            is the total number of items in the bag, and M is the number of items equal to <paramref name="item" />.</remarks>
      <param name="item">The item to search for.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates all the items in the bag equal to <paramref name="item" />. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.DistinctItems">
      <summary>
            Enumerates all the items in the bag, but enumerates equal items
            just once, even if they occur multiple times in the bag.
            </summary>
      <remarks>If the bag is changed while items are being enumerated, the
            enumeration will terminate with an InvalidOperationException.</remarks>
      <returns>An IEnumerable&lt;T&gt; that enumerates the unique items.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.LastIndexOf(`0)">
      <summary>
            Get the index of the given item in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. If multiple
            equal items exist, the largest index of the equal items is returned.
            </summary>
      <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="item">The item to get the index of.</param>
      <returns>The index of the last item in the sorted bag equal to <paramref name="item" />, or -1 if the item is not present
            in the set.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.IndexOf(`0)">
      <summary>
            Get the index of the given item in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. If multiple
            equal items exist, the smallest index of the equal items is returned.
            </summary>
      <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="item">The item to get the index of.</param>
      <returns>The index of the first item in the sorted bag equal to <paramref name="item" />, or -1 if the item is not present
            in the set.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Add(`0)">
      <summary>
            Adds a new item to the bag. Since bags can contain duplicate items, the item 
            is added even if the bag already contains an item equal to <paramref name="item" />. In
            this case, the new item is placed after all equal items already present in the bag.
            </summary>
      <remarks>
        <para>Adding an item takes time O(log N), where N is the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to add to the bag.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds all the items in <paramref name="collection" /> to the bag. 
            </summary>
      <remarks>
        <para>Adding the collection takes time O(M log N), where N is the number of items in the bag, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to add to the bag.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Remove(`0)">
      <summary>
            Searches the bag for one item equal to <paramref name="item" />, and if found,
            removes it from the bag. If not found, the bag is unchanged. If more than one item
            equal to <paramref name="item" />, the item that was last inserted is removed.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>Removing an item from the bag takes time O(log N), where N is the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the bag.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.RemoveAllCopies(`0)">
      <summary>
            Searches the bag for all items equal to <paramref name="item" />, and 
            removes all of them from the bag. If not found, the bag is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>RemoveAllCopies() takes time O(M log N), where N is the total number of items in the bag, and M is
            the number of items equal to <paramref name="item" />.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>The number of copies of <paramref name="item" /> that were found and removed. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the items in <paramref name="collection" /> from the bag. Items not
            present in the bag are ignored.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>Removing the collection takes time O(M log N), where N is the number of items in the bag, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to remove from the bag.</param>
      <returns>The number of items removed from the bag.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Clear">
      <summary>
            Removes all items from the bag.
            </summary>
      <remarks>Clearing the bag takes a constant amount of time, regardless of the number of items in it.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.GetFirst">
      <summary>
            Returns the first item in the bag: the item
            that would appear first if the bag was enumerated. This is also
            the smallest item in the bag.
            </summary>
      <remarks>GetFirst() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The first item in the bag. If more than one item
            is smallest, the first one added is returned.</returns>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.GetLast">
      <summary>
            Returns the last item in the bag: the item
            that would appear last if the bag was enumerated. This is also the largest
            item in the bag.
            </summary>
      <remarks>GetLast() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The last item in the bag. If more than one item
            is largest, the last one added is returned.</returns>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.RemoveFirst">
      <summary>
            Removes the first item in the bag. This is also the smallest
            item in the bag.
            </summary>
      <remarks>RemoveFirst() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The item that was removed, which was the smallest item in the bag. </returns>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.RemoveLast">
      <summary>
            Removes the last item in the bag. This is also the largest item in the bag.
            </summary>
      <remarks>RemoveLast() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The item that was removed, which was the largest item in the bag. </returns>
      <exception cref="T:System.InvalidOperationException">The bag is empty.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.IsSupersetOf(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Determines if this bag is a superset of another bag. Neither bag is modified.
            This bag is a superset of <paramref name="otherBag" /> if every element in
            <paramref name="otherBag" /> is also in this bag, at least the same number of
            times.
            </summary>
      <remarks>IsSupersetOf is computed in time O(M log N), where M is the size of the 
            <paramref name="otherBag" />, and N is the size of the this bag.</remarks>
      <param name="otherBag">OrderedBag to compare to.</param>
      <returns>True if this is a superset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.IsProperSupersetOf(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Determines if this bag is a proper superset of another bag. Neither bag is modified.
            This bag is a proper superset of <paramref name="otherBag" /> if every element in
            <paramref name="otherBag" /> is also in this bag, at least the same number of
            times. Additional, this bag must have strictly more items than <paramref name="otherBag" />.
            </summary>
      <remarks>IsProperSupersetOf is computed in time O(M log N), where M is the number of unique items in 
            <paramref name="otherBag" />.</remarks>
      <param name="otherBag">OrderedBag to compare to.</param>
      <returns>True if this is a proper superset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.IsSubsetOf(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Determines if this bag is a subset of another bag. Neither bag is modified.
            This bag is a subset of <paramref name="otherBag" /> if every element in this bag
            is also in <paramref name="otherBag" />, at least the same number of
            times.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref name="otherBag" />, and N is the size of the this bag.</remarks>
      <param name="otherBag">OrderedBag to compare to.</param>
      <returns>True if this is a subset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.IsProperSubsetOf(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Determines if this bag is a proper subset of another bag. Neither bag is modified.
            This bag is a subset of <paramref name="otherBag" /> if every element in this bag
            is also in <paramref name="otherBag" />, at least the same number of
            times. Additional, this bag must have strictly fewer items than <paramref name="otherBag" />.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref nameb="otherBag" />, and N is the size of the this bag.</remarks>
      <param name="otherBag">OrderedBag to compare to.</param>
      <returns>True if this is a proper subset of <paramref name="otherBag" />.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.IsDisjointFrom(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Determines if this bag is disjoint from another bag. Two bags are disjoint
            if no item from one set is equal to any item in the other bag.
            </summary>
      <remarks>
        <para>The answer is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherBag">Bag to check disjointness with.</param>
      <returns>True if the two bags are disjoint, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.IsEqualTo(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Determines if this bag is equal to another bag. This bag is equal to
            <paramref name="otherBag" /> if they contain the same items, each the
            same number of times.
            </summary>
      <remarks>IsEqualTo is computed in time O(N), where N is the number of items in 
            this bag.</remarks>
      <param name="otherBag">OrderedBag to compare to</param>
      <returns>True if this bag is equal to <paramref name="otherBag" />, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.UnionWith(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. This bag receives
            the union of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>The union of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to union with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Union(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Computes the union of this bag with another bag. The union of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the union contains the item Maximum(X,Y) times. A new bag is 
            created with the union of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The union of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to union with.</param>
      <returns>The union of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.SumWith(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Computes the sum of this bag with another bag. The sum of two bags
            is all items from both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. This bag receives
            the sum of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>The sum of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to sum with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Sum(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Computes the sum of this bag with another bag. he sum of two bags
            is all items from both of the bags.  If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item (X+Y) times. A new bag is 
            created with the sum of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The sum of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to sum with.</param>
      <returns>The sum of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.IntersectionWith(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item Minimum(X,Y) times. This bag receives
            the intersection of the two bags, the other bag is unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two bags is computed in time O(N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to intersection with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Intersection(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Computes the intersection of this bag with another bag. The intersection of two bags
            is all items that appear in both of the bags. If an item appears X times in one bag,
            and Y times in the other bag, the sum contains the item Minimum(X,Y) times. A new bag is 
            created with the intersection of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both bags, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two bags is computed in time O(N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to intersection with.</param>
      <returns>The intersection of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.DifferenceWith(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag" />. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X). This bag receives
            the difference of the two bags; the other bag is unchanged.
            </summary>
      <remarks>
        <para>The difference of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to difference with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Difference(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Computes the difference of this bag with another bag. The difference of these two bags
            is all items that appear in this bag, but not in <paramref name="otherBag" />. If an item appears X times in this bag,
            and Y times in the other bag, the difference contains the item X - Y times (zero times if Y &gt;= X).  A new bag is 
            created with the difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The difference of two bags is computed in time O(M + N log M), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to difference with.</param>
      <returns>The difference of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.SymmetricDifferenceWith(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y times). This bag receives
            the symmetric difference of the two bags; the other bag is unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to symmetric difference with.</param>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.SymmetricDifference(NSoft.NFramework.Collections.PowerCollections.OrderedBag{`0})">
      <summary>
            Computes the symmetric difference of this bag with another bag. The symmetric difference of two bags
            is all items that appear in either of the bags, but not both. If an item appears X times in one bag,
            and Y times in the other bag, the symmetric difference contains the item AbsoluteValue(X - Y times). A new bag is 
            created with the symmetric difference of the bags and is returned. This bag and the other bag 
            are unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two bags is computed in time O(M + N), where M is the size of the 
            larger bag, and N is the size of the smaller bag.</para>
      </remarks>
      <param name="otherBag">Bag to symmetric difference with.</param>
      <returns>The symmetric difference of the two bags.</returns>
      <exception cref="T:System.InvalidOperationException">This bag and <paramref name="otherBag" /> don't use the same method for comparing items.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="otherBag" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.AsList">
      <summary>
            Get a read-only list view of the items in this ordered bag. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedBag.
            </summary>
      <returns>A read-only IList&lt;T&gt; view onto this OrderedBag.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Reversed">
      <summary>
             Returns a View collection that can be used for enumerating the items in the bag in 
             reversed order.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.Reversed()) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Reverse does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <returns>An OrderedBag.View of items in reverse order.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Range(`0,System.Boolean,`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the bag.
             Only items that are greater than <paramref name="from" /> and 
             less than <paramref name="to" /> are included. The items are enumerated in sorted order.
             Items equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive" /> and <paramref name="toInclusive" /> parameters.
             </summary>
      <remarks>
        <p>If <paramref name="from" /> is greater than or equal to <paramref name="to" />, the returned collection is empty. </p>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.Range(from, true, to, false)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Range does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedBag.View of items in the given range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.RangeFrom(`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the bag.
             Only items that are greater than (and optionally, equal to) <paramref name="from" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="from" /> can be included
             or excluded depending on the <paramref name="fromInclusive" /> parameter.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.RangeFrom(from, true)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling RangeFrom does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
      <returns>An OrderedBag.View of items in the given range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.RangeTo(`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the bag.
             Only items that are less than (and optionally, equal to) <paramref name="to" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to" /> can be included
             or excluded depending on the <paramref name="toInclusive" /> parameter.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in bag.RangeTo(to, false)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the bag while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling RangeTo does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedBag.View of items in the given range.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Comparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare items in this bag. 
            </summary>
      <value>If the bag was created using a comparer, that comparer is returned. If the bag was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for T (Comparer&lt;T&gt;.Default) is returned.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Count">
      <summary>
            Returns the number of items in the bag.
            </summary>
      <remarks>The size of the bag is returned in constant time.</remarks>
      <value>The number of items in the bag.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.Item(System.Int32)">
      <summary>
            Get the item by its index in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="index">The index to get the item by.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1">
      <summary>
            ReadOnlyListBase is an abstract class that can be used as a base class for a read-only collection that needs 
            to implement the generic IList&lt;T&gt; and non-generic IList collections. The derived class needs
            to override the Count property and the get part of the indexer. The implementation
            of all the other methods in IList&lt;T&gt; and IList are handled by ListBase.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.#ctor">
      <summary>
            Creates a new ReadOnlyListBase.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.GetEnumerator">
      <summary>
            Enumerates all of the items in the list, in order. The item at index 0
            is enumerated first, then the item at index 1, and so on.
            </summary>
      <returns>An IEnumerator&lt;T&gt; that enumerates all the
            items in the list.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.Contains(`0)">
      <summary>
            Determines if the list contains any item that compares equal to <paramref name="item" />.
            The implementation simply checks whether IndexOf(item) returns a non-negative value.
            </summary>
      <remarks>Equality in the list is determined by the default sense of
            equality for T. If T implements IComparable&lt;T&gt;, the
            Equals method of that interface is used to determine equality. Otherwise, 
            Object.Equals is used to determine equality.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the list contains an item that compares equal to <paramref name="item" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.CopyTo(`0[])">
      <summary>
            Copies all the items in the list, in order, to <paramref name="array" />,
            starting at index 0.
            </summary>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies all the items in the list, in order, to <paramref name="array" />,
            starting at <paramref name="arrayIndex" />.
            </summary>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
      <param name="arrayIndex">The starting index in <paramref name="array" />
            to copy to.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
      <summary>
            Copies a range of elements from the list to <paramref name="array" />,
            starting at <paramref name="arrayIndex" />.
            </summary>
      <param name="index">The starting index in the source list of the range to copy.</param>
      <param name="array">The array to copy to. This array must have a size
            that is greater than or equal to Count + arrayIndex.</param>
      <param name="arrayIndex">The starting index in <paramref name="array" />
            to copy to.</param>
      <param name="count">The number of items to copy.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.Find(System.Func{`0,System.Boolean})">
      <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
      <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate" />,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.TryFind(System.Func{`0,System.Boolean},`0@)" />.</remarks>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The first item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, the default value for T is returned.</returns>
      <seealso cref="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.TryFind(System.Func{`0,System.Boolean},`0@)" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.TryFind(System.Func{`0,System.Boolean},`0@)">
      <summary>
            Finds the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. 
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <param name="foundItem">If true is returned, this parameter receives the first item in the list
            that satifies the condition defined by <paramref name="predicate" />.</param>
      <returns>True if an item that  satisfies the condition <paramref name="predicate" /> was found. False 
            if no item in the list satisfies that condition.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.FindLast(System.Func{`0,System.Boolean})">
      <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, than
            the default value for T (null or all-zero) is returned.
            </summary>
      <remarks>If the default value for T (null or all-zero) matches the condition defined by <paramref name="predicate" />,
            and the list might contain the default value, then it is impossible to distinguish the different between finding
            the default value and not finding any item. To distinguish these cases, use <see cref="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.TryFindLast(System.Func{`0,System.Boolean},`0@)" />.</remarks>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The last item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, the default value for T is returned.</returns>
      <seealso cref="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.TryFindLast(System.Func{`0,System.Boolean},`0@)" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.TryFindLast(System.Func{`0,System.Boolean},`0@)">
      <summary>
            Finds the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. 
            </summary>
      <param name="predicate">A delegate that defines the condition to check for.</param>
      <param name="foundItem">If true is returned, this parameter receives the last item in the list
            that satifies the condition defined by <paramref name="predicate" />.</param>
      <returns>True if an item that  satisfies the condition <paramref name="predicate" /> was found. False 
            if no item in the list satisfies that condition.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.FindIndex(System.Func{`0,System.Boolean})">
      <summary>
            Finds the index of the first item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the first item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.FindIndex(System.Int32,System.Func{`0,System.Boolean})">
      <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index" /> to the end, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The starting index of the range to check.</param>
      <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.FindIndex(System.Int32,System.Int32,System.Func{`0,System.Boolean})">
      <summary>
            Finds the index of the first item, in the range of <paramref name="count" /> items starting from <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The starting index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the first item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.FindLastIndex(System.Func{`0,System.Boolean})">
      <summary>
            Finds the index of the last item in the list that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <returns>The index of the last item that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.FindLastIndex(System.Int32,System.Func{`0,System.Boolean})">
      <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The ending index of the range to check.</param>
      <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.FindLastIndex(System.Int32,System.Int32,System.Func{`0,System.Boolean})">
      <summary>
            Finds the index of the last item, in the range of <paramref name="count" /> items ending at <paramref name="index" />, that satisfies the condition
            defined by <paramref name="predicate" />. If no item matches the condition, -1 is returned.
            </summary>
      <param name="predicate">A delegate that defined the condition to check for.</param>
      <param name="index">The ending index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the last item in the given range that satisfies the condition <paramref name="predicate" />. If no item satisfies that
            condition, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.IndexOf(`0)">
      <summary>
            Finds the index of the first item in the list that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <returns>The index of the first item in the list that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.IndexOf(`0,System.Int32)">
      <summary>
            Finds the index of the first item, in the range of items extending from <paramref name="index" /> to the end,  
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The starting index of the range to check.</param>
      <returns>The index of the first item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.IndexOf(`0,System.Int32,System.Int32)">
      <summary>
            Finds the index of the first item, in the range of <paramref name="count" /> items starting from <paramref name="index" />,  
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The starting index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the first item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.LastIndexOf(`0)">
      <summary>
            Finds the index of the last item in the list that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <returns>The index of the last item in the list that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.LastIndexOf(`0,System.Int32)">
      <summary>
            Finds the index of the last item, in the range of items extending from the beginning
            of the list to <paramref name="index" />, that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search fror.</param>
      <param name="index">The ending index of the range to check.</param>
      <returns>The index of the last item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.LastIndexOf(`0,System.Int32,System.Int32)">
      <summary>
            Finds the index of the last item, in the range of <paramref name="count" /> items ending at <paramref name="index" />, 
            that is equal to <paramref name="item" />. 
            </summary>
      <remarks>The default implementation of equality for type T is used in the search. This is the
            equality defined by IComparable&lt;T&gt; or object.Equals.</remarks>
      <param name="item">The item to search for.</param>
      <param name="index">The ending index of the range to check.</param>
      <param name="count">The number of items in range to check.</param>
      <returns>The index of the last item in the given range that that is equal to <paramref name="item" />.  If no item is equal
            to <paramref name="item" />, -1 is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.Range(System.Int32,System.Int32)">
      <summary>
            Returns a view onto a sub-range of this list. Items are not copied; the
            returned IList&lt;T&gt; is simply a different view onto the same underlying items. 
            </summary>
      <remarks>
        <para>This method can be used to apply an algorithm to a portion of a list. For example:</para>
        <code>Algorithms.Reverse(deque.Range(3, 6))</code>
            will return the reverse opf the 6 items beginning at index 3.</remarks>
      <param name="start">The starting index of the view.</param>
      <param name="count">The number of items in the view.</param>
      <returns>A list that is a view onto the given sub-part of this list. </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> or <paramref name="count" /> is negative.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="start" /> + <paramref name="count" /> is greater than the
            size of the list.</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.Count">
      <summary>
            The property must be overridden by the derived class to return the number of 
            items in the list.
            </summary>
      <value>The number of items in the list.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.ReadOnlyListBase`1.Item(System.Int32)">
      <summary>
            The get part of the indexer must be overridden by the derived class to get 
            values of the list at a particular index.
            </summary>
      <param name="index">The index in the list to get or set an item at. The
            first item in the list has index 0, and the last has index Count-1.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View">
      <summary>
             The OrderedBag&lt;T&gt;.View class is used to look at a subset of the items
             inside an ordered bag. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
      <remarks>
        <p>Views are dynamic. If the underlying bag changes, the view changes in sync. If a change is made
             to the view, the underlying bag changes accordingly.</p>
        <p>Typically, this class is used in conjunction with a foreach statement to enumerate the items 
             in a subset of the OrderedBag. For example:</p>
        <code>
             foreach(T item in bag.Range(from, to)) {
                // process item
             }
            </code>
      </remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View.GetEnumerator">
      <summary>
            Enumerate all the items in this view.
            </summary>
      <returns>An IEnumerator&lt;T&gt; with the items in this view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View.Clear">
      <summary>
            Removes all the items within this view from the underlying bag.
            </summary>
      <example>The following removes all the items that start with "A" from an OrderedBag.
            <code>
            bag.Range("A", "B").Clear();
            </code></example>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View.Add(`0)">
      <summary>
            Adds a new item to the bag underlying this View. If the bag already contains an item equal to
            <paramref name="item" />, that item is replaces with <paramref name="item" />. If
            <paramref name="item" /> is outside the range of this view, an InvalidOperationException
            is thrown.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>Adding an item takes time O(log N), where N is the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to add.</param>
      <returns>True if the bag already contained an item equal to <paramref name="item" /> (which was replaced), false 
            otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View.Remove(`0)">
      <summary>
            Searches the underlying bag for an item equal to <paramref name="item" />, and if found,
            removes it from the bag. If not found, the bag is unchanged. If the item is outside
            the range of this view, the bag is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the bag.</para>
        <para>Removing an item from the bag takes time O(log N), where N is the number of items in the bag.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the bag, or
            was outside the range of this view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View.Contains(`0)">
      <summary>
            Determines if this view of the bag contains an item equal to <paramref name="item" />. The bag
            is not changed. If 
            </summary>
      <remarks>Searching the bag for an item takes time O(log N), where N is the number of items in the bag.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the bag contains <paramref name="item" />, and <paramref name="item" /> is within
            the range of this view. False otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View.IndexOf(`0)">
      <summary>
            Get the first index of the given item in the view. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="item">The item to get the index of.</param>
      <returns>The index of the first item in the view equal to <paramref name="item" />, or -1 if the item is not present
            in the view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View.LastIndexOf(`0)">
      <summary>
            Get the last index of the given item in the view. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="item">The item to get the index of.</param>
      <returns>The index of the last item in the view equal to <paramref name="item" />, or -1 if the item is not present
            in the view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View.AsList">
      <summary>
            Get a read-only list view of the items in this view. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedSet.
            </summary>
      <returns>A read-only IList&lt;T&gt; view onto this view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View.Reversed">
      <summary>
            Creates a new View that has the same items as this view, in the reversed order.
            </summary>
      <returns>A new View that has the reversed order of this view, with the same upper 
            and lower bounds.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View.GetFirst">
      <summary>
            Returns the first item in this view: the item
            that would appear first if the view was enumerated. 
            </summary>
      <remarks>GetFirst() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The first item in the view. </returns>
      <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View.GetLast">
      <summary>
            Returns the last item in the view: the item
            that would appear last if the view was enumerated. 
            </summary>
      <remarks>GetLast() takes time O(log N), where N is the number of items in the bag.</remarks>
      <returns>The last item in the view. </returns>
      <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View.Count">
      <summary>
            Number of items in this view.
            </summary>
      <value>Number of items that lie within the bounds the view.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedBag`1.View.Item(System.Int32)">
      <summary>
            Get the item by its index in the sorted order. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="index">The index to get the item by.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2">
      <summary>
             OrderedDictionary&lt;TKey, TValue&gt; is a collection that maps keys of type TKey
             to values of type TValue. The keys are maintained in a sorted order, and at most one value
             is permitted for each key.
             </summary>
      <remarks>
        <p>The keys are compared in one of three ways. If TKey implements IComparable&lt;TKey&gt; or IComparable,
             then the CompareTo method of that interface will be used to compare elements. Alternatively, a comparison
             function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
        <p>OrderedDictionary is implemented as a balanced binary tree. Inserting, deleting, and looking up an
             an element all are done in log(N) type, where N is the number of keys in the tree.</p>
        <p>
          <see cref="T:System.Collections.Generic.Dictionary`2" /> is similar, but uses hashing instead of comparison, and does not maintain
             the keys in sorted order.</p>
      </remarks>
      <seealso cref="T:System.Collections.Generic.Dictionary`2" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.#ctor">
      <summary>
            Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey&gt;
            or IComparable. 
            The CompareTo method of this interface will be used to compare keys in this dictionary.
            </summary>
      <exception cref="T:System.InvalidOperationException">TKey does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedDictionary. The Compare method of the passed comparison object
            will be used to compare keys in this dictionary.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never
            be called, and need not be implemented.</remarks>
      <param name="comparer">An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.#ctor(System.Comparison{`0})">
      <summary>
            Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.
            </summary>
      <param name="comparison">A delegate to a method that will be used to compare keys.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
        <para>Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey&gt;
            or IComparable. 
            The CompareTo method of this interface will be used to compare keys in this dictionary.</para>
        <para>A collection and keys and values (typically another dictionary) is used to initialized the 
            contents of the dictionary.</para>
      </summary>
      <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
      <exception cref="T:System.InvalidOperationException">TKey does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{`0})">
      <summary>
        <para>Creates a new OrderedDictionary. The Compare method of the passed comparison object
            will be used to compare keys in this dictionary.</para>
        <para>A collection and keys and values (typically another dictionary) is used to initialized the 
            contents of the dictionary.</para>
      </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never
            be called, and need not be implemented.</remarks>
      <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
      <param name="comparer">An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Comparison{`0})">
      <summary>
        <para>Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.</para>
        <para>A collection and keys and values (typically another dictionary) is used to initialized the 
            contents of the dictionary.</para>
      </summary>
      <param name="keysAndValues">A collection of keys and values whose contents are used to initialized the dictionary.</param>
      <param name="comparison">A delegate to a method that will be used to compare keys.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.Clone">
      <summary>
            Makes a shallow clone of this dictionary; i.e., if keys or values of the
            dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the dictionary takes time O(N), where N is the number of keys in the dictionary.</remarks>
      <returns>The cloned dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.CloneContents">
      <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If TKey or TValue is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the dictionary takes time O(N log N), where N is the number of keys in the dictionary.</para>
      </remarks>
      <returns>The cloned dictionary.</returns>
      <exception cref="T:System.InvalidOperationException">TKey or TValue is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.Reversed">
      <summary>
             Returns a View collection that can be used for enumerating the keys and values in the collection in 
             reversed order.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Reversed()) {
                // process pair
             }
            </code></p>
        <p>If an entry is added to or deleted from the dictionary while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Reverse does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <returns>An OrderedDictionary.View of key-value pairs in reverse order.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.Range(`0,System.Boolean,`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than <paramref name="from" /> and 
             less than <paramref name="to" /> are included. The keys are enumerated in sorted order.
             Keys equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive" /> and <paramref name="toInclusive" /> parameters.
             </summary>
      <remarks>
        <p>If <paramref name="from" /> is greater than or equal to <paramref name="to" />, the returned collection is empty. </p>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, true, to, false)) {
                // process pair
             }
            </code>
        <p>Calling Range does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.RangeFrom(`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than (and optionally, equal to) <paramref name="from" /> are included. 
             The keys are enumerated in sorted order. Keys equal to <paramref name="from" /> can be included
             or excluded depending on the <paramref name="fromInclusive" /> parameter.
             </summary>
      <remarks>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, true)) {
                // process pair
             }
            </code>
        <p>Calling RangeFrom does not copy of the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
      <returns>An OrderedDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.RangeTo(`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only items that are less than (and optionally, equal to) <paramref name="to" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to" /> can be included
             or excluded depending on the <paramref name="toInclusive" /> parameter.
             </summary>
      <remarks>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, false)) {
                // process pair
             }
            </code>
        <p>Calling RangeTo does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.Remove(`0)">
      <summary>
            Removes the key (and associated value) from the collection that is equal to the passed in key. If
            no key in the dictionary is equal to the passed key, false is returned and the 
            dictionary is unchanged.
            </summary>
      <remarks>Equality between keys is determined by the comparison instance or delegate used
            to create the dictionary.</remarks>
      <param name="key">The key to remove.</param>
      <returns>True if the key was found and removed. False if the key was not found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.Clear">
      <summary>
            Removes all keys and values from the dictionary.
            </summary>
      <remarks>Clearing the dictionary takes a constant amount of time, regardless of the number of keys in it.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.GetValueElseAdd(`0,`1@)">
      <summary>
            Finds a key in the dictionary. If the dictionary already contains
            a key equal to the passed key, then the existing value is returned via value. If the dictionary
            doesn't contain that key, then value is associated with that key.
            </summary>
      <remarks>
        <para> between keys is determined by the comparison instance or delegate used
            to create the dictionary.</para>
        <para>This method takes time O(log N), where N is the number of keys in the dictionary. If a value is added, It is more efficient than
            calling TryGetValue followed by Add, because the dictionary is not searched twice.</para>
      </remarks>
      <param name="key">The new key. </param>
      <param name="value">The new value to associated with that key, if the key isn't present. If the key was present, 
            returns the exist value associated with that key.</param>
      <returns>True if key was already present, false if key wasn't present (and a new value was added).</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.Add(`0,`1)">
      <summary>
            Adds a new key and value to the dictionary. If the dictionary already contains
            a key equal to the passed key, then an ArgumentException is thrown
            </summary>
      <remarks>
        <para>Equality between keys is determined by the comparison instance or delegate used
            to create the dictionary.</para>
        <para>Adding an key and value takes time O(log N), where N is the number of keys in the dictionary.</para>
      </remarks>
      <param name="key">The new key. "null" is a valid key value.</param>
      <param name="value">The new value to associated with that key.</param>
      <exception cref="T:System.ArgumentException">key is already present in the dictionary</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.Replace(`0,`1)">
      <summary>
            Changes the value associated with a given key. If the dictionary does not contain
            a key equal to the passed key, then an ArgumentException is thrown.
            </summary>
      <remarks>
        <p>Unlike adding or removing an element, changing the value associated with a key
            can be performed while an enumeration (foreach) on the the dictionary is in progress.</p>
        <p>Equality between keys is determined by the comparison instance or delegate used
            to create the dictionary.</p>
        <p>Replace takes time O(log N), where N is the number of entries in the dictionary.</p>
      </remarks>
      <param name="key">The new key. </param>
      <param name="value">The new value to associated with that key.</param>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">key is not present in the dictionary</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.AddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
      <summary>
            Adds multiple key-value pairs to a dictionary. If a key exists in both the current instance and dictionaryToAdd,
            then the value is updated with the value from <paramref name="keysAndValues" /> (no exception is thrown).
            Since IDictionary&lt;TKey,TValue&gt; inherits from IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;, this
            method can be used to merge one dictionary into another.
            </summary>
      <remarks>AddMany takes time O(M log (N+M)), where M is the size of <paramref name="keysAndValues" />, and N is the size of
            this dictionary.</remarks>
      <param name="keysAndValues">A collection of keys and values whose contents are added to the current dictionary.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the keys found in another collection (such as an array or List&lt;TKey&gt;). Each key in keyCollectionToRemove
            is removed from the dictionary. Keys that are not present are ignored.
            </summary>
      <remarks>RemoveMany takes time O(M log N), where M is the size of keyCollectionToRemove, and N is this
            size of this collection.</remarks>
      <returns>The number of keys removed from the dictionary.</returns>
      <param name="keyCollectionToRemove">A collection of keys to remove from the dictionary.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.ContainsKey(`0)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. The dictionary
            is not changed.
            </summary>
      <remarks>Searching the dictionary for a key takes time O(log N), where N is the number of keys in the dictionary.</remarks>
      <param name="key">The key to search for.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.TryGetValue(`0,`1@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, the value
            associated with that key is returned through the value parameter.
            </summary>
      <remarks>TryGetValue takes time O(log N), where N is the number of entries in the dictionary.</remarks>
      <param name="key">The key to search for.</param>
      <param name="value">Returns the value associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the entries in the dictionary. Each entry is 
            returned as a KeyValuePair&lt;TKey,TValue&gt;.
            The entries are enumerated in the sorted order of the keys.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the elements of the dictionary, which uses this method implicitly.</p>
        <p>If an element is added to or deleted from the dictionary while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumeration all the entries in the dictionary takes time O(N log N), where N is the number
            of entries in the dictionary.</p>
      </remarks>
      <returns>An enumerator for enumerating all the elements in the OrderedDictionary.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.Comparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TKey (Comparer&lt;TKey&gt;.Default) is returned.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.Item(`0)">
      <summary>
            Gets or sets the value associated with a given key. When getting a value, if this
            key is not found in the collection, then an ArgumentException is thrown. When setting
            a value, the value replaces any existing value in the dictionary.
            </summary>
      <remarks>The indexer takes time O(log N), where N is the number of entries in the dictionary.</remarks>
      <value>The value associated with the key</value>
      <exception cref="T:System.ArgumentException">A value is being retrieved, and the key is not present in the dictionary.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="key" /> is null.</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.Count">
      <summary>
            Returns the number of keys in the dictionary.
            </summary>
      <remarks>The size of the dictionary is returned in constant time..</remarks>
      <value>The number of keys in the dictionary.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.View">
      <summary>
             The OrderedDictionary&lt;TKey,TValue&gt;.View class is used to look at a subset of the keys and values
             inside an ordered dictionary. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
      <remarks>
        <p>Views are dynamic. If the underlying dictionary changes, the view changes in sync. If a change is made
             to the view, the underlying dictionary changes accordingly.</p>
        <p>Typically, this class is used in conjunction with a foreach statement to enumerate the keys
             and values in a subset of the OrderedDictionary. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, to)) {
                // process pair
             }
            </code>
      </remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.View.GetEnumerator">
      <summary>
            Enumerate all the keys and values in this view.
            </summary>
      <returns>An IEnumerator of KeyValuePairs with the keys and views in this view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.View.ContainsKey(`0)">
      <summary>
            Tests if the key is present in the part of the dictionary being viewed.
            </summary>
      <param name="key">Key to check for.</param>
      <returns>True if the key is within this view. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.View.TryGetValue(`0,`1@)">
      <summary>
            Determines if this view contains a key equal to <paramref name="key" />. If so, the value
            associated with that key is returned through the value parameter. 
            </summary>
      <param name="key">The key to search for.</param>
      <param name="value">Returns the value associated with key, if true was returned.</param>
      <returns>True if the key is within this view. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.View.Remove(`0)">
      <summary>
            Removes the key (and associated value) from the underlying dictionary of this view. that is equal to the passed in key. If
            no key in the view is equal to the passed key, the dictionary and view are unchanged.
            </summary>
      <param name="key">The key to remove.</param>
      <returns>True if the key was found and removed. False if the key was not found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.View.Clear">
      <summary>
            Removes all the keys and values within this view from the underlying OrderedDictionary.
            </summary>
      <example>The following removes all the keys that start with "A" from an OrderedDictionary.
            <code>
            dictionary.Range("A", "B").Clear();
            </code></example>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.View.Reversed">
      <summary>
            Creates a new View that has the same keys and values as this, in the reversed order.
            </summary>
      <returns>A new View that has the reversed order of this view.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.View.Count">
      <summary>
            Number of keys in this view.
            </summary>
      <value>Number of keys that lie within the bounds the view.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2.View.Item(`0)">
      <summary>
            Gets or sets the value associated with a given key. When getting a value, if this
            key is not found in the collection, then an ArgumentException is thrown. When setting
            a value, the value replaces any existing value in the dictionary. When setting a value, the 
            key must be within the range of keys being viewed.
            </summary>
      <value>The value associated with the key.</value>
      <exception cref="T:System.ArgumentException">A value is being retrieved, and the key is not present in the dictionary, 
            or a value is being set, and the key is outside the range of keys being viewed by this View.</exception>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2">
      <summary>
        <para>The OrderedMultiDictionary class that associates values with a key. Unlike an OrderedDictionary,
             each key can have multiple values associated with it. When indexing an OrderedMultidictionary, instead
             of a single value associated with a key, you retrieve an enumeration of values.</para>
        <para>All of the key are stored in sorted order. Also, the values associated with a given key 
             are kept in sorted order as well.</para>
        <para>When constructed, you can chose to allow the same value to be associated with a key multiple
             times, or only one time. </para>
      </summary>
      <typeparam name="TKey">The type of the keys.</typeparam>
      <typeparam name="TValue">The of values associated with the keys.</typeparam>
      <seealso cref="T:NSoft.NFramework.Collections.PowerCollections.OrderedDictionary`2" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean)">
      <summary>
            Create a new OrderedMultiDictionary. The default ordering of keys and values are used. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <remarks>The default ordering of keys and values will be used, as defined by TKey and TValue's implementation
            of IComparable&lt;T&gt; (or IComparable if IComparable&lt;T&gt; is not implemented). If a different ordering should be
            used, other constructors allow a custom Comparer or IComparer to be passed to changed the ordering.</remarks>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <exception cref="T:System.InvalidOperationException">TKey or TValue does not implement either IComparable&lt;T&gt; or IComparable.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Comparison{`0})">
      <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyComparison">A delegate to a method that will be used to compare keys.</param>
      <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Comparison{`0},System.Comparison{`1})">
      <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyComparison">A delegate to a method that will be used to compare keys.</param>
      <param name="valueComparison">A delegate to a method that will be used to compare values.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IComparer{`0})">
      <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <exception cref="T:System.InvalidOperationException">TValue does not implement either IComparable&lt;TValue&gt; or IComparable.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.#ctor(System.Boolean,System.Collections.Generic.IComparer{`0},System.Collections.Generic.IComparer{`1})">
      <summary>
            Create a new OrderedMultiDictionary. If duplicate values
            are allowed, multiple copies of the same value can be associated with the same key. For example, the key "foo"
            could have "a", "a", and "b" associated with it. If duplicate values are not allowed, only one copies of a given value can
            be associated with the same key, although different keys can have the same value. For example, the key "foo" could
            have "a" and "b" associated with it, which key "bar" has values "b" and "c" associated with it.
            </summary>
      <param name="allowDuplicateValues">Can the same value be associated with a key multiple times?</param>
      <param name="keyComparer">An IComparer&lt;TKey&gt; instance that will be used to compare keys.</param>
      <param name="valueComparer">An IComparer&lt;TValue&gt; instance that will be used to compare values.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.Add(`0,`1)">
      <summary>
        <para>Adds a new value to be associated with a key. If duplicate values are permitted, this
            method always adds a new key-value pair to the dictionary.</para>
        <para>If duplicate values are not permitted, and <paramref name="key" /> already has a value
            equal to <paramref name="value" /> associated with it, then that value is replaced with <paramref name="value" />,
            and the number of values associate with <paramref name="key" /> is unchanged.</para>
      </summary>
      <param name="key">The key to associate with.</param>
      <param name="value">The value to associated with <paramref name="key" />.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.Remove(`0,`1)">
      <summary>
            Removes a given value from the values associated with a key. If the
            last value is removed from a key, the key is removed also.
            </summary>
      <param name="key">A key to remove a value from.</param>
      <param name="value">The value to remove.</param>
      <returns>True if <paramref name="value" /> was associated with <paramref name="key" /> (and was
            therefore removed). False if <paramref name="value" /> was not associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.Remove(`0)">
      <summary>
            Removes a key and all associated values from the dictionary. If the
            key is not present in the dictionary, it is unchanged and false is returned.
            </summary>
      <param name="key">The key to remove.</param>
      <returns>True if the key was present and was removed. Returns 
            false if the key was not present.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.Clear">
      <summary>
            Removes all keys and values from the dictionary.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.EqualValues(`1,`1)">
      <summary>
            Determine if two values are equal.
            </summary>
      <param name="value1">First value to compare.</param>
      <param name="value2">Second value to compare.</param>
      <returns>True if the values are equal.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.Contains(`0,`1)">
      <summary>
            Checks to see if <paramref name="value" /> is associated with <paramref name="key" />
            in the dictionary.
            </summary>
      <param name="key">The key to check.</param>
      <param name="value">The value to check.</param>
      <returns>True if <paramref name="value" /> is associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.ContainsKey(`0)">
      <summary>
            Checks to see if the key is present in the dictionary and has
            at least one value associated with it.
            </summary>
      <param name="key">The key to check.</param>
      <returns>True if <paramref name="key" /> is present and has at least
            one value associated with it. Returns false otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, all the values
            associated with that key are returned through the values parameter. 
            </summary>
      <param name="key">The key to search for.</param>
      <param name="values">Returns all values associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.EnumerateKeys">
      <summary>
            Enumerate all of the keys in the dictionary.
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; of all of the keys in the dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.CountValues(`0)">
      <summary>
            Gets the number of values associated with a given key.
            </summary>
      <param name="key">The key to count values of.</param>
      <returns>The number of values associated with <paramref name="key" />. If <paramref name="key" />
            is not present in the dictionary, zero is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.CountAllValues">
      <summary>
            Gets a total count of values in the collection. 
            </summary>
      <returns>The total number of values associated with all keys in the dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.Clone">
      <summary>
            Makes a shallow clone of this dictionary; i.e., if keys or values of the
            dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the dictionary takes time O(N), where N is the number of key-value pairs in the dictionary.</remarks>
      <returns>The cloned dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.CloneContents">
      <summary>
            Makes a deep clone of this dictionary. A new dictionary is created with a clone of
            each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If TKey or TValue is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the dictionary takes time O(N log N), where N is the number of key-value pairs in the dictionary.</para>
      </remarks>
      <returns>The cloned dictionary.</returns>
      <exception cref="T:System.InvalidOperationException">TKey or TValue is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.Reversed">
      <summary>
             Returns a View collection that can be used for enumerating the keys and values in the collection in 
             reversed order.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Reversed()) {
                // process pair
             }
            </code></p>
        <p>If an entry is added to or deleted from the dictionary while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Reverse does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <returns>An OrderedDictionary.View of key-value pairs in reverse order.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.Range(`0,System.Boolean,`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than <paramref name="from" /> and 
             less than <paramref name="to" /> are included. The keys are enumerated in sorted order.
             Keys equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive" /> and <paramref name="toInclusive" /> parameters.
             </summary>
      <remarks>
        <p>If <paramref name="from" /> is greater than or equal to <paramref name="to" />, the returned collection is empty. </p>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, true, to, false)) {
                // process pair
             }
            </code>
        <p>Calling Range does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedMultiDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.RangeFrom(`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only keys that are greater than (and optionally, equal to) <paramref name="from" /> are included. 
             The keys are enumerated in sorted order. Keys equal to <paramref name="from" /> can be included
             or excluded depending on the <paramref name="fromInclusive" /> parameter.
             </summary>
      <remarks>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, true)) {
                // process pair
             }
            </code>
        <p>Calling RangeFrom does not copy of the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--keys equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
             be included in the range.</param>
      <returns>An OrderedMultiDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.RangeTo(`0,System.Boolean)">
      <summary>
             Returns a collection that can be used for enumerating some of the keys and values in the collection. 
             Only items that are less than (and optionally, equal to) <paramref name="to" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to" /> can be included
             or excluded depending on the <paramref name="toInclusive" /> parameter.
             </summary>
      <remarks>
        <p>The sorted order of the keys is determined by the comparison instance or delegate used
             to create the dictionary.</p>
        <p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.RangeFrom(from, false)) {
                // process pair
             }
            </code>
        <p>Calling RangeTo does not copy the data in the dictionary, and the operation takes constant time.</p>
      </remarks>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--keys equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedMultiDictionary.View of key-value pairs in the given range.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.KeyComparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare keys in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TKey (Comparer&lt;TKey&gt;.Default) is returned.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.ValueComparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare values in this dictionary. 
            </summary>
      <value>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for TValue (Comparer&lt;TValue&gt;.Default) is returned.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.Count">
      <summary>
            Gets the number of key-value pairs in the dictionary. Each value associated
            with a given key is counted. If duplicate values are permitted, each duplicate
            value is included in the count.
            </summary>
      <value>The number of key-value pairs in the dictionary.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.KeyValuePairs">
      <summary>
            Gets a read-only collection of all key-value pairs in the dictionary. If a key has multiple
            values associated with it, then a key-value pair is present for each value associated
            with the key.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.View">
      <summary>
             The OrderedMultiDictionary&lt;TKey,TValue&gt;.View class is used to look at a subset of the keys and values
             inside an ordered multi-dictionary. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
      <remarks>
        <p>Views are dynamic. If the underlying dictionary changes, the view changes in sync. If a change is made
             to the view, the underlying dictionary changes accordingly.</p>
        <p>Typically, this class is used in conjunction with a foreach statement to enumerate the keys
             and values in a subset of the OrderedMultiDictionary. For example:</p>
        <code>
             foreach(KeyValuePair&lt;TKey, TValue&gt; pair in dictionary.Range(from, to)) {
                // process pair
             }
            </code>
      </remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.View.EnumerateKeys">
      <summary>
            Enumerate all the keys in the dictionary. 
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.View.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
      <summary>
            Enumerate all of the values associated with a given key. If the key exists and has values associated with it, an enumerator for those
            values is returned throught <paramref name="values" />. If the key does not exist, false is returned.
            </summary>
      <param name="key">The key to get values for.</param>
      <param name="values">If true is returned, this parameter receives an enumerators that
            enumerates the values associated with that key.</param>
      <returns>True if the key exists and has values associated with it. False otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.View.ContainsKey(`0)">
      <summary>
            Tests if the key is present in the part of the dictionary being viewed.
            </summary>
      <param name="key">Key to check</param>
      <returns>True if the key is within this view. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.View.Contains(`0,`1)">
      <summary>
            Tests if the key-value pair is present in the part of the dictionary being viewed.
            </summary>
      <param name="key">Key to check for.</param>
      <param name="value">Value to check for.</param>
      <returns>True if the key-value pair is within this view. </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.View.CountValues(`0)">
      <summary>
            Gets the number of values associated with a given key.
            </summary>
      <param name="key">The key to count values of.</param>
      <returns>The number of values associated with <paramref name="key" />. If <paramref name="key" />
            is not present in this view, zero is returned.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.View.Add(`0,`1)">
      <summary>
            Adds the given key-value pair to the underlying dictionary of this view.
            If <paramref name="key" /> is not within the range of this view, an
            ArgumentException is thrown.
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="key" /> is not 
            within the range of this view.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.View.Remove(`0)">
      <summary>
            Removes the key (and associated value) from the underlying dictionary of this view. If
            no key in the view is equal to the passed key, the dictionary and view are unchanged.
            </summary>
      <param name="key">The key to remove.</param>
      <returns>True if the key was found and removed. False if the key was not found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.View.Remove(`0,`1)">
      <summary>
            Removes the key and value from the underlying dictionary of this view. that is equal to the passed in key. If
            no key in the view is equal to the passed key, or has the given value associated with it, the dictionary and view are unchanged.
            </summary>
      <param name="key">The key to remove.</param>
      <param name="value">The value to remove.</param>
      <returns>True if the key-value pair was found and removed. False if the key-value pair was not found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.View.Clear">
      <summary>
            Removes all the keys and values within this view from the underlying OrderedMultiDictionary.
            </summary>
      <example>The following removes all the keys that start with "A" from an OrderedMultiDictionary.
            <code>
            dictionary.Range("A", "B").Clear();
            </code></example>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.View.Reversed">
      <summary>
            Creates a new View that has the same keys and values as this, in the reversed order.
            </summary>
      <returns>A new View that has the reversed order of this view.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedMultiDictionary`2.View.Count">
      <summary>
            Number of keys in this view.
            </summary>
      <value>Number of keys that lie within the bounds the view.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1">
      <summary>
             OrderedSet&lt;T&gt; is a collection that contains items of type T. 
             The item are maintained in a sorted order, and duplicate items are not allowed. Each item has
             an index in the set: the smallest item has index 0, the next smallest item has index 1,
             and so forth.
             </summary>
      <remarks>
        <p>The items are compared in one of three ways. If T implements IComparable&lt;TKey&gt; or IComparable,
             then the CompareTo method of that interface will be used to compare items. Alternatively, a comparison
             function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey&gt;.</p>
        <p>OrderedSet is implemented as a balanced binary tree. Inserting, deleting, and looking up an
             an element all are done in log(N) type, where N is the number of keys in the tree.</p>
        <p>
          <see cref="T:NSoft.NFramework.Collections.PowerCollections.Set`1" /> is similar, but uses hashing instead of comparison, and does not maintain
             the items in sorted order.</p>
      </remarks>
      <seealso cref="T:NSoft.NFramework.Collections.PowerCollections.Set`1" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.#ctor">
      <summary>
             Creates a new OrderedSet. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this set.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.#ctor(System.Comparison{`0})">
      <summary>
            Creates a new OrderedSet. The passed delegate will be used to compare items in this set.
            </summary>
      <param name="comparison">A delegate to a method that will be used to compare items.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedSet. The Compare method of the passed comparison object
            will be used to compare items in this set.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
      <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Creates a new OrderedSet. The T must implement IComparable&lt;T&gt;
             or IComparable. 
             The CompareTo method of this interface will be used to compare items in this set. The set is
             initialized with all the items in the given collection.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
      <param name="collection">A collection with items to be placed into the OrderedSet.</param>
      <exception cref="T:System.InvalidOperationException">T does not implement IComparable&lt;TKey&gt;.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Comparison{`0})">
      <summary>
            Creates a new OrderedSet. The passed delegate will be used to compare items in this set.
            The set is initialized with all the items in the given collection.
            </summary>
      <param name="collection">A collection with items to be placed into the OrderedSet.</param>
      <param name="comparison">A delegate to a method that will be used to compare items.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
      <summary>
            Creates a new OrderedSet. The Compare method of the passed comparison object
            will be used to compare items in this set. The set is
            initialized with all the items in the given collection.
            </summary>
      <remarks>
            The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
            be called, and need not be implemented.
            </remarks>
      <param name="collection">A collection with items to be placed into the OrderedSet.</param>
      <param name="comparer">An instance of IComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.Clone">
      <summary>
            Makes a shallow clone of this set; i.e., if items of the
            set are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the set takes time O(N), where N is the number of items in the set.</remarks>
      <returns>The cloned set.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.CloneContents">
      <summary>
            Makes a deep clone of this set. A new set is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the set takes time O(N log N), where N is the number of items in the set.</para>
      </remarks>
      <returns>The cloned set.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the items in the set. 
            The items are enumerated in sorted order.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
        <p>If an item is added to or deleted from the set while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumeration all the items in the set takes time O(N log N), where N is the number
            of items in the set.</p>
      </remarks>
      <returns>An enumerator for enumerating all the items in the OrderedSet.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.Contains(`0)">
      <summary>
            Determines if this set contains an item equal to <paramref name="item" />. The set
            is not changed.
            </summary>
      <remarks>Searching the set for an item takes time O(log N), where N is the number of items in the set.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the set contains <paramref name="item" />. False if the set does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.TryGetItem(`0,`0@)">
      <summary>
        <para>Determines if this set contains an item equal to <paramref name="item" />, according to the 
            comparison mechanism that was used when the set was created. The set
            is not changed.</para>
        <para>If the set does contain an item equal to <paramref name="item" />, then the item from the set is returned.</para>
      </summary>
      <remarks>Searching the set for an item takes time O(log N), where N is the number of items in the set.</remarks>
      <example>
            In the following example, the set contains strings which are compared in a case-insensitive manner. 
            <code>
            OrderedSet&lt;string&gt; set = new OrderedSet&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase);
            set.Add("HELLO");
            string s;
            bool b = set.TryGetItem("Hello", out s);   // b receives true, s receives "HELLO".
            </code></example>
      <param name="item">The item to search for.</param>
      <param name="foundItem">Returns the item from the set that was equal to <paramref name="item" />.</param>
      <returns>True if the set contains <paramref name="item" />. False if the set does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.IndexOf(`0)">
      <summary>
            Get the index of the given item in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="item">The item to get the index of.</param>
      <returns>The index of the item in the sorted set, or -1 if the item is not present
            in the set.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.Add(`0)">
      <summary>
            Adds a new item to the set. If the set already contains an item equal to
            <paramref name="item" />, that item is replaced with <paramref name="item" />.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Adding an item takes time O(log N), where N is the number of items in the set.</para>
      </remarks>
      <param name="item">The item to add to the set.</param>
      <returns>True if the set already contained an item equal to <paramref name="item" /> (which was replaced), false 
            otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds all the items in <paramref name="collection" /> to the set. If the set already contains an item equal to
            one of the items in <paramref name="collection" />, that item will be replaced.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Adding the collection takes time O(M log N), where N is the number of items in the set, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to add to the set.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.Remove(`0)">
      <summary>
            Searches the set for an item equal to <paramref name="item" />, and if found,
            removes it from the set. If not found, the set is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Removing an item from the set takes time O(log N), where N is the number of items in the set.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the set.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the items in <paramref name="collection" /> from the set. Items
            not present in the set are ignored.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Removing the collection takes time O(M log N), where N is the number of items in the set, and M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to remove from the set.</param>
      <returns>The number of items removed from the set.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.Clear">
      <summary>
            Removes all items from the set.
            </summary>
      <remarks>Clearing the sets takes a constant amount of time, regardless of the number of items in it.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.GetFirst">
      <summary>
            Returns the first item in the set: the item
            that would appear first if the set was enumerated. This is also
            the smallest item in the set.
            </summary>
      <remarks>GetFirst() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The first item in the set. </returns>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.GetLast">
      <summary>
            Returns the lastl item in the set: the item
            that would appear last if the set was enumerated. This is also the
            largest item in the set.
            </summary>
      <remarks>GetLast() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The lastl item in the set. </returns>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.RemoveFirst">
      <summary>
            Removes the first item in the set. This is also the smallest item in the set.
            </summary>
      <remarks>RemoveFirst() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The item that was removed, which was the smallest item in the set. </returns>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.RemoveLast">
      <summary>
            Removes the last item in the set. This is also the largest item in the set.
            </summary>
      <remarks>RemoveLast() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The item that was removed, which was the largest item in the set. </returns>
      <exception cref="T:System.InvalidOperationException">The set is empty.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.IsSupersetOf(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Determines if this set is a superset of another set. Neither set is modified.
            This set is a superset of <paramref name="otherSet" /> if every element in
            <paramref name="otherSet" /> is also in this set.
            <remarks>IsSupersetOf is computed in time O(M log N), where M is the size of the 
            <paramref name="otherSet" />, and N is the size of the this set.</remarks></summary>
      <param name="otherSet">OrderedSet to compare to.</param>
      <returns>True if this is a superset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.IsProperSupersetOf(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Determines if this set is a proper superset of another set. Neither set is modified.
            This set is a proper superset of <paramref name="otherSet" /> if every element in
            <paramref name="otherSet" /> is also in this set.
            Additionally, this set must have strictly more items than <paramref name="otherSet" />.
            </summary>
      <remarks>IsProperSupersetOf is computed in time O(M log N), where M is the number of unique items in 
            <paramref name="otherSet" />.</remarks>
      <param name="otherSet">OrderedSet to compare to.</param>
      <returns>True if this is a proper superset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.IsSubsetOf(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Determines if this set is a subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet" /> if every element in this set
            is also in <paramref name="otherSet" />.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref name="otherSet" />, and N is the size of the this set.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a subset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.IsProperSubsetOf(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Determines if this set is a proper subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet" /> if every element in this set
            is also in <paramref name="otherSet" />. Additionally, this set must have strictly 
            fewer items than <paramref name="otherSet" />.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N log M), where M is the size of the 
            <paramref name="otherSet" />, and N is the size of the this set.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a proper subset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.IsEqualTo(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Determines if this set is equal to another set. This set is equal to
            <paramref name="otherSet" /> if they contain the same items.
            </summary>
      <remarks>IsEqualTo is computed in time O(N), where N is the number of items in 
            this set.</remarks>
      <param name="otherSet">Set to compare to</param>
      <returns>True if this set is equal to <paramref name="otherSet" />, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.UnionWith(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. This set receives
            the union of the two sets, the other set is unchanged.
            </summary>
      <remarks>
        <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The union of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to union with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.IsDisjointFrom(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Determines if this set is disjoint from another set. Two sets are disjoint
            if no item from one set is equal to any item in the other set.
            </summary>
      <remarks>
        <para>The answer is computed in time O(N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to check disjointness with.</param>
      <returns>True if the two sets are disjoint, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.Union(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. A new set is 
            created with the union of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The union of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to union with.</param>
      <returns>The union of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.IntersectionWith(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. This set receives
            the intersection of the two sets, the other set is unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two sets is computed in time O(N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to intersection with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.Intersection(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. A new set is 
            created with the intersection of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two sets is computed in time O(N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to intersection with.</param>
      <returns>The intersection of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.DifferenceWith(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet" />. This set receives
            the difference of the two sets; the other set is unchanged.
            </summary>
      <remarks>
        <para>The difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to difference with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.Difference(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet" />. A new set is 
            created with the difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>The difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to difference with.</param>
      <returns>The difference of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.SymmetricDifferenceWith(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. This set receives
            the symmetric difference of the two sets; the other set is unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to symmetric difference with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.SymmetricDifference(NSoft.NFramework.Collections.PowerCollections.OrderedSet{`0})">
      <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. A new set is 
            created with the symmetric difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to symmetric difference with.</param>
      <returns>The symmetric difference of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.AsList">
      <summary>
            Get a read-only list view of the items in this ordered set. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedSet.
            </summary>
      <returns>A read-only IList&lt;T&gt; view onto this OrderedSet.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.Reversed">
      <summary>
             Returns a View collection that can be used for enumerating the items in the set in 
             reversed order.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.Reversed()) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Reverse does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <returns>An OrderedSet.View of items in reverse order.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.Range(`0,System.Boolean,`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the set..
             Only items that are greater than <paramref name="from" /> and 
             less than <paramref name="to" /> are included. The items are enumerated in sorted order.
             Items equal to the end points of the range can be included or excluded depending on the
             <paramref name="fromInclusive" /> and <paramref name="toInclusive" /> parameters.
             </summary>
      <remarks>
        <p>If <paramref name="from" /> is greater than <paramref name="to" />, the returned collection is empty. </p>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.Range(from, true, to, false)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling Range does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedSet.View of items in the given range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.RangeFrom(`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the set..
             Only items that are greater than (and optionally, equal to) <paramref name="from" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="from" /> can be included
             or excluded depending on the <paramref name="fromInclusive" /> parameter.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.RangeFrom(from, true)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling RangeFrom does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="from">The lower bound of the range.</param>
      <param name="fromInclusive">If true, the lower bound is inclusive--items equal to the lower bound will
             be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
             be included in the range.</param>
      <returns>An OrderedSet.View of items in the given range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.RangeTo(`0,System.Boolean)">
      <summary>
             Returns a View collection that can be used for enumerating a range of the items in the set..
             Only items that are less than (and optionally, equal to) <paramref name="to" /> are included. 
             The items are enumerated in sorted order. Items equal to <paramref name="to" /> can be included
             or excluded depending on the <paramref name="toInclusive" /> parameter.
             </summary>
      <remarks>
        <p>Typically, this method is used in conjunction with a foreach statement. For example:
            <code>
             foreach(T item in set.RangeTo(to, false)) {
                // process item
             }
            </code></p>
        <p>If an item is added to or deleted from the set while the View is being enumerated, then 
             the enumeration will end with an InvalidOperationException.</p>
        <p>Calling RangeTo does not copy the data in the tree, and the operation takes constant time.</p>
      </remarks>
      <param name="to">The upper bound of the range. </param>
      <param name="toInclusive">If true, the upper bound is inclusive--items equal to the upper bound will
             be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
             be included in the range.</param>
      <returns>An OrderedSet.View of items in the given range.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.Comparer">
      <summary>
            Returns the IComparer&lt;T&gt; used to compare items in this set. 
            </summary>
      <value>If the set was created using a comparer, that comparer is returned. If the set was
            created using a comparison delegate, then a comparer equivalent to that delegate
            is returned. Otherwise
            the default comparer for T (Comparer&lt;T&gt;.Default) is returned.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.Count">
      <summary>
            Returns the number of items in the set.
            </summary>
      <remarks>The size of the set is returned in constant time.</remarks>
      <value>The number of items in the set.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.Item(System.Int32)">
      <summary>
            Get the item by its index in the sorted order. The smallest item has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="index">The index to get the item by.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.View">
      <summary>
             The OrderedSet&lt;T&gt;.View class is used to look at a subset of the Items
             inside an ordered set. It is returned from the Range, RangeTo, RangeFrom, and Reversed methods. 
             </summary>
      <remarks>
        <p>Views are dynamic. If the underlying set changes, the view changes in sync. If a change is made
             to the view, the underlying set changes accordingly.</p>
        <p>Typically, this class is used in conjunction with a foreach statement to enumerate the items 
             in a subset of the OrderedSet. For example:</p>
        <code>
             foreach(T item in set.Range(from, to)) {
                // process item
             }
            </code>
      </remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.View.GetEnumerator">
      <summary>
            Enumerate all the items in this view.
            </summary>
      <returns>An IEnumerator&lt;T&gt; with the items in this view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.View.Clear">
      <summary>
            Removes all the items within this view from the underlying set.
            </summary>
      <example>The following removes all the items that start with "A" from an OrderedSet.
            <code>
            set.Range("A", "B").Clear();
            </code></example>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.View.Add(`0)">
      <summary>
            Adds a new item to the set underlying this View. If the set already contains an item equal to
            <paramref name="item" />, that item is replaces with <paramref name="item" />. If
            <paramref name="item" /> is outside the range of this view, an InvalidOperationException
            is thrown.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Adding an item takes time O(log N), where N is the number of items in the set.</para>
      </remarks>
      <param name="item">The item to add.</param>
      <returns>True if the set already contained an item equal to <paramref name="item" /> (which was replaced), false 
            otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.View.Remove(`0)">
      <summary>
            Searches the underlying set for an item equal to <paramref name="item" />, and if found,
            removes it from the set. If not found, the set is unchanged. If the item is outside
            the range of this view, the set is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Removing an item from the set takes time O(log N), where N is the number of items in the set.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the set, or
            was outside the range of this view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.View.Contains(`0)">
      <summary>
            Determines if this view of the set contains an item equal to <paramref name="item" />. The set
            is not changed. If 
            </summary>
      <remarks>Searching the set for an item takes time O(log N), where N is the number of items in the set.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the set contains <paramref name="item" />, and <paramref name="item" /> is within
            the range of this view. False otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.View.IndexOf(`0)">
      <summary>
            Get the index of the given item in the view. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>Finding the index takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="item">The item to get the index of.</param>
      <returns>The index of the item in the view, or -1 if the item is not present
            in the view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.View.AsList">
      <summary>
            Get a read-only list view of the items in this view. The
            items in the list are in sorted order, with the smallest item
            at index 0. This view does not copy any data, and reflects any
            changes to the underlying OrderedSet.
            </summary>
      <returns>A read-only IList&lt;T&gt; view onto this view.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.View.Reversed">
      <summary>
            Creates a new View that has the same items as this view, in the reversed order.
            </summary>
      <returns>A new View that has the reversed order of this view, with the same upper 
            and lower bounds.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.View.GetFirst">
      <summary>
            Returns the first item in this view: the item
            that would appear first if the view was enumerated. 
            </summary>
      <remarks>GetFirst() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The first item in the view. </returns>
      <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.View.GetLast">
      <summary>
            Returns the last item in the view: the item
            that would appear last if the view was enumerated. 
            </summary>
      <remarks>GetLast() takes time O(log N), where N is the number of items in the set.</remarks>
      <returns>The last item in the view. </returns>
      <exception cref="T:System.InvalidOperationException">The view has no items in it.</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.View.Count">
      <summary>
            Number of items in this view.
            </summary>
      <value>Number of items that lie within the bounds the view.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1.View.Item(System.Int32)">
      <summary>
            Get the item by its index in the sorted order. The smallest item in the view has index 0,
            the next smallest item has index 1, and the largest item has index Count-1. 
            </summary>
      <remarks>The indexer takes time O(log N), which N is the number of items in 
            the set.</remarks>
      <param name="index">The index to get the item by.</param>
      <returns>The item at the given index.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is
            less than zero or greater than or equal to Count.</exception>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.Pair`2">
      <summary>
            Stores a pair of objects within a single struct. This struct is useful to use as the
            T of a collection, or as the TKey or TValue of a dictionary.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.PowerCollections.Pair`2.First">
      <summary>
            The first element of the pair.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.PowerCollections.Pair`2.Second">
      <summary>
            The second element of the pair.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Pair`2.#ctor(`0,`1)">
      <summary>
            Creates a new pair with given first and second elements.
            </summary>
      <param name="first">The first element of the pair.</param>
      <param name="second">The second element of the pair.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Pair`2.#ctor(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Creates a new pair using elements from a KeyValuePair structure. The
            First element gets the Key, and the Second elements gets the Value.
            </summary>
      <param name="keyAndValue">The KeyValuePair to initialize the Pair with .</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Pair`2.Equals(System.Object)">
      <summary>
            Determines if this pair is equal to another object. The pair is equal to another object 
            if that object is a Pair, both element types are the same, and the first and second elements
            both compare equal using object.Equals.
            </summary>
      <param name="obj">Object to compare for equality.</param>
      <returns>True if the objects are equal. False if the objects are not equal.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Pair`2.Equals(NSoft.NFramework.Collections.PowerCollections.Pair{`0,`1})">
      <summary>
            Determines if this pair is equal to another pair. The pair is equal if  the first and second elements
            both compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="other">Pair to compare with for equality.</param>
      <returns>True if the pairs are equal. False if the pairs are not equal.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Pair`2.GetHashCode">
      <summary>
            Returns a hash code for the pair, suitable for use in a hash-table or other hashed collection.
            Two pairs that compare equal (using Equals) will have the same hash code. The hash code for
            the pair is derived by combining the hash codes for each of the two elements of the pair.
            </summary>
      <returns>The hash code.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Pair`2.CompareTo(NSoft.NFramework.Collections.PowerCollections.Pair{`0,`1})">
      <summary>
        <para> Compares this pair to another pair of the some type. The pairs are compared by using
            the IComparable&lt;T&gt; or IComparable interface on TFirst and TSecond. The pairs
            are compared by their first elements first, if their first elements are equal, then they
            are compared by their second elements.</para>
        <para>If either TFirst or TSecond does not implement IComparable&lt;T&gt; or IComparable, then
            an NotSupportedException is thrown, because the pairs cannot be compared.</para>
      </summary>
      <param name="other">The pair to compare to.</param>
      <returns>An integer indicating how this pair compares to <paramref name="other" />. Less
            than zero indicates this pair is less than <paramref name="other" />. Zero indicate this pair is
            equals to <paramref name="other" />. Greater than zero indicates this pair is greater than
            <paramref name="other" />.</returns>
      <exception cref="T:System.NotSupportedException">Either FirstSecond or TSecond is not comparable
            via the IComparable&lt;T&gt; or IComparable interfaces.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Pair`2.ToString">
      <summary>
            Returns a string representation of the pair. The string representation of the pair is
            of the form:
            <c>First: {0}, Second: {1}</c>
            where {0} is the result of First.ToString(), and {1} is the result of Second.ToString() (or
            "null" if they are null.)
            </summary>
      <returns> The string representation of the pair.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Pair`2.op_Equality(NSoft.NFramework.Collections.PowerCollections.Pair{`0,`1},NSoft.NFramework.Collections.PowerCollections.Pair{`0,`1})">
      <summary>
            Determines if two pairs are equal. Two pairs are equal if  the first and second elements
            both compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="pair1">First pair to compare.</param>
      <param name="pair2">Second pair to compare.</param>
      <returns>True if the pairs are equal. False if the pairs are not equal.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Pair`2.op_Inequality(NSoft.NFramework.Collections.PowerCollections.Pair{`0,`1},NSoft.NFramework.Collections.PowerCollections.Pair{`0,`1})">
      <summary>
            Determines if two pairs are not equal. Two pairs are equal if  the first and second elements
            both compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="pair1">First pair to compare.</param>
      <param name="pair2">Second pair to compare.</param>
      <returns>True if the pairs are not equal. False if the pairs are equal.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Pair`2.op_Explicit(NSoft.NFramework.Collections.PowerCollections.Pair{`0,`1})~System.Collections.Generic.KeyValuePair{`0,`1}">
      <summary>
            Converts a Pair to a KeyValuePair. The Key part of the KeyValuePair gets
            the First element, and the Value part of the KeyValuePair gets the Second 
            elements.
            </summary>
      <param name="pair">Pair to convert.</param>
      <returns>The KeyValuePair created from <paramref name="pair" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Pair`2.ToKeyValuePair">
      <summary>
            Converts this Pair to a KeyValuePair. The Key part of the KeyValuePair gets
            the First element, and the Value part of the KeyValuePair gets the Second 
            elements.
            </summary>
      <returns>The KeyValuePair created from this Pair.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Pair`2.op_Explicit(System.Collections.Generic.KeyValuePair{`0,`1})~NSoft.NFramework.Collections.PowerCollections.Pair{`0,`1}">
      <summary>
            Converts a KeyValuePair structure into a Pair. The
            First element gets the Key, and the Second element gets the Value.
            </summary>
      <param name="keyAndValue">The KeyValuePair to convert.</param>
      <returns>The Pair created by converted the KeyValuePair into a Pair.</returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.ReadOnlyDictionaryBase`2">
      <summary>
            ReadOnlyDictionaryBase is a base class that can be used to more easily implement the
            generic IDictionary&lt;T&gt; and non-generic IDictionary interfaces.
            </summary>
      <remarks>
        <para>To use ReadOnlyDictionaryBase as a base class, the derived class must override
            Count, TryGetValue, GetEnumerator. </para>
      </remarks>
      <typeparam name="TKey">The key type of the dictionary.</typeparam>
      <typeparam name="TValue">The value type of the dictionary.</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyDictionaryBase`2.#ctor">
      <summary>
            Creates a new DictionaryBase. This must be called from the constructor of the
            derived class to specify whether the dictionary is read-only and the name of the
            collection.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyDictionaryBase`2.Remove(`0)">
      <summary>
            Removes a key from the dictionary. Always throws an exception
            indicating that this method is not supported in a read-only dictionary.
            </summary>
      <param name="key">Key to remove from the dictionary.</param>
      <returns>True if the key was found, false otherwise.</returns>
      <exception cref="T:System.NotSupportedException">Always thrown.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyDictionaryBase`2.ContainsKey(`0)">
      <summary>
            Determines whether a given key is found
            in the dictionary.
            </summary>
      <remarks>The default implementation simply calls TryGetValue and returns
            what it returns.</remarks>
      <param name="key">Key to look for in the dictionary.</param>
      <returns>True if the key is present in the dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyDictionaryBase`2.TryGetValue(`0,`1@)">
      <summary>
            Determines if this dictionary contains a key equal to <paramref name="key" />. If so, the value
            associated with that key is returned through the value parameter. This method must be overridden 
            in the derived class.
            </summary>
      <param name="key">The key to search for.</param>
      <param name="value">Returns the value associated with key, if true was returned.</param>
      <returns>True if the dictionary contains key. False if the dictionary does not contain key.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyDictionaryBase`2.ToString">
      <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
      <returns>The string representation of the dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyDictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            Determines if a dictionary contains a given KeyValuePair. This implementation checks to see if the
            dictionary contains the given key, and if the value associated with the key is equal to (via object.Equals)
            the value.
            </summary>
      <param name="item">A KeyValuePair containing the Key and Value to check for.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyDictionaryBase`2.DebuggerDisplayString">
      <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.ReadOnlyDictionaryBase`2.Item(`0)">
      <summary>
            The indexer of the dictionary. The set accessor throws an NotSupportedException
            stating the dictionary is read-only.
            </summary>
      <remarks>The get accessor is implemented by calling TryGetValue.</remarks>
      <param name="key">Key to find in the dictionary.</param>
      <returns>The value associated with the key.</returns>
      <exception cref="T:System.NotSupportedException">Always thrown from the set accessor, indicating
            that the dictionary is read only.</exception>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown from the get accessor if the key
            was not found.</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.ReadOnlyDictionaryBase`2.Keys">
      <summary>
            Returns a collection of the keys in this dictionary. 
            </summary>
      <value>A read-only collection of the keys in this dictionary.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.ReadOnlyDictionaryBase`2.Values">
      <summary>
            Returns a collection of the values in this dictionary. The ordering of 
            values in this collection is the same as that in the Keys collection.
            </summary>
      <value>A read-only collection of the values in this dictionary.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2">
      <summary>
            MultiDictionaryBase is a base class that can be used to more easily implement a class
            that associates multiple values to a single key. The class implements the generic
            IDictionary&lt;TKey, ICollection&lt;TValue&gt;&gt; interface. The resulting collection
            is read-only -- items cannot be added or removed.
            </summary>
      <remarks>
        <para>To use ReadOnlyMultiDictionaryBase as a base class, the derived class must override
            Count, Contains(TKey,TValue), EnumerateKeys, and TryEnumerateValuesForKey . </para>
      </remarks>
      <typeparam name="TKey">The key type of the dictionary.</typeparam>
      <typeparam name="TValue">The value type of the dictionary.</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.#ctor">
      <summary>
            Creates a new ReadOnlyMultiDictionaryBase. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.EnumerateKeys">
      <summary>
            Enumerate all the keys in the dictionary. This method must be overridden by a derived
            class.
            </summary>
      <returns>An IEnumerator&lt;TKey&gt; that enumerates all of the keys in the collection that
            have at least one value associated with them.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.TryEnumerateValuesForKey(`0,System.Collections.Generic.IEnumerator{`1}@)">
      <summary>
            Enumerate all of the values associated with a given key. This method must be overridden
            by the derived class. If the key exists and has values associated with it, an enumerator for those
            values is returned throught <paramref name="values" />. If the key does not exist, false is returned.
            </summary>
      <param name="key">The key to get values for.</param>
      <param name="values">If true is returned, this parameter receives an enumerators that
            enumerates the values associated with that key.</param>
      <returns>True if the key exists and has values associated with it. False otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.ContainsKey(`0)">
      <summary>
            Determines whether a given key is found in the dictionary.
            </summary>
      <remarks>The default implementation simply calls TryGetValue.
            It may be appropriate to override this method to 
            provide a more efficient implementation.</remarks>
      <param name="key">Key to look for in the dictionary.</param>
      <returns>True if the key is present in the dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.Contains(`0,`1)">
      <summary>
            Determines if this dictionary contains a key-value pair equal to <paramref name="key" /> and 
            <paramref name="value" />. The dictionary is not changed. This method must be overridden in the derived class.
            </summary>
      <param name="key">The key to search for.</param>
      <param name="value">The value to search for.</param>
      <returns>True if the dictionary has associated <paramref name="value" /> with <paramref name="key" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.ICollection{`1}})">
      <summary>
            Determines if this dictionary contains the given key and all of the values associated with that key..
            </summary>
      <param name="pair">A key and collection of values to search for.</param>
      <returns>True if the dictionary has associated all of the values in <paramref name="pair" />.Value with <paramref name="pair" />.Key.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.EqualValues(`1,`1)">
      <summary>
            If the derived class does not use the default comparison for values, this
            methods should be overridden to compare two values for equality. This is
            used for the correct implementation of ICollection.Contains on the Values
            and KeyValuePairs collections.
            </summary>
      <param name="value1">First value to compare.</param>
      <param name="value2">Second value to compare.</param>
      <returns>True if the values are equal.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.CountValues(`0)">
      <summary>
            Gets a count of the number of values associated with a key. The
            default implementation is slow; it enumerators all of the values
            (using TryEnumerateValuesForKey) to count them. A derived class
            may be able to supply a more efficient implementation.
            </summary>
      <param name="key">The key to count values for.</param>
      <returns>The number of values associated with <paramref name="key" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.CountAllValues">
      <summary>
            Gets a total count of values in the collection. This default implementation
            is slow; it enumerates all of the keys in the dictionary and calls CountValues on each.
            A derived class may be able to supply a more efficient implementation.
            </summary>
      <returns>The total number of values associated with all keys in the dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.ToString">
      <summary>
            Shows the string representation of the dictionary. The string representation contains
            a list of the mappings in the dictionary.
            </summary>
      <returns>The string representation of the dictionary.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.DebuggerDisplayString">
      <summary>
            Display the contents of the dictionary in the debugger. This is intentionally private, it is called
            only from the debugger due to the presence of the DebuggerDisplay attribute. It is similar
            format to ToString(), but is limited to 250-300 characters or so, so as not to overload the debugger.
            </summary>
      <returns>The string representation of the items in the collection, similar in format to ToString().</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.GetEnumerator">
      <summary>
            Enumerate all the keys in the dictionary, and for each key, the collection of values for that key.
            </summary>
      <returns>An enumerator to enumerate all the key, ICollection&lt;value&gt; pairs in the dictionary.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.Count">
      <summary>
            Gets the number of keys in the dictionary. This property must be overridden
            in the derived class.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.Keys">
      <summary>
            Gets a read-only collection all the keys in this dictionary.
            </summary>
      <value>An readonly ICollection&lt;TKey&gt; of all the keys in this dictionary.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.Values">
      <summary>
            Gets a read-only collection of all the values in the dictionary. 
            </summary>
      <returns>A read-only ICollection&lt;TValue&gt; of all the values in the dictionary.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.KeyValuePairs">
      <summary>
            Gets a read-only collection of all key-value pairs in the dictionary. If a key has multiple
            values associated with it, then a key-value pair is present for each value associated
            with the key.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.ReadOnlyMultiDictionaryBase`2.Item(`0)">
      <summary>
            Returns a collection of all of the values in the dictionary associated with <paramref name="key" />.
            If the key is not present in the dictionary, an ICollection with no
            values is returned. The returned ICollection is read-only.
            </summary>
      <param name="key">The key to get the values associated with.</param>
      <value>An ICollection&lt;TValue&gt; with all the values associated with <paramref name="key" />.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.DuplicatePolicy">
      <summary>
            Describes what to do if a key is already in the tree when doing an
            insertion.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.PowerCollections.DuplicatePolicy.InsertFirst">
      <summary>
            Insert a new node before duplicates
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.PowerCollections.DuplicatePolicy.InsertLast">
      <summary>
            Insert a new node after duplicates
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.PowerCollections.DuplicatePolicy.ReplaceFirst">
      <summary>
            Replace the first of the duplicate nodes
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.PowerCollections.DuplicatePolicy.ReplaceLast">
      <summary>
            Replace the last of the duplicate nodes
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.PowerCollections.DuplicatePolicy.DoNothing">
      <summary>
            Do nothing to the tree
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1">
      <summary>
             The base implementation for various collections classes that use Red-Black trees
             as part of their implementation. This class should not (and can not) be 
             used directly by end users; it's only for internal use by the collections package.
             </summary>
      <remarks>
             The Red-Black tree manages items of type T, and uses a IComparer&lt;T&gt; that
             compares items to sort the tree. Multiple items can compare equal and be stored
             in the tree. Insert, Delete, and Find operations are provided in their full generality;
             all operations allow dealing with either the first or last of items that compare equal. 
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            Initialize a red-black tree, using the given interface instance to compare elements. Only
            Compare is used on the IComparer interface.
            </summary>
      <param name="comparer">The IComparer&lt;T&gt; used to sort keys.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.Clone">
      <summary>
            Clone the tree, returning a new tree containing the same items. Should
            take O(N) take.
            </summary>
      <returns>Clone version of this tree.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.Find(`0,System.Boolean,System.Boolean,`0@)">
      <summary>
            Finds the key in the tree. If multiple items in the tree have
            compare equal to the key, finds the first or last one. Optionally replaces the item
            with the one searched for.
            </summary>
      <param name="key">Key to search for.</param>
      <param name="findFirst">If true, find the first of duplicates, else finds the last of duplicates.</param>
      <param name="replace">If true, replaces the item with key (if function returns true)</param>
      <param name="item">Returns the found item, before replacing (if function returns true).</param>
      <returns>True if the key was found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.FindIndex(`0,System.Boolean)">
      <summary>
            Finds the index of the key in the tree. If multiple items in the tree have
            compare equal to the key, finds the first or last one. 
            </summary>
      <param name="key">Key to search for.</param>
      <param name="findFirst">If true, find the first of duplicates, else finds the last of duplicates.</param>
      <returns>Index of the item found if the key was found, -1 if not found.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.GetItemByIndex(System.Int32)">
      <summary>
            Find the item at a particular index in the tree.
            </summary>
      <param name="index">The zero-based index of the item. Must be &gt;= 0 and &lt; Count.</param>
      <returns>The item at the particular index.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.Insert(`0,NSoft.NFramework.Collections.PowerCollections.DuplicatePolicy,`0@)">
      <summary>
            Insert a new node into the tree, maintaining the red-black invariants.
            </summary>
      <remarks>Algorithm from Sedgewick, "Algorithms".</remarks>
      <param name="item">The new item to insert</param>
      <param name="dupPolicy">What to do if equal item is already present.</param>
      <param name="previous">If false, returned, the previous item.</param>
      <returns>false if duplicate exists, otherwise true.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.Delete(`0,System.Boolean,`0@)">
      <summary>
            Deletes a key from the tree. If multiple elements are equal to key, 
            deletes the first or last. If no element is equal to the key, 
            returns false.
            </summary>
      <remarks>Top-down algorithm from Weiss. Basic plan is to move down in the tree, 
            rotating and recoloring along the way to always keep the current node red, which 
            ensures that the node we delete is red. The details are quite complex, however! </remarks>
      <param name="key">Key to delete.</param>
      <param name="deleteFirst">Which item to delete if multiple are equal to key. True to delete the first, false to delete last.</param>
      <param name="item">Returns the item that was deleted, if true returned.</param>
      <returns>True if an element was deleted, false if no element had 
            specified key.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.GetEnumerator">
      <summary>
            Enumerate all the items in-order
            </summary>
      <returns>An enumerator for all the items, in order.</returns>
      <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.BoundedRangeTester(System.Boolean,`0,System.Boolean,`0)">
      <summary>
            Gets a range tester that defines a range by first and last items.
            </summary>
      <param name="useFirst">If true, bound the range on the bottom by first.</param>
      <param name="first">If useFirst is true, the inclusive lower bound.</param>
      <param name="useLast">If true, bound the range on the top by last.</param>
      <param name="last">If useLast is true, the exclusive upper bound.</param>
      <returns>A RangeTester delegate that tests for an item in the given range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.DoubleBoundedRangeTester(`0,System.Boolean,`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by first and last items.
            </summary>
      <param name="first">The lower bound.</param>
      <param name="firstInclusive">True if the lower bound is inclusive, false if exclusive.</param>
      <param name="last">The upper bound.</param>
      <param name="lastInclusive">True if the upper bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for an item in the given range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.LowerBoundedRangeTester(`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by a lower bound.
            </summary>
      <param name="first">The lower bound.</param>
      <param name="inclusive">True if the lower bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for an item in the given range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.UpperBoundedRangeTester(`0,System.Boolean)">
      <summary>
            Gets a range tester that defines a range by upper bound.
            </summary>
      <param name="last">The upper bound.</param>
      <param name="inclusive">True if the upper bound is inclusive, false if exclusive.</param>
      <returns>A RangeTester delegate that tests for an item in the given range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.EqualRangeTester(`0)">
      <summary>
            Gets a range tester that defines a range by all items equal to an item.
            </summary>
      <param name="equalTo">The item that is contained in the range.</param>
      <returns>A RangeTester delegate that tests for an item equal to <paramref name="equalTo" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.EntireRangeTester(`0)">
      <summary>
            A range tester that defines a range that is the entire tree.
            </summary>
      <param name="item">Item to test.</param>
      <returns>Always returns 0.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.EnumerateRange(NSoft.NFramework.Collections.PowerCollections.RedBlackTree{`0}.RangeTester)">
      <summary>
            Enumerate the items in a custom range in the tree. The range is determined by 
            a RangeTest delegate.
            </summary>
      <param name="rangeTester">Tests an item against the custom range.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the custom range in order.</returns>
      <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.EnumerateRangeReversed(NSoft.NFramework.Collections.PowerCollections.RedBlackTree{`0}.RangeTester)">
      <summary>
            Enumerate the items in a custom range in the tree, in reversed order. The range is determined by 
            a RangeTest delegate.
            </summary>
      <param name="rangeTester">Tests an item against the custom range.</param>
      <returns>An IEnumerable&lt;T&gt; that enumerates the custom range in reversed order.</returns>
      <exception cref="T:System.InvalidOperationException">The tree has an item added or deleted during the enumeration.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.DeleteItemFromRange(NSoft.NFramework.Collections.PowerCollections.RedBlackTree{`0}.RangeTester,System.Boolean,`0@)">
      <summary>
            Deletes either the first or last item from a range, as identified by a RangeTester
            delegate. If the range is empty, returns false.
            </summary>
      <remarks>Top-down algorithm from Weiss. Basic plan is to move down in the tree, 
            rotating and recoloring along the way to always keep the current node red, which 
            ensures that the node we delete is red. The details are quite complex, however! </remarks>
      <param name="rangeTester">Range to delete from.</param>
      <param name="deleteFirst">If true, delete the first item from the range, else the last.</param>
      <param name="item">Returns the item that was deleted, if true returned.</param>
      <returns>True if an element was deleted, false if the range is empty.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.DeleteRange(NSoft.NFramework.Collections.PowerCollections.RedBlackTree{`0}.RangeTester)">
      <summary>
            Delete all the items in a range, identified by a RangeTester delegate.
            </summary>
      <param name="rangeTester">The delegate that defines the range to delete.</param>
      <returns>The number of items deleted.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.CountRange(NSoft.NFramework.Collections.PowerCollections.RedBlackTree{`0}.RangeTester)">
      <summary>
            Count the items in a custom range in the tree. The range is determined by 
            a RangeTester delegate.
            </summary>
      <param name="rangeTester">The delegate that defines the range.</param>
      <returns>The number of items in the range.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.FirstItemInRange(NSoft.NFramework.Collections.PowerCollections.RedBlackTree{`0}.RangeTester,`0@)">
      <summary>
            Find the first item in a custom range in the tree, and it's index. The range is determined
            by a RangeTester delegate.
            </summary>
      <param name="rangeTester">The delegate that defines the range.</param>
      <param name="item">Returns the item found, if true was returned.</param>
      <returns>Index of first item in range if range is non-empty, -1 otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.LastItemInRange(NSoft.NFramework.Collections.PowerCollections.RedBlackTree{`0}.RangeTester,`0@)">
      <summary>
            Find the last item in a custom range in the tree, and it's index. The range is determined
            by a RangeTester delegate.
            </summary>
      <param name="rangeTester">The delegate that defines the range.</param>
      <param name="item">Returns the item found, if true was returned.</param>
      <returns>Index of the item if range is non-empty, -1 otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.Print">
      <summary>
            Prints out the tree.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.Validate">
      <summary>
            Validates that the tree is correctly sorted, and meets the red-black tree 
            axioms.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.ElementCount">
      <summary>
            Returns the number of elements in the tree.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.RedBlackTree`1.RangeTester">
      <summary>
            A delegate that tests if an item is within a custom range. The range must be a contiguous
            range of items with the ordering of this tree. The range test function must test
            if an item is before, withing, or after the range.
            </summary>
      <param name="item">Item to test against the range.</param>
      <returns>Returns negative if item is before the range, zero if item is withing the range,
            and positive if item is after the range.</returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.Set`1">
      <summary>
             Set&lt;T&gt; is a collection that contains items of type T. 
             The item are maintained in a haphazard, unpredictable order, and duplicate items are not allowed.
             </summary>
      <remarks>
        <p>The items are compared in one of two ways. If T implements IComparable&lt;T&gt; 
             then the Equals method of that interface will be used to compare items, otherwise the Equals
             method from Object will be used. Alternatively, an instance of IComparer&lt;T&gt; can be passed
             to the constructor to use to compare items.</p>
        <p>Set is implemented as a hash table. Inserting, deleting, and looking up an
             an element all are done in approximately constant time, regardless of the number of items in the Set.</p>
        <p>
          <see cref="T:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1" /> is similar, but uses comparison instead of hashing, and does maintains
             the items in sorted order.</p>
      </remarks>
      <seealso cref="T:NSoft.NFramework.Collections.PowerCollections.OrderedSet`1" />
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.#ctor">
      <summary>
             Creates a new Set. The Equals method and GetHashCode method on T
             will be used to compare items for equality.
             </summary>
      <remarks>
             Items that are null are permitted, and will be sorted before all other items.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new Set. The Equals and GetHashCode method of the passed comparer object
            will be used to compare items in this set.
            </summary>
      <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
             Creates a new Set. The Equals method and GetHashCode method on T
             will be used to compare items for equality.
             </summary>
      <remarks>
             Items that are null are permitted.
            </remarks>
      <param name="collection">A collection with items to be placed into the Set.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Creates a new Set. The Equals and GetHashCode method of the passed comparer object
            will be used to compare items in this set. The set is
            initialized with all the items in the given collection.
            </summary>
      <param name="collection">A collection with items to be placed into the Set.</param>
      <param name="equalityComparer">An instance of IEqualityComparer&lt;T&gt; that will be used to compare items.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.Clone">
      <summary>
            Makes a shallow clone of this set; i.e., if items of the
            set are reference types, then they are not cloned. If T is a value type,
            then each element is copied as if by simple assignment.
            </summary>
      <remarks>Cloning the set takes time O(N), where N is the number of items in the set.</remarks>
      <returns>The cloned set.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.CloneContents">
      <summary>
            Makes a deep clone of this set. A new set is created with a clone of
            each element of this set, by calling ICloneable.Clone on each element. If T is
            a value type, then each element is copied as if by simple assignment.
            </summary>
      <remarks>
        <para>If T is a reference type, it must implement
            ICloneable. Otherwise, an InvalidOperationException is thrown.</para>
        <para>Cloning the set takes time O(N), where N is the number of items in the set.</para>
      </remarks>
      <returns>The cloned set.</returns>
      <exception cref="T:System.InvalidOperationException">T is a reference type that does not implement ICloneable.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.GetEnumerator">
      <summary>
            Returns an enumerator that enumerates all the items in the set. 
            The items are enumerated in sorted order.
            </summary>
      <remarks>
        <p>Typically, this method is not called directly. Instead the "foreach" statement is used
            to enumerate the items, which uses this method implicitly.</p>
        <p>If an item is added to or deleted from the set while it is being enumerated, then 
            the enumeration will end with an InvalidOperationException.</p>
        <p>Enumerating all the items in the set takes time O(N), where N is the number
            of items in the set.</p>
      </remarks>
      <returns>An enumerator for enumerating all the items in the Set.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.Contains(`0)">
      <summary>
            Determines if this set contains an item equal to <paramref name="item" />. The set
            is not changed.
            </summary>
      <remarks>Searching the set for an item takes approximately constant time, regardless of the number of items in the set.</remarks>
      <param name="item">The item to search for.</param>
      <returns>True if the set contains <paramref name="item" />. False if the set does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.TryGetItem(`0,`0@)">
      <summary>
        <para>Determines if this set contains an item equal to <paramref name="item" />, according to the 
            comparison mechanism that was used when the set was created. The set
            is not changed.</para>
        <para>If the set does contain an item equal to <paramref name="item" />, then the item from the set is returned.</para>
      </summary>
      <remarks>Searching the set for an item takes approximately constant time, regardless of the number of items in the set.</remarks>
      <example>
            In the following example, the set contains strings which are compared in a case-insensitive manner. 
            <code>
            Set&lt;string&gt; set = new Set&lt;string&gt;(StringComparer.CurrentCultureIgnoreCase);
            set.Add("HELLO");
            string s;
            bool b = set.TryGetItem("Hello", out s);   // b receives true, s receives "HELLO".
            </code></example>
      <param name="item">The item to search for.</param>
      <param name="foundItem">Returns the item from the set that was equal to <paramref name="item" />.</param>
      <returns>True if the set contains <paramref name="item" />. False if the set does not contain <paramref name="item" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.Add(`0)">
      <summary>
            Adds a new item to the set. If the set already contains an item equal to
            <paramref name="item" />, that item is replaced with <paramref name="item" />.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Adding an item takes approximately constant time, regardless of the number of items in the set.</para>
      </remarks>
      <param name="item">The item to add to the set.</param>
      <returns>True if the set already contained an item equal to <paramref name="item" /> (which was replaced), false 
            otherwise.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.AddMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Adds all the items in <paramref name="collection" /> to the set. If the set already contains an item equal to
            one of the items in <paramref name="collection" />, that item will be replaced.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Adding the collection takes time O(M), where M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to add to the set.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.Remove(`0)">
      <summary>
            Searches the set for an item equal to <paramref name="item" />, and if found,
            removes it from the set. If not found, the set is unchanged.
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Removing an item from the set takes approximately constant time, regardless of the size of the set.</para>
      </remarks>
      <param name="item">The item to remove.</param>
      <returns>True if <paramref name="item" /> was found and removed. False if <paramref name="item" /> was not in the set.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Removes all the items in <paramref name="collection" /> from the set. 
            </summary>
      <remarks>
        <para>Equality between items is determined by the comparison instance or delegate used
            to create the set.</para>
        <para>Removing the collection takes time O(M), where M is the 
            number of items in <paramref name="collection" />.</para>
      </remarks>
      <param name="collection">A collection of items to remove from the set.</param>
      <returns>The number of items removed from the set.</returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="collection" /> is null.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.Clear">
      <summary>
            Removes all items from the set.
            </summary>
      <remarks>Clearing the set takes a constant amount of time, regardless of the number of items in it.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.IsSupersetOf(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Determines if this set is a superset of another set. Neither set is modified.
            This set is a superset of <paramref name="otherSet" /> if every element in
            <paramref name="otherSet" /> is also in this set.
            <remarks>IsSupersetOf is computed in time O(M), where M is the size of the 
            <paramref name="otherSet" />.</remarks></summary>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a superset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.IsProperSupersetOf(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Determines if this set is a proper superset of another set. Neither set is modified.
            This set is a proper superset of <paramref name="otherSet" /> if every element in
            <paramref name="otherSet" /> is also in this set.
            Additionally, this set must have strictly more items than <paramref name="otherSet" />.
            </summary>
      <remarks>IsProperSubsetOf is computed in time O(M), where M is the size of
            <paramref name="otherSet" />.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a proper superset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.IsSubsetOf(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Determines if this set is a subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet" /> if every element in this set
            is also in <paramref name="otherSet" />.
            </summary>
      <remarks>IsSubsetOf is computed in time O(N), where N is the size of the this set.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a subset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.IsProperSubsetOf(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Determines if this set is a proper subset of another set. Neither set is modified.
            This set is a subset of <paramref name="otherSet" /> if every element in this set
            is also in <paramref name="otherSet" />. Additionally, this set must have strictly 
            fewer items than <paramref name="otherSet" />.
            </summary>
      <remarks>IsProperSubsetOf is computed in time O(N), where N is the size of the this set.</remarks>
      <param name="otherSet">Set to compare to.</param>
      <returns>True if this is a proper subset of <paramref name="otherSet" />.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.IsEqualTo(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Determines if this set is equal to another set. This set is equal to
            <paramref name="otherSet" /> if they contain the same items.
            </summary>
      <remarks>IsEqualTo is computed in time O(N), where N is the number of items in 
            this set.</remarks>
      <param name="otherSet">Set to compare to</param>
      <returns>True if this set is equal to <paramref name="otherSet" />, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.IsDisjointFrom(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Determines if this set is disjoint from another set. Two sets are disjoint
            if no item from one set is equal to any item in the other set.
            </summary>
      <remarks>
        <para>The answer is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to check disjointness with.</param>
      <returns>True if the two sets are disjoint, false otherwise.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.UnionWith(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. This set receives
            the union of the two sets, the other set is unchanged.
            </summary>
      <remarks>
        <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The union of two sets is computed in time O(M + N), where M is the size of the 
            larger set, and N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to union with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.Union(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Computes the union of this set with another set. The union of two sets
            is all items that appear in either or both of the sets. A new set is 
            created with the union of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>If equal items appear in both sets, the union will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The union of two sets is computed in time O(M + N), where M is the size of the 
            one set, and N is the size of the other set.</para>
      </remarks>
      <param name="otherSet">Set to union with.</param>
      <returns>The union of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.IntersectionWith(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. This set receives
            the intersection of the two sets, the other set is unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to intersection with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.Intersection(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Computes the intersection of this set with another set. The intersection of two sets
            is all items that appear in both of the sets. A new set is 
            created with the intersection of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
            two equal items.</para>
        <para>The intersection of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to intersection with.</param>
      <returns>The intersection of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.DifferenceWith(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet" />. This set receives
            the difference of the two sets; the other set is unchanged.
            </summary>
      <remarks>
        <para>The difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to difference with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.Difference(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Computes the difference of this set with another set. The difference of these two sets
            is all items that appear in this set, but not in <paramref name="otherSet" />. A new set is 
            created with the difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>The difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to difference with.</param>
      <returns>The difference of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.SymmetricDifferenceWith(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. This set receives
            the symmetric difference of the two sets; the other set is unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to symmetric difference with.</param>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Set`1.SymmetricDifference(NSoft.NFramework.Collections.PowerCollections.Set{`0})">
      <summary>
            Computes the symmetric difference of this set with another set. The symmetric difference of two sets
            is all items that appear in either of the sets, but not both. A new set is 
            created with the symmetric difference of the sets and is returned. This set and the other set 
            are unchanged.
            </summary>
      <remarks>
        <para>The symmetric difference of two sets is computed in time O(N), where N is the size of the smaller set.</para>
      </remarks>
      <param name="otherSet">Set to symmetric difference with.</param>
      <returns>The symmetric difference of the two sets.</returns>
      <exception cref="T:System.InvalidOperationException">This set and <paramref name="otherSet" /> don't use the same method for comparing items.</exception>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.Set`1.Comparer">
      <summary>
            Returns the IEqualityComparer&lt;T&gt; used to compare items in this set. 
            </summary>
      <value>If the set was created using a comparer, that comparer is returned. Otherwise
            the default comparer for T (EqualityComparer&lt;T&gt;.Default) is returned.</value>
    </member>
    <member name="P:NSoft.NFramework.Collections.PowerCollections.Set`1.Count">
      <summary>
            Returns the number of items in the set.
            </summary>
      <remarks>The size of the set is returned in constant time.</remarks>
      <value>The number of items in the set.</value>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.Strings">
      <summary>
            A holder class for localizable strings that are used. Currently, these are not loaded from resources, but 
            just coded into this class. To make this library localizable, simply change this class to load the
            given strings from resources.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.Triple`3">
      <summary>
            Stores a triple of objects within a single struct. This struct is useful to use as the
            T of a collection, or as the TKey or TValue of a dictionary.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.PowerCollections.Triple`3.First">
      <summary>
            The first element of the triple.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.PowerCollections.Triple`3.Second">
      <summary>
            The second element of the triple.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.PowerCollections.Triple`3.Third">
      <summary>
            The thrid element of the triple.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Triple`3.#ctor(`0,`1,`2)">
      <summary>
            Creates a new triple with given elements.
            </summary>
      <param name="first">The first element of the triple.</param>
      <param name="second">The second element of the triple.</param>
      <param name="third">The third element of the triple.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Triple`3.Equals(System.Object)">
      <summary>
            Determines if this triple is equal to another object. The triple is equal to another object 
            if that object is a Triple, all element types are the same, and the all three elements
            compare equal using object.Equals.
            </summary>
      <param name="obj">Object to compare for equality.</param>
      <returns>True if the objects are equal. False if the objects are not equal.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Triple`3.Equals(NSoft.NFramework.Collections.PowerCollections.Triple{`0,`1,`2})">
      <summary>
            Determines if this triple is equal to another triple. Two triples are equal if the all three elements
            compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="other">Triple to compare with for equality.</param>
      <returns>True if the triples are equal. False if the triples are not equal.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Triple`3.GetHashCode">
      <summary>
            Returns a hash code for the triple, suitable for use in a hash-table or other hashed collection.
            Two triples that compare equal (using Equals) will have the same hash code. The hash code for
            the triple is derived by combining the hash codes for each of the two elements of the triple.
            </summary>
      <returns>The hash code.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Triple`3.CompareTo(NSoft.NFramework.Collections.PowerCollections.Triple{`0,`1,`2})">
      <summary>
        <para> Compares this triple to another triple of the some type. The triples are compared by using
            the IComparable&lt;T&gt; or IComparable interface on TFirst, TSecond, and TThird. The triples
            are compared by their first elements first, if their first elements are equal, then they
            are compared by their second elements. If their second elements are also equal, then they
            are compared by their third elements.</para>
        <para>If TFirst, TSecond, or TThird does not implement IComparable&lt;T&gt; or IComparable, then
            an NotSupportedException is thrown, because the triples cannot be compared.</para>
      </summary>
      <param name="other">The triple to compare to.</param>
      <returns>An integer indicating how this triple compares to <paramref name="other" />. Less
            than zero indicates this triple is less than <paramref name="other" />. Zero indicate this triple is
            equals to <paramref name="other" />. Greater than zero indicates this triple is greater than
            <paramref name="other" />.</returns>
      <exception cref="T:System.NotSupportedException">Either FirstSecond, TSecond, or TThird is not comparable
            via the IComparable&lt;T&gt; or IComparable interfaces.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Triple`3.ToString">
      <summary>
            Returns a string representation of the triple. The string representation of the triple is
            of the form:
            <c>First: {0}, Second: {1}, Third: {2}</c>
            where {0} is the result of First.ToString(), {1} is the result of Second.ToString(), and
            {2} is the result of Third.ToString() (or "null" if they are null.)
            </summary>
      <returns> The string representation of the triple.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Triple`3.op_Equality(NSoft.NFramework.Collections.PowerCollections.Triple{`0,`1,`2},NSoft.NFramework.Collections.PowerCollections.Triple{`0,`1,`2})">
      <summary>
            Determines if two triples are equal. Two triples are equal if the all three elements
            compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="pair1">First triple to compare.</param>
      <param name="pair2">Second triple to compare.</param>
      <returns>True if the triples are equal. False if the triples are not equal.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Triple`3.op_Inequality(NSoft.NFramework.Collections.PowerCollections.Triple{`0,`1,`2},NSoft.NFramework.Collections.PowerCollections.Triple{`0,`1,`2})">
      <summary>
            Determines if two triples are not equal. Two triples are equal if the all three elements
            compare equal using IComparable&lt;T&gt;.Equals or object.Equals.
            </summary>
      <param name="pair1">First triple to compare.</param>
      <param name="pair2">Second triple to compare.</param>
      <returns>True if the triples are not equal. False if the triples are equal.</returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.PowerCollections.Util">
      <summary>
            A holder class for various internal utility functions that need to be shared.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Util.IsCloneableType(System.Type,System.Boolean@)">
      <summary>
            Determine if a type is cloneable: either a value type or implementing
            ICloneable.
            </summary>
      <param name="type">Type to check.</param>
      <param name="isValue">Returns if the type is a value type, and does not implement ICloneable.</param>
      <returns>True if the type is cloneable.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Util.SimpleClassName(System.Type)">
      <summary>
            Returns the simple name of the class, for use in exception messages. 
            </summary>
      <returns>The simple name of this class.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Util.CreateEnumerableWrapper``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Wrap an enumerable so that clients can't get to the underlying
            implementation via a down-case
            </summary>
      <param name="wrapped">Enumerable to wrap.</param>
      <returns>A wrapper around the enumerable.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PowerCollections.Util.GetHashCode``1(``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Gets the hash code for an object using a comparer. Correctly handles
            null.
            </summary>
      <param name="item">Item to get hash code for. Can be null.</param>
      <param name="equalityComparer">The comparer to use.</param>
      <returns>The hash code for the item.</returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.BinaryHeap`1">
      <summary>
            이진 트리 방식으로 데이타를 저장합니다. 저장소는 1차원 배열이지만, 정렬 순서는 이진 트리 방식을 사용하여, 검색 속도를 높힙니다.
            </summary>
      <typeparam name="T">힙 요수의 수형</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryHeap`1.Sort(System.Collections.Generic.IList{`0},System.Collections.Generic.IComparer{`0})">
      <summary>
            BinaryHeap{T} 를 Ascending 정렬하여 반환합니다.
            </summary>
      <param name="list">
      </param>
      <param name="comparer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryHeap`1.PopRoot">
      <summary>
            Root 값을 꺼냅니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryHeap`1.PeekRoot">
      <summary>
            Root 값을 조사합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryHeap`1.Insert(`0)">
      <summary>
            요소를 추가합니다.
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Collections.BinaryHeapPriorityQueue`1">
      <summary>
        <see cref="T:NSoft.NFramework.Collections.BinaryHeap`1" /> 을 이용하는 우선순위에 의해 내부 정렬을 수행하는 큐입니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryHeapPriorityQueue`1.Peek">
      <summary>
            최상위 값을 Peek 합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.BinaryTree`1">
      <summary>
            이진 트리를 구성한다.
            </summary>
      <remarks>
            이진 트리에서는 <c>BinaryTreeNode</c>(노드)의 Value (값)을 중복을 허용하지 않는다.<br />
            중복된 노드 값이 들어 왔을 때는 무시한다.
            </remarks>
      <typeparam name="T">이진 트리를 구성하는 노드 <c>BinaryTreeNode</c> 의 값의 수형</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.#ctor">
      <summary>
            기본 생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            생성자
            </summary>
      <param name="comparer">노드의 값을 비교하기 위한 비교자</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            생성자
            </summary>
      <param name="collection">노드를 구성할 값들의 컬렉션</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
      <summary>
            생성자
            </summary>
      <param name="collection">노드를 구성할 값들의 컬렉션</param>
      <param name="comparer">노드의 값을 비교하기 위한 비교자</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetEnumerableByPreOrderedNode(NSoft.NFramework.Collections.BinaryTreeNode{`0})">
      <summary>
            PreOrder 방식의 이진트리 노드에 대한 반복자를 만든다. (자신,Left,Right 순)
            </summary>
      <param name="root">시작 노드</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetEnumerableByInOrderedNode(NSoft.NFramework.Collections.BinaryTreeNode{`0})">
      <summary>
            InOrder 방법으로 이진트리 노드 탐색의 반복자를 만든다. (Left,자신, Right 순)
            </summary>
      <param name="root">시작 노드</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetEnumerableByPostOrderedNode(NSoft.NFramework.Collections.BinaryTreeNode{`0})">
      <summary>
            지정된 노드를 기준으로 PostOrder (Left-&gt;Right-&gt;자신 순)으로 이진트리 노드 탐색이 가능한 반복자를 제공한다.
            </summary>
      <param name="root">시작 노드</param>
      <returns>이진트리 노드 반복자</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetEnumerableByInRevOrderedNode(NSoft.NFramework.Collections.BinaryTreeNode{`0})">
      <summary>
            지정된 노드를 기준으로 InRevOrder( Right-&gt;자신-&gt;Left 순)으로 이진트리 노드 탐색이 가능한 반복자를 제공한다.
            </summary>
      <param name="root">시작 노드</param>
      <returns>이진트리 노드 반복자</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.Clone">
      <summary>
            이진트리를 복제한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetValueEnumerable(NSoft.NFramework.Collections.TraversalMethod)">
      <summary>
            탐색 방법에 따른 값에 대한 노드 값에 대한 반복자를 제공한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetNodeEnumerable(NSoft.NFramework.Collections.TraversalMethod)">
      <summary>
            탐색 방법에 따른 노드에 대한 반복자를 반환한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            값들을 이진 트리에 추가한다.
            </summary>
      <param name="values">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.Add(`0)">
      <summary>
            지정된 값을 가진 새로운 노드를 Tree에 추가한다.
            </summary>
      <remarks>
            중복을 허용하지 않는다.
            </remarks>
      <param name="value">이진트리 노드의 값</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.Clear">
      <summary>
            트리에서 노드들을 모두 제거한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.Contains(`0)">
      <summary>
            지정된 값을 가진 노드가 있는지 검사한다.
            </summary>
      <param name="value">찾을 값</param>
      <returns>존재 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.CopyTo(`0[],System.Int32)">
      <summary>
            이진트리에 있는 노드의 값들을 InOrder 탐색 방식으로 1차원 배열에 복사한다.
            </summary>
      <param name="array">값을 담을 1차원 배열</param>
      <param name="arrayIndex">값을 담을 배열의 첫번째 위치</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.CopyTo(`0[],System.Int32,NSoft.NFramework.Collections.TraversalMethod)">
      <summary>
            이진트리에 있는 노드의 값들을 1차원 배열에 복사한다.
            </summary>
      <param name="array">값을 담을 1차원 배열</param>
      <param name="arrayIndex">값을 담을 배열의 첫번째 위치</param>
      <param name="method">탐색 방법</param>
      <exception cref="T:System.ArgumentOutOfRangeException">값을 담을 배열의 주어진 크기가 작을때</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.Remove(`0)">
      <summary>
            지정된 값을 가진 노드를 삭제한다.
            </summary>
      <param name="value">삭제할 값</param>
      <returns>삭제 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.FindNode(`0)">
      <summary>
            지정된 값을 가진 노드를 검색하여 반환한다.
            </summary>
      <returns>검색된 노드, 검색 실패시에는 null을 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.FindNode(`0,NSoft.NFramework.Collections.BinaryTreeNode{`0}@,NSoft.NFramework.Collections.BinaryTreeNode{`0}@)">
      <summary>
            지정된 값을 가진 노드를 검색한다.
            </summary>
      <param name="value">검색할 값</param>
      <param name="current">검색 값을 가진 노드</param>
      <param name="parent">찾은 노드의 부모 노드</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetLeftMostChild">
      <summary>
            트리에서 가장 왼쪽에 있는 노드를 구한다.
            </summary>
      <returns>노드</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetLeftMostChild(NSoft.NFramework.Collections.BinaryTreeNode{`0})">
      <summary>
            기준노드를 루트로 볼 때 가장 왼쪽에 있는 노드를 구한다.
            </summary>
      <param name="current">기준 노드</param>
      <returns>노드, 없을 시에는 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetRightMostChild">
      <summary>
            트리의 가장 오른쪽에 있는 노드를 구한다.
            </summary>
      <returns>노드, 없을 시에는 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetRightMostChild(NSoft.NFramework.Collections.BinaryTreeNode{`0})">
      <summary>
            기준노드를 루트로 볼 때 가장 오른쪽에 있는 노드를 구한다.
            </summary>
      <param name="current">
      </param>
      <returns>노드, 없을 시에는 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.TraverseToString(NSoft.NFramework.Collections.TraversalMethod)">
      <summary>
            탐색 방법에 따라 탐색하면서 값들을 집합형식으로 표현한 문자열을 반환한다.
            </summary>
      <param name="method">탐색 방법</param>
      <returns>노드 값을 집합으로 표현한 문자열 </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetTreeDataList(System.Collections.Generic.IList{`0})">
      <summary>
            노드들의 Value를 지정된 컬렉션에 담는다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetTreeDataList(System.Collections.Generic.IList{`0},NSoft.NFramework.Collections.TraversalMethod)">
      <summary>
            노드들을 지정된 탐색 방법에 따라 지정된 컬렉션에 담는다.
            </summary>
      <param name="list">
      </param>
      <param name="method">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.ToString">
      <summary>
            InOrder 방식으로 노드들의 값을 집합형식의 문자열로 만듦
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.ToString(NSoft.NFramework.Collections.TraversalMethod)">
      <summary>
            지정된 탐색 방법으로 노드들의 값을 집합형식의 문자열로 만듦
            </summary>
      <param name="method">탐색 방법</param>
      <returns>문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetEnumerator">
      <summary>
            Return enumerator by by InOrder traversal method.
            </summary>
      <returns>Enumerator of {T}</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetEnumerator(NSoft.NFramework.Collections.TraversalMethod)">
      <summary>
            Return enumerator by the specified traversal method.
            </summary>
      <param name="method">Traversal method</param>
      <returns>Enumerator of {T}</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetNodeEnumerator">
      <summary>
            Return binary tree node enumerator by InOrder traversal method.
            </summary>
      <returns>Enumerator of <see cref="T:NSoft.NFramework.Collections.BinaryTreeNode`1" /></returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTree`1.GetNodeEnumerator(NSoft.NFramework.Collections.TraversalMethod)">
      <summary>
            Return binary tree node enumerator by the specified traversal method.
            </summary>
      <param name="method">
      </param>
      <returns>Enumerator of <see cref="T:NSoft.NFramework.Collections.BinaryTreeNode`1" /></returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTree`1.IsEmpty">
      <summary>
            트리가 비었는지 검사 (Root가 널이면 빈 트리이다.)
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTree`1.Root">
      <summary>
            Root node of this binary tree
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTree`1.PreOrder">
      <summary>
            PreOrder (자신-&gt;Left-&gt;Right 순)으로 탐색이 가능한 Value에 대한 반복자를 제공한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTree`1.PreOrderNode">
      <summary>
            PreOrder 방식의 이진트리 노드에 대한 반복자를 만든다. (자신,Left,Right 순)
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTree`1.InOrder">
      <summary>
            InOrder (Left-&gt;자신-&gt;Right 순) 으로 Value 탐색이 가능한 반복자를 제공한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTree`1.InOrderNode">
      <summary>
            InOrder 방법으로 이진트리 노드 탐색의 반복자를 만든다. (Left,자신, Right 순)
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTree`1.PostOrder">
      <summary>
            PostOrder (Left-&gt;Right-&gt;자신 순)으로 Value 탐색이 가능한 반복자를 제공한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTree`1.PostOrderNode">
      <summary>
            PostOrder (Left-&gt;Right-&gt;자신 순)으로 이진트리 노드 탐색이 가능한 반복자를 제공한다.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTree`1.InRevOrder">
      <summary>
            지정된 노드를 기준으로 InRevOrder( Right-&gt;자신-&gt;Left 순)으로 값 탐색이 가능한 반복자를 제공한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTree`1.InRevOrderNode">
      <summary>
            지정된 노드를 기준으로 InRevOrder( Right-&gt;자신-&gt;Left 순)으로 이진트리 노드 탐색이 가능한 반복자를 제공한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTree`1.Count">
      <summary>
            이진트리에 있는 노드의 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTree`1.IsReadOnly">
      <summary>
            읽기 전용인가?
            </summary>
      <value>
      </value>
    </member>
    <member name="T:NSoft.NFramework.Collections.BinaryTreeNode`1">
      <summary>
            Binary Tree Node
            </summary>
      <typeparam name="T">Type of Item that contains in BinaryTreeNode </typeparam>
    </member>
    <member name="T:NSoft.NFramework.Collections.Node`1">
      <summary>
            Basic node for DataStructures
            </summary>
      <typeparam name="T">object type</typeparam>
    </member>
    <member name="T:NSoft.NFramework.Collections.INode`1">
      <summary>
            Node that has object.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="P:NSoft.NFramework.Collections.INode`1.Value">
      <summary>
            Value that current node contains 
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.INode`1.Nodes">
      <summary>
            Associated nodes
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Node`1.#ctor">
      <summary>
            default constructor
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Node`1.#ctor(`0)">
      <summary>
            constructor
            </summary>
      <param name="itemValue">Item Value</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Node`1.ToString">
      <summary>
            노드가 가진 값을 반환한다.
            </summary>
      <returns>ItemValue의 정보, null 이면 "null"을 반환한다.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.Node`1.Value">
      <summary>
            노드가 가진 값
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.Node`1.Nodes">
      <summary>
            이 노드와 관련된 노드들
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.BinaryTreeNode`1.LEFT_INDEX">
      <summary>
            Left Node
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.BinaryTreeNode`1.RIGHT_INDEX">
      <summary>
            Right Node
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTreeNode`1.#ctor(`0)">
      <summary>
            default constructor
            </summary>
      <param name="value">node value</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.BinaryTreeNode`1.#ctor(`0,NSoft.NFramework.Collections.Node{`0},NSoft.NFramework.Collections.Node{`0})">
      <summary>
            constructor
            </summary>
      <param name="value">node value</param>
      <param name="leftNode">left node</param>
      <param name="rightNode">right node</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTreeNode`1.Nodes">
      <summary>
            child nodes	(left, right만 있다)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTreeNode`1.Left">
      <summary>
            left child node
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.BinaryTreeNode`1.Right">
      <summary>
            right child node
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.CollectionTool.INITIAL_CAPACITY">
      <summary>
            Initial capacity (16)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.CollectionTool.LEFT">
      <summary>
            Left (0) used by BinaryTree
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.CollectionTool.RIGHT">
      <summary>
            Right (1) used by BinaryTree
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.CollectionTool.DEFAULT_MRU_SIZE">
      <summary>
            Default MRU Stack size (4)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.CollectionTool.ItemDelimiter">
      <summary>
            요소 구분자 (쉼표)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.CollectionTool.OpenBrace">
      <summary>
            컬렉션을 표현할 때의 집합의 구분자 (중괄호)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.CollectionTool.CloseBrace">
      <summary>
            컬렉션을 표현할 때의 집합의 구분자 (중괄호)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.DoubleQueue`1">
      <summary>
            양방향으로 넣고 빼기가 가능한 큐이다.
            </summary>
      <remarks>
            DoubleQueue 인스턴스는 멀티 쓰레드에 안전하지 않습니다.
            </remarks>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.#ctor(System.Int32)">
      <summary>
            생성자
            </summary>
      <param name="capacity">큐의 크기</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            생성자
            </summary>
      <param name="collection">큐에 추가할 요소</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.Clear">
      <summary>
            큐의 요소를 모두 제거한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.Contains(`0)">
      <summary>
            큐에 지정된 item이 존재하는지 검사한다.
            </summary>
      <param name="item">검사할 요소</param>
      <returns>존재여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.CopyTo(`0[])">
      <summary>
            큐의 모든 요소를 지정된 배열에 복사한다.
            </summary>
      <param name="array">대상 배열</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.CopyTo(`0[],System.Int32)">
      <summary>
            큐의 요소를 지정된 배열에 복사한다.
            </summary>
      <param name="array">대상 배열</param>
      <param name="arrayIndex">복사 위치</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.DequeueHead">
      <summary>
            큐의 첫번째 요소를 큐에서 꺼낸다.
            </summary>
      <returns>꺼낸 요소</returns>
      <exception cref="T:System.InvalidOperationException">큐에 더이상의 요소가 없을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.PeekHead">
      <summary>
            큐의 첫번째 요소를 조회한다.
            </summary>
      <returns>첫번째 요소, 빈 큐인 경우에는 null을 반환합니다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.DequeueTail">
      <summary>
            큐의 끝의 요소를 꺼냅니다.
            </summary>
      <returns>요소</returns>
      <exception cref="T:System.InvalidOperationException">큐에 더이상의 요소가 없을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.PeekTail">
      <summary>
            큐의 끝의 요소를 반환한다.
            </summary>
      <returns>마지막 요소, 빈 큐인 경우에는 null을 반환합니다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.EnqueueHead(`0)">
      <summary>
            큐의 처음부분에 요소를 추가한다.
            </summary>
      <param name="item">요소</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.EnqueueTail(`0)">
      <summary>
            큐의 끝에 요소를 추가한다.
            </summary>
      <param name="item">요소</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.Reverse">
      <summary>
            요소의 순서를 반대로 정렬한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.ToArray">
      <summary>
            큐의 요소를 배열로 반환한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.TrimExcess">
      <summary>
            큐의 내부 버퍼를 실제 크기와 같게 한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.ToString">
      <summary>
            인스턴스의 내용을 표현
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.GetEnumerator">
      <summary>
            Return enumerator by In Order traversal method.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.DoubleQueue`1.Clone">
      <summary>
            현재 RwDoubleQueue 인스턴스 개체의 복사본을 만든다. Shallow copy를 수행한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.DoubleQueue`1.Count">
      <summary>
            현재 큐에 저장된 요소의 수
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.DoubleQueue`1.Capacity">
      <summary>
            현재 큐의 크기
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.FrequencyTableSortOrder">
      <summary>
            Enumeration defining the various orders of sorting
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.FrequencyTableSortOrder.Value_Ascending">
      <summary>
            값을 기준으로 오름차순
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.FrequencyTableSortOrder.Value_Descending">
      <summary>
            값 기준의 내림차순
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.FrequencyTableSortOrder.Frequency_Ascending">
      <summary>
            빈도 기준의 오름차순
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.FrequencyTableSortOrder.Frequency_Descending">
      <summary>
            빈도 기준의 내림차순
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.FrequencyTableSortOrder.None">
      <summary>
            정렬 없음
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.TextAnalyzeMode">
      <summary>
            Enumeration defining the literal frequency analysis
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.TextAnalyzeMode.AllCharacters">
      <summary>
            모든 문자
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.TextAnalyzeMode.NoNumerals">
      <summary>
            숫자 제외
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.TextAnalyzeMode.NoSpecialCharacters">
      <summary>
            특수문자 제외
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.TextAnalyzeMode.LettersOnly">
      <summary>
            글자만
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.TextAnalyzeMode.NumeralsOnly">
      <summary>
            숫자만
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.TextAnalyzeMode.SpecialCharactersOnly">
      <summary>
            특수문자만
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.FrequencyTable`1">
      <summary>
            A generic frequency table (빈도수 검사를 할때 유용한 Class입니다)
            </summary>
      <typeparam name="T">요수의 수형</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.FrequencyTable`1.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.FrequencyTable`1.#ctor(System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="initialCapacity">Initial buffer size</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.FrequencyTable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Constructor
            </summary>
      <param name="samples">요소 열거자</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.FrequencyTable`1.#ctor(`0,NSoft.NFramework.Collections.TextAnalyzeMode)">
      <summary>
            Constructor
            </summary>
      <param name="text">분석할 정보</param>
      <param name="mode">분석 모드</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="text" />가 문자열이 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.FrequencyTable`1.Add(`0)">
      <summary>
            Add the specified value.
            </summary>
      <param name="value">value to add.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.FrequencyTable`1.Add(`0,NSoft.NFramework.Collections.TextAnalyzeMode)">
      <summary>
            Add text to analyzed
            </summary>
      <param name="text">text to analyzed</param>
      <param name="mode">analyze mode</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.FrequencyTable`1.Remove(`0)">
      <summary>
            Remove the specified value
            </summary>
      <param name="value">value to remove.</param>
      <exception cref="T:System.InvalidOperationException">value not exists.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.FrequencyTable`1.GetTableAsArray">
      <summary>
            Get array of frequency table entry
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.FrequencyTable`1.GetTableAsArray(NSoft.NFramework.Collections.FrequencyTableSortOrder)">
      <summary>
             Get array of frequency table entry
            </summary>
      <param name="order">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.FrequencyTable`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.FrequencyTable`1.ToString">
      <summary>
            Return informatio of this instance.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.FrequencyTable`1.Length">
      <summary>
            actual number of entries
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.FrequencyTable`1.SampleSize">
      <summary>
            the sample size
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.FrequencyTable`1.Tag">
      <summary>
            user defined tag
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.FrequencyTable`1.Description">
      <summary>
            Description.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.FrequencyTable`1.ScarcestValue">
      <summary>
            Returns the scarcest value ( actually the first occurence of the lowest frequency is considered )
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.FrequencyTable`1.Mode">
      <summary>
            return the most Frequency value
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.FrequencyTable`1.HighestFrequency">
      <summary>
            return the highest observed frequency
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.FrequencyTable`1.SmallestFrequency">
      <summary>
            return the lowest observed frequency
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.FrequencyTableEntry`1">
      <summary>
            A generic structure storing the frequency information for each value
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.FrequencyTableEntry`1.#ctor(`0,System.Int32,System.Double,System.Double)">
      <summary>
            Constructor
            </summary>
      <param name="value">The value counted</param>
      <param name="absFreq">absolute frequency</param>
      <param name="relFreq">relative frequency</param>
      <param name="percentage">sample size</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.FrequencyTableEntry`1.ToString">
      <summary>
            Returns frequencies of this instance.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.FrequencyTableEntry`1.Value">
      <summary>
            Counted value
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.FrequencyTableEntry`1.AbsoluteFrequency">
      <summary>
            Absolute Frequency
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.FrequencyTableEntry`1.RelativeFrequency">
      <summary>
            Relative Frequency
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.FrequencyTableEntry`1.Percentage">
      <summary>
            Percentage
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.MultiMap`2">
      <summary>
            일반적인 Key - Value 의 1:1 쌍이 아닌 1:N 관계인 Key-ValueCollection 관계를 갖는다. (실제로는 IDictionary{TKey, IList{TValue}} 와 같다.)
            </summary>
      <remarks>
            일반적인 Dictionary의 경우에는 키-값이 1:1의 쌍으로 구성됩니다. 
            <see cref="T:NSoft.NFramework.Collections.MultiMap`2" />은 1:N의 관계를 가질 수 있도록 해줍니다.
            </remarks>
      <typeparam name="TKey">키 타입</typeparam>
      <typeparam name="TValue">값 타입</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.#ctor">
      <summary>
            기본 생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.#ctor(System.Int32)">
      <summary>
            생성자
            </summary>
      <param name="capacity">초기 용량</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            생성자
            </summary>
      <param name="comparer">키 비교자</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.Add(`0,`1)">
      <summary>
            새로운 요소를 추가한다.
            </summary>
      <param name="key">키</param>
      <param name="value">값</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.AddSingleMap(`0,`1)">
      <summary>
            요소 하나를 추가한다.
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.ContainsValue(`1)">
      <summary>
            지정된 값을 가진 요소가 있는지 여부
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.ToString">
      <summary>
            인스턴스 정보를 문자열로 표현
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.Add(`0,System.Collections.Generic.IEnumerable{`1})">
      <summary>
            요소를 추가한다.
            </summary>
      <param name="key">키값</param>
      <param name="values">요소 값들</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.ContainsKey(`0)">
      <summary>
            지정된 키를 가진 요소의 존재여부
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.Remove(`0)">
      <summary>
            지정된 키를 가진 요소를 삭제한다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.TryGetValue(`0,System.Collections.Generic.IList{`1}@)">
      <summary>
            Try get value from internal dictionary, if not exists, return false
            </summary>
      <param name="key">key to retrieve</param>
      <param name="value">value matched by key</param>
      <returns>indicate exists the key</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IList{`1}})">
      <summary>
            요소를 추가한다.
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.Clear">
      <summary>
            모든 요소를 제거한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IList{`1}})">
      <summary>
            지정된 요소의 값들이 모두 존재하는지 검사 (하나라도 존재하지 않으면 False를 반환한다.
            </summary>
      <param name="item">검사할 요소</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IList{`1}}[],System.Int32)">
      <summary>
            요소들을 지정된 배열에 복사한다.
            </summary>
      <param name="array">
      </param>
      <param name="arrayIndex">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.IList{`1}})">
      <summary>
            지정된 요소 제거
            </summary>
      <param name="item">
      </param>
      <returns>제거 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.GetEnumerator">
      <summary>
            Return enumerator
            </summary>
      <returns>enumerator of <see cref="T:System.Collections.Generic.KeyValuePair`2" /></returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiMap`2.Clone">
      <summary>
            인스턴스를 복제한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiMap`2.KeyCount">
      <summary>
            키의 갯수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiMap`2.ValueCount">
      <summary>
            맵에 있는 모든 값의 갯수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiMap`2.Keys">
      <summary>
            키 컬렉션
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiMap`2.Values">
      <summary>
            Multimap value collection. value type is IList{TValue}
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiMap`2.Item(`0)">
      <summary>
            Indexer
            </summary>
      <param name="key">키</param>
      <returns>값 컬렉션</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiMap`2.Count">
      <summary>
            요소 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiMap`2.IsReadOnly">
      <summary>
            읽기 전용 여부
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.MultiSet`2">
      <summary>
            키-Set(값) 의 형식을 가진다. 즉 키는 하나인데, 값은 여러 개의 중복 없는 값을 가진다.
            </summary>
      <typeparam name="TKey">키 형식</typeparam>
      <typeparam name="TValue">값 형식</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.#ctor">
      <summary>
            Default constructor
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
      <summary>
            Constructor
            </summary>
      <param name="capacity">initial capacity</param>
      <param name="comparer">value comparer</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.Add(`0,`1)">
      <summary>
            Add item
            </summary>
      <param name="key">key</param>
      <param name="value">value</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.ContainsValue(`1)">
      <summary>
            지정된 value를 가지고 있는지 검사합니다.
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.GetAllValues">
      <summary>
            MultiSet에서 가지고 있는 모든 값을 하나의 HashSet으로 만들어서 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.ContainsKey(`0)">
      <summary>
            지정된 키를 가지는지 검사한다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.Add(`0,System.Collections.Generic.IEnumerable{`1})">
      <summary>
            지정된 키에 값들을 추가합니다. (중복불가)
            </summary>
      <param name="key">
      </param>
      <param name="values">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.Remove(`0)">
      <summary>
            지정된 키를 제거합니다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.TryGetValue(`0,System.Collections.Generic.HashSet{`1}@)">
      <summary>
            지정된 키에 해당하는 HashSet 을 구해봅니다. 있으면 True를 반환하고, 없으면 False를 반환합니다.
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.Add(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.HashSet{`1}})">
      <summary>
            Add new item
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.Clear">
      <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only. 
                            </exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.Contains(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.HashSet{`1}})">
      <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
      <returns>
            true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.
            </returns>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.
                            </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.HashSet{`1}}[],System.Int32)">
      <summary>
            요소를 지정된 array로 복사한다.
            </summary>
      <param name="array">
      </param>
      <param name="arrayIndex">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.Remove(System.Collections.Generic.KeyValuePair{`0,System.Collections.Generic.HashSet{`1}})">
      <summary>
            지정된 요소가 있으면 제거합니다.
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.MultiSet`2.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiSet`2.InnerSet">
      <summary>
            Inner Dictionary
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiSet`2.KeyCount">
      <summary>
            키의 갯수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiSet`2.ValueCount">
      <summary>
            맵에 있는 모든 값의 갯수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiSet`2.Item(`0)">
      <summary>
            Indexer
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiSet`2.Keys">
      <summary>
            Key Collection
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiSet`2.Values">
      <summary>
            Collection of HashSet{TValue}
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiSet`2.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.MultiSet`2.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
      <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
            </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.NodeCollection`1">
      <summary>
            Collection of <see cref="T:NSoft.NFramework.Collections.Node`1" /></summary>
      <typeparam name="N">Node Value Type</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.NodeCollection`1.#ctor">
      <summary>
            default constructor
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.NodeCollection`1.#ctor(System.Collections.Generic.IEnumerable{NSoft.NFramework.Collections.Node{`0}})">
      <summary>
            constructor
            </summary>
      <param name="list">N 타입의 값을 가지는 노드의 리스트 객체</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.NodeCollection`1.#ctor(System.Int32)">
      <summary>
            constructor
            </summary>
      <param name="count">컬렉션에 새로 만들 노드의 갯수</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.NodeCollection`1.FindByValue(`0)">
      <summary>
            Find Node contains the specified value.
            </summary>
      <param name="value">searching value</param>
      <returns>node that contains the value. if not exist return null.</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.NodeCollection`1.FindAllByValue(`0)">
      <summary>
            Find all nodes that contains the specified value.
            </summary>
      <param name="value">seaching value</param>
      <returns>Collection of Node that contains the specified value</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.NodeCollection`1.ToString">
      <summary>
            Return Node informations
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.PascalSet">
      <summary>
            Pascal Language에 있는 Set을 구현한 클래스입니다.
            </summary>
      <remarks>
            int, char 형의 집합을 구현한 것이다. enum의 [flags] attribute를 이용한 bit 연산을 수행해도 되지만,
            Delphi 의 Set 예약어처럼 편리하게 사용할 수 있다.
            </remarks>
      <example>
        <code>
            // alphabet 만
            PascalSet alphabetSet = new PascalSet('A', 'z'); // asciiSet.Union(chars.ToArray());
            // 모음
            PascalSet vowels = alphabetSet.Union('A', 'a', 'E', 'e', 'I', 'i', 'O', 'o', 'U', 'u');
            // 자음
            PascalSet consonants = vowels.Complement();
            
            string contents = "Hey, realweb members. make money please.";
            
            int contentLength = contents.Length;
            int vowelCount =0;
            int consonantCount = 0;
            int otherCount = 0;
            
            for (int i = 0; i &lt; contentLength; i++)
            {
            	char c = contents[i];
            
            	if (vowels.ContainsElement(c))              // 모음
            		vowelCount++;
            	else if (consonants.ContainsElement(c))     // 자음
            		consonantCount++;
            	else                                        // 기타
            		otherCount++;
            }
            Console.Write("주어진 문장에는 {0}개의 모음, {1}개의 자음, {2}개의 비 알파벳 문자가 있습니다.", vowelCount, consonantCount, otherCount);
            
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.AreSimilar(NSoft.NFramework.Collections.PascalSet,NSoft.NFramework.Collections.PascalSet)">
      <summary>
            지정된 두 PascalSet의 집합 범위(LowerBound, UpperBound)가 같은지 검사한다. (Same이, Equivalent, Equal과는 다르다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.CheckSimilar(NSoft.NFramework.Collections.PascalSet,NSoft.NFramework.Collections.PascalSet)">
      <summary>
            지정된 두 집합의 집합 범위가 같은지 검사한다.
            </summary>
      <exception cref="T:System.ArgumentException">두 집합이 같은 종류가 아닐 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.#ctor(System.Int32,System.Int32)">
      <summary>
            Initialize a new instance of PascalSet with lowerBound, upperBound
            </summary>
      <param name="lowerBound">하한값</param>
      <param name="upperBound">상한값</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.#ctor(System.Char,System.Char)">
      <summary>
            Constructor
            </summary>
      <param name="lowerBound">Lower bound.</param>
      <param name="upperBound">Upper bound.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.#ctor(System.Char,System.Char,System.Char[])">
      <summary>
            Constructor
            </summary>
      <param name="lowerBound">Lower bound.</param>
      <param name="upperBound">Upper bound.</param>
      <param name="elements">element of this instance</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.#ctor(System.Int32,System.Int32,System.Int32[])">
      <summary>
            Constructor
            </summary>
      <param name="lowerBound">Lower bound.</param>
      <param name="upperBound">Upper bound.</param>
      <param name="elements">element of this instance</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.#ctor(NSoft.NFramework.Collections.PascalSet)">
      <summary>
            Constructor for copying
            </summary>
      <param name="set">instance to copied</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.AddElements(System.Int32[])">
      <summary>
            현재 집합에 지정된 배열 값들을 요소로 추가한다.
            </summary>
      <param name="values">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.AddElements(System.Char[])">
      <summary>
            Add elements to this instance.
            </summary>
      <param name="values">array of element to added.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.RemoveElements(System.Int32[])">
      <summary>
            현재 집합에 지정된 배열 값들을 요소에서 제거한다.
            </summary>
      <param name="values">array of element to removed.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.RemoveElements(System.Char[])">
      <summary>
            현재 집합에 지정된 배열 값들을 요소에서 제거한다.
            </summary>
      <param name="values">array of element to removed.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.SetElements(System.Boolean,System.Int32[])">
      <summary>
            현재 집합에 지정된 값들을 요소로 포함 시키거나, 제외시킨다.
            </summary>
      <param name="contains">포함시킬 것인가, 제외시킬 것인가</param>
      <param name="values">array of elements to set</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.SetElements(System.Boolean,System.Char[])">
      <summary>
            현재 집합에 지정된 값들을 요소로 포함 시키거나, 제외시킨다.
            </summary>
      <param name="contains">포함시킬 것인가, 제외시킬 것인가</param>
      <param name="values">array of elements to set</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.ContainsElement(System.Int32)">
      <summary>
            현재 집합이 지정한 값을 요소로 가지고 있는지 검사한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.ContainsElement(System.Char)">
      <summary>
            현재 집합이 지정한 값을 요소로 가지고 있는지 검사한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.Union(NSoft.NFramework.Collections.PascalSet)">
      <summary>
            현재 집합과 지정된 집합의 합집합을 만든다
            </summary>
      <param name="set">집합</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.Union(System.Int32[])">
      <summary>
            현재 집합과 지정된 배열의 값들을 요소로 가지는 집합의 합집합을 만든다.
            </summary>
      <param name="values">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.Union(System.Char[])">
      <summary>
            현재 집합과 지정된 배열의 값들을 요소로 가지는 집합의 합집합을 만든다.
            </summary>
      <param name="values">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.op_BitwiseOr(NSoft.NFramework.Collections.PascalSet,NSoft.NFramework.Collections.PascalSet)">
      <summary>
            합집합 연산자 (OR)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.Intersection(NSoft.NFramework.Collections.PascalSet)">
      <summary>
            현재 집합과 지정된 집합의 교집합을 만든다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.Intersection(System.Int32[])">
      <summary>
            현재 집합과 지정된 값을 요소로 가진 집합의 교집합을 구한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.Intersection(System.Char[])">
      <summary>
            현재 집합과 지정된 값을 요소로 가진 집합의 교집합을 구한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.op_BitwiseAnd(NSoft.NFramework.Collections.PascalSet,NSoft.NFramework.Collections.PascalSet)">
      <summary>
            교집합 연산자 (AND)
            </summary>
      <param name="lhs">
      </param>
      <param name="rhs">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.Difference(NSoft.NFramework.Collections.PascalSet)">
      <summary>
            현재 집합에서 지정된 집합의 요소를 뺀 집합 (차집합) 을 만든다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.Difference(System.Int32[])">
      <summary>
             현재 집합에서 지정된 배열 값을 뺀 차집합을 만든다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.Difference(System.Char[])">
      <summary>
             현재 집합에서 지정된 배열 값을 뺀 차집합을 만든다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.op_Subtraction(NSoft.NFramework.Collections.PascalSet,NSoft.NFramework.Collections.PascalSet)">
      <summary>
            차집합 연산자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.Complement">
      <summary>
            현재 집합의 여집합을 만든다.
            </summary>
      <returns>인스턴스의 여집합</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.op_LogicalNot(NSoft.NFramework.Collections.PascalSet)">
      <summary>
            Complement(여집합) 연산자
            </summary>
      <param name="lhs">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.ExclusiveOr(NSoft.NFramework.Collections.PascalSet)">
      <summary>
            현재 집합과 지정된 집합의 XOR 연산을 수행한다. ( XOR = (A | B) - ( A &amp; B) )
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.ExclusiveOr(System.Int32[])">
      <summary>
            현재 집합과 지정된 값들의 집합의 XOR 연산을 수행한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.ExclusiveOr(System.Char[])">
      <summary>
            현재 집합과 지정된 값들의 집합의 XOR 연산을 수행한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.op_ExclusiveOr(NSoft.NFramework.Collections.PascalSet,NSoft.NFramework.Collections.PascalSet)">
      <summary>
            XOR 연산자 ( XOR = (A | B) - ( A &amp; B) )
            </summary>
      <param name="lhs">집합</param>
      <param name="rhs">집합</param>
      <returns>두 집합의 XOR 결과 집합</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.IsSubset(NSoft.NFramework.Collections.PascalSet)">
      <summary>
            현재 집합이 지정된 집합의 부분집합인지 판단한다. (두 집합이 일치해도 부분집합이다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.IsSubset(System.Int32[])">
      <summary>
            현재 집합이 지정된 값을 가진 집합의 부분집합인지 판단한다. (두 집합이 일치해도 부분집합이다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.IsSubset(System.Char[])">
      <summary>
            현재 집합이 지정된 값을 가진 집합의 부분집합인지 판단한다. (두 집합이 일치해도 부분집합이다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.IsProperSubset(NSoft.NFramework.Collections.PascalSet)">
      <summary>
            현재 집합이 지정된 집합의 참부분집합인지 판단한다. (두집합이 동치이면 False이다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.IsProperSubset(System.Int32[])">
      <summary>
            현재 집합이 지정된 집합의 참부분집합인지 판단한다. (두집합이 동치이면 False이다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.IsProperSubset(System.Char[])">
      <summary>
            현재 집합이 지정된 집합의 참부분집합인지 판단한다. (두집합이 동치이면 False이다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.IsSuperset(NSoft.NFramework.Collections.PascalSet)">
      <summary>
            현재 집합이 지정된 집합의 모집합인지 판단한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.IsSuperset(System.Int32[])">
      <summary>
            현재 집합이 지정된 값을 가진 집합의 모집합인지 판단한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.IsSuperset(System.Char[])">
      <summary>
            현재 집합이 지정된 값을 가진 집합의 모집합인지 판단한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.IsProperSuperset(NSoft.NFramework.Collections.PascalSet)">
      <summary>
            현재 집합이 지정된 집합의 순모집합인지 판단한다. (두집합이 동치이면 False이다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.IsProperSuperset(System.Int32[])">
      <summary>
            현재 집합이 지정된 값을 가진 집합의 순모집합인지 판단한다. (두집합이 동치이면 False이다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.IsProperSuperset(System.Char[])">
      <summary>
            현재 집합이 지정된 값을 가진 집합의 순모집합인지 판단한다. (두집합이 동치이면 False이다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.Equals(NSoft.NFramework.Collections.PascalSet)">
      <summary>
            현재 집합과 지정된 집합이 같은지 검사한다.
            </summary>
      <param name="set">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.Clone">
      <summary>
            인스턴스를 복제한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.ToString">
      <summary>
            현재 집합을 문자열로 표현한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.CopyTo(System.Array,System.Int32)">
      <summary>
            현재 집합의 요소들을 지정된 배열에 복사한다.
            </summary>
      <param name="array">요소가 저장된 대상 배열</param>
      <param name="startIndex">배열의 시작 인덱스</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.PascalSet.GetEnumerator">
      <summary>
            집합 요소의 반복자
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.PascalSet.LowerBound">
      <summary>
            하한
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.PascalSet.UpperBound">
      <summary>
            상한
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.PascalSet.Count">
      <summary>
            현재 집합의 요소 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.PascalSet.IsSynchronized">
      <summary>
            Indicate that this instance is synchronized.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.PascalSet.SyncRoot">
      <summary>
            synchronized root object.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.Set`1">
      <summary>
            무한 집합에 대한 클래스이다.
            </summary>
      <remarks>
            집합 연산을 제공하는 컬렉션이다.
            </remarks>
      <typeparam name="T">요소 타입</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.#ctor">
      <summary>
            기본 생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            생성자
            </summary>
      <param name="collection">요소 컬렉션</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.Add(`0)">
      <summary>
            요소 추가 - 중복된 요소는 무시한다.
            </summary>
      <param name="item">요소</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            지정된 컬렉션의 요소들을 추가한다.
            </summary>
      <param name="collection">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.Clear">
      <summary>
            모든 요소를 제거한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.Contains(`0)">
      <summary>
            요소 존재 여부
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.ContainsRange(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            현재 집합이 지정된 컬렉션의 모든 요소를 가지고 있는지 검사.
            </summary>
      <param name="collection">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.Remove(`0)">
      <summary>
            요소 제거
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            현재 집합에서 지정된 컬렉션의 요소들을 제거한다.
            </summary>
      <param name="collection">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.RetainRange(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            현재 집합에서 지정된 컬렉션의 요소만 남겨두고 다 제거한다. - 교집합
            </summary>
      <param name="collection">요소 컬렉션</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.Sort">
      <summary>
            요소 정렬
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.Sort(System.Collections.Generic.IComparer{`0})">
      <summary>
            요소 정렬
            </summary>
      <param name="comparer">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.ToArray">
      <summary>
            요소를 1차원 배열로 만들어 반환한다.
            </summary>
      <returns>요소의 1차원 배열</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.Union(NSoft.NFramework.Collections.Set{`0})">
      <summary>
            합집합
            </summary>
      <remarks>현 집합과 지정한 집합의 합집합을 만든다.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.op_BitwiseOr(NSoft.NFramework.Collections.Set{`0},NSoft.NFramework.Collections.Set{`0})">
      <summary>
            합집합 연산자
            </summary>
      <param name="lhs">
      </param>
      <param name="rhs">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.Intersection(NSoft.NFramework.Collections.Set{`0})">
      <summary>
            교집합
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.op_BitwiseAnd(NSoft.NFramework.Collections.Set{`0},NSoft.NFramework.Collections.Set{`0})">
      <summary>
            교집합 연산자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.Difference(NSoft.NFramework.Collections.Set{`0})">
      <summary>
            현재 집합에서 지정된 집합을 뺀 차집합
            </summary>
      <param name="set">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.op_Subtraction(NSoft.NFramework.Collections.Set{`0},NSoft.NFramework.Collections.Set{`0})">
      <summary>
            차집합 연산자
            </summary>
      <param name="lhs">
      </param>
      <param name="rhs">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.ExclusiveOr(NSoft.NFramework.Collections.Set{`0})">
      <summary>
            요소가 두집합중에 한 군데에만 속해 있는 집합
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.op_ExclusiveOr(NSoft.NFramework.Collections.Set{`0},NSoft.NFramework.Collections.Set{`0})">
      <summary>
            ExclusiveOr (XOR) 연산자
            </summary>
      <param name="lhs">
      </param>
      <param name="rhs">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.IsSubset(NSoft.NFramework.Collections.Set{`0})">
      <summary>
            현재 집합이 지정된 집합의 subset인지 판단한다. - 동치이면 True
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.IsProperSubset(NSoft.NFramework.Collections.Set{`0})">
      <summary>
            현재 집합이 지정된 집합의 참부분집합인지 판단한다. (동치이면 순 부분집합이 아니다.)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.IsSuperset(NSoft.NFramework.Collections.Set{`0})">
      <summary>
            현재 집합이 지정된 집합의 Superset인지 판다.
            </summary>
      <param name="set">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.IsProperSuperset(NSoft.NFramework.Collections.Set{`0})">
      <summary>
            현집합이 지정된 집합의 순부모집합인지 검사
            </summary>
      <param name="set">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.op_Equality(NSoft.NFramework.Collections.Set{`0},NSoft.NFramework.Collections.Set{`0})">
      <summary>
            두 집합이 동치인지 판단
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.op_Inequality(NSoft.NFramework.Collections.Set{`0},NSoft.NFramework.Collections.Set{`0})">
      <summary>
            두 집합이 동치가 아니면 True, 동치이면 False를 반환
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.Equals(System.Object)">
      <summary>
            현재 집합이 지정된 개체와 동치인지 판단
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.GetHashCode">
      <summary>
            Return hash code of this instance.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.ToString">
      <summary>
            Set 요소를 나열한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.ToString(System.Boolean)">
      <summary>
            Set 요소를 나열한다.
            </summary>
      <param name="sorted">정렬 여부</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.CopyTo(`0[],System.Int32)">
      <summary>
            요소들을 대상 배열에 복사한다.
            </summary>
      <param name="array">
      </param>
      <param name="arrayIndex">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.GetEnumerator">
      <summary>
            반복자
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.Set`1.Clone">
      <summary>
            인스턴스 복제
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.Set`1.Count">
      <summary>
            요소 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.Set`1.IsEmpty">
      <summary>
            빈 집합 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.Set`1.Item(System.Int32)">
      <summary>
            Indexer
            </summary>
      <param name="index">위치 인덱스</param>
      <returns>요소</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.Set`1.IsReadOnly">
      <summary>
            읽기 전용 여부
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.SkipList`1">
      <summary>
            SkipList 알고리듬을 구현한 것이다.
            SortedList와 BinarySearchTree 의 장점만을 조합해서 만든 것이다.
            </summary>
      <remarks>
            기본적으로는 LinkedList이지만 정렬된 각 노드들이 Next 노드를 여러개를 가지고 있어서, 검색에서 빠른 결과를 가져온다.
            단 구성하는 값은 중복을 허용하지 않는다.
            </remarks>
      <typeparam name="T">요소 타입</typeparam>
    </member>
    <member name="F:NSoft.NFramework.Collections.SkipList`1._probability">
      <summary>
            SkipListNode의 Height를 결정하기 위한 확률 요소
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.#ctor">
      <summary>
            기본생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.#ctor(System.Int32)">
      <summary>
            생성자
            </summary>
      <param name="randomSeed">내부 난수 시드 값</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.#ctor(System.Collections.Generic.IComparer{`0})">
      <summary>
            생성자
            </summary>
      <param name="comparer">요소 비교자</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
      <summary>
            생성자
            </summary>
      <param name="randomSeed">내부 난수 시드 값</param>
      <param name="comparer">요소 비교자</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.ChooseRandomHeight(System.Int32)">
      <summary>
            새 노드의 Height를 결정한다. (주사위로)
            반환 값은 1 과 maxHeight 사이 값이다.
            </summary>
      <param name="maxHeight">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.BuildUpdateTable(`0)">
      <summary>
            SkipList에서 추가/삭제시에 Update해야 할 기존 노드들을 찾아서 빌드한다.
            </summary>
      <param name="value">추가나 삭제할 값</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.Clone">
      <summary>
            인스턴스를 본제한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.ToString">
      <summary>
            인스턴스 정보를 문자열로 만든다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.ToStringDetail">
      <summary>
            각 노드들의 Link 관계까지 자세히 표현한 정보를 반환한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.Add(`0)">
      <summary>
            지정된 값을 가진 요소를 생성해서 리스트에 추가한다.
            </summary>
      <param name="value">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.AddRange(`0[])">
      <summary>
            지정된 값들을 리스트에 추가한다.
            </summary>
      <param name="values">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.Clear">
      <summary>
            리스트의 모든 요소를 삭제한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.Contains(`0)">
      <summary>
            리스트에 지정된 값을 가진 요소가 있는지 검사한다.
            </summary>
      <param name="value">검사할 값</param>
      <returns>존재 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.CopyTo(`0[])">
      <summary>
            지정된 배열에 리스트의 값들을 복사한다.
            </summary>
      <param name="array">대상 배열</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.CopyTo(`0[],System.Int32)">
      <summary>
            지정된 배열에 리스트의 값들을 복사한다.
            </summary>
      <param name="array">대상 배열</param>
      <param name="arrayIndex">복사 시작 위치</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.Remove(`0)">
      <summary>
            지정된 값을 가진 요소를 리스트에서 삭제한다.
            </summary>
      <param name="value">요소 값</param>
      <returns>제거 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipList`1.GetEnumerator">
      <summary>
            반복자
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.SkipList`1.Height">
      <summary>
            검색을 위해 부가적으로 링크를 가지고 있는데 Height 가 높을 수록 검색 속도는 빨라지나 조작에는 성능이 느려진다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.SkipList`1.Count">
      <summary>
            리스트가 가진 요소의 수
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.SkipList`1.IsReadOnly">
      <summary>
            읽기전용 여부
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.SkipListNode`1">
      <summary>
            Node of SkipList
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipListNode`1.#ctor">
      <summary>
            default constructor
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipListNode`1.#ctor(System.Int32)">
      <summary>
            constructor
            </summary>
      <param name="height">count of searching node.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipListNode`1.#ctor(`0,System.Int32)">
      <summary>
            constructor
            </summary>
      <param name="value">node value.</param>
      <param name="height">count of searching node.</param>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipListNode`1.ToString">
      <summary>
            노드가 가진 값을 반환한다.
            </summary>
      <returns>ItemValue의 정보, null 이면 "null"을 반환한다.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.SkipListNode`1.Nodes">
      <summary>
            현재 노드와 연관된 노드들의 컬렉션입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.SkipListNode`1.Height">
      <summary>
            현재 노드와 연관된 노드들의 갯수 (컬렉션의 크기입니다.)
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.SkipListNode`1.Item(System.Int32)">
      <summary>
            현재 노드와 관련된 노드를 반환한다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.SkipListNodeCollection`1">
      <summary>
            Collection of <see cref="T:NSoft.NFramework.Collections.SkipListNode`1" /></summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Collections.SkipListNodeCollection`1.#ctor(System.Int32)">
      <summary>
            constructor
            </summary>
      <param name="height">collection buffer size</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.SkipListNodeCollection`1.Item(System.Int32)">
      <summary>
            Indexer
            </summary>
      <param name="index">
      </param>
      <returns>
        <see cref="T:NSoft.NFramework.Collections.SkipListNode`1" /> instance.</returns>
    </member>
    <member name="T:NSoft.NFramework.Collections.TraversalMethod">
      <summary>
            Binary Tree를 탐색할 때의 방법을 말합니다.
            </summary>
      <remarks>
            Binary Tree의 요소들을 탐색할 때 순서에 따라 전혀 다른 결과를 나타낸다.
            </remarks>
    </member>
    <member name="F:NSoft.NFramework.Collections.TraversalMethod.PreOrder">
      <summary>
            자신-&gt;Left-&gt;Right 순으로 
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.TraversalMethod.InOrder">
      <summary>
            Left-&gt;자신-&gt;Right 순으로 (오름차순)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.TraversalMethod.PostOrder">
      <summary>
            Left-&gt;Right-&gt;자신 순으로
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Collections.TraversalMethod.InRevOrder">
      <summary>
            Right-&gt;자신-&gt;Left 순으로 (내림차순)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.Vertex`1">
      <summary>
            Graph 의 Vertex
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.ValueObjectBase">
      <summary>
            DDD의 Value Object를 표현하는 추상 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.IValueObject">
      <summary>
            DDD에서 Value Object 나타내는 기본 인터페이스
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Vertex`1.#ctor">
      <summary>
            constructor
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.Vertex`1.#ctor(`0)">
      <summary>
            constructor
            </summary>
      <param name="value">value of vertex</param>
    </member>
    <member name="P:NSoft.NFramework.Collections.Vertex`1.Value">
      <summary>
            Value of this vertext
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.Vertex`1.Adjacents">
      <summary>
            Adjacent vertices
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.WeakReferenceDictionary`2">
      <summary>
            개체를 저장해 두지만, Gabage Collector가 삭제할 수 있도록 개체의 
            <see cref="T:System.WeakReference" />를 저장한다.
            </summary>
      <remarks>
            WeakReferenceDictionary의 Instance 는 Thread-safe하다.<br />
            
            개체의 <see cref="T:System.WeakReference" />를 저장하는 것이므로 
            Gabage Collector에 의해 삭제되면 null값을 가지게 되므로
            반환받은 값은 항상 null 값을 검사해야 한다.
            </remarks>
      <typeparam name="TKey">Key 타입</typeparam>
      <typeparam name="TValue">Value 타입</typeparam>
    </member>
    <member name="F:NSoft.NFramework.Collections.WeakReferenceDictionary`2._syncLock">
      <summary>
            thread-safe 한 함수들로 만들기 위해
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.WeakReferenceDictionary`2.GetValue(`0)">
      <summary>
            캐시에 저장된 key 값을 가진 객체를 반환한다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.WeakReferenceDictionary`2.Add(`0,`1)">
      <summary>
            캐시에 객체를 저장한다.
            </summary>
      <param name="key">객체의 유일 키값</param>
      <param name="value">객체</param>
      <returns>저장 여부</returns>
      <exception cref="T:System.ArgumentNullException">key나 value가 null이면 예외를 발생한다.</exception>
    </member>
    <member name="M:NSoft.NFramework.Collections.WeakReferenceDictionary`2.ContainsKey(`0)">
      <summary>
            캐시 저장소에 해당 key를 가진 개체가 존재하는지 검사
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.WeakReferenceDictionary`2.IsAlive(`0)">
      <summary>
            캐시에 저장된 객체가 Gabage Collector에 의해 리소스가 해제되지 않았음을 검사한다.
            즉 아직 메모리에 살아있는지 검사한다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Collections.WeakReferenceDictionary`2.GetGeneration(`0)">
      <summary>
            캐시에 키값을 가지는 개체의 GabageCollector 의 Generation 값을 구한다.
            </summary>
      <remarks>
            Generation 값이 -1 이면 메모리에서 해제 된 것이고, 
            숫자가 커질 수록 사용하지 않고, 오래된 개체이다.
            </remarks>
      <param name="key">객체의 키값</param>
      <returns>Generation Number, -1이면 메모리에서 해제된 것이다.</returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.WeakReferenceDictionary`2.Repository">
      <summary>
            저장소
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.WeakReferenceDictionary`2.Item(`0)">
      <summary>
            캐시에 저장된 key 값을 가진 개체
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Collections.WeakReferenceDictionary`2.Count">
      <summary>
            캐시에 저장된 전체 개체의 수 (상태에 상관없이)
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Collections.WeakReferenceDictionary`2.ActiveCount">
      <summary>
            캐시에 저장된 개체중 살아있는 개체의 수
            </summary>
      <value>
      </value>
    </member>
    <member name="T:NSoft.NFramework.Collections.WeakReferenceMap">
      <summary>
            객체의 Weak Reference 를 보관하여, Gabage Collection에 의해 수거되는 것을 허용하는 Hashtable입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Collections.WeakReferenceMap.Scavenge">
      <summary>
            이미 Gabage Collector에 의해 수거된 요소들을 제거합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.WeakReferenceMap.Count">
      <summary>
            단순히 컬렉션의 요소를 반환합니다. 실제 GC에 의해 소멸된 것도 갯수에 포함될 수 있습니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Collections.WeakReferenceWrapper">
      <summary>
            객체에 대해 WeakReference를 표현합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.WeakReferenceWrapper.IsAlive">
      <summary>
            원본 객체가 아직 살아있는지 (GC에 의해 청소되지 않았으면 True)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Collections.WeakReferenceWrapper.Target">
      <summary>
            GC에 의해 청소가 될 원본 객체
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Compressions.Compressors.AbstractCompressor">
      <summary>
            Compressor의 기본 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Compressions.ICompressor">
      <summary>
            압축/복원을 수행하는 압축기의 기본 Interface
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.ICompressor.Compress(System.Byte[])">
      <summary>
            지정된 데이타를 압축한다.
            </summary>
      <param name="input">압축할 Data</param>
      <returns>압축된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.ICompressor.Decompress(System.Byte[])">
      <summary>
            압축된 데이타를 복원한다.
            </summary>
      <param name="input">복원할 Data</param>
      <returns>복원된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.AbstractCompressor.Compress(System.Byte[])">
      <summary>
            지정된 데이타를 압축한다.
            </summary>
      <param name="input">압축할 Data</param>
      <returns>압축된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.AbstractCompressor.Decompress(System.Byte[])">
      <summary>
            압축된 데이타를 복원한다.
            </summary>
      <param name="input">복원할 Data</param>
      <returns>복원된 Data</returns>
    </member>
    <member name="T:NSoft.NFramework.Compressions.Compressors.CloneCompressor">
      <summary>
            Data를 복사만하고, Compression은 수행하지 않는 Class. Dummy로 사용할 때 필요한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.CloneCompressor.Compress(System.Byte[])">
      <summary>
            데이타를 복사만 한다.
            </summary>
      <param name="input">압축할 Data</param>
      <returns>압축된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.CloneCompressor.Decompress(System.Byte[])">
      <summary>
            데이타를 복사만 한다.
            </summary>
      <param name="input">복원할 Data</param>
      <returns>복원된 Data</returns>
    </member>
    <member name="T:NSoft.NFramework.Compressions.Compressors.DeflateCompressor">
      <summary>
            Deflate Algorithm을 이용하여 압축/복원을 수행하는 Class
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.DeflateCompressor.Compress(System.Byte[])">
      <summary>
            지정된 데이타를 압축한다.
            </summary>
      <param name="input">압축할 Data</param>
      <returns>압축된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.DeflateCompressor.Decompress(System.Byte[])">
      <summary>
            압축된 데이타를 복원한다.
            </summary>
      <param name="input">복원할 Data</param>
      <returns>복원된 Data</returns>
    </member>
    <member name="T:NSoft.NFramework.Compressions.Compressors.GZipCompressor">
      <summary>
            GZip Algorithm을 이용하여 압축/복원을 수행하는 Class
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.GZipCompressor.Compress(System.Byte[])">
      <summary>
            지정된 데이타를 압축한다.
            </summary>
      <param name="input">압축할 Data</param>
      <returns>압축된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.GZipCompressor.Decompress(System.Byte[])">
      <summary>
            압축된 데이타를 복원한다.
            </summary>
      <param name="input">복원할 Data</param>
      <returns>복원된 Data</returns>
    </member>
    <member name="T:NSoft.NFramework.Compressions.Compressors.IonicBZip2Compressor">
      <summary>
            Ionic 라이브러리의 BZip2 알고리즘을 이용한 Compressor 입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.IonicBZip2Compressor.#ctor">
      <summary>
            Initialize a new instance of SharpGZipCompressor with zip level : 6 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.IonicBZip2Compressor.#ctor(System.Int32)">
      <summary>
            Initialize a new instance of SharpGZipCompressor with zip level.
            </summary>
      <param name="zipLevel">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.IonicBZip2Compressor.Compress(System.Byte[])">
      <summary>
            지정된 데이타를 압축한다.
            </summary>
      <param name="input">압축할 Data</param>
      <returns>압축된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.IonicBZip2Compressor.Decompress(System.Byte[])">
      <summary>
            압축된 데이타를 복원한다.
            </summary>
      <param name="input">복원할 Data</param>
      <returns>복원된 Data</returns>
    </member>
    <member name="P:NSoft.NFramework.Compressions.Compressors.IonicBZip2Compressor.ZipLevel">
      <summary>
            Compression level (1~9)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Compressions.Compressors.IonicDeflateCompressor">
      <summary>
            Ionic 라이브러리의 Deflate 알고리즘을 이용한 Compressor 입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.IonicDeflateCompressor.Compress(System.Byte[])">
      <summary>
            지정된 데이타를 압축한다.
            </summary>
      <param name="input">압축할 Data</param>
      <returns>압축된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.IonicDeflateCompressor.Decompress(System.Byte[])">
      <summary>
            압축된 데이타를 복원한다.
            </summary>
      <param name="input">복원할 Data</param>
      <returns>복원된 Data</returns>
    </member>
    <member name="T:NSoft.NFramework.Compressions.Compressors.IonicGZipCompressor">
      <summary>
            Ionic 라이브러리의 GZip 알고리즘을 이용한 Compressor 입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.IonicGZipCompressor.Compress(System.Byte[])">
      <summary>
            지정된 데이타를 압축한다.
            </summary>
      <param name="input">압축할 Data</param>
      <returns>압축된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.IonicGZipCompressor.Decompress(System.Byte[])">
      <summary>
            압축된 데이타를 복원한다.
            </summary>
      <param name="input">복원할 Data</param>
      <returns>복원된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.IonicZlibCompressor.Compress(System.Byte[])">
      <summary>
            지정된 데이타를 압축한다.
            </summary>
      <param name="input">압축할 Data</param>
      <returns>압축된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.IonicZlibCompressor.Decompress(System.Byte[])">
      <summary>
            압축된 데이타를 복원한다.
            </summary>
      <param name="input">복원할 Data</param>
      <returns>복원된 Data</returns>
    </member>
    <member name="T:NSoft.NFramework.Compressions.Compressors.SevenZipCompressor">
      <summary>
            7Zip Algorithm을 이용한 Compressor (참고: http://www.7-zip.org/sdk.html)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.SevenZipCompressor.Compress(System.Byte[])">
      <summary>
            지정된 데이타를 압축한다.
            </summary>
      <param name="input">압축할 Data</param>
      <returns>압축된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.SevenZipCompressor.Decompress(System.Byte[])">
      <summary>
            압축된 데이타를 복원한다.
            </summary>
      <param name="input">복원할 Data</param>
      <returns>복원된 Data</returns>
    </member>
    <member name="T:NSoft.NFramework.Compressions.Compressors.SharpBZip2Compressor">
      <summary>
            BZip2 Algorithm을 이용하여 압축/복원을 수행하는 Class
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.SharpBZip2Compressor.Compress(System.Byte[])">
      <summary>
            지정된 데이타를 압축한다.
            </summary>
      <param name="input">압축할 Data</param>
      <returns>압축된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.SharpBZip2Compressor.Decompress(System.Byte[])">
      <summary>
            압축된 데이타를 복원한다.
            </summary>
      <param name="input">복원할 Data</param>
      <returns>복원된 Data</returns>
    </member>
    <member name="T:NSoft.NFramework.Compressions.Compressors.SharpGZipCompressor">
      <summary>
            ICSharpCode.SharpZipLib 의 GZip Alogorithm을 이용한 Compressor
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.SharpGZipCompressor.#ctor">
      <summary>
            Initialize a new instance of SharpGZipCompressor with zip level : 6 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.SharpGZipCompressor.#ctor(System.Int32)">
      <summary>
            Initialize a new instance of SharpGZipCompressor with zip level.
            </summary>
      <param name="zipLevel">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.SharpGZipCompressor.Compress(System.Byte[])">
      <summary>
            지정된 데이타를 압축한다.
            </summary>
      <param name="input">압축할 Data</param>
      <returns>압축된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressors.SharpGZipCompressor.Decompress(System.Byte[])">
      <summary>
            압축된 데이타를 복원한다.
            </summary>
      <param name="input">복원할 Data</param>
      <returns>복원된 Data</returns>
    </member>
    <member name="P:NSoft.NFramework.Compressions.Compressors.SharpGZipCompressor.ZipLevel">
      <summary>
            Compression level (0~9)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.SevenZip.ICoder.Code(System.IO.Stream,System.IO.Stream,System.Int64,System.Int64,NSoft.NFramework.Compressions.SevenZip.ICodeProgress)">
      <summary>
            Codes streams.
            </summary>
      <param name="inStream">
            input Stream.
            </param>
      <param name="outStream">
            output Stream.
            </param>
      <param name="inSize">
            input Size. -1 if unknown.
            </param>
      <param name="outSize">
            output Size. -1 if unknown.
            </param>
      <param name="progress">
            callback progress reference.
            </param>
      <exception cref="T:NSoft.NFramework.Compressions.SevenZip.DataErrorException">
            if input stream is not valid
            </exception>
    </member>
    <member name="M:NSoft.NFramework.Compressions.SevenZip.ICodeProgress.SetProgress(System.Int64,System.Int64)">
      <summary>
            Callback progress.
            </summary>
      <param name="inSize">
            input size. -1 if unknown.
            </param>
      <param name="outSize">
            output size. -1 if unknown.
            </param>
    </member>
    <member name="T:NSoft.NFramework.Compressions.SevenZip.CoderPropID">
      <summary>
            Provides the fields that represent properties idenitifiers for compressing.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.DefaultProp">
      <summary>
            Specifies default property.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.DictionarySize">
      <summary>
            Specifies size of dictionary.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.UsedMemorySize">
      <summary>
            Specifies size of memory for PPM*.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.Order">
      <summary>
            Specifies order for PPM methods.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.BlockSize">
      <summary>
            Specifies Block Size.
            </summary>
    </member>
    <!-- Badly formed XML comment ignored for member "F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.PosStateBits" -->
    <!-- Badly formed XML comment ignored for member "F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.LitContextBits" -->
    <!-- Badly formed XML comment ignored for member "F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.LitPosBits" -->
    <member name="F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.NumFastBytes">
      <summary>
            Specifies number of fast bytes for LZ*.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.MatchFinder">
      <summary>
            Specifies match finder. LZMA: "BT2", "BT4" or "BT4B".
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.MatchFinderCycles">
      <summary>
            Specifies the number of match finder cyckes.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.NumPasses">
      <summary>
            Specifies number of passes.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.Algorithm">
      <summary>
            Specifies number of algorithm.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.NumThreads">
      <summary>
            Specifies the number of threads.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Compressions.SevenZip.CoderPropID.EndMarker">
      <summary>
            Specifies mode with end marker.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressAdapter.Compress(System.Byte[])">
      <summary>
            바이트 배열 데이터를 압축합니다.
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressAdapter.Decompress(System.Byte[])">
      <summary>
            바이트 배열 데이터를 복원합니다.
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressAdapter.Compress(System.IO.Stream)">
      <summary>
            지정된 스트림을 압축합니다.
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressAdapter.Decompress(System.Byte[],System.IO.Stream)">
      <summary>
            지정한 데이터를 압축하여, <paramref name="destinationStream" /> 에 저장합니다.
            </summary>
      <param name="input">
      </param>
      <param name="destinationStream">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressAdapter.CompressAsync(System.IO.Stream,System.IO.Stream)">
      <summary>
            원본 스트림을 압축하여, 대상 스트림에 씁니다.
            </summary>
      <param name="sourceStream">
      </param>
      <param name="destinationStream">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressAdapter.DecompressAsync(System.IO.Stream,System.IO.Stream)">
      <summary>
            원본 스트림을 압축 해제하여, 대상 스트림에 씁니다.
            </summary>
      <param name="sourceStream">
      </param>
      <param name="targetStream">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Compressions.CompressAdapter.BaseCompressor">
      <summary>
            사용할 Compressor
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Compressions.Compressor">
      <summary>
            IoC를 통해 내부 ICompressor를 이용하여 Compression기능을 제공하는 Utility Class입니다.<br />
            기본적으로 GZipCompressor를 사용합니다.
            </summary>
      <example>
        <code>
            	byte[] plain = plainText.ToBytes();
            	byte[] compressed = Compressor.Compress(plain);
            	byte[] recovery = Compressor.Decompress(compressed);
            	Assert.AreEqual(plain, recovery);
            	</code>
      </example>
    </member>
    <member name="F:NSoft.NFramework.Compressions.Compressor.DefaultEncoding">
      <summary>
             압축기 기본 문자 인코딩 방식 (<see cref="P:System.Text.Encoding.UTF8" />)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressor.Compress(System.Byte[])">
      <summary>
            지정된 데이타를 압축한다.
            </summary>
      <param name="input">압축할 Data</param>
      <returns>압축된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressor.Decompress(System.Byte[])">
      <summary>
            압축된 데이타를 복원한다.
            </summary>
      <param name="input">복원할 Data</param>
      <returns>복원된 Data</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressor.Compress(System.String)">
      <summary>
            지정된 문자열을 압축하고, 압축된 데이타를 Base64 인코딩으로 변환하여 반환한다.
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressor.Decompress(System.String)">
      <summary>
            Base64로 인코딩된 압축 문자열을 복원하여 <see cref="P:System.Text.Encoding.UTF8" /> 문자열로 반환한다.
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressor.Compress(System.IO.Stream)">
      <summary>
            스트림을 압축한다.
            </summary>
      <param name="input">압축할 <see cref="T:System.IO.Stream" /></param>
      <returns>압축된 <see cref="T:System.IO.MemoryStream" /></returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.Compressor.Decompress(System.IO.Stream)">
      <summary>
            압축된 스트림을 복원한다.
            </summary>
      <param name="input">압축된 Stream</param>
      <returns>복원된 <see cref="T:System.IO.MemoryStream" /></returns>
    </member>
    <member name="P:NSoft.NFramework.Compressions.Compressor.InnerCompressor">
      <summary>
            Instance of inner compressor
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Compressions.CompressorEx">
      <summary>
        <see cref="T:NSoft.NFramework.Compressions.ICompressor" /> 의 Entension Methods 을 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressorEx.CompressAsync(NSoft.NFramework.Compressions.ICompressor,System.Byte[])">
      <summary>
            비동기 방식으로 지정한 정보를 압축합니다.
            </summary>
      <param name="compressor">
        <see cref="T:NSoft.NFramework.Compressions.ICompressor" /> 구현 객체</param>
      <param name="plain">압축할 데이터</param>
      <returns>압축을 수행하는 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressorEx.DecompressAsync(NSoft.NFramework.Compressions.ICompressor,System.Byte[])">
      <summary>
            비동기 방식으로 압축된 데이타를 복원합니다.
            </summary>
      <param name="compressor">
        <see cref="T:NSoft.NFramework.Compressions.ICompressor" /> 구현 객체</param>
      <param name="cipher">압축 복원할 데이터</param>
      <returns>압축 복원 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressorEx.CompressString(NSoft.NFramework.Compressions.ICompressor,System.String)">
      <summary>
            지정된 문자열을 압축하고, 압축된 데이타를 Base64 인코딩으로 변환하여 반환한다.
            </summary>
      <param name="compressor">
        <see cref="T:NSoft.NFramework.Compressions.ICompressor" /> 구현 객체</param>
      <param name="text">압축할 문자열</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressorEx.DecompressString(NSoft.NFramework.Compressions.ICompressor,System.String)">
      <summary>
            Base64로 인코딩된 압축 문자열을 복원하여 <see cref="P:System.Text.Encoding.UTF8" /> 문자열로 반환한다.
            </summary>
      <param name="compressor">
        <see cref="T:NSoft.NFramework.Compressions.ICompressor" /> 구현 객체</param>
      <param name="text">압축 복원을 할 문자열</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressorEx.CompressStringAsync(NSoft.NFramework.Compressions.ICompressor,System.String)">
      <summary>
            지정된 문자열을 압축하고, 압축된 데이타를 Base64 인코딩으로 변환하여 반환한다.
            </summary>
      <param name="compressor">
        <see cref="T:NSoft.NFramework.Compressions.ICompressor" /> 구현 객체</param>
      <param name="text">압축할 문자열</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressorEx.DecompressStringAsync(NSoft.NFramework.Compressions.ICompressor,System.String)">
      <summary>
            Base64로 인코딩된 압축 문자열을 복원하여 <see cref="P:System.Text.Encoding.UTF8" /> 문자열로 반환한다.
            </summary>
      <param name="compressor">
        <see cref="T:NSoft.NFramework.Compressions.ICompressor" /> 구현 객체</param>
      <param name="text">압축 복원을 할 문자열</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressorEx.CompressStream(NSoft.NFramework.Compressions.ICompressor,System.IO.Stream)">
      <summary>
            스트림을 압축한다.
            </summary>
      <param name="compressor">
        <see cref="T:NSoft.NFramework.Compressions.ICompressor" /> 구현 객체</param>
      <param name="stream">압축할 <see cref="T:System.IO.Stream" /></param>
      <returns>압축된 <see cref="T:System.IO.MemoryStream" /></returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressorEx.DecompressStream(NSoft.NFramework.Compressions.ICompressor,System.IO.Stream)">
      <summary>
            압축된 스트림을 복원한다.
            </summary>
      <param name="compressor">
        <see cref="T:NSoft.NFramework.Compressions.ICompressor" /> 구현 객체</param>
      <param name="stream">압축된 Stream</param>
      <returns>복원된 <see cref="T:System.IO.MemoryStream" /></returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressorEx.CompressStreamAsync(NSoft.NFramework.Compressions.ICompressor,System.IO.Stream)">
      <summary>
            스트림을 압축한다.
            </summary>
      <param name="compressor">
        <see cref="T:NSoft.NFramework.Compressions.ICompressor" /> 구현 객체</param>
      <param name="stream">압축할 <see cref="T:System.IO.Stream" /></param>
      <returns>압축된 <see cref="T:System.IO.MemoryStream" /></returns>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressorEx.DecompressStreamAsync(NSoft.NFramework.Compressions.ICompressor,System.IO.Stream)">
      <summary>
            압축된 스트림을 복원한다.
            </summary>
      <param name="compressor">
        <see cref="T:NSoft.NFramework.Compressions.ICompressor" /> 구현 객체</param>
      <param name="stream">압축된 Stream</param>
      <returns>복원된 <see cref="T:System.IO.MemoryStream" /></returns>
    </member>
    <member name="F:NSoft.NFramework.Compressions.CompressorTool.BUFFER_SIZE">
      <summary>
            Decompress시에 사용할 버퍼의 크기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Compressions.CompressorTool.EmptyBytes">
      <summary>
            빈 바이크 배열
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Compressions.CompressorTool.IsZeroLength(System.Byte[])">
      <summary>
            빈 데이타인지 검사한다.
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Configurations.AssemblyQualifiedTypeNameConverter">
      <summary>
            Represents a configuration converter that converts a string to <see cref="T:System.Type" /> based on a fully qualified name.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Configurations.AssemblyQualifiedTypeNameConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
      <summary>
            Returns the assembly qualified name for the passed in Type.
            </summary>
      <param name="context">The container representing this System.ComponentModel.TypeDescriptor.</param>
      <param name="culture">Culture info for assembly</param>
      <param name="value">Value to convert.</param>
      <param name="destinationType">Type to convert to.</param>
      <returns>Assembly Qualified Name as a string</returns>
    </member>
    <member name="M:NSoft.NFramework.Configurations.AssemblyQualifiedTypeNameConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
      <summary>
            Returns a type based on the assembly qualified name passed in as data.
            </summary>
      <param name="context">The container representing this System.ComponentModel.TypeDescriptor.</param>
      <param name="culture">Culture info for assembly.</param>
      <param name="value">Data to convert.</param>
      <returns>Type of the data</returns>
    </member>
    <member name="T:NSoft.NFramework.Configurations.NamedConfigurationElement">
      <summary>
            Represents a named <see cref="T:System.Configuration.ConfigurationElement" /> wher the name is the key to a collection.
            </summary>
      <remarks>
            This class is used in conjunction with a <see cref="T:NSoft.NFramework.Configurations.NamedElementCollection`1" />.
            </remarks>
    </member>
    <member name="F:NSoft.NFramework.Configurations.NamedConfigurationElement.nameProperty">
      <summary>
            Name of the property that holds the name of <see cref="T:NSoft.NFramework.Configurations.NamedConfigurationElement" />.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Configurations.NamedConfigurationElement.#ctor">
      <summary>
            Initialize a new instance of a <see cref="T:NSoft.NFramework.Configurations.NamedConfigurationElement" /> class.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Configurations.NamedConfigurationElement.#ctor(System.String)">
      <summary>
            Intialize a new instance of a <see cref="T:NSoft.NFramework.Configurations.NamedConfigurationElement" /> class with a name.
            </summary>
      <param name="name">The name of the element.</param>
    </member>
    <member name="M:NSoft.NFramework.Configurations.NamedConfigurationElement.DeserializeElement(System.Xml.XmlReader)">
      <summary>
            This method supports the Enterprise Library infrastructure and is not intended to be used directly from your code.
            Updates the configuration properties of the receiver with the information in the current element in the <paramref name="reader" />.
            </summary>
      <param name="reader">The reader over the configuration file.</param>
    </member>
    <member name="P:NSoft.NFramework.Configurations.NamedConfigurationElement.Name">
      <summary>
            Gets or sets the name of the element.
            </summary>
      <value>
            The name of the element.
            </value>
    </member>
    <member name="T:NSoft.NFramework.Configurations.NamedElementCollection`1">
      <summary>
            Represents a collection of <see cref="T:NSoft.NFramework.Configurations.NamedConfigurationElement" /> objects.
            </summary>
      <typeparam name="T">A newable object that inherits from <see cref="T:NSoft.NFramework.Configurations.NamedConfigurationElement" />.</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Configurations.NamedElementCollection`1.ForEach(System.Action{`0})">
      <summary>
            Performs the specified action on each element of the collection.
            </summary>
      <param name="action">The action to perform.</param>
    </member>
    <member name="M:NSoft.NFramework.Configurations.NamedElementCollection`1.Get(System.Int32)">
      <summary>
            Gets the configuration element at the specified index location. 
            </summary>
      <param name="index">The index location of the <see name="T" /> to return. </param>
      <returns>The <see name="T" /> at the specified index. </returns>
    </member>
    <member name="M:NSoft.NFramework.Configurations.NamedElementCollection`1.Add(`0)">
      <summary>
            Add an instance of <typeparamref name="T" /> to the collection.
            </summary>
      <param name="element">An instance of <typeparamref name="T" />.</param>
    </member>
    <member name="M:NSoft.NFramework.Configurations.NamedElementCollection`1.Get(System.String)">
      <summary>
            Gets the named instance of <typeparamref name="T" /> from the collection.
            </summary>
      <param name="name">The name of the <typeparamref name="T" /> instance to retrieve.</param>
      <returns>The instance of <typeparamref name="T" /> with the specified key; otherwise, <see langword="null" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Configurations.NamedElementCollection`1.Contains(System.String)">
      <summary>
            Determines if the name exists in the collection.
            </summary>
      <param name="name">The name to search.</param>
      <returns>
        <see langword="true" /> if the name is contained in the collection; otherwise, <see langword="false" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Configurations.NamedElementCollection`1.Remove(System.String)">
      <summary>
            Remove the named element from the collection.
            </summary>
      <param name="name">The name of the element to remove.</param>
    </member>
    <member name="M:NSoft.NFramework.Configurations.NamedElementCollection`1.Clear">
      <summary>
            Clear the collection.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Configurations.NamedElementCollection`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection. 
            </summary>
      <returns>An enumerator that iterates through the collection.</returns>
    </member>
    <member name="M:NSoft.NFramework.Configurations.NamedElementCollection`1.CreateNewElement">
      <summary>
            Creates a new instance of a <typeparamref name="T" /> object.
            </summary>
      <returns>A new <see cref="T:System.Configuration.ConfigurationElement" />.</returns>
    </member>
    <member name="M:NSoft.NFramework.Configurations.NamedElementCollection`1.GetElementKey(System.Configuration.ConfigurationElement)">
      <summary>
            Gets the element key for a specified configuration element when overridden in a derived class. 
            </summary>
      <param name="element">The <see cref="T:System.Configuration.ConfigurationElement" /> to return the key for. </param>
      <returns>An <see cref="T:System.Object" /> that acts as the key for the specified <see cref="T:System.Configuration.ConfigurationElement" />.</returns>
    </member>
    <member name="T:NSoft.NFramework.Configurations.SerializableConfigurationSection">
      <summary>
            Represents a configuration section that can be serialized and deserialized to XML.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Configurations.SerializableConfigurationSection.GetSchema">
      <summary>
            Returns the XML schema for the configuration section.
            </summary>
      <returns>A string with the XML schema, or <see langword="null" /> (<b>Nothing</b> 
            in Visual Basic) if there is no schema.</returns>
    </member>
    <member name="M:NSoft.NFramework.Configurations.SerializableConfigurationSection.ReadXml(System.Xml.XmlReader)">
      <summary>
            Updates the configuration section with the values from an <see cref="T:System.Xml.XmlReader" />.
            </summary>
      <param name="reader">The <see cref="T:System.Xml.XmlReader" /> that reads the configuration source located at the element that describes the configuration section.</param>
    </member>
    <member name="M:NSoft.NFramework.Configurations.SerializableConfigurationSection.WriteXml(System.Xml.XmlWriter)">
      <summary>
            Writes the configuration section values as an XML element to an <see cref="T:System.Xml.XmlWriter" />.
            </summary>
      <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> that writes to the configuration source.</param>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.Aria.AriaEngine">
      <summary>
            ARIA 알고리즘을 사용하여, 암호회/복호화를 수행합니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Cryptography.Aria.AriaEngine.DefaultAriaKeySize">
      <summary>
            기본 키 사이즈 (256)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Aria.AriaEngine.Encrypt(System.Byte[],System.Int32,System.Byte[],System.Int32)">
      <summary>
            암호화를 수행하여, 결과를 <paramref name="o" />에 저장합니다.
            </summary>
      <param name="i">
      </param>
      <param name="ioffset">
      </param>
      <param name="o">
      </param>
      <param name="ooffset">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Aria.AriaEngine.Encrypt(System.Byte[],System.Int32)">
      <summary>
            암호화를 수행하여, 결과를 반환합니다.
            </summary>
      <param name="i">
      </param>
      <param name="ioffset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Aria.AriaEngine.Decrypt(System.Byte[],System.Int32,System.Byte[],System.Int32)">
      <summary>
            복호화를 수행하여, 결과를 대상 버퍼에 씁니다.
            </summary>
      <param name="i">
      </param>
      <param name="ioffset">
      </param>
      <param name="o">
      </param>
      <param name="ooffset">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Aria.AriaEngine.Decrypt(System.Byte[],System.Int32)">
      <summary>
            복호화를 수행하여, 결과를 반환합니다.
            </summary>
      <param name="i">
      </param>
      <param name="ioffset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.Encryptors.HashEncryptor">
      <summary>
            해시 암호화를 수행합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.IHashEncryptor">
      <summary>
            Hash Algorithm을 이용해서 암호화를 수행한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.IHashEncryptor.ComputeHash(System.String)">
      <summary>
            지정된 문자열을 암호화를 수행한다.
            </summary>
      <param name="plainText">암호화할 문자열</param>
      <returns>Hashing한 정보</returns>
      <exception cref="T:System.ArgumentNullException">암호화할 문자열이 빈 문자열일 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.IHashEncryptor.ComputeHash(System.String,NSoft.NFramework.Cryptography.EncryptionStringFormat)">
      <summary>
            지정된 문자열을 암호화를 수행하고, 값을 일반적인 값으로 반환한다.
            </summary>
      <param name="plainText">암호화할 문자열</param>
      <param name="format">암호화한 정보를 문자열로 표현시 사용할 포맷 (Base64/Hex)</param>
      <returns>Hashing한 정보</returns>
      <exception cref="T:System.ArgumentNullException">암호화할 문자열이 빈 문자열일 때</exception>
    </member>
    <member name="P:NSoft.NFramework.Cryptography.IHashEncryptor.Algorithm">
      <summary>
            Hash Algorithm 종류
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.HashEncryptor.#ctor">
      <summary>
            SHA256 알고리즘을 이용한 Hash 암호화 클래스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.HashEncryptor.#ctor(System.Security.Cryptography.HashAlgorithm)">
      <summary>
            지정된 HashAlgorithm을 이용하는 HashEncryptor를 생성합니다.
            </summary>
      <param name="algorithm">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.HashEncryptor.ComputeHash(System.String)">
      <summary>
            지정된 문자열을 암호화를 수행한다.
            </summary>
      <param name="plainText">암호화할 문자열</param>
      <returns>Hashing한 정보</returns>
      <exception cref="T:System.ArgumentNullException">암호화할 문자열이 빈 문자열일 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.HashEncryptor.ComputeHash(System.String,NSoft.NFramework.Cryptography.EncryptionStringFormat)">
      <summary>
            지정된 문자열을 암호화를 수행하고, 값을 일반적인 값으로 반환한다.
            </summary>
      <param name="plainText">암호화할 문자열</param>
      <param name="format">암호화한 정보를 문자열로 표현시 사용할 포맷 (Base64/Hex)</param>
      <returns>Hashing한 정보</returns>
      <exception cref="T:System.ArgumentNullException">암호화할 문자열이 빈 문자열일 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.HashEncryptor.Finalize">
      <summary>
            소멸자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.HashEncryptor.Dispose">
      <summary>
            리소스 해제
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.HashEncryptor.Dispose(System.Boolean)">
      <summary>
            리소스 해제
            </summary>
      <param name="disposing">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Cryptography.Encryptors.HashEncryptor.Algorithm">
      <summary>
            Hash Algorithm
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Cryptography.Encryptors.HashEncryptor.IsDisposed">
      <summary>
            리소스 해제 여부
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.Encryptors.SHA256HashEncryptor">
      <summary>
            SHA256 해시 알고리즘을 이용한 암호화기
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.Encryptors.SHA384HashEncryptor">
      <summary>
            SHA384 해시 알고리즘을 이용한 암호화기. 차라리 <see cref="T:NSoft.NFramework.Cryptography.Encryptors.SHA512HashEncryptor" />를 사용하세요.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.Encryptors.SHA512HashEncryptor">
      <summary>
            SHA512 해시 알고리즘을 이용한 암호화기
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.Encryptors.AriaSymmetricEncryptor">
      <summary>
            ARIA 알고리즘은 대칭형 암호화 알고리즘으로서, 암호화/복호화가 가능합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.ISymmetricEncryptor">
      <summary>
            대칭형 암호화를 수행합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.ISymmetricEncryptor.Encrypt(System.Byte[])">
      <summary>
            지정한 정보를 암호화한다.
            </summary>
      <param name="plainBytes">암호화할 정보</param>
      <returns>암호화된 정보</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.ISymmetricEncryptor.Decrypt(System.Byte[])">
      <summary>
            지정한 암호화된 정보를 복호화한다.
            </summary>
      <param name="cipher">암호화된 정보</param>
      <returns>복호화된 정보</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.AriaSymmetricEncryptor.Encrypt(System.Byte[])">
      <summary>
            지정한 정보를 암호화한다.
            </summary>
      <param name="plainBytes">암호화할 정보</param>
      <returns>암호화된 정보</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.AriaSymmetricEncryptor.Decrypt(System.Byte[])">
      <summary>
            지정한 암호화된 정보를 복호화한다.
            </summary>
      <param name="cipher">암호화된 정보</param>
      <returns>복호화된 정보</returns>
    </member>
    <member name="P:NSoft.NFramework.Cryptography.Encryptors.AriaSymmetricEncryptor.Password">
      <summary>
            비밀번호
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Cryptography.Encryptors.AriaSymmetricEncryptor.Key">
      <summary>
            비밀 번호에 해당하는 문자열
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Cryptography.Encryptors.AriaSymmetricEncryptor.KeySize">
      <summary>
            마스터 키의 크기 <see cref="P:NSoft.NFramework.Cryptography.Encryptors.AriaSymmetricEncryptor.Key" />의 길이의 8배
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.Encryptors.DESSymmetricEncryptor">
      <summary>
            DES 대칭형 알고리즘을 사용한 암호 클래스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptor.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptor.#ctor(System.Security.Cryptography.SymmetricAlgorithm)">
      <summary>
            Constructor
            </summary>
      <param name="algorithm">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptor.#ctor(System.Security.Cryptography.SymmetricAlgorithm,System.String)">
      <summary>
            Constructor
            </summary>
      <param name="algorithm">
      </param>
      <param name="key">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptor.Encrypt(System.Byte[])">
      <summary>
            지정한 정보를 암호화한다.
            </summary>
      <param name="plainBytes">암호화할 정보</param>
      <returns>암호화된 정보</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptor.Decrypt(System.Byte[])">
      <summary>
            지정한 암호화된 정보를 복호화한다.
            </summary>
      <param name="cipher">암호화된 정보</param>
      <returns>복호화된 정보</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptor.Finalize">
      <summary>
            소멸자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptor.Dispose">
      <summary>
            리소스 해제
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptor.Dispose(System.Boolean)">
      <summary>
            리소스 해제
            </summary>
      <param name="disposing">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptor.Algorithm">
      <summary>
            대칭형 암호화 Algorithm
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptor.Key">
      <summary>
            암호화시 사용될 비밀번호
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptor.IsDisposed">
      <summary>
            리소스 해제 여부
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.Encryptors.RC2SymmetricEncryptor">
      <summary>
            RC2 대칭형 알고리즘을 사용하는 암호화 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.Encryptors.RijndaelSymmetricEncryptor">
      <summary>
            Rijndael 대칭형 알고리즘을 사용하는 암호화기입니다. 가장 많이 사용되어지는 알고리즘입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.Encryptors.TripleDESSymmetricEncryptor">
      <summary>
            Triple DES 대칭형 알고리즘을 사용한 암호화 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptorEx">
      <summary>
            대칭형 암호화 인스턴스(<see cref="T:NSoft.NFramework.Cryptography.ISymmetricEncryptor" />)에 대한 확장 메소드를 제공합니다. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptorEx.EncryptAsync(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.Byte[])">
      <summary>
            비동기 방식으로 데이터를 암호화 합니다.
            </summary>
      <param name="encryptor">
      </param>
      <param name="plainBytes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptorEx.DecriptAsync(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.Byte[])">
      <summary>
            비동기 방식으로 암호화된 데이터를 복원합니다.
            </summary>
      <param name="encryptor">
      </param>
      <param name="cipher">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptorEx.EncryptString(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.String)">
      <summary>
            문자열을 암호화합니다.
            </summary>
      <param name="encryptor">
      </param>
      <param name="text">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptorEx.DecryptString(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.String)">
      <summary>
            암호화된 문자열을 복원합니다.
            </summary>
      <param name="encryptor">
      </param>
      <param name="encryptedText">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptorEx.EncryptStringAsync(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.String)">
      <summary>
            비동기 방식으로 문자열을 암호화합니다.
            </summary>
      <param name="encryptor">
      </param>
      <param name="text">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptorEx.DecryptStringAsync(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.String)">
      <summary>
            비동기 방식으로 암호화된 문자열을 복원합니다.
            </summary>
      <param name="encryptor">
      </param>
      <param name="encryptedText">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptorEx.EncryptStream(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.IO.Stream)">
      <summary>
            스트림을 암호화 합니다.
            </summary>
      <param name="encryptor">
      </param>
      <param name="stream">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptorEx.DecryptStream(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.IO.Stream)">
      <summary>
            암호화된 스트림을 복원합니다.
            </summary>
      <param name="encryptor">
      </param>
      <param name="stream">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptorEx.EncryptStreamAsync(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.IO.Stream)">
      <summary>
            비동기 방식으로 스트림을 암호화합니다.
            </summary>
      <param name="encryptor">
      </param>
      <param name="stream">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.Encryptors.SymmetricEncryptorEx.DecryptStreamAsync(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.IO.Stream)">
      <summary>
            비동기 방식으로 암호화된 스트림을 복원합니다.
            </summary>
      <param name="encryptor">
      </param>
      <param name="stream">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.CryptoTool">
      <summary>
            암호화 관련 Utility Class 입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.ComputeHashToBytes(NSoft.NFramework.Cryptography.IHashEncryptor,System.String)">
      <summary>
            Hash 값을 계산합니다.
            </summary>
      <param name="hasher">Hash 알고리즘을 이용하는 암호기</param>
      <param name="plainText">원본 문자열</param>
      <returns>Hashing 된 바이트 배열</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.ComputeHashToString(NSoft.NFramework.Cryptography.IHashEncryptor,System.String,NSoft.NFramework.Cryptography.EncryptionStringFormat)">
      <summary>
            Hash 값을 계산해서, 문자열로 반환합니다.
            </summary>
      <param name="hasher">Hash 알고리즘을 이용하는 암호기</param>
      <param name="plainText">원본 문자열</param>
      <param name="format">암호화된 정보의 문자열 형식(Base64|HexDecimal)</param>
      <returns>Hashing 된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.EncryptBytes(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.Byte[])">
      <summary>
            대칭형 암호화 알고리즘을 이용하여 <paramref name="plainBytes" />를 암호화 합니다.
            </summary>
      <param name="encryptor">대칭형 암호화 인스턴스</param>
      <param name="plainBytes">원본 정보</param>
      <returns>암호화된 정보</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.DecryptBytes(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.Byte[])">
      <summary>
            대칭형 암호화 알고르즘을 이용하여 <paramref name="cipherBytes" />를 복호화 합니다.
            </summary>
      <param name="encryptor">대칭형 암호화 인스턴스</param>
      <param name="cipherBytes">암호화된 정보</param>
      <returns>복호화된 정보</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.EncryptString(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.String,NSoft.NFramework.Cryptography.EncryptionStringFormat)">
      <summary>
            대칭형 암호화 알고리즘을 이용하여 <paramref name="plainText" />를 암호화하여, <paramref name="format" /> 형태의 문자열로 반환합니다.
            </summary>
      <param name="encryptor">대칭형 암호화 인스턴스</param>
      <param name="plainText">원본 문자열</param>
      <param name="format">암호화된 정보의 문자열 형식(Base64|HexDecimal)</param>
      <returns>암호화된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.DecryptString(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.String,NSoft.NFramework.Cryptography.EncryptionStringFormat)">
      <summary>
            대칭형 암호화 알고리즘을 이용하여, <paramref name="format" />형태의 <paramref name="cipherText" />를 복호화합니다.
            </summary>
      <param name="encryptor">대칭형 암호화 인스턴스</param>
      <param name="cipherText">암호화된 정보</param>
      <param name="format">암호화된 정보의 문자열 형식(Base64|HexDecimal)</param>
      <returns>복화화된 원본 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.EncryptStream(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.IO.Stream)">
      <summary>
            대칭형 암호화 알고리즘을 이용하여, <paramref name="plainStream" />을 암호화하여 스트림으로 반환합니다.
            </summary>
      <param name="encryptor">대칭형 암호화 인스턴스</param>
      <param name="plainStream">원본 스트림</param>
      <returns>암호화된 스트림</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.DecryptString(NSoft.NFramework.Cryptography.ISymmetricEncryptor,System.IO.Stream)">
      <summary>
            대칭형 암호화 알고리즘을 이용하여, <paramref name="cipherStream" />을 복호화한 스트림을 반환합니다.
            </summary>
      <param name="encryptor">대칭형 암호화 인스턴스</param>
      <param name="cipherStream">암호화된 정보를 가진 스트림</param>
      <returns>복호화된 정보를 가진 스트림</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.ClearBuffer(System.Byte[])">
      <summary>
            Clear the specified buffer value to 0.
            </summary>
      <param name="bytes">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.BytesToHex(System.Byte[])">
      <summary>
            Byte 배열을 16진수 문자열로 변환한다.
            </summary>
      <param name="bytes">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.HexToBytes(System.String)">
      <summary>
            16진수 형태의 문자열을 파싱하여 byte 배열을 만든다.
            </summary>
      <param name="hexString">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.BytesToString(System.Byte[],NSoft.NFramework.Cryptography.EncryptionStringFormat)">
      <summary>
            암호화된 Byte 배열을 지정된 형식의 문자열로 변환한다.
            </summary>
      <param name="bytes">
      </param>
      <param name="format">
      </param>
      <returns>
      </returns>
      <seealso cref="M:NSoft.NFramework.Cryptography.CryptoTool.StringToBytes(System.String,NSoft.NFramework.Cryptography.EncryptionStringFormat)" />
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.StringToBytes(System.String,NSoft.NFramework.Cryptography.EncryptionStringFormat)">
      <summary>
            지정된 형식의 문자열을 byte 배열로 변환한다.
            </summary>
      <param name="content">변환할 문자열</param>
      <param name="format">변활할 포맷</param>
      <returns>
      </returns>
      <seealso cref="M:NSoft.NFramework.Cryptography.CryptoTool.BytesToString(System.Byte[],NSoft.NFramework.Cryptography.EncryptionStringFormat)" />
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.StreamToBytes(System.IO.Stream)">
      <summary>
        <see cref="T:System.IO.Stream" /> 객체 정보를 읽어서, Byte 배열로 만든다.
            </summary>
      <param name="inStream">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.GenerateSalt(System.Int32)">
      <summary>
            랜덤한 숫자를 만들어낸다. 비밀번호 키를 만들 때 좋다.
            </summary>
      <param name="saltLength">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.DerivePassword(System.String,System.Int32)">
      <summary>
            보통 문자열을 SALT 를 이용해 암호화된 새로운 비밀번호를 만든다.
            </summary>
      <param name="originalPassword">원본 문자열</param>
      <param name="newPasswordLength">암호화된 새로운 비밀번호의 길이</param>
      <returns>암호화된 비밀번호를 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.DerivePasswordAsText(System.String,System.Int32,NSoft.NFramework.Cryptography.EncryptionStringFormat)">
      <summary>
            원본 문자열을 SALT 를 이용해 암호화 하여, 원하는 형식의 문자열로 반환한다.
            </summary>
      <param name="originalPassword">원본 문자열</param>
      <param name="newPasswordLength">새로운 문자열의 byte stream 크기</param>
      <param name="format">Base64 or HexaDecimal ContentFormat</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.CryptoTool.GetInitialVector(System.Int32)">
      <summary>
            SymmetricAlgorithm 에서 KeySize에 해당하는 Initial Vector를 구한다.
            </summary>
      <param name="keyLength">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Cryptography.EncryptionStringFormat">
      <summary>
            암호화한 문자열로 변환할 때, 문자열 포맷 종류
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Cryptography.EncryptionStringFormat.HexDecimal">
      <summary>
            16 진수 포맷
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Cryptography.EncryptionStringFormat.Base64">
      <summary>
            Base64 인코딩 포맷
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.HashEncryptor.ComputeHash(System.String)">
      <summary>
            지정된 문자열을 암호화를 수행한다.
            </summary>
      <param name="plainText">암호화할 문자열</param>
      <returns>Hashing한 정보</returns>
      <exception cref="T:System.ArgumentNullException">암호화할 문자열이 빈 문자열일 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Cryptography.HashEncryptor.ComputeHash(System.String,NSoft.NFramework.Cryptography.EncryptionStringFormat)">
      <summary>
            지정된 문자열을 암호화를 수행하고, 값을 일반적인 값으로 반환한다.
            </summary>
      <param name="plainText">암호화할 문자열</param>
      <param name="format">암호화한 정보를 문자열로 표현시 사용할 포맷 (Base64/Hex)</param>
      <returns>Hashing한 정보</returns>
      <exception cref="T:System.ArgumentNullException">암호화할 문자열이 빈 문자열일 때</exception>
    </member>
    <member name="P:NSoft.NFramework.Cryptography.HashEncryptor.Algorithm">
      <summary>
            Hash Algorithm 종류
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Cryptography.KeySize.RC2">
      <summary>
            Key size for RC2 algorithm (64)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Cryptography.KeySize.DES">
      <summary>
            Key size for DES algorithm (64)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Cryptography.KeySize.TripleDES">
      <summary>
            Key size for TripleDES algorithm (192)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Cryptography.KeySize.AES">
      <summary>
            Key size for AES algorithm (128)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Cryptography.KeySize.RSA">
      <summary>
            Key size for RSA algorithm (2048)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider">
      <summary>
            ASP.NET Applications 에 대한 <see cref="T:System.Diagnostics.PerformanceCounter" />를 제공합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Diagnostics.InstancePerformanceCounterProviderBase">
      <summary>
            인스턴스 성능 카운터 제공자의 기본 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Diagnostics.PerformanceCounterProviderBase">
      <summary>
            성능 카운터 제공자의 기본 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Diagnostics.IPerformanceCounterProvider">
      <summary>
            PerformanceCounter 제공자입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.IPerformanceCounterProvider.GetCounterNames">
      <summary>
            제공하는 PerformanceCounter 들의 CountName을 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.IPerformanceCounterProvider.CategoryName">
      <summary>
            PerformanceCounter가 속한 Category 명
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.IPerformanceCounterProvider.PerformanceCounters">
      <summary>
            제공되는 PerformanceCounter의 컬렉션입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.PerformanceCounterProviderBase.#ctor(System.String)">
      <summary>
            생성자
            </summary>
      <param name="categoryName">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.PerformanceCounterProviderBase.GetCounterNames">
      <summary>
            제공하는 PerformanceCounter 들의 CountName을 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.PerformanceCounterProviderBase.CreatePerformanceCounter(System.String)">
      <summary>
            지정된 이름의 Counter를 생성합니다.
            </summary>
      <param name="counterName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.PerformanceCounterProviderBase.CategoryName">
      <summary>
            PerformanceCounter가 속한 Category 명
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.PerformanceCounterProviderBase.PerformanceCounters">
      <summary>
            제공되는 PerformanceCounter의 컬렉션입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Diagnostics.IInstancePerformanceCounterProvider">
      <summary>
            Instance 별로 PerformanceCounter를 제공하는 Provider의 인터페이스입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.IInstancePerformanceCounterProvider.InstanceName">
      <summary>
            Instance name
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.InstancePerformanceCounterProviderBase.#ctor(System.String)">
      <summary>
            생성자
            </summary>
      <param name="categoryName">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.InstancePerformanceCounterProviderBase.#ctor(System.String,System.String)">
      <summary>
            생성자
            </summary>
      <param name="categoryName">
      </param>
      <param name="instanceName">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.InstancePerformanceCounterProviderBase.CreatePerformanceCounter(System.String)">
      <summary>
            지정된 이름의 Counter를 생성합니다.
            </summary>
      <param name="counterName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.InstancePerformanceCounterProviderBase.InstanceName">
      <summary>
            인스턴스 명
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.ApplicationLifetimeEvents">
      <summary>
            Application Lifetime Events
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.ApplicationLifetimeEventsPerSec">
      <summary>
            Application Lifetime Events
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.AuditFailureEventsRaised">
      <summary>
            Audit Failure Events Raised
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.AuditSuccessEventsRaised">
      <summary>
            Audit Success Events Raised
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.CachePercentOfMachineMemoryLimitUsed">
      <summary>
            Cache % Machine Memory Limit Used
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.CachePercentOfProcessMemoryLimitUsed">
      <summary>
            Cache % Process Memory Limit Used
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.CompilationsTotal">
      <summary>
            Compilations Total
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.DebuggingRequests">
      <summary>
            Debugging Requests
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.ErrorEventRaised">
      <summary>
            Error Events Raised
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.ErrorEventRaisedPerSec">
      <summary>
            Error Events Raised/Sec
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.ErrorsDuringCompilation">
      <summary>
            Errors During Compilation
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.ErrorsDuringExecution">
      <summary>
            Errors During Execution
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.ErrorsDuringPreProcessing">
      <summary>
            Errors During Preprocessing
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.ErrorsTotal">
      <summary>
            Errors Total
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.ErrorsTotalPerSec">
      <summary>
            Errors Total
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.ErrorsUnhandledDuringExecution">
      <summary>
            Errors Unhanded During Execution
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.ErrorsUnhandledDuringExecutionPerSec">
      <summary>
            Errors Unhanded During Execution/Sec
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.EventsRaised">
      <summary>
            Events Raised
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.EventsRaisedPerSec">
      <summary>
            Events Raised/Sec
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestBytesInTotal">
      <summary>
            Request Bytes In Total
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestBytesOutTotal">
      <summary>
            Request Bytes Out Total
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestErrorEventsRaised">
      <summary>
            Request Error Events Raised
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestErrorEventsRaisedPerSec">
      <summary>
            Events Raised/Sec
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestExecutionTime">
      <summary>
            Request Execution Time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestWaitTime">
      <summary>
            Request Wait Time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestsDisconnected">
      <summary>
            Request Disconnected
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestsExecuting">
      <summary>
            Request Executing
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestsFailed">
      <summary>
            Request Failed
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestsInApplicationQueue">
      <summary>
            Requests In Application Queue
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestsRejected">
      <summary>
            Requests Rejected
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestsSucceeded">
      <summary>
            Requests Succeeded
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestsTimedOut">
      <summary>
            Requests Timed Out
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestsTotal">
      <summary>
            Requests Total
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.RequestsPerSec">
      <summary>
            Requests/Sec
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.SessionSQLServerConnectionsTotal">
      <summary>
            Session SQL Server connections total
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.SessionStateServerConnectionsTotal">
      <summary>
            Session State Server connections total
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.SessionsAbandoned">
      <summary>
            Sessions Abandoned
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.SessionsActive">
      <summary>
            Sessions Active
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.SessionsTimedOut">
      <summary>
            Sessions Timed Out
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.SessionsTotal">
      <summary>
            Sessions Total
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.TransactionsAborted">
      <summary>
            Transactions Aborted
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.TransactionsCommitted">
      <summary>
            Transactions Committed
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.TransactionsPending">
      <summary>
            Transactions Pending
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.TransactionsTotal">
      <summary>
            Transactions Total
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.TransactionsPerSec">
      <summary>
            Transactions/Sec
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetApplicationsPerformanceCounterProvider.ViewstateMACValidationFailure">
      <summary>
            Viewstate MAC Validation Failure
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Diagnostics.Providers.AspNetPerformanceCounterProvider">
      <summary>
            ASP.NET 성능 측정 제공자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.Providers.AspNetPerformanceCounterProvider.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetPerformanceCounterProvider.ApplicationRestarts">
      <summary>
            Application Restarts
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetPerformanceCounterProvider.ApplicationsRunning">
      <summary>
            Applications Running
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetPerformanceCounterProvider.RequestExecutionTime">
      <summary>
            Request Execution Time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetPerformanceCounterProvider.RequestWaitTime">
      <summary>
            Request Wait Time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetPerformanceCounterProvider.RequestsCurrent">
      <summary>
            Requests Current
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetPerformanceCounterProvider.RequestsDisconnected">
      <summary>
            Requests Disconnected
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetPerformanceCounterProvider.RequestsQueued">
      <summary>
            Requests Queued
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetPerformanceCounterProvider.RequestsRejected">
      <summary>
            Requests Rejected
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetPerformanceCounterProvider.WorkerProcessRestarts">
      <summary>
            Worker Process Restarts
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.AspNetPerformanceCounterProvider.WorkerProcessesRunning">
      <summary>
            Worker Processes Running
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Diagnostics.Providers.ClrDataPerformanceCounterProvider">
      <summary>
            .NET CLR Data 관련 Performance Counter를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.Providers.ClrDataPerformanceCounterProvider.#ctor">
      <summary>
            Contructor
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrDataPerformanceCounterProvider.CurrentCountOfConnectionPools">
      <summary>
            Current # connection pools
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrDataPerformanceCounterProvider.CurrentCountOfPooledAndNonPooledConnecxtions">
      <summary>
            Current # ppoled and nonpooled connections
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrDataPerformanceCounterProvider.CurrentCountOfPooledConnections">
      <summary>
            SqlClient: Current # pooled connections
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrDataPerformanceCounterProvider.PeekCountOfPooledConnections">
      <summary>
            SqlClient: Peek # pooled connections
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrDataPerformanceCounterProvider.TotalCountOfFailedCommands">
      <summary>
            SqlClient: Total # failed commands
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrDataPerformanceCounterProvider.TotalCountOfFailedConnects">
      <summary>
            SqlClient: Total # failed connects
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Diagnostics.Providers.ClrLockAndThreadPerformanceCounterProvider">
      <summary>
            .NET CLR LocksAndThreads 범주의 PerformanceCounter를 제공합니다.
            </summary>
      <example>
        <code>
            CategoryName=.NET CLR LocksAndThreads
            	InstanceName=_Global_
            		Counter Name=# of current logical Threads
            		Counter Name=# of current physical Threads
            		Counter Name=# of current recognized threads
            		Counter Name=# of total recognized threads
            		Counter Name=Contention Rate / sec
            		Counter Name=Current Queue Length
            		Counter Name=Queue Length / sec
            		Counter Name=Queue Length Peak
            		Counter Name=rate of recognized threads / sec
            		Counter Name=Total # of Contentions
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.Providers.ClrLockAndThreadPerformanceCounterProvider.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrLockAndThreadPerformanceCounterProvider.CounterOfCurrentLogicalThreads">
      <summary>
            # of current logical Threads
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrLockAndThreadPerformanceCounterProvider.CounterOfCurrentPhysicalThreads">
      <summary>
            # of current physical Threads
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrLockAndThreadPerformanceCounterProvider.CountOfCurrentRecognizedThreads">
      <summary>
            # of current recognized Threads
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrLockAndThreadPerformanceCounterProvider.ContentionRatePerSec">
      <summary>
            Contention Rate / sec
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrLockAndThreadPerformanceCounterProvider.CurrentQueueLength">
      <summary>
            Current Queue Length
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrLockAndThreadPerformanceCounterProvider.QueueLengthPerSec">
      <summary>
            Queue Length / sec
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrLockAndThreadPerformanceCounterProvider.QueueLengthPeak">
      <summary>
            Queue Length Peak
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrLockAndThreadPerformanceCounterProvider.TotalCountOfContentions">
      <summary>
            Total # of Contentions
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Diagnostics.Providers.ClrMemoryPerformanceCounterProvider">
      <summary>
            .NET CLR Memory Category의 <see cref="T:System.Diagnostics.PerformanceCounter" />를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.Providers.ClrMemoryPerformanceCounterProvider.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrMemoryPerformanceCounterProvider.BytesInAllHeaps">
      <summary>
            # Bytes in all Heaps
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrMemoryPerformanceCounterProvider.GCHandles">
      <summary>
            # GC Handles
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrMemoryPerformanceCounterProvider.Gen0Collections">
      <summary>
            # Gen 0 Collections
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrMemoryPerformanceCounterProvider.Gen1Collections">
      <summary>
            # Gen 1 Collections
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrMemoryPerformanceCounterProvider.Gen2Collections">
      <summary>
            # Gen 2 Collections
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrMemoryPerformanceCounterProvider.TotalCommittedBytes">
      <summary>
            # Total committed Bytes
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrMemoryPerformanceCounterProvider.TotalReservedBytes">
      <summary>
            # Total reserved Bytes
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrMemoryPerformanceCounterProvider.TimeInGCPercent">
      <summary>
            % Time in GC
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrMemoryPerformanceCounterProvider.AllocatedBytesPerSec">
      <summary>
            Allocated Bytes/sec
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ClrMemoryPerformanceCounterProvider.LargeObjectHeapSize">
      <summary>
            Large Object Heap size
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Diagnostics.Providers.MemoryPerformanceCounterProvider">
      <summary>
             Memory 관련 <see cref="T:System.Diagnostics.PerformanceCounter" />를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.Providers.MemoryPerformanceCounterProvider.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.MemoryPerformanceCounterProvider.CommittedBytesInUsePercent">
      <summary>
            사용중인 메모리 (Bytes)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.MemoryPerformanceCounterProvider.AvailableBytes">
      <summary>
            시스템의 남은 메모리 용량 (Byte 단위)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.MemoryPerformanceCounterProvider.AvailableKbytes">
      <summary>
            시스템의 남은 메모리 용량 (Kb 단위)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.MemoryPerformanceCounterProvider.AvailableMbytes">
      <summary>
            시스템의 남은 메모리 용량 (Mb 단위)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.MemoryPerformanceCounterProvider.CacheBytes">
      <summary>
            Pages per second
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.MemoryPerformanceCounterProvider.PagesPerSec">
      <summary>
            Pages per second
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Diagnostics.Providers.ProcessorPerformanceCounterProvider">
      <summary>
            Processor Category에 대한 <see cref="T:System.Diagnostics.PerformanceCounter" /> 를 제공합니다.
            </summary>
      <example>
        <code>
            CategoryName=Processor
            	InstanceName=_Total
            		Counter Name=% C1 Time
            		Counter Name=% C2 Time
            		Counter Name=% C3 Time
            		Counter Name=% DPC Time
            		Counter Name=% Idle Time
            		Counter Name=% Interrupt Time
            		Counter Name=% Privileged Time
            		Counter Name=% Processor Time
            		Counter Name=% User Time
            		Counter Name=C1 Transitions/sec
            		Counter Name=C2 Transitions/sec
            		Counter Name=C3 Transitions/sec
            		Counter Name=DPC Rate
            		Counter Name=DPCs Queued/sec
            		Counter Name=Interrupts/sec
            	InstanceName=0
            		Counter Name=% C1 Time
            		Counter Name=% C2 Time
            		Counter Name=% C3 Time
            		Counter Name=% DPC Time
            		Counter Name=% Idle Time
            		Counter Name=% Interrupt Time
            		Counter Name=% Privileged Time
            		Counter Name=% Processor Time
            		Counter Name=% User Time
            		Counter Name=C1 Transitions/sec
            		Counter Name=C2 Transitions/sec
            		Counter Name=C3 Transitions/sec
            		Counter Name=DPC Rate
            		Counter Name=DPCs Queued/sec
            		Counter Name=Interrupts/sec
            	InstanceName=1
            		Counter Name=% C1 Time
            		Counter Name=% C2 Time
            		Counter Name=% C3 Time
            		Counter Name=% DPC Time
            		Counter Name=% Idle Time
            		Counter Name=% Interrupt Time
            		Counter Name=% Privileged Time
            		Counter Name=% Processor Time
            		Counter Name=% User Time
            		Counter Name=C1 Transitions/sec
            		Counter Name=C2 Transitions/sec
            		Counter Name=C3 Transitions/sec
            		Counter Name=DPC Rate
            		Counter Name=DPCs Queued/sec
            		Counter Name=Interrupts/sec
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.Providers.ProcessorPerformanceCounterProvider.#ctor">
      <summary>
            "_Total"에 대한 Processor Category에 대한 <see cref="T:System.Diagnostics.PerformanceCounter" />를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.Providers.ProcessorPerformanceCounterProvider.#ctor(System.String)">
      <summary>
            CPU 별로 Performance Counter를 얻을 때, "0", "1" ... CPU 숫자까지...
            </summary>
      <param name="instanceName">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ProcessorPerformanceCounterProvider.PercentOfC1Time">
      <summary>
            % C1 Time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ProcessorPerformanceCounterProvider.PercentOfC2Time">
      <summary>
            % C2 Time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ProcessorPerformanceCounterProvider.PercentOfC3Time">
      <summary>
            % C3 Time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ProcessorPerformanceCounterProvider.PercentOfDpcTime">
      <summary>
            % DPC Time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ProcessorPerformanceCounterProvider.PercentOfIdleTime">
      <summary>
            % Idle Time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ProcessorPerformanceCounterProvider.PercentOfInterruptTime">
      <summary>
            % Interrupt Time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ProcessorPerformanceCounterProvider.PercentOfPrivilegedTime">
      <summary>
            % Privileged Time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ProcessorPerformanceCounterProvider.PercentOfProcessorTime">
      <summary>
            % Processor Time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ProcessorPerformanceCounterProvider.PercentOfUserTime">
      <summary>
            % User Time
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.ProcessorPerformanceCounterProvider.InterruptsPerSec">
      <summary>
            Interrupts/sec
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Diagnostics.Providers.SystemPerformanceCounterProvider">
      <summary>
            시스템 관련 성능 측정을 위한 <see cref="T:System.Diagnostics.PerformanceCounter" />를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.Providers.SystemPerformanceCounterProvider.#ctor">
      <summary>
            Constructor
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.SystemPerformanceCounterProvider.ContextSwitchesPerSec">
      <summary>
            Context Switches/sec
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.SystemPerformanceCounterProvider.Processes">
      <summary>
            Processes
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.SystemPerformanceCounterProvider.ProcessorQueueLength">
      <summary>
            Processor Queue Length
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.SystemPerformanceCounterProvider.SystemCallsPerSec">
      <summary>
            System Calls/sec
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.Providers.SystemPerformanceCounterProvider.Threads">
      <summary>
            Threads
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Diagnostics.PerformanceCounterTool">
      <summary>
            Windows System 성능 측정을 위한 Utility Class 입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.PerformanceCounterTool.GetProcessors">
      <summary>
            모든 개별 프로세스 성능 측정기 얻기
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.PerformanceCounterTool.GetProcessor(System.String)">
      <summary>
            지정한 인스턴스 이름의 Processor의 PerformanceCounterProvider를 반환합니다.
            </summary>
      <param name="instanceName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.PerformanceCounterTool.Categories">
      <summary>
            시스템에서 제공하는 성능 측정을 위한 Category 들
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.PerformanceCounterTool.System">
      <summary>
            시스템 성능 측정기
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.PerformanceCounterTool.Memory">
      <summary>
            메모리 성능 측정기
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.PerformanceCounterTool.Processor">
      <summary>
            프로세스 성능 측정기
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.PerformanceCounterTool.ClrLockAndThreads">
      <summary>
            .NET CLR LocksAndThreads 범주의 PerformanceCounter를 제공합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.PerformanceCounterTool.ClrMemory">
      <summary>
            .NET CLR Memory Category의 <see cref="T:System.Diagnostics.PerformanceCounter" />를 제공합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.PerformanceCounterTool.AspNet">
      <summary>
            ASP.NET 성능 측정 제공자
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Diagnostics.PerformanceCounterTool.AspNetApplications">
      <summary>
            ASP.NET Applications 에 대한 <see cref="T:System.Diagnostics.PerformanceCounter" />를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.ProcessTool.TrimAllProcessMemory(System.Boolean,System.String[])">
      <summary>
            시스템에서 실행중인 모든 프로세스에 대해, 사용하지 않는 WorkingSet 메모리를 OS에게 반환하도록 합니다.
            </summary>
      <param name="excludeThisProcess">현재 프로세스를 제외할 것인가 여부 (기본값은 제외)</param>
      <param name="excludeProcessNames">메모리 반환을 하지 않을 프로세스 명의 컬렉션</param>
    </member>
    <member name="M:NSoft.NFramework.Diagnostics.ProcessTool.TrimProcessMemory(System.Diagnostics.Process)">
      <summary>
            지정된 프로세스의 사용하지 않는 WorkingSet 메모리를 OS에게 반환하도록 합니다.
            </summary>
      <param name="process">메모리 해제를 할 프로세스</param>
      <returns>메모리 해제 여부</returns>
    </member>
    <member name="T:NSoft.NFramework.DynamicProxy.DynamicProxyTool">
      <summary>
            Castle.DynamicProxy 에 대한 확장 메소드를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.IsDynamicProxy(System.Object)">
      <summary>
            지정된 객체가 <see cref="T:Castle.DynamicProxy.ProxyGenerator" />로 생성된 Proxy인지 파악합니다.
            </summary>
      <param name="proxy">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.IsDynamicProxyType``1">
      <summary>
            지정된 형식이 DynamicProxy 로 생성된 Proxy의 수형인지 파악합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.IsDynamicProxyType(System.Type)">
      <summary>
            지정된 형식이 DynamicProxy 로 생성된 Proxy의 수형인지 파악합니다.
            </summary>
      <param name="proxiedType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.GetUnproxiedType(System.Type)">
      <summary>
            지정된 수형이 Proxy 수형이라면, 기본 수형을 반환합니다.
            </summary>
      <param name="proxiedType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.Create``1(System.Type[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
            지정된 객체 생성 메소드를 통해 원본 객체를 생성하고, Interceptor를 가지는 Proxy를 생성하여 반환합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="additionalInterfaces">
      </param>
      <param name="interceptors">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.Create(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
            지정된 객체 생성 메소드를 통해 원본 객체를 생성하고, Interceptor를 가지는 Proxy를 생성하여 반환합니다.
            </summary>
      <param name="classToProxy">
      </param>
      <param name="additionalInterfaces">
      </param>
      <param name="interceptors">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.Create(System.Func{System.Object},System.Type[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
            지정된 객체 생성 메소드를 통해 원본 객체를 생성하고, Interceptor를 가지는 Proxy를 생성하여 반환합니다.
            </summary>
      <param name="targetFactory">
      </param>
      <param name="additionalInterfaces">
      </param>
      <param name="interceptors">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.CreateNotifyPropertyChanged``1">
      <summary>
        <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> 인터페이스를 구현한 것처럼 감싸주는 Proxy를 생성합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.CreateNotifyPropertyChanged(System.Type)">
      <summary>
            지정된 수형에서 <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> 를 구현한 Proxy로 생성합니다.
            </summary>
      <param name="classToProxy">Proxy 대상 수형</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.CreateNotifyPropertyChanged(System.Func{System.Object})">
      <summary>
            지정된 수형에서 <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> 를 구현한 Proxy로 생성합니다.
            </summary>
      <param name="targetFactory">Proxy 대상 인스턴스 생성 Factory</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.CreateEditableObject``1">
      <summary>
            지정된 수형에서 <see cref="T:System.ComponentModel.IEditableObject" /> 를 구현한 Proxy로 생성합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.CreateEditableObject(System.Type)">
      <summary>
            지정된 수형에서 <see cref="T:System.ComponentModel.IEditableObject" /> 를 구현한 Proxy로 생성합니다.
            </summary>
      <param name="classToProxy">Proxy 대상 수형</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.CreateEditableObject(System.Func{System.Object})">
      <summary>
            지정된 수형에서 <see cref="T:System.ComponentModel.IEditableObject" /> 를 구현한 Proxy로 생성합니다.
            </summary>
      <param name="targetFactory">Proxy 대상 인스턴스 생성 Factory</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.CreateEditablePropertyChanged``1">
      <summary>
            지정된 수형에서 <see cref="T:System.ComponentModel.IEditableObject" />, <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> 를 구현한 Proxy로 생성합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.CreateEditablePropertyChanged(System.Type)">
      <summary>
            지정된 수형에서 <see cref="T:System.ComponentModel.IEditableObject" />, <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> 를 구현한 Proxy로 생성합니다.
            </summary>
      <param name="classToProxy">Proxy 대상 수형</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.DynamicProxyTool.CreateEditablePropertyChanged(System.Func{System.Object})">
      <summary>
            지정된 수형에서 <see cref="T:System.ComponentModel.IEditableObject" />, <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> 를 구현한 Proxy로 생성합니다.
            </summary>
      <param name="targetFactory">Proxy 대상 인스턴스 생성 Factory</param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.DynamicProxy.EditableObjectInterceptor">
      <summary>
            객체에 <see cref="T:System.ComponentModel.IEditableObject" /> 인터페이스를 제공하는 Proxy를 생성할 때, 제공하는 Interceptor입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.DynamicProxy.NotifyPropertyChangedInterceptor">
      <summary>
            특정 형식을 <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> 인터페이스를 구현한 것처럼 해주는 Interceptor입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.DynamicProxy.NotifyPropertyChangedInterceptor.Intercept(Castle.DynamicProxy.IInvocation)">
      <summary>
            원본 인스턴스에 대한 작업에 대해 Intercept를 수행합니다.
            </summary>
      <param name="invocation">
      </param>
    </member>
    <member name="T:NSoft.NFramework.InversionOfControl.WindsorInstallers.CompressorInstaller">
      <summary>
            Castle.Windsor의 컨테이너에 <see cref="T:NSoft.NFramework.Compressions.ICompressor" />로 구현된 클래스들을 등록 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.WindsorInstallers.CompressorInstaller.Install(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
      <summary>
            Performs the installation in the <see cref="T:Castle.Windsor.IWindsorContainer" />.
            </summary>
      <param name="container">The container.</param>
      <param name="store">The configuration store.</param>
    </member>
    <member name="T:NSoft.NFramework.InversionOfControl.WindsorInstallers.EncryptorInstaller">
      <summary>
            암호화 기능을 수행하는 <see cref="T:NSoft.NFramework.Cryptography.IHashEncryptor" />, <see cref="T:NSoft.NFramework.Cryptography.ISymmetricEncryptor" /> 컴포넌트를 Windsor Container에 등록합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.WindsorInstallers.EncryptorInstaller.Install(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
      <summary>
            Performs the installation in the <see cref="T:Castle.Windsor.IWindsorContainer" />.
            </summary>
      <param name="container">The container.</param>
      <param name="store">The configuration store.</param>
    </member>
    <member name="T:NSoft.NFramework.InversionOfControl.WindsorInstallers.SerializerInstaller">
      <summary>
        <see cref="T:NSoft.NFramework.ISerializer" />, <see cref="T:NSoft.NFramework.ISerializer`1" />를 Castle.Windsor에 등록하는 컴포넌트 인스톨러
            </summary>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.WindsorInstallers.SerializerInstaller.Install(Castle.Windsor.IWindsorContainer,Castle.MicroKernel.SubSystems.Configuration.IConfigurationStore)">
      <summary>
            Performs the installation in the <see cref="T:Castle.Windsor.IWindsorContainer" />.
            </summary>
      <param name="container">The container.</param>
      <param name="store">The configuration store.</param>
    </member>
    <member name="T:NSoft.NFramework.InversionOfControl.ConfigurationObjectAttribute">
      <summary>
            IoC 환경설정에 쓰이는 Class임을 나타내는 Attribute이다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.InversionOfControl.ConfigurationObjectConverter">
      <summary>
            Castle.Windsor의 환경설정상의 property value를 인스턴스 속성에 지정하는 작업을 수행한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.ConfigurationObjectConverter.CanHandleType(System.Type)">
      <summary>
        <see cref="T:NSoft.NFramework.InversionOfControl.ConfigurationObjectAttribute" /> 가 정의된 Class에 대해서 Windsor의 Prameters 값을 변환해준다.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.ConfigurationObjectConverter.PerformConversion(Castle.Core.Configuration.IConfiguration,System.Type)">
      <summary>
            Castle.Windsor 환경설정 정보에 있는 속성정보를 Instance의 속성 값으로 매핑한다.
            </summary>
      <param name="configuration">Castle configuration object</param>
      <param name="targetType">target type</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.ConfigurationObjectConverter.PerformConversion(System.String,System.Type)">
      <summary>
            Castle.Windsor 환경설정 정보에 있는 값을 해당 형식의 생성자에 제공하여 인스턴스를 빌드한다.
            </summary>
      <param name="value">인스턴싱할때 생성자에 제공할 인자 값</param>
      <param name="targetType">인스턴싱할 형식</param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.InversionOfControl.ContainerSelector">
      <summary>
            여러 상황을 동시에 지원하기 위해, 다중 Container를 등록해 놓고, 일시적으로 다른 Container를 이용할 수 있도록 한다.
            </summary>
      <remarks>
            IoC에서 Parameter로 줄 때 http://www.castleproject.org/container/documentation/trunk/usersguide/arrayslistsanddicts.html 를 참고하세요
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.ContainerSelector.UseContainer(System.String)">
      <summary>
            기본 Container의 자식 Container중에 해당 이름을 가진 Container를 사용한다.
            </summary>
      <param name="name">Container 명</param>
      <returns>
      </returns>
      <example>
        <code>
            using(ContainerSelector.Enter(name))
            {
            	Assert.AreEqual(name + "Compressor", Compressor.DefaultCompressor.GetType().Name);
            }
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.ContainerSelector.#ctor(System.Collections.IDictionary)">
      <summary>
            Constructor
            </summary>
      <param name="containers">자식 container 정보</param>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.ContainerSelector.Register(System.String,Castle.Windsor.IWindsorContainer)">
      <summary>
            새로운 Container를 등록한다.
            </summary>
      <param name="name">
      </param>
      <param name="container">
      </param>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.ContainerSelector.Enter(System.String)">
      <summary>
            지정된 이름을 가진 자식 Container를 사용합니다.
            </summary>
      <param name="name">자식 컨테이너 명</param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.InversionOfControl.ContainerSelector.ContainerNames">
      <summary>
            자식 Container들의 이름 목록
            </summary>
    </member>
    <member name="T:NSoft.NFramework.InversionOfControl.IoC">
      <summary>
            Castle (http://www.castleproject.org) 의 IoC Library인 Castle.Windsor를 이용하여 IoC/DI 를 수행하는 Utility Class입니다.
            </summary>
      <remarks>
            Castle.Core.dll, Castle.MicroKernel.dll, Castle.Windsor.dll을 참조해야 합니다.
            </remarks>
      <example>
        <code>
            	if(IoC.IsNotInitialized)
            		IoC.Initialize(new WindsorContainer(new XmlInterpreter());  // castle configuration file로부터 환경 설정을 수행한다.
            
            	ICompressor component = IoC.Resolve{ICompressor}();        // intanciate class that is implemented ICompressor 
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.Initialize">
      <summary>
            초기화가 되어 있지 않다면 Castle.Windsor의 환경설정 정보를 바탕으로 IoC를 초기화 합니다.
            </summary>
      <example>
        <code>
            // 아래 두 코드는 수행하는 내용이 같다.
            
            // Initialize IoC with default application configuration.
            IoC.Initialize(); 
            
            // Initialize IoC with default configuration defined in App/Web configuration
            if(IoC.IsNotInitialized)
            	IoC.Initialize(new WindsorContainer(new XmlInterpreter()));
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.InitializeFromXmlFile(System.String)">
      <summary>
            지정된 IoC / DI 환경설정 정보를 바탕으로  IoC Container를 초기화 합니다.
            </summary>
      <param name="xmlfile">
      </param>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.InitializeFromResource(System.Reflection.Assembly,System.String)">
      <summary>
            리소스에 저장된 환경설정 파일을 로드하여 초기화합니다.
            참고 : http://www.primordialcode.com/blog/post/castle-windsor-enabling-xml-configuration-files-silverlight
            </summary>
      <param name="assembly">리소스를 소유한 Assembly</param>
      <param name="resourceFilename">리소스 파일 명</param>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.InitializeWithEmptyContainer">
      <summary>
            초기화가 되어 있지 않다면 빈 Container를 사용하는 IoC를 초기화 합니다. (환경설정을 하지 않고도 사용할 수 있도록 있습니다.)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.Initialize(Castle.Windsor.IWindsorContainer)">
      <summary>
            지정된 Container를 Global Container로 설정하여, 전역적으로 사용가능토록 한다.
            </summary>
      <example>
        <code>
            	if(IoC.IsNotInitialized)
            	{
            		// 빈 컨테이너를 만든다.
            		IoC.Initialize(new WindsorContainer());
            
            		// 환경설정에서 Component 정의를 읽어오려면
            		// IoC.Initialize(new WindsorContainer(new XmlInterpreter());
            
            		// 특정 환경설정 파일에서 Component 정의를 읽어오려면
            		// IoC.Initialize(new WindsorContainer(windsorConfigurationFileName));
            	}
            </code>
      </example>
      <param name="container">
      </param>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.UseLocalContainer(Castle.Windsor.IWindsorContainer)">
      <summary>
            Global Container 대신 일시적으로 사용할 Local Container를 사용하기 위한 Utility 함수
            </summary>
      <param name="localContainer">
      </param>
      <returns>
      </returns>
      <example>
        <code>
            using(IoC.UseLocalContainer(localContainer))
            {
            	// some code for using localContainer
            }
            // some code for using global container
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.Reset(Castle.Windsor.IWindsorContainer)">
      <summary>
            지정된 Container 사용을 중지합니다.
            </summary>
      <param name="containerToReset">
      </param>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.Reset">
      <summary>
            현재 활성화된 Container를 Reset 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.RegisterComponents(System.Reflection.Assembly,System.Type,Castle.Core.LifestyleType)">
      <summary>
            특정 Assembly에 있는 기본이 되는 Service type에 해당하는 component를 IoC Container에 등록한다.
            </summary>
      <param name="assembly">Component가 정의된 Assembly</param>
      <param name="serviceType">Component의 Service type (Interface type)</param>
      <param name="lifestyleType">Component life style (Singleton, Transient ...)</param>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.AddComponentInstance``1(``0)">
      <summary>
            Container에 지정된 인스턴스를 추가한다.
            </summary>
      <typeparam name="TService">추가할 인스턴스의 서비스 수형</typeparam>
      <param name="instance">추가할 인스턴스</param>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.AddComponentInstance``1(``0,Castle.Core.LifestyleType)">
      <summary>
            Container에 지정된 인스턴스를 추가한다.
            </summary>
      <typeparam name="TService">추가할 인스턴스의 서비스 수형</typeparam>
      <param name="lifestyle">인스턴스 라이프스타일</param>
      <param name="instance">추가할 인스턴스</param>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.AddComponentInstance``1(System.Type,System.Object)">
      <summary>
            Container에 지정된 인스턴스를 추가한다.
            </summary>
      <typeparam name="TComponent">추가할 인스턴스의 수형</typeparam>
      <param name="serviceType">추가할 인스턴스의 서비스 수형 (interface)</param>
      <param name="instance">추가할 인스턴스</param>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.AddComponentInstance``1(System.Type,System.Object,Castle.Core.LifestyleType)">
      <summary>
            Container에 지정된 인스턴스를 추가한다.
            </summary>
      <typeparam name="TComponent">추가할 인스턴스의 수형</typeparam>
      <param name="serviceType">추가할 인스턴스의 서비스 수형 (interface)</param>
      <param name="instance">추가할 인스턴스</param>
      <param name="lifestyle">lifestyle for component (ie. singleton, thread, trasient) </param>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.HasComponent``1">
      <summary>
            지정된 서비스가 컨테이너에 등록되어 있는지 확인한다.
            </summary>
      <typeparam name="TService">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.HasComponent(System.Type)">
      <summary>
            지정된 서비스가 컨테이너에 등록되어 있는지 확인한다.
            </summary>
      <param name="service">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.HasComponent(System.String)">
      <summary>
            지정된 ComponentId의 컴포넌트가 컨테이너에 등록되어 있는지 확인한다.
            </summary>
      <param name="componentId">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.Resolve(System.Type)">
      <summary>
            지정된 Service 형태의 Component를 인스턴싱한다.
            </summary>
      <param name="service">인스턴싱할 Component의 형식</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.Resolve``1">
      <summary>
            지정된 형식의 Component를 인스턴싱한다.
            </summary>
      <typeparam name="TService">Type of Component</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.Resolve``1(System.String)">
      <summary>
            지정된 Component Id의 Component를 Resolve한다.
            </summary>
      <typeparam name="TService">Instancing을 원하는 Component의 Service Type</typeparam>
      <param name="componentId">Component Id</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.Resolve``1(System.String,System.Collections.IDictionary)">
      <summary>
            지정된 Component Id의 Component를 Resolve한다.
            </summary>
      <typeparam name="TService">Instancing을 원하는 Component의 Service Type</typeparam>
      <param name="componentId">Component Id</param>
      <param name="arguments">인스턴싱할 객체의 속성정보 (속성명=속성값)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.Resolve``1(System.Collections.IDictionary)">
      <summary>
            지정된 Component Id의 Component를 Resolve한다.
            </summary>
      <typeparam name="TService">Instancing을 원하는 Component의 Service Type</typeparam>
      <param name="arguments">인스턴싱할 객체의 속성정보 (속성명=속성값)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.Resolve``1(System.Object)">
      <summary>
            지정된 Component Id의 Component를 Resolve한다.
            </summary>
      <typeparam name="TService">Instancing을 원하는 Component의 Service Type</typeparam>
      <param name="argumentsAsAnonymousType">인스턴싱할 객체의 속성정보</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.ResolveOrDefault``1(System.String)">
      <summary>
            해당 컴포넌트 Id의 컴포넌트가 있다면, 그 놈을 Resove 하고, 없다면, ServiceType이 {TService} 인 첫번째 컴포넌트를 반환한다.
            </summary>
      <typeparam name="TService">
      </typeparam>
      <param name="componentId">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.TryResolve``1">
      <summary>
            Castle Component를 인스턴싱 작업을 시도한다. 
            실패시에는 예외를 발생시키는 것이 아니라 지정된 타입의 default(T)를 반환한다.
            </summary>
      <typeparam name="TComponent">생성할 객체</typeparam>
      <returns>정의된 컴포넌트가 없다면 지정된 형식의 기본 인스턴스를 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.TryResolve``1(``0)">
      <summary>
            Castle Component를 인스턴싱 작업을 시도한다. 실패시에는 예외를 발생시키는 것이 아니라 
            지정된 타입의 default를 반환하고, 성공시에는 인스턴싱을 반환한다.
            옵션에 따른 Dependency Injection시에 유용하다.
            </summary>
      <typeparam name="TComponent">인스턴싱할 형식</typeparam>
      <param name="instance">default value (default instance.)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.TryResolve``1(System.Func{``0},System.Boolean)">
      <summary>
            지정된 형식의 Component를 가져옵니다. Container에 등록되어 있지 않다면, instancingFunction으로 Component를 인스턴싱 합니다.
            </summary>
      <typeparam name="TService">
      </typeparam>
      <param name="instancingFunction">
      </param>
      <param name="registerComponent">Container에 서비스를 등록할 것인가?</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.TryResolve``1(System.Func{``0},System.Boolean,Castle.Core.LifestyleType)">
      <summary>
            지정된 형식의 Component를 가져옵니다. Container에 등록되어 있지 않다면, instancingFunction으로 Component를 인스턴싱 합니다.
            LifeStyleType은 항상 Singleton으로 해주셔야 합니다.
            </summary>
      <typeparam name="TService">
      </typeparam>
      <param name="instancingFunction">
      </param>
      <param name="registerComponent">Container에 서비스를 등록할 것인가?</param>
      <param name="lifestyleType">무시된다. 무조건 Singleton이다.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.TryResolve``2">
      <summary>
            지정된 형식의 Component를 인스턴스화 합니다. Container에 해당 Component가 정의되어 있지 않다면, Container에 추가하고, 인스턴스를 반환한다.
            </summary>
      <typeparam name="TService">Service type (interface)</typeparam>
      <typeparam name="TComponent">Component type (instance)</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.TryResolve``2(Castle.Core.LifestyleType)">
      <summary>
            지정된 형식의 Component를 인스턴스화 합니다. Container에 해당 Component가 정의되어 있지 않다면, Container에 추가하고, 인스턴스를 반환한다.
            </summary>
      <typeparam name="TService">Service type (interface)</typeparam>
      <typeparam name="TComponent">Component type (instance)</typeparam>
      <param name="lifestyleType">instance lifestyle (singleton, thread, transient)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.TryResolve``2(Castle.Core.LifestyleType,System.Collections.IDictionary)">
      <summary>
            지정된 형식의 Component를 인스턴스화 합니다. Container에 해당 Component가 정의되어 있지 않다면, Container에 추가하고, 인스턴스를 반환한다.
            </summary>
      <typeparam name="TService">Service type (interface)</typeparam>
      <typeparam name="TComponent">Component type (instance)</typeparam>
      <param name="lifestyleType">instance lifestyle (singleton, thread, transient)</param>
      <param name="arguments">컴포넌트 생성자의 인자로 쓰일 값들</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.ResolveAll(System.Type)">
      <summary>
            지정된 타입의 Component를 모두 인스턴싱합니다.
            </summary>
      <param name="serviceType">인스턴싱할 Type</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.ResolveAll``1">
      <summary>
            지정된 타입의 Component를 모두 인스턴싱합니다.
            </summary>
      <typeparam name="T">인스턴싱할 Service Type</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.CreateNotifyPropertyChangedProxy``1">
      <summary>
            IoC를 통해 컴포넌트를 Resolve하고, <see cref="T:System.ComponentModel.INotifyPropertyChanged" />를 가지는 Proxy로 생성하여 반환합니다.
            NOTE: 원본 클래스의 속성이나 메소드가 virtual 이어야만 proxy의 interceptor가 수행합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.CreateNotifyPropertyChangedProxy``1(System.String)">
      <summary>
            IoC를 통해 컴포넌트를 Resolve하고, <see cref="T:System.ComponentModel.INotifyPropertyChanged" />를 가지는 Proxy로 생성하여 반환합니다.
            NOTE: 원본 클래스의 속성이나 메소드가 virtual 이어야만 proxy의 interceptor가 수행합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="componentId">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.CreateNotifyPropertyChangedProxy(System.Type)">
      <summary>
            IoC를 통해 컴포넌트를 Resolve하고, <see cref="T:System.ComponentModel.INotifyPropertyChanged" />를 가지는 Proxy로 생성하여 반환합니다.
            NOTE: 원본 클래스의 속성이나 메소드가 virtual 이어야만 proxy의 interceptor가 수행합니다.
            </summary>
      <param name="typeToProxy">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.CreateProxy``1(System.String,System.Type[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
            IoC를 통해 컴포넌트를 Resolve하고, <see cref="T:System.ComponentModel.INotifyPropertyChanged" />를 가지는 Proxy로 생성하여 반환합니다.
            NOTE: 원본 클래스의 속성이나 메소드가 virtual 이어야만 proxy의 interceptor가 수행합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="componentId">
      </param>
      <param name="additionalInterfacesInterfaceToProxy">
      </param>
      <param name="interceptors">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.IoC.CreateProxy(System.Type,System.Type[],Castle.DynamicProxy.IInterceptor[])">
      <summary>
            IoC를 통해 컴포넌트를 Resolve하고, <see cref="T:System.ComponentModel.INotifyPropertyChanged" />를 가지는 Proxy로 생성하여 반환합니다.
            NOTE: 원본 클래스의 속성이나 메소드가 virtual 이어야만 proxy의 interceptor가 수행합니다.
            </summary>
      <param name="componentType">
      </param>
      <param name="additionalInterfacesInterfaceToProxy">
      </param>
      <param name="interceptors">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.InversionOfControl.IoC.IsInitialized">
      <summary>
            IoC 전역 컨테이너가 초기화가 되었는지 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.InversionOfControl.IoC.IsNotInitialized">
      <summary>
            IoC 전역 컨테이너가 초기화가 되지 않았는지 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.InversionOfControl.IoC.Container">
      <summary>
            Current Container <see cref="T:Castle.Windsor.IWindsorContainer" /></summary>
    </member>
    <member name="T:NSoft.NFramework.InversionOfControl.UriTypeConverter">
      <summary>
            Castle.Windsor 환경설정에서 parameters 의 값으로 URI 형태의 문자열을 형변환을 수행한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.UriTypeConverter.CanHandleType(System.Type)">
      <summary>
            형변환이 가능한지 검사한다.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.UriTypeConverter.PerformConversion(Castle.Core.Configuration.IConfiguration,System.Type)">
      <summary>
            환경설정에 정의된 값을 이용하여 URI 형으로 변환하여 반환한다.
            </summary>
      <param name="configuration">
      </param>
      <param name="targetType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.InversionOfControl.UriTypeConverter.PerformConversion(System.String,System.Type)">
      <summary>
            지정된 값을 이용하여 URI 형으로 변환하여 반환한다.
            </summary>
      <param name="value">
      </param>
      <param name="targetType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.IO.FileTool">
      <summary>
            파일 IO 관련 Helper Class
            </summary>
    </member>
    <member name="F:NSoft.NFramework.IO.FileTool.FMT_VERSION">
      <summary>
            버전 정보를 나타내는 포맷 - Major.Minor.Release.Build
            </summary>
    </member>
    <member name="F:NSoft.NFramework.IO.FileTool.UNKNOWN_VERSION">
      <summary>
            알 수 없는 버전에 대한 상수 값 = "0.0.0.0"
            </summary>
    </member>
    <member name="F:NSoft.NFramework.IO.FileTool.DEFAULT_BUFFER_SIZE">
      <summary>
            기본 파일 버퍼 사이즈 (4Kbyte)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.IO.FileTool.DEFAULT_MIME_TYPE">
      <summary>
            기본 Mime Type 입니다. (application/octet-stream)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.SaveTask(System.String,System.String,System.Text.Encoding,System.Boolean)">
      <summary>
            비동기 방식으로 <paramref name="text" />를 파일(<paramref name="filepath" />)에 저장합니다.
            완료되었는지는 <see cref="P:System.Threading.Tasks.Task.IsCompleted" /> 를 확인하세요. 
            대기 시에는 ((IAsyncResult)task).AsyncWaitHandle.WaitOne() 을 사용하세요.
            </summary>
      <param name="filepath">저장할 파일의 전체경로</param>
      <param name="text">저장할 파일 내용</param>
      <param name="encoding">파일 내용의 인코딩 방식</param>
      <param name="overwrite">겹쳐쓰기 여부</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.ReadTextTask(System.String,System.Text.Encoding)">
      <summary>
             비동기 방식으로 파일의 전체 내용을 읽어 문자열로 반환합니다.
             </summary>
      <param name="filepath">읽을 파일의 전체 경로</param>
      <param name="encoding">인코딩 방식</param>
      <returns>파일 내용</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetPhysicalPath(System.String)">
      <summary>
            가상경로를 절대 경로로 계산한다.
            </summary>
      <param name="virtualPath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetTempPath">
      <summary>
            시스템의 Temporary Directory를 반환한다. (C:\Documents and Settings\Administrator\Local Settings\Temp)
            </summary>
      <returns>임시 폴더</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetCurrentPath">
      <summary>
            Application 현재 폴더 (Path)를 구한다.
            </summary>
      <returns>현재 폴더의 전체경로</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetSystemPath">
      <summary>
            Windows System Directory의 경로를 구한다. (C:\Windows\System32)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetWindowsPath">
      <summary>
            Windows Directory의 경로를 구한다. (C:\Windows)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetProgramFilesPath">
      <summary>
            Windows Program Files 경로를 구한다. (C:\Program Files)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetProgramsPath">
      <summary>
            Programs 폴더의 경로를 구한다. (C:\Documents and Settings\Administrator)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetSpecialFolderPath(System.Environment.SpecialFolder)">
      <summary>
            Shell의 특정 폴더를 찾는다. <br />
            시스템 특수 폴더는 공용 정보가 들어 있는 
            Program Files, Programs, System 또는 Startup 등과 같은 폴더입니다. 
            특수 폴더는 Windows를 설치할 때 기본적으로 시스템에서 설정하거나 사용자가 명시적으로 설정합니다.
            </summary>
      <param name="folder">Environment.SpecialFolder</param>
      <returns>특정 폴더 Path</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetTempFileName(System.String)">
      <summary>
            지정한 접두사로 고유한 임시 파일을 만들고, 디스크에 해당 이름으로 크기가 0 바이트인 파일을 만듭니다. 
            </summary>
      <param name="prefix">파일명에 쓰일 접두사</param>
      <returns>임시파일명</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetTempFileName">
      <summary>
            고유한 임시 파일 이름을 반환하고, 디스크에 해당 이름으로 크기가 0 바이트인 파일을 만듭니다.
            </summary>
      <returns>임시파일명</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetFileVersionInfo(System.String)">
      <summary>
            파일의 버전 정보를 구한다.
            </summary>
      <param name="filename">버전 정보를 검색할 파일의 전체경로 및 이름</param>
      <returns>FileVersionInfo 인스턴스 반환, 파일이 없으면 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetFileVersion(System.String)">
      <summary>
            지정된 파일의 Version 정보를 반환한다.
            </summary>
      <param name="filename">검색할 파일의 전체경로</param>
      <returns>파일버전 정보, 파일이 없다면 UNKNOWN_VERSION을 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.ParseVersion(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
      <summary>
            파일 버전 정보를 분해하여 각 구분별로 숫자로 나타낸다. (major.minor.release.build)
            </summary>
      <param name="version">버전 정보</param>
      <param name="major">
      </param>
      <param name="minor">
      </param>
      <param name="release">
      </param>
      <param name="build">
      </param>
      <remarks>파싱이 불가능할 때에는 모든 값들이 0이 된다.</remarks>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.MakeVersion(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            지정된 버전 요소 값으로 버전을 나타내는 문자열을 만든다.
            </summary>
      <param name="major">
      </param>
      <param name="minor">
      </param>
      <param name="release">
      </param>
      <param name="build">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.CompareVersion(System.String,System.String)">
      <summary>
            두 버전을 비교한다.
            </summary>
      <param name="version1">
      </param>
      <param name="version2">
      </param>
      <returns>반환값이 양수이면 version1 이 더 높고, 같으면 두 버전이 같으며, 음수이면 version2 가 더 높은 버전이다.</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.DirectoryExists(System.String)">
      <summary>
            해당 디렉토리가 존재하는지 확인한다.
            </summary>
      <param name="path">검사할 경로</param>
      <returns>경로 존재 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.ExtractFilePath(System.String)">
      <summary>
            경로 문자열에서 Directory 명만 추출해 낸다.
            </summary>
      <param name="path">경로명</param>
      <example>
            string assemPath = System.Reflection.Assembly.GetExecutingAssembly().Location;
            
            Console.WriteLine();
            Console.WriteLine("Path : " + assemPath);
            Console.WriteLine("ExtractFilePath : " + FileUtil.ExtractFilePath(assemPath));
            Console.WriteLine("ExtractFileName : " + FileUtil.ExtractFileName(assemPath));
            Console.WriteLine("ExtractFileExt : " + FileUtil.ExtractFileExt(assemPath));
            
            // Output
            Path : C:\NSoft\NFramework\test\NFramework.Test\bin\Debug\NFramework.Test.dll
            ExtractFilePath : C:\NSoft\NFramework\test\NFramework.Test\bin\Debug
            ExtractFileName : NSoft.NFramework.Test.dll
            ExtractFileExt : dll
            </example>
      <returns>경로만</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.ExtractFileName(System.String)">
      <summary>
            경로 문자열에서 파일 이름에 해당하는 문자열만 추출한다.
            </summary>
      <param name="path">
      </param>
      <returns>
      </returns>
      <example>
            string assemPath = System.Reflection.Assembly.GetExecutingAssembly().Location;
            
            Console.WriteLine();
            Console.WriteLine("Path : " + assemPath);
            Console.WriteLine("ExtractFilePath : " + FileUtil.ExtractFilePath(assemPath));
            Console.WriteLine("ExtractFileName : " + FileUtil.ExtractFileName(assemPath));
            Console.WriteLine("ExtractFileExt : " + FileUtil.ExtractFileExt(assemPath));
            
            // Output
            Path : C:\NSoft\NFramework\test\NFramework.Test\bin\Debug\NFramework.Test.dll
            ExtractFilePath : C:\NSoft\NFramework\test\NFramework.Test\bin\Debug
            ExtractFileName : NSoft.NFramework.Test.dll
            ExtractFileExt : dll
            </example>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.ExtractFileExt(System.String)">
      <summary>
            경로 문자열에서 파일의 Extension 문자열만 추출한다.
            </summary>
      <param name="path">
      </param>
      <example>
            string assemPath = System.Reflection.Assembly.GetExecutingAssembly().Location;
            
            Console.WriteLine();
            Console.WriteLine("Path : " + assemPath);
            Console.WriteLine("ExtractFilePath : " + FileUtil.ExtractFilePath(assemPath));
            Console.WriteLine("ExtractFileName : " + FileUtil.ExtractFileName(assemPath));
            Console.WriteLine("ExtractFileExt : " + FileUtil.ExtractFileExt(assemPath));
            
            // Output
            Path : C:\NSoft\NFramework\test\NFramework.Test\bin\Debug\NFramework.Test.dll
            ExtractFilePath : C:\NSoft\NFramework\test\NFramework.Test\bin\Debug
            ExtractFileName : NSoft.NFramework.Test.dll
            ExtractFileExt : dll
            </example>
      <returns>파일명이 temp.txt라면 "txt" 만 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetFileSystemInfo(System.String)">
      <summary>
            지정한 경로의 파일시스템를 반환합니다.
            </summary>
      <param name="path">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetValidFileName(System.String,System.String,System.String)">
      <summary>
            지정된 파일 경로에 금칙 문자를 주어진 대체 문자열로 변경하여, 유효한 경로 문자열을 만든다.
            </summary>
      <param name="filename">변경할 파일명</param>
      <param name="invalidReplacement">금칙문자를 대체할 문자열</param>
      <param name="spaceReplacement">공백을 대체할 문자열 (null이면 공백은 그대로 둔다)</param>
      <example>
        <code>
            string filename = @"abc&lt;&gt;def|{}|gh.txt";
            string validFilename = FileTool.GetValidFileName(path, "_");
            Console.WriteLine("Input FileName={0}\tValid FileName={1}", filename, validFilename);
            
            // output : Input Path=abc&lt;&gt;def|{}|gh.txt	Valid FileName=abc__def_{}_gh.txt
            </code>
      </example>
      <returns>유효한 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.IsValidPath(System.String)">
      <summary>
            제대로 된 경로명인가 확인한다.
            </summary>
      <param name="path">Path 문자열</param>
      <returns>빈문자열이거나 경로명이 잘못되었으면 False를 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetValidPath(System.String,System.String,System.String)">
      <summary>
            지정된 파일 경로에 금칙 문자를 주어진 대체 문자열로 변경하여, 유효한 경로 문자열을 만든다.
            </summary>
      <param name="path">변경할 경로</param>
      <param name="invalidReplacement">금칙문자를 대체할 문자열</param>
      <param name="spaceReplacement">공백을 대체할 문자열 (null이면 공백은 그대로 둔다)</param>
      <example>
        <code>
            string path = @"c:\temp\abc&lt;&gt;def|{}|gh.txt";
            string validPath = FileUtil.GetValidPath(path, "_");
            Console.WriteLine("Input Path={0}\tValid Path={1}", path, validPath);
            
            // output : Input Path=c:\temp\abc&lt;&gt;def|{}|gh.txt	Valid Path=c:\temp\abc__def_{}_gh.txt
            </code>
      </example>
      <returns>유효한 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetDirectorySize(System.String,System.Boolean)">
      <summary>
            지정된 경로의 크기 (서브 디렉토리와 파일의 크기를 합산) 을 구한다.
            </summary>
      <param name="path">크기를 구하고자 하는 폴더의 경로</param>
      <param name="withSubDirectory">서브디렉토리 포함 여부</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetFileSize(System.String)">
      <summary>
            해당 파일의 크기를 구한다.
            </summary>
      <param name="filename">검사할 파일의 전체 경로</param>
      <returns>파일 크기, 파일이 존재하지 않으면 -1을 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetFileCreateTime(System.String)">
      <summary>
            파일의 생성 시간을 구한다.
            </summary>
      <param name="filename">검사할 파일의 전체 경로</param>
      <returns>파일 생성된 시간</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetFileLastWriteTime(System.String)">
      <summary>
            파일에 마지막 Access한 시간
            </summary>
      <param name="filename">파일의 전체 경로</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.FileExists(System.String)">
      <summary>
            파일이 존재 하는지 검사하다.
            </summary>
      <param name="filename">검사할 파일의 전체 경로</param>
      <returns>존재 유무</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.ChangeFileAttributesToWritable(System.String)">
      <summary>
            File 속성을 쓰기 가능하도록 한다.
            </summary>
      <param name="filename">속성을 설정할 파일의 전체경로</param>
      <exception cref="T:System.IO.FileNotFoundException">지정한 파일을 찾을 수 없을 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.IsFileReadOnly(System.String)">
      <summary>
            파일이 읽기 전용인지 검사
            </summary>
      <param name="filename">검사할 파일의 전체 경로</param>
      <returns>
        <see langword="true" /> 읽기 전용인 경우, 그렇지 않다면 false</returns>
      <exception cref="T:System.IO.FileNotFoundException">지정한 파일이 없는 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.CreateDirectory(System.String)">
      <summary>
            지정한 Directory가 존재하지 않는다면 새로 생성한다.
            </summary>
      <param name="path">전체 경로</param>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.DeleteDirectory(System.String,System.Boolean)">
      <summary>
            지정된 Directory를 삭제한다. 해당 Directory에 속한 Sub Directory와 파일도 삭제 가능하다.
            </summary>
      <param name="path">삭제할 디렉토리 경로</param>
      <param name="recursive">하위 디렉토리나 파일을 삭제할지 여부</param>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.CopyDirectory(System.String,System.String,System.Boolean)">
      <summary>
            디렉토리 전체를 복사한다.
            </summary>
      <param name="srcPath">원본 경로</param>
      <param name="destPath">대상 경로</param>
      <param name="overwrite">겹쳐쓰기 옵션</param>
      <exception cref="T:System.IO.DirectoryNotFoundException">원본 경로가 없을 시, 대상 경로의 부모 경로가 없을 시</exception>
      <remarks>
            대상경로가 존재하지 않을 시에는 새로 만들어 사용한다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.MoveDirectory(System.String,System.String)">
      <summary>
            원본 디렉토리를 대상 디렉토리로 이동시킨다.
            </summary>
      <param name="srcPath">이동할 파일 또는 경로</param>
      <param name="destPath">새위치</param>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.CopyFile(System.String,System.String,System.Boolean)">
      <summary>
            파일 복사
            </summary>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.MoveFile(System.String,System.String,System.Boolean)">
      <summary>
            파일 이동
            </summary>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.CreateEmptyFile(System.String)">
      <summary>
            길이가 0인 파일을 만든다.
            </summary>
      <param name="filePath">빈 파일의 전체 경로</param>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.DeleteFile(System.String,System.Boolean)">
      <summary>
            파일 삭제
            </summary>
      <param name="filename">삭제할 파일명</param>
      <param name="fireException">에러발생시 throw 할 것인지 여부</param>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.RenameFile(System.String,System.String)">
      <summary>
            파일명 변경, <see cref="M:NSoft.NFramework.IO.FileTool.MoveFile(System.String,System.String,System.Boolean)" /> 와 같음
            </summary>
      <param name="srcFileName">원본 파일 경로</param>
      <param name="destFileName">대상 파일 경로</param>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.RenameFile(System.IO.FileInfo,System.String)">
      <summary>
             파일명 변경, <see cref="M:NSoft.NFramework.IO.FileTool.MoveFile(System.String,System.String,System.Boolean)" /> 와 같음
            </summary>
      <param name="srcFileInfo">원본 파일에 대한 FileInfo 인스턴스 개체</param>
      <param name="destFileName">대상 파일명</param>
      <exception cref="T:System.IO.IOException">대상 파일이 존재하면 덮어쓰기 할 수 없습니다.</exception>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.FindNewFileName(System.String)">
      <summary>
            파일을 겹쳐쓰기를 방지하기위해 같은 이름의 파일이 있으면 새로운 파일 이름을 반환한다.
            </summary>
      <param name="filename">원하는 파일명</param>
      <returns>새로운 파일명</returns>
      <remarks>
            해당 파일을 찾고, 그 파일이 없으면 해당 파일명을 반환하고,
            중복되는 파일명이 있으면 "FileName[1].ext" 와 같이 뒤에 인덱스를 붙여서 만든다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetNewFileName(System.String)">
      <summary>
            파일을 겹쳐쓰기를 방지하기위해 지정된 파일명이 있다면, IE 처럼 파일명을 새로 생성한다.
            </summary>
      <param name="filename">원하는 파일명</param>
      <returns>새로운 파일명</returns>
      <remarks>
            해당 파일을 찾고, 그 파일이 없으면 해당 파일명을 반환하고,
            중복되는 파일명이 있으면 "FileName[1].ext" 와 같이 뒤에 인덱스를 붙여서 만든다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetFileStream(System.String,NSoft.NFramework.FileOpenMode)">
      <summary>
            파일 스트림 <see cref="T:System.IO.FileStream" />을 생성해 준다.
            </summary>
      <param name="filename">대상 파일 경로</param>
      <param name="openMode">열기 모드</param>
      <returns>파일 스트림, 실패시에는 null 반환</returns>
      <exception cref="T:System.IO.FileNotFoundException">파일이 존재하지 않을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetBufferedFileStream(System.String,NSoft.NFramework.FileOpenMode)">
      <summary>
            파일 스트림을 데코레이션한 버퍼 스트림을 생성한다.
            </summary>
      <param name="filename">파일 경로 명</param>
      <param name="openMode">열기 모드</param>
      <returns>버퍼링되는 파일 스트림, 실패시에는 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.Save(System.String,System.IO.Stream,System.Boolean)">
      <summary>
        <paramref name="stream" />을 읽어, <paramref name="filepath" />의 파일에 저장합니다.
            해당 파일이 존재하면 겹쳐 쓰거나 추가를 할 수 있습니다. 파일이 없으면 새로 생성합니다. 
            </summary>
      <param name="filepath">대상 파일 경로</param>
      <param name="stream">저장할 내용</param>
      <param name="overwrite">겹쳐쓰기 여부</param>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.Save(System.String,System.String,System.Boolean,System.Text.Encoding)">
      <summary>
            지정된 파일에 문자열을 지정된 인코딩 방식으로 저장합니다. 
            해당 파일이 존재하면 겹쳐 쓰거나 추가를 할 수 있습니다. 파일이 없으면 새로 생성합니다.
            </summary>
      <param name="filepath">대상 파일 경로</param>
      <param name="text">저장할 문자열</param>
      <param name="overwrite">덮어 쓰기 여부</param>
      <param name="enc">인코딩</param>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.Save(System.String,System.Byte[],System.Boolean)">
      <summary>
            바이트 배열을 지정한 파일에 저장합니다.
            </summary>
      <param name="filepath">파일 이름</param>
      <param name="bytes">저장할 바이트 배열</param>
      <param name="overwrite">겹쳐쓰기 옵션</param>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.ToByteArray(System.String)">
      <summary>
            파일을 읽어서 Byte Array로 반환한다.
            </summary>
      <param name="filepath">읽을 파일명</param>
      <returns>파일이 존재하지 않거나, 파일 내용이 없으면 길이가 0인 Byte Array가 반환된다.</returns>
      <example>
            이진 파일을 Byte Array로 반환한다.
            <code>
            	byte[] buff = FileTool.ToByteArray(filename);
            	string s = StringTool.AsString(buff);
            </code></example>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.ToStream(System.String,System.Text.Encoding)">
      <summary>
            파일 내용을 읽어서 메모리 스트림으로 변환합니다.
            </summary>
      <param name="filepath">읽을 파일 전체 경로</param>
      <param name="enc">인코딩 형식</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.ToString(System.String,System.Text.Encoding)">
      <summary>
            파일 내용을 지정된 인코딩 방식으로 문자열로 변환합니다.
            </summary>
      <param name="filepath">읽을 파일 전체 경로</param>
      <param name="enc">인코딩 형식</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.Base64Encode(System.String)">
      <summary>
            파일 내용을 읽어 Base64 형식의 문자열로 변환합니다.<br />
            Http Protocol에서는 이진 Data는 전송할 수 없으므로, Base64 Encoding 방식을 기본으로 사용한다.
            </summary>
      <param name="filepath">읽을 파일 경로</param>
      <returns>Base64로 인코딩된 문자열</returns>
      <example>
            파일을 읽어 Base64형식의 문자열로 인코딩하고, 다시 디코딩하여 파일을 저장하는 예제입니다.
            <code>
            const string srcFile  = @"C:\Windows\부채.bmp";
            const string destFile = @"C:\Windows\부채2.bmp";
            
            PerfCount.Start();
            
            string base64String;
            
            Console.WriteLine("\n-----------------------------------------------");
            Console.WriteLine(srcFile + " 을 읽어서 Base64String을 만듭니다.");
            base64String = FileTool.Base64Encode(srcFile);
            Console.WriteLine(base64String);
            
            Console.WriteLine("\n-----------------------------------------------");
            Console.WriteLine(destFile + "로 위의 내용을 Decoding해서 저장합니다.");
            
            byte[] buffer = StringTool.Base64Decode(base64String);
            base64String = null;
            FileTool.Save(destFile, buffer, true);
            buffer = null;
            
            // 성능 측정을 위해서 쓰는 것입니다.
            Console.WriteLine("Base64Encode , Base64Decode Time : {0} sec", PerfCount.End() * 1000);
            </code></example>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.Base64Encode(System.String,System.Char[]@)">
      <summary>
            파일 내용을 읽어 Base64 형식의 문자열로 변환합니다.<br />
            Http Protocol에서는 이진 Data는 전송할 수 없으므로, Base64 Encoding 방식을 기본으로 사용한다.
            </summary>
      <param name="filepath">읽을 파일 경로</param>
      <param name="outArray">Base64로 인코딩된 파일 내용</param>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetDirectories(System.String,System.String)">
      <summary>
            해당 폴더를 기준으로 검색 패턴과 일치하는 폴더를 검색한다.
            </summary>
      <param name="path">
      </param>
      <param name="searchPattern">검색할 패턴</param>
      <returns>검색된 폴더의 string array</returns>
      <example>
        <code>
            	string[] dirs = FileTool.GetDirectories("C:\", "W*");
            	foreach(string dir in dirs)
            		Console.WriteLine(dir);
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetDirectories(System.String)">
      <summary>
            해당 폴더를 기준으로 하위 폴더의 Path를 문자열 배열로 반환한다.
            </summary>
      <param name="path">경로</param>
      <returns>하위 폴더 이름의 배열</returns>
      <example>
        <code>
            	string[] dirList = FileTool.GetDirectories("C:\");
            	foreach(string dir in dirList)
            		Console.WriteLine(dir);
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetFiles(System.String,System.String)">
      <summary>
            지정된 폴더에 있는 파일중에 검색 패턴과 일치하는 파일의 이름을 배열로 반환한다.
            </summary>
      <param name="path">경로</param>
      <param name="searchPattern">검색 패턴</param>
      <returns>검색된 파일들의 이름 배열</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.GetFiles(System.String)">
      <summary>
            지정된 폴더에 있는 모든 파일의 이름을 배열로 반환한다.
            </summary>
      <param name="path">검색할 폴더</param>
      <returns>지정된 폴더에 있는 모든 파일</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.FileTool.ParsePath(System.String,System.String@,System.String@,System.String@,System.String@)">
      <summary>
            파일 경로를 분석해서 root (drive), directory, file, extension 정보를 구한다.
            <c>Path.GetPathRoot()</c> 참조
            </summary>
      <param name="path">분석할 파일 경로</param>
      <param name="root">"C:\" 같은 문자열이거나 빈 문자열</param>
      <param name="dirName">디렉토리 정보 혹은 빈 문자열</param>
      <param name="fullFileName">전체 파일이름 (extension 포함) 혹은 빈 문자열</param>
      <param name="extension">파일 Extension 혹은 빈 문자열</param>
    </member>
    <member name="T:NSoft.NFramework.IO.StreamTool">
      <summary>
            Stream 개체에 Value type 정보를 read/write할 수있는 Utility class
            </summary>
      <remarks>
            Serializable 객체를 사용하면 되겠지만, 지정된 Stream에 기록할 때 쓰는 고전적인 방법이다.
            </remarks>
      <example>
            스트림에 정보를 쓰고, 읽는 작업을 합니다.
            <code>
            using (ValueStream ms = new ValueStream())
            using (ValueStream ms2 = new ValueStream())
            {
                string s = "동해물과 백두산이";
                byte[] b = StreamTool.ToBytes(s);
                ms.Write(s);
                ms.Write(true);
                ms.Write(1234);
                ms.Write('x');
                ms.Write(1245.567F);
                ms.Write((double)999.99);
                ms.Write(4444L);
                ms.Write((short)127);
                ms.Write(StreamTool.ToBytes(s));
            
                ms.Position = 0;
            
                Console.WriteLine(ms.ReadString());
                Console.WriteLine(ms.ReadBoolean());
                Console.WriteLine(ms.ReadInt32());
                Console.WriteLine(ms.ReadChar());
                Console.WriteLine(ms.ReadFloat());
                Console.WriteLine(ms.ReadDouble());
                Console.WriteLine(ms.ReadInt64());
                Console.WriteLine(ms.ReadInt16());
            
                Console.WriteLine(StreamTool.AsString(ms.ReadBytes(b.Length)));
            
                // Stream 간의 복사
                ms.Position = 0;
                ms2.Write(ms);
                ms2.Position = 0;
                MemoryStream ms3 = (MemoryStream)ms2.ReadStream();
                ms3.Position = 0;
            
                Console.WriteLine(StreamTool.ReadString(ms3));
                Console.WriteLine(StreamTool.ReadBoolean(ms3));
                Console.WriteLine(StreamTool.ReadInt32(ms3));
                Console.WriteLine(StreamTool.ReadChar(ms3));
                Console.WriteLine(StreamTool.ReadFloat(ms3));
                Console.WriteLine(StreamTool.ReadDouble(ms3));
                Console.WriteLine(StreamTool.ReadInt64(ms3));
                Console.WriteLine(StreamTool.ReadInt16(ms3));
                Console.WriteLine(StreamTool.AsString(StreamTool.ReadBytes(ms3, b.Length)));
            }
            </code></example>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.CopyStreamToStream(System.IO.Stream,System.IO.Stream)">
      <summary>
        <paramref name="srcStream" /> 스트림을 읽어, <paramref name="destStream" />에 쓴다.
            </summary>
      <param name="srcStream">원본 스트림</param>
      <param name="destStream">대상 스트림</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.CopyStreamToStream(System.IO.Stream,System.IO.Stream,System.Int32)">
      <summary>
        <paramref name="srcStream" /> 스트림을 읽어, <paramref name="destStream" />에 쓴다. 
            </summary>
      <param name="srcStream">원본 스트림</param>
      <param name="destStream">대상 스트림</param>
      <param name="bufferSize">버퍼 크기</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadAllBytes(System.IO.Stream)">
      <summary>
        <paramref name="stream" /> 의 현재 위치부터 끝까지 읽어서 바이트배열로 변환합니다.
            </summary>
      <param name="stream">읽을 스트림</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.SetStreamPosition(System.IO.Stream,System.Int32)">
      <summary>
            Stream의 Position을 변경한다.
            </summary>
      <param name="stream">대상 스트림 객체</param>
      <param name="position">지정된 포지션</param>
      <exception cref="T:System.IO.IOException">포지션이 스트림 객체의 크기보다 클때</exception>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Write(System.IO.Stream,System.String)">
      <summary>
            스트림에 값 쓰기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Write(System.IO.Stream,System.Int32)">
      <summary>
            스트림에 값 쓰기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Write(System.IO.Stream,System.Int64)">
      <summary>
            스트림에 값 쓰기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Write(System.IO.Stream,System.Double)">
      <summary>
            스트림에 값 쓰기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Write(System.IO.Stream,System.Single)">
      <summary>
            스트림에 값 쓰기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Write(System.IO.Stream,System.UInt32)">
      <summary>
            스트림에 값 쓰기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Write(System.IO.Stream,System.UInt64)">
      <summary>
            스트림에 값 쓰기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Write(System.IO.Stream,System.Char)">
      <summary>
            스트림에 값 쓰기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Write(System.IO.Stream,System.Int16)">
      <summary>
            스트림에 값 쓰기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Write(System.IO.Stream,System.Boolean)">
      <summary>
            스트림에 값 쓰기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Write(System.IO.Stream,System.UInt16)">
      <summary>
            스트림에 값 쓰기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Write(System.IO.Stream,System.IO.Stream)">
      <summary>
            원본 스트림을 대상 스트림에 쓴다.
            </summary>
      <remarks>
            원본 스트림의 크기를 먼저 대상 스트림에 기록하고, 내용을 쓴다. 
            읽어 올 때도 크기를 먼저 읽고, 그 크기 만큼 내용을 읽어온다.
            </remarks>
      <param name="stream">복사 대상 스트림</param>
      <param name="source">원본 스트림</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Read(System.IO.Stream,System.Double@)">
      <summary>
            지정된 <paramref name="stream" />을 읽어서 값을 반환한다.
            </summary>
      <param name="stream">읽을 대상 <see cref="T:System.IO.Stream" /> 인스턴스</param>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Read(System.IO.Stream,System.Single@)">
      <summary>
            지정된 <paramref name="stream" />을 읽어서 값을 반환한다.
            </summary>
      <param name="stream">읽을 대상 <see cref="T:System.IO.Stream" /> 인스턴스</param>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Read(System.IO.Stream,System.Int32@)">
      <summary>
            지정된 <paramref name="stream" />을 읽어서 값을 반환한다.
            </summary>
      <param name="stream">읽을 대상 <see cref="T:System.IO.Stream" /> 인스턴스</param>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Read(System.IO.Stream,System.Int64@)">
      <summary>
            지정된 <paramref name="stream" />을 읽어서 값을 반환한다.
            </summary>
      <param name="stream">읽을 대상 <see cref="T:System.IO.Stream" /> 인스턴스</param>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Read(System.IO.Stream,System.UInt32@)">
      <summary>
            지정된 <paramref name="stream" />을 읽어서 값을 반환한다.
            </summary>
      <param name="stream">읽을 대상 <see cref="T:System.IO.Stream" /> 인스턴스</param>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Read(System.IO.Stream,System.UInt64@)">
      <summary>
            지정된 <paramref name="stream" />을 읽어서 값을 반환한다.
            </summary>
      <param name="stream">읽을 대상 <see cref="T:System.IO.Stream" /> 인스턴스</param>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Read(System.IO.Stream,System.Int16@)">
      <summary>
            지정된 <paramref name="stream" />을 읽어서 값을 반환한다.
            </summary>
      <param name="stream">읽을 대상 <see cref="T:System.IO.Stream" /> 인스턴스</param>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Read(System.IO.Stream,System.UInt16@)">
      <summary>
            지정된 <paramref name="stream" />을 읽어서 값을 반환한다.
            </summary>
      <param name="stream">읽을 대상 <see cref="T:System.IO.Stream" /> 인스턴스</param>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Read(System.IO.Stream,System.Char@)">
      <summary>
            지정된 <paramref name="stream" />을 읽어서 값을 반환한다.
            </summary>
      <param name="stream">읽을 대상 <see cref="T:System.IO.Stream" /> 인스턴스</param>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Read(System.IO.Stream,System.Boolean@)">
      <summary>
            지정된 <paramref name="stream" />을 읽어서 값을 반환한다.
            </summary>
      <param name="stream">읽을 대상 <see cref="T:System.IO.Stream" /> 인스턴스</param>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Read(System.IO.Stream,System.String@)">
      <summary>
            지정된 <paramref name="stream" />을 읽어서 값을 반환한다.
            </summary>
      <param name="stream">읽을 대상 <see cref="T:System.IO.Stream" /> 인스턴스</param>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.Read(System.IO.Stream,System.IO.Stream@)">
      <summary>
            지정된 <paramref name="stream" />을 읽어서 <paramref name="target" />에 저장한다.
            </summary>
      <param name="stream">읽을 대상 <see cref="T:System.IO.Stream" /> 인스턴스</param>
      <param name="target">읽은 값을 저장한 <see cref="T:System.IO.Stream" /> 인스턴스</param>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadString(System.IO.Stream)">
      <summary>
        <paramref name="stream" />에서 값 읽어오기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadInt16(System.IO.Stream)">
      <summary>
        <paramref name="stream" />에서 값 읽어오기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadInt32(System.IO.Stream)">
      <summary>
        <paramref name="stream" />에서 값 읽어오기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadInt64(System.IO.Stream)">
      <summary>
        <paramref name="stream" />에서 값 읽어오기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadUInt16(System.IO.Stream)">
      <summary>
        <paramref name="stream" />에서 값 읽어오기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadUInt32(System.IO.Stream)">
      <summary>
        <paramref name="stream" />에서 값 읽어오기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadUInt64(System.IO.Stream)">
      <summary>
        <paramref name="stream" />에서 값 읽어오기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadChar(System.IO.Stream)">
      <summary>
        <paramref name="stream" />에서 값 읽어오기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadBoolean(System.IO.Stream)">
      <summary>
        <paramref name="stream" />에서 값 읽어오기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadFloat(System.IO.Stream)">
      <summary>
        <paramref name="stream" />에서 값 읽어오기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadDouble(System.IO.Stream)">
      <summary>
        <paramref name="stream" />에서 값 읽어오기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadBytes(System.IO.Stream,System.Int32)">
      <summary>
        <paramref name="stream" />에서 값 읽어오기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <param name="length">읽을 길이</param>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.StreamTool.ReadStream(System.IO.Stream)">
      <summary>
        <paramref name="stream" />에서 값 읽어오기
            </summary>
      <param name="stream">대상 Stream 객체</param>
      <returns>읽은 값</returns>
    </member>
    <member name="T:NSoft.NFramework.IO.ValueStream">
      <summary>
            예전 방식대로 <c>Stream</c>에 값 형식의 정보를 저장하고, 조회할 때 사용하는 Class
            </summary>
      <example>
            스트림에 정보를 쓰고, 읽는 작업을 합니다.
            <code>
            using (ValueStream ms = new ValueStream())
            using (ValueStream ms2 = new ValueStream())
            {
                string s = "동해물과 백두산이";
                byte[] b = StreamTool.ToBytes(s);
                ms.Write(s);
                ms.Write(true);
                ms.Write(1234);
                ms.Write('x');
                ms.Write(1245.567F);
                ms.Write((double)999.99);
                ms.Write(4444L);
                ms.Write((short)127);
                ms.Write(StreamTool.ToBytes(s));
            
                ms.Position = 0;
            
                Console.WriteLine(ms.ReadString());
                Console.WriteLine(ms.ReadBoolean());
                Console.WriteLine(ms.ReadInt32());
                Console.WriteLine(ms.ReadChar());
                Console.WriteLine(ms.ReadFloat());
                Console.WriteLine(ms.ReadDouble());
                Console.WriteLine(ms.ReadInt64());
                Console.WriteLine(ms.ReadInt16());
            
                Console.WriteLine(StreamTool.AsString(ms.ReadBytes(b.Length)));
            
                // Stream 간의 복사
                ms.Position = 0;
                ms2.Write(ms);
                ms2.Position = 0;
                MemoryStream ms3 = (MemoryStream)ms2.ReadStream();
                ms3.Position = 0;
            
                Console.WriteLine(StreamTool.ReadString(ms3));
                Console.WriteLine(StreamTool.ReadBoolean(ms3));
                Console.WriteLine(StreamTool.ReadInt32(ms3));
                Console.WriteLine(StreamTool.ReadChar(ms3));
                Console.WriteLine(StreamTool.ReadFloat(ms3));
                Console.WriteLine(StreamTool.ReadDouble(ms3));
                Console.WriteLine(StreamTool.ReadInt64(ms3));
                Console.WriteLine(StreamTool.ReadInt16(ms3));
                Console.WriteLine(StreamTool.AsString(StreamTool.ReadBytes(ms3, b.Length)));
            }
            </code></example>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Write(System.String)">
      <summary>
            인스턴스에 <paramref name="s" /> 값 쓰기
            </summary>
      <param name="s">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Write(System.Int16)">
      <summary>
            인스턴스에 <paramref name="v" /> 값 쓰기
            </summary>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Write(System.Int32)">
      <summary>
            인스턴스에 <paramref name="v" /> 값 쓰기
            </summary>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Write(System.Int64)">
      <summary>
            인스턴스에 <paramref name="v" /> 값 쓰기
            </summary>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Write(System.UInt16)">
      <summary>
            인스턴스에 <paramref name="v" /> 값 쓰기
            </summary>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Write(System.UInt32)">
      <summary>
            인스턴스에 <paramref name="v" /> 값 쓰기
            </summary>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Write(System.UInt64)">
      <summary>
            인스턴스에 <paramref name="v" /> 값 쓰기
            </summary>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Write(System.Single)">
      <summary>
            인스턴스에 <paramref name="v" /> 값 쓰기
            </summary>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Write(System.Double)">
      <summary>
            인스턴스에 <paramref name="v" /> 값 쓰기
            </summary>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Write(System.Boolean)">
      <summary>
            인스턴스에 <paramref name="v" /> 값 쓰기
            </summary>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Write(System.Char)">
      <summary>
            인스턴스에 <paramref name="v" /> 값 쓰기
            </summary>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Write(System.Byte[])">
      <summary>
            인스턴스에 <paramref name="v" /> 값 쓰기
            </summary>
      <param name="v">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Write(System.IO.Stream)">
      <summary>
            인스턴스에 <paramref name="stream" /> 값 쓰기
            </summary>
      <param name="stream">쓸 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Read(System.String@)">
      <summary>
            인스턴스에서 값 읽기
            </summary>
      <param name="s">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Read(System.Int16@)">
      <summary>
            인스턴스에서 값 읽기
            </summary>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Read(System.Int32@)">
      <summary>
            인스턴스에서 값 읽기
            </summary>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Read(System.Int64@)">
      <summary>
            인스턴스에서 값 읽기
            </summary>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Read(System.UInt16@)">
      <summary>
            인스턴스에서 값 읽기
            </summary>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Read(System.UInt32@)">
      <summary>
            인스턴스에서 값 읽기
            </summary>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Read(System.UInt64@)">
      <summary>
            인스턴스에서 값 읽기
            </summary>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Read(System.Single@)">
      <summary>
            인스턴스에서 값 읽기
            </summary>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Read(System.Double@)">
      <summary>
            인스턴스에서 값 읽기
            </summary>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Read(System.Boolean@)">
      <summary>
            인스턴스에서 값 읽기
            </summary>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Read(System.Char@)">
      <summary>
            인스턴스에서 값 읽기
            </summary>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Read(System.Byte[])">
      <summary>
            인스턴스에서 값 읽기
            </summary>
      <param name="v">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.Read(System.IO.Stream@)">
      <summary>
            인스턴스에서 값 읽기
            </summary>
      <param name="stream">읽은 값</param>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.ReadString">
      <summary>
            인스턴스에서 문자열 읽기
            </summary>
      <returns>읽은 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.ReadInt16">
      <summary>
            인스턴스에서 <see cref="T:System.Int16" /> 형식의 값 읽기
            </summary>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.ReadInt32">
      <summary>
            인스턴스에서 <see cref="T:System.Int32" /> 형식의 값 읽기
            </summary>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.ReadInt64">
      <summary>
            인스턴스에서 <see cref="T:System.Int64" /> 형식의 값 읽기
            </summary>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.ReadUInt16">
      <summary>
            인스턴스에서 <see cref="T:System.UInt16" /> 형식의 값 읽기
            </summary>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.ReadUInt32">
      <summary>
            인스턴스에서 <see cref="T:System.UInt32" /> 형식의 값 읽기
            </summary>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.ReadUInt64">
      <summary>
            인스턴스에서 <see cref="T:System.UInt64" /> 형식의 값 읽기
            </summary>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.ReadFloat">
      <summary>
            인스턴스에서 <see cref="T:System.Single" /> 형식의 값 읽기
            </summary>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.ReadDouble">
      <summary>
            인스턴스에서 <see cref="T:System.Double" /> 형식의 값 읽기
            </summary>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.ReadChar">
      <summary>
            인스턴스에서 <see cref="T:System.Char" /> 형식의 값 읽기
            </summary>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.ReadBoolean">
      <summary>
            인스턴스에서 <see cref="T:System.Boolean" /> 형식의 값 읽기
            </summary>
      <returns>읽은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.ReadBytes(System.Int32)">
      <summary>
            스트림에서 현위치부터 <paramref name="length" /> 길이 만큼 읽어서 일차원 바이트 배열로 반환한다.
            </summary>
      <param name="length">읽을 길이</param>
      <returns>일차원 바이트 배열</returns>
    </member>
    <member name="M:NSoft.NFramework.IO.ValueStream.ReadStream">
      <summary>
            인스턴스의 현재 <see cref="P:System.IO.Stream.Position" />에서부터 끝까지 읽어서 <see cref="T:System.IO.Stream" />으로 반환한다.
            </summary>
      <returns>읽은 <see cref="T:System.IO.Stream" /> 인스턴스</returns>
    </member>
    <member name="T:NSoft.NFramework.Json.BsonSerializer">
      <summary>
            BSON 형식으로 직렬화, 역직렬화를 수행합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Serializations.Serializers.AbstractSerializer">
      <summary>
            Serializer의 추상 클래스
            </summary>
    </member>
    <member name="M:NSoft.NFramework.ISerializer.Serialize(System.Object)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">직렬화할 객체</param>
      <returns>직렬화된 객체 정보, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.ISerializer.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">객체를 직렬화한 정보</param>
      <returns>역직렬화한 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.AbstractSerializer.Serialize(System.Object)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">직렬화할 객체</param>
      <returns>직렬화된 객체 정보, graph가 null이면, 길이가 0인 byte[] 반환</returns>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="graph" />의 형식이 byte[] 가 아닌 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.AbstractSerializer.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">객체를 직렬화한 정보</param>
      <returns>역직렬화한 객체</returns>
    </member>
    <member name="T:NSoft.NFramework.Json.IJsonSerializer">
      <summary>
            JSON 방식의 Serializer의 인터페이스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.IJsonSerializer.Deserialize(System.Byte[],System.Type)">
      <summary>
            특정 수형으로 역직렬화를 수행합니다.
            </summary>
      <param name="data">직렬화된 정보</param>
      <param name="targetType">역직렬화할 대상 수형</param>
      <returns>역직렬화 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.BsonSerializer.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.BsonSerializer.#ctor(Newtonsoft.Json.JsonSerializer)">
      <summary>
            생성자
            </summary>
      <param name="serializer">Json Serializer</param>
    </member>
    <member name="M:NSoft.NFramework.Json.BsonSerializer.Serialize(System.Object)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">직렬화할 객체</param>
      <returns>직렬화된 객체 정보, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.BsonSerializer.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">객체를 직렬화한 정보</param>
      <returns>역직렬화한 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.BsonSerializer.Deserialize(System.Byte[],System.Type)">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">객체를 직렬화한 정보</param>
      <param name="targetType">역직렬화된 객체의 수형</param>
      <returns>역직렬화한 객체</returns>
    </member>
    <member name="P:NSoft.NFramework.Json.BsonSerializer.Instance">
      <summary>
        <see cref="T:NSoft.NFramework.Json.BsonSerializer" />의 Singleton 인스턴스
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Json.BsonSerializer.Serializer">
      <summary>
            Json Serializer
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Json.BsonSerializer`1">
      <summary>
            BSON 형식으로 직렬화, 역직렬화를 수행합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.Serializations.Serializers.AbstractSerializer`1">
      <summary>
            Serializer의 추상 클래스
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.ISerializer`1">
      <summary>
            인스턴스를 Serialize/Deserialize를 수행하는 Class의 기본 인터페이스
            </summary>
      <typeparam name="T">Serialize를 수행할 형식</typeparam>
    </member>
    <member name="M:NSoft.NFramework.ISerializer`1.Serialize(`0)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">object to be serialized.</param>
      <returns>직렬화된 객체, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.ISerializer`1.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">serialized data to be deserialized.</param>
      <returns>deserialized object</returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.AbstractSerializer`1.Serialize(`0)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">object to be serialized.</param>
      <returns>직렬화된 객체, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.AbstractSerializer`1.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">serialized data to be deserialized.</param>
      <returns>deserialized object</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.BsonSerializer`1.Serialize(`0)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">object to be serialized.</param>
      <returns>직렬화된 객체, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.BsonSerializer`1.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">serialized data to be deserialized.</param>
      <returns>deserialized object</returns>
    </member>
    <member name="P:NSoft.NFramework.Json.BsonSerializer`1.Instance">
      <summary>
        <see cref="T:NSoft.NFramework.Json.BsonSerializer`1" /> 의 Singlton 인스턴스
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Json.BsonSerializer`1.Serializer">
      <summary>
            내부 <see cref="T:Newtonsoft.Json.JsonSerializer" /></summary>
    </member>
    <member name="T:NSoft.NFramework.Json.CompressBsonSerializer`1">
      <summary>
            압축 가능한 Bson Serializer 입니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.Serializations.Serializers.CompressSerializer`1">
      <summary>
            Decorator 패턴을 이용하여, 직렬화 후 압축해주는 Decorator 입니다.
            </summary>
      <typeparam name="T">직렬화 대상 수형</typeparam>
    </member>
    <member name="T:NSoft.NFramework.Serializations.Serializers.AbstractSerializerDecorator`1">
      <summary>
            특정 인스턴스를 직렬화/역직렬화 시에 추가 변환 작업 (압축/암호화 등)을 수행하는 Decorator에 대한 기본 클래스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.AbstractSerializerDecorator`1.Serialize(`0)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">직렬화할 객체</param>
      <returns>직렬화된 객체 정보, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.AbstractSerializerDecorator`1.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">객체를 직렬화한 정보</param>
      <returns>역직렬화한 객체</returns>
    </member>
    <member name="P:NSoft.NFramework.Serializations.Serializers.AbstractSerializerDecorator`1.Serializer">
      <summary>
            Wrapping 된 실제 Serializer
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.CompressSerializer`1.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.CompressSerializer`1.#ctor(NSoft.NFramework.ISerializer{`0})">
      <summary>
            생성자
            </summary>
      <param name="serializer">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.CompressSerializer`1.#ctor(NSoft.NFramework.ISerializer{`0},NSoft.NFramework.Compressions.ICompressor)">
      <summary>
            생성자
            </summary>
      <param name="serializer">실제 Serializer</param>
      <param name="compressor">압축기</param>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.CompressSerializer`1.Serialize(`0)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">직렬화할 객체</param>
      <returns>직렬화된 객체 정보, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.CompressSerializer`1.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">객체를 직렬화한 정보</param>
      <returns>역직렬화한 객체</returns>
    </member>
    <member name="P:NSoft.NFramework.Serializations.Serializers.CompressSerializer`1.Compressor">
      <summary>
            압축기 (기본은 <see cref="T:NSoft.NFramework.Compressions.Compressors.SharpBZip2Compressor" />입니다.)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.CompressBsonSerializer`1.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.CompressBsonSerializer`1.#ctor(NSoft.NFramework.Json.BsonSerializer{`0})">
      <summary>
            생성자
            </summary>
      <param name="serializer">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Json.CompressBsonSerializer`1.Instance">
      <summary>
        <see cref="T:NSoft.NFramework.Json.CompressBsonSerializer`1" /> 의 Singleton 인스턴스
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Json.CompressJsonSerializer`1">
      <summary>
            압축 가능한 JsonSerializer 입니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Json.CompressJsonSerializer`1.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.CompressJsonSerializer`1.#ctor(NSoft.NFramework.Json.JsonByteSerializer{`0})">
      <summary>
            생성자
            </summary>
      <param name="serializer">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Json.CompressJsonSerializer`1.Instance">
      <summary>
        <see cref="T:NSoft.NFramework.Json.CompressJsonSerializer`1" /> 의 Singleton 인스턴스
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Json.JsonByteSerializer">
      <summary>
            JSON 포맷으로 객체를 직렬화/역직렬화를 수행합니다. 직렬화된 정보를 Text가 아닌 UTF-8 인코딩 방식으로 byte[] 로 변환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonByteSerializer.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonByteSerializer.#ctor(Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            생성자
            </summary>
      <param name="jsonSerializerSettings">직렬화 설정 방식</param>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonByteSerializer.Serialize(System.Object)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">object to be serialized.</param>
      <returns>직렬화된 객체, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonByteSerializer.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">serialized data to be deserialized.</param>
      <returns>deserialized object</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonByteSerializer.Deserialize(System.Byte[],System.Type)">
      <summary>
            특정 수형으로 역직렬화를 수행합니다.
            </summary>
      <param name="data">직렬화된 정보</param>
      <param name="targetType">역직렬화할 대상 수형</param>
      <returns>역직렬화 결과</returns>
    </member>
    <member name="P:NSoft.NFramework.Json.JsonByteSerializer.Instance">
      <summary>
        <see cref="T:NSoft.NFramework.Json.JsonByteSerializer" />의 Singleton 인스턴스
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Json.JsonByteSerializer.SerializerSettings">
      <summary>
            SerializeSettings
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Json.JsonByteSerializer`1">
      <summary>
            JSON 포맷으로 객체를 직렬화/역직렬화를 수행합니다. 직렬화된 정보를 Text가 아닌 UTF-8 인코딩 방식으로 byte[] 로 변환합니다.
            </summary>
      <typeparam name="T">직렬화 대상 객체의 수형</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonByteSerializer`1.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonByteSerializer`1.#ctor(Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            생성자
            </summary>
      <param name="jsonSerializerSettings">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonByteSerializer`1.Serialize(`0)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">object to be serialized.</param>
      <returns>직렬화된 객체, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonByteSerializer`1.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">serialized data to be deserialized.</param>
      <returns>deserialized object</returns>
    </member>
    <member name="P:NSoft.NFramework.Json.JsonByteSerializer`1.Instance">
      <summary>
        <see cref="T:NSoft.NFramework.Json.JsonByteSerializer`1" />의 Singleton 인스턴스
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Json.JsonByteSerializer`1.SerializerSettings">
      <summary>
            SerializeSettings
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Json.JsonTool">
      <summary>
            Json 관련 Utility Method를 제공합니다. 
            </summary>
      <summary>
            JSON 포맷으로 객체 Mapping을 수행합니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Json.JsonTool.DefaultJsonSerializerSettings">
      <summary>
            Json 직렬화의 기본 설정
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Json.JsonTool.DefaultBsonSerializerSettings">
      <summary>
            Bson 직렬화의 기본 설정
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.ToJsonDateTime(System.DateTime)">
      <summary>
            JSON 형식에서 DataTime 을 내부적으로 double이 아닌 long을 변경해서 저장하므로, .NET DateTime과 오차가 생길 수 있다.
            직렬화된 정보 중 DateTime에 대한 비교는 꼭 ToJsonDateTime() 이용해서 DateTime을 변경한 후 비교해야 합니다.
            </summary>
      <param name="dateTime">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.SerializeAsText(System.Object,System.Nullable{Newtonsoft.Json.Formatting},Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            지정한 객체를 JSON 포맷으로 직렬화를 수행하고, 문자열로 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.SerializeAsText``1(``0,System.Nullable{Newtonsoft.Json.Formatting},Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            지정한 객체를 JSON 포맷으로 직렬화를 수행하고, 문자열로 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.SerializeAsBytes(System.Object,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            지정한 객체를 JSON 포맷으로 직렬화를 수행하고, byte array로 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.SerializeAsBytes``1(``0,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            지정한 객체를 JSON 포맷으로 직렬화를 수행하고, byte array로 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.SerializeWithCompress(System.Object,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            지정한 객체를 JSON 포맷으로 직렬화를 수행하고, 압축하여 byte array로 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.SerializeWithCompress``1(``0,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            지정한 객체를 JSON 포맷으로 직렬화를 수행하고, 압축하여 byte array로 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.DeserializeFromText(System.String,System.Type,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
        <paramref name="jsonText" /> 로부터 <paramref name="targetType" /> 수형으로 역직렬화를 수행합니다.
            </summary>
      <param name="jsonText">Json 직렬화 문자열</param>
      <param name="targetType">역직렬화 대상 수형</param>
      <param name="jsonSerializerSettings">Json 직렬화 관련 설정</param>
      <returns>역직렬화 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.DeserializeFromText``1(System.String,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
        <paramref name="jsonText" /> 로부터 {T} 수형으로 역직렬화를 수행합니다.
            </summary>
      <typeparam name="T">역직렬화 대상 수형</typeparam>
      <param name="jsonText">Json 직렬화 문자열</param>
      <param name="jsonSerializerSettings">Json 직렬화 관련 설정</param>
      <returns>역직렬화 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.DeserializeFromBytes(System.Byte[],System.Type,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
        <paramref name="bsonBytes" /> 로부터 <paramref name="targetType" /> 수형으로 역직렬화를 수행합니다.
            </summary>
      <param name="bsonBytes">Bson 직렬화 바이트 배열</param>
      <param name="targetType">역직렬화 대상 수형</param>
      <param name="jsonSerializerSettings">Json 직렬화 관련 설정</param>
      <returns>역직렬화 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.DeserializeFromBytes``1(System.Byte[],Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
        <paramref name="bsonBytes" /> 로부터 {T} 수형으로 역직렬화를 수행합니다.
            </summary>
      <typeparam name="T">역직렬화 대상 수형</typeparam>
      <param name="bsonBytes">Json 직렬화 바이트 배열</param>
      <param name="jsonSerializerSettings">Json 직렬화 관련 설정</param>
      <returns>역직렬화 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.DeserializeWithDecompress``1(System.Byte[],Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            압축된 <paramref name="bsonBytes" /> 을 압축해제한 후 {T} 수형으로 역직렬화를 수행합니다.
            </summary>
      <typeparam name="T">역직렬화 대상 수형</typeparam>
      <param name="bsonBytes">Json 직렬화 바이트 배열</param>
      <param name="jsonSerializerSettings">Json 직렬화 관련 설정</param>
      <returns>역직렬화 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.Map``1(System.Object,Newtonsoft.Json.JsonSerializerSettings,System.Action{System.Object,``0})">
      <summary>
             객체를 JSON 직렬화/역직렬화를 통해, T 수형의 인스턴스를 빌드합니다.
            </summary>
      <typeparam name="T">대상 수형</typeparam>
      <param name="source">원본객체</param>
      <param name="serializerSettings">JSON 직렬화 설정 정보</param>
      <param name="additionalMapping">부가 매핑 정보</param>
      <returns>매핑된 T 수형의 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.Map(System.Object,System.Type,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            객체를 JSON 직렬화/역직렬화를 통해, <paramref name="targetType" /> 수형의 인스턴스를 빌드합니다.
            </summary>
      <param name="source">원본 객체</param>
      <param name="targetType">대상 수형</param>
      <param name="serializerSettings">JSON 직렬화 설정 정보</param>
      <returns>매핑된 대상 수형의 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.TryMap``1(System.Object,``0@)">
      <summary>
            원본 객체를 JSON 포맷으로 직렬화를 수행하고, 대상 형식으로 역직렬화를 수행합니다. 두 수형이 달라도 상관없습니다.
            </summary>
      <param name="source">원본 객체</param>
      <param name="target">대상 객체</param>
      <returns>Mapping 성공 여부</returns>
      <see cref="T:NSoft.NFramework.Reflections.ObjectMapper" />
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.TryMap``1(System.Object,Newtonsoft.Json.JsonSerializerSettings,``0@)">
      <summary>
            원본 객체를 JSON 포맷으로 직렬화를 수행하고, 대상 형식으로 역직렬화를 수행합니다. 두 수형이 달라도 상관없습니다.
            </summary>
      <param name="source">원본 객체</param>
      <param name="target">대상 객체</param>
      <param name="serializerSettings">JSON 직렬화 설정 정보</param>
      <returns>Mapping 성공 여부</returns>
      <see cref="T:NSoft.NFramework.Reflections.ObjectMapper" />
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.TryMap(System.Object,System.Type,System.Object@)">
      <summary>
            원본 객체를 JSON 포맷으로 직렬화를 수행하고, 대상 수형으로 역직렬화를 수행합니다. 두 수형이 달라도 상관없습니다.
            </summary>
      <param name="source">원본 객체</param>
      <param name="targetType">대상 객체의 수형</param>
      <param name="target">대상 객체</param>
      <returns>Mapping 성공 여부</returns>
      <see cref="T:NSoft.NFramework.Reflections.ObjectMapper" />
    </member>
    <member name="M:NSoft.NFramework.Json.JsonTool.TryMap(System.Object,System.Type,Newtonsoft.Json.JsonSerializerSettings,System.Object@)">
      <summary>
            원본 객체를 JSON 포맷으로 직렬화를 수행하고, 대상 수형으로 역직렬화를 수행합니다. 두 수형이 달라도 상관없습니다.
            </summary>
      <param name="source">원본 객체</param>
      <param name="targetType">대상 객체의 수형</param>
      <param name="serializerSettings">JSON 직렬화 설정 정보</param>
      <param name="target">대상 객체</param>
      <returns>Mapping 성공 여부</returns>
      <see cref="T:NSoft.NFramework.Reflections.ObjectMapper" />
    </member>
    <member name="T:NSoft.NFramework.LinqEx.DynamicQueryable">
      <summary>
            Dynamic Query for LINQ
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.DynamicQueryable.Where``1(System.Linq.IQueryable{``0},System.String,System.Object[])">
      <summary>
            지정된 시퀀스를 필터링한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.DynamicQueryable.Where(System.Linq.IQueryable,System.String,System.Object[])">
      <summary>
            지정된 시퀀스를 필터링한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.DynamicQueryable.Select(System.Linq.IQueryable,System.String,System.Object[])">
      <summary>
            Select
            </summary>
      <param name="source">
      </param>
      <param name="selector">
      </param>
      <param name="values">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.DynamicQueryable.OrderBy``1(System.Linq.IQueryable{``0},System.String,System.Object[])">
      <summary>
            정렬
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">
      </param>
      <param name="ordering">
      </param>
      <param name="values">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.DynamicQueryable.OrderBy(System.Linq.IQueryable,System.String,System.Object[])">
      <summary>
            정렬
            </summary>
      <param name="source">
      </param>
      <param name="ordering">
      </param>
      <param name="values">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.DynamicQueryable.Take(System.Linq.IQueryable,System.Int32)">
      <summary>
      </summary>
      <param name="source">
      </param>
      <param name="count">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.DynamicQueryable.Skip(System.Linq.IQueryable,System.Int32)">
      <summary>
      </summary>
      <param name="source">
      </param>
      <param name="count">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.DynamicQueryable.GroupBy(System.Linq.IQueryable,System.String,System.String,System.Object[])">
      <summary>
            Group By
            </summary>
      <param name="source">
      </param>
      <param name="keySelector">
      </param>
      <param name="elementSelector">
      </param>
      <param name="values">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.DynamicQueryable.Any(System.Linq.IQueryable)">
      <summary>
            ANY
            </summary>
      <param name="source">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.DynamicQueryable.Count(System.Linq.IQueryable)">
      <summary>
            Count
            </summary>
      <param name="source">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.DynamicClass">
      <summary>
            Dynamic Class
            </summary>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.DynamicProperty">
      <summary>
            동적 속성
            </summary>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.DynamicExpression">
      <summary>
            동적 질의를 표현하기 위한 표현식
            </summary>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.EnumerableTool">
      <summary>
            LINQ 용 확장 함수들을 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.IsEmptySequence``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            지정한 시퀀가 비었으면 true를 반환합니다.
            </summary>
      <seealso cref="M:NSoft.NFramework.LinqEx.EnumerableTool.ItemExists``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.IsNotEmptySequence``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            시퀀스가 비어있지 않았는지 검사합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">
      </param>
      <param name="predicate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ItemExists``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            지정된 컬렉션에 검색 조건에 맞는 요소가 존재하는지 알아본다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ItemExistsAtLeast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
            지정된 시퀀스의 요소가 최소한 지정된 갯수 이상인지 확인한다.
            </summary>
      <typeparam name="T">시퀀스 요소의 수형</typeparam>
      <param name="source">시퀀스</param>
      <param name="count">최소 요소 수</param>
      <returns>지정된 시퀀스의 요소수가 지정된 최소 요소수보다 크거나 같다면 True, 작다면 False를 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.RepeatSequenceUnsafe``1(System.Collections.IEnumerable,System.Int32)">
      <summary>
            sequence를 count 수 만큼 반복한 sequence를 생성한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.RepeatSequence``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
            sequence를 count 수 만큼 반복한 sequence를 생성한다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">
      </param>
      <param name="count">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Replicate``1(System.Func{``0},System.Int32)">
      <summary>
        <paramref name="count" /> 갯수만큼 요소를 생성해서 반환합니다.
            </summary>
      <typeparam name="T">요소의 수형</typeparam>
      <param name="itemFactory">요소 생성 함수</param>
      <param name="count">생성할 요소의 갯수</param>
      <returns>생성된 요소의 열거자</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Replicate``1(System.Func{System.Int32,``0},System.Int32)">
      <summary>
        <paramref name="count" /> 갯수만큼 요소를 생성해서 반환합니다.
            </summary>
      <typeparam name="T">요소의 수형</typeparam>
      <param name="itemFactory">요소 생성 함수</param>
      <param name="count">생성할 요소의 갯수</param>
      <returns>생성된 요소의 열거자</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.RemoveAll``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
      <summary>
        <paramref name="sequence" />중에 <paramref name="canRemove" />를 만족시키는 요소는 삭제합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="sequence">
      </param>
      <param name="canRemove">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.SerialSequence``1(``0,``0,System.Int32)">
      <summary>
            시작값으로부터 변화하는 시퀀스를 만든다. 
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="seed">
      </param>
      <param name="step">
      </param>
      <param name="count">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Between``1(``0,``0,``0,System.Collections.Generic.IComparer{``0})">
      <summary>
            지정한 값이 MinValue, MaxValue 내에 있는지 판단한다.
            </summary>
      <typeparam name="T">IComparable{T} 를 구현한 수형이어야 한다.</typeparam>
      <param name="source">검사할 값</param>
      <param name="minValue">최소 값</param>
      <param name="maxValue">최대 값</param>
      <param name="comparer">T 수형의 비교자</param>
      <returns>최소값이상, 최대값 이하면 True, 아니면 False를 반환한다</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Between``1(System.Collections.Generic.IEnumerable{``0},``0,``0)">
      <summary>
            지정한 소스의 요소가 최소, 최대 구간 안에 있는 값만 반환한다. (최대, 최소 값 포함)
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">시퀀스</param>
      <param name="minValue">최소 값</param>
      <param name="maxValue">최대 값</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ToDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
      <summary>
            KeyValuePair{TKey, TValue} 의 시퀀스를 IDictionary{TKey, TValue} 로 바꾼다.
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="source">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ToBindingList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            지정된 시퀀스를 BindingList{T}로 변환한다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ToBindingListUnsafe``1(System.Collections.IEnumerable)">
      <summary>
            지정된 시퀀스를 BindingList{T}로 변환한다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ToStack``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
        <paramref name="sequence" />에 있는 요소들을 Stack에 넣어서 반환한다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="sequence">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ToQueue``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            지정된 시퀀스를 큐에 담아 반환한다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="sequence">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.BinaryTreePreOrderScan``1(``0,System.Func{``0,``0},System.Func{``0,``0},System.Func{System.Int32,System.Boolean},System.Int32)">
      <summary>
            BinaryTree를 PreOrder 방식으로 탐색한다 (Self, Left, Right 순으로 탐색)
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">시작 노드</param>
      <param name="getLeft">노드의 왼쪽 Child Node를 구하는 메소드</param>
      <param name="getRight">노드의 오른쪽 Child Node를 구하는 메소드</param>
      <param name="canYieldLevel">소스를 반환할 수 있는 레벨인가 판단하는 함수</param>
      <param name="level">노드 레벨</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.BinaryTreeInOrderScan``1(``0,System.Func{``0,``0},System.Func{``0,``0},System.Func{System.Int32,System.Boolean},System.Int32)">
      <summary>
            BinaryTree를 InOrder 방식으로 탐색한다 (Left, Self, Right 순으로 탐색) : 오름차순 정렬 순서대로 가져온다. 
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">시작 노드</param>
      <param name="getLeft">노드의 왼쪽 Child Node를 구하는 메소드</param>
      <param name="getRight">노드의 오른쪽 Child Node를 구하는 메소드</param>
      <param name="canYieldLevel">소스를 반환할 수 있는 레벨인가 판단하는 함수</param>
      <param name="level">노드 레벨</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.BinaryTreePostOrderScan``1(``0,System.Func{``0,``0},System.Func{``0,``0},System.Func{System.Int32,System.Boolean},System.Int32)">
      <summary>
            BinaryTree를 PostOrder 방식으로 탐색한다 (Left, Right, Self 순으로 탐색)
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">시작 노드</param>
      <param name="getLeft">노드의 왼쪽 Child Node를 구하는 메소드</param>
      <param name="getRight">노드의 오른쪽 Child Node를 구하는 메소드</param>
      <param name="canYieldLevel">소스를 반환할 수 있는 레벨인가 판단하는 함수</param>
      <param name="level">노드 레벨</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.BinaryTreeInRevOrderScan``1(``0,System.Func{``0,``0},System.Func{``0,``0},System.Func{System.Int32,System.Boolean},System.Int32)">
      <summary>
            BinaryTree를 InReverseOrder 방식으로 탐색한다 (Right, Self, Left 순으로 탐색) : 내림차순 정렬 순서대로 가져온다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">시작 노드</param>
      <param name="getLeft">노드의 왼쪽 Child Node를 구하는 메소드</param>
      <param name="getRight">노드의 오른쪽 Child Node를 구하는 메소드</param>
      <param name="canYieldLevel">소스를 반환할 수 있는 레벨인가 판단하는 함수</param>
      <param name="level">노드 레벨</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.GraphBreadthFirstScan``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Breadth-First Scan for Adjacent Graph
            </summary>
      <typeparam name="T">탐색할 Node의 수형</typeparam>
      <param name="source">Graph의 시작 Point</param>
      <param name="getAdjacent">현재 Node와 연결된 인접한 노드들을 찾아주는 함수</param>
      <returns>Breadth-Firth Algorithm으로 탐색한 노드들의 컬렉션</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.GraphDepthFirstScan``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
      <summary>
            Depth-First Scan for Adjacent Graph
            </summary>
      <typeparam name="T">탐색할 Node의 수형</typeparam>
      <param name="source">Graph의 시작 Point</param>
      <param name="getAdjacent">현재 Node와 연결된 인접한 노드들을 찾아주는 함수</param>
      <returns>Depth-Firth Algorithm으로 탐색한 노드들의 컬렉션</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.CountUnsafe(System.Collections.IEnumerable)">
      <summary>
            요소의 수를 계산한다.
            </summary>
      <param name="source">시퀀스</param>
      <returns>요소의 수</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.CountUnsafe(System.Collections.IEnumerator)">
      <summary>
            요소의 수를 계산한다.
            </summary>
      <param name="iterator">반복자</param>
      <returns>요소의 수</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.SingleUnsafe(System.Collections.IEnumerable)">
      <summary>
            지정된 collection에 유일하게 1개의 요소만 있는지 검사하고, 그 값을 반환한다.
            여러개의 요소가 있다면 예외를 발생시키고, 요소가 없다면 null을 반환시킨다.
            </summary>
      <param name="source">시퀀스</param>
      <returns>유일한 값, 없으면 null을 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ConvertUnsafe``1(System.Collections.IEnumerable)">
      <summary>
            sequence 를 지정된 수형으로 변환한 sequence로 만듭니다. 
            Nullable로 변환시에는 x=&gt;(double?)x 와 같은 expression을 넣어줘야 제대로 됩니다.
            </summary>
      <typeparam name="TResult">변환할 수형</typeparam>
      <param name="source">시퀀스</param>
      <returns>변환된 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ConvertUnsafe``1(System.Collections.IEnumerator)">
      <summary>
            sequence 를 지정된 수형으로 변환한 sequence로 만듭니다. 
            Nullable로 변환시에는 x=&gt;(double?)x 와 같은 expression을 넣어줘야 제대로 됩니다.
            </summary>
      <typeparam name="TResult">변환할 수형</typeparam>
      <param name="iterator">반복자</param>
      <returns>변환된 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ConvertUnsafe``1(System.Collections.IEnumerable,System.Func{System.Object,``0})">
      <summary>
            sequence 를 지정된 수형으로 변환한 sequence로 만듭니다. 
            Nullable로 변환시에는 x=&gt;(double?)x 와 같은 expression을 넣어줘야 제대로 됩니다.
            </summary>
      <typeparam name="TResult">변환할 수형</typeparam>
      <param name="source">시퀀스</param>
      <param name="converter">시퀀스 요소의 변환방식을 표현한 변환 메소드</param>
      <returns>변환된 시퀀스</returns>
      <example>
        <code>
            	int[] numbers = new int[] {1,2,3,4,5,6};
                var negatives = numbers.Convert&lt;int&gt;(x=&gt;-x);	 // 모두 음수로 변경
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ConvertUnsafe``1(System.Collections.IEnumerator,System.Func{System.Object,``0})">
      <summary>
            sequence 를 지정된 수형으로 변환한 sequence로 만듭니다. 
            Nullable로 변환시에는 x=&gt;(double?)x 와 같은 expression을 넣어줘야 제대로 됩니다.
            </summary>
      <typeparam name="TResult">변환할 수형</typeparam>
      <param name="iterator">반복자</param>
      <param name="converter">시퀀스 요소의 변환방식을 표현한 변환 메소드</param>
      <returns>변환된 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ToArrayUnsafe``1(System.Collections.IEnumerable)">
      <summary>
            지정된 시퀀스를 T 수형의 1차원 배열로 변환
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ToListUnsafe``1(System.Collections.IEnumerable)">
      <summary>
            시퀀스를 IList{T} 형식으로 변환한다.
            </summary>
      <typeparam name="T">변환될 시퀀스 요소의 수형</typeparam>
      <param name="source">시퀀스</param>
      <returns>T 수형의 요소를 가진 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.ToList``1(``0[])">
      <summary>
            items를 IList{T} 형식으로 변환한다.
            </summary>
      <typeparam name="T">변환될 시퀀스 요소의 수형</typeparam>
      <param name="source">시퀀스</param>
      <returns>T 수형의 요소를 가진 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            시퀀스에서 찾고자하는 요소의 첫번째 인덱스를 구한다.
            </summary>
      <typeparam name="T">Type of element to search</typeparam>
      <param name="source">sequence for search</param>
      <param name="searchItem">element to search</param>
      <returns>index of searched item, if not found element, return -1</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.IndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
        <paramref name="predicate" /> 조건에 만족하는 첫번째 요소의 인덱스를 반환합니다.
            </summary>
      <typeparam name="T">Type of element to search</typeparam>
      <param name="source">sequence for search</param>
      <param name="predicate">검색 조건</param>
      <returns>index of searched item, if not found element, return -1</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.LastIndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
      <summary>
            시퀀스에서 찾고자하는 요소의 마지막 인덱스를 구한다.
            </summary>
      <typeparam name="T">Type of element to search</typeparam>
      <param name="source">sequence for search</param>
      <param name="searchItem">element to search</param>
      <returns>index of searched item, if not found element, return -1</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.LastIndexOf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
      <summary>
            시퀀스에서 찾고자하는 요소의 마지막 인덱스를 구한다.
            </summary>
      <typeparam name="T">Type of element to search</typeparam>
      <param name="source">sequence for search</param>
      <param name="predicate">filtering function</param>
      <returns>index of searched item, if not found element, return -1</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Map``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
            TInput 수형의 시퀀스를 매핑 함수를 통해 TOutput 시퀀스로 변환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Reduce``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1,``0,``1})">
      <summary>
            입력 시퀀스를 도출 함수를 이용하여, 하나의 값을 만들어 냅니다. 집계, 합, 평균 등을 계산할 때 사용합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Reduce``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})">
      <summary>
            입력 시퀀스를 도출 함수를 이용하여, 하나의 값을 만들어 냅니다. 집계, 합, 평균 등을 계산할 때 사용합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.GetValueOrDefault``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}},``0)">
      <summary>
            nullable 수형의 시퀀스를 단순 수형의 시퀀스로 변환한다.
            </summary>
      <typeparam name="T">Nullable이 가능한 수형</typeparam>
      <param name="sequence">nullable 수형을 가진 시퀀스</param>
      <param name="defaultValue">요소의 값이 null일 경우 제공할 기본 값</param>
      <returns>nullable의 단순 수형의 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Paging``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
            시퀀스를 페이지 크기만큼의 요소로 Paging 처리를 수행합니다. TPL에서는 Partitioning 이라고도 합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="sequence">
      </param>
      <param name="pageSize">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.RunEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            지정된 시퀀스의 모든 요소에 대해 <paramref name="action" /> 을 수행합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="sequence">입력 시퀀스</param>
      <param name="action">실행할 함수</param>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.RunEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Action{``0})">
      <summary>
            지정된 시퀀스의 모든 요소에 대해 <paramref name="action" /> 을 수행하고, 중간마다 경계를 구분짓는 <paramref name="separatorAction" />을 수행합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="sequence">입력 시퀀스</param>
      <param name="action">실행할 메소드</param>
      <param name="separatorAction">구분을 위한 메소드 ("," 를 넣는 작업 등)</param>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.RunEachAsync``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
            지정된 시퀀스의 모든 요소에 대해 <paramref name="action" /> 을 비동기 방식으로 수행합니다.
            </summary>
      <typeparam name="T">입력 인자의 수형</typeparam>
      <param name="sequence">입력 시퀀스</param>
      <param name="action">실행할 메소드</param>
      <returns>실행 결과 값의 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.RunEachAsync``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
        <paramref name="sequence" /> 요소들을 <paramref name="func" /> 의 인자로 호출하고, 반환값들을 컬렉션으로 반환합니다.
            </summary>
      <typeparam name="T">입력 인자의 수형</typeparam>
      <typeparam name="TResult">함수 반환 수형</typeparam>
      <param name="sequence">입력 시퀀스</param>
      <param name="func">실행할 함수</param>
      <returns>실행 결과 값의 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Different``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            차집합 ( first - second )
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="first">
      </param>
      <param name="second">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Complement``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            여집합 ( (first-second) U (second-first) )
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="first">
      </param>
      <param name="second">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.In``1(``0,System.Collections.Generic.IEnumerable{``0})">
      <summary>
            value가 시퀀스의 요소로 존재하는지 판단한다.
            </summary>
      <typeparam name="T">요소의 수형</typeparam>
      <param name="value">검사할 요소</param>
      <param name="values">컬렉션</param>
      <returns>지정된 컬렉션에 요소가 존재한다면 True, 아니면 False를 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.In``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            시퀀스에 <paramref name="values" />에 있는 요소와 같은 값을 가지는 요소가 하나라도 있으면 true를 반환한다.
            </summary>
      <typeparam name="T">시퀀스 요소의 수형</typeparam>
      <param name="sequence">시퀀스</param>
      <param name="values">검사할 값들</param>
      <returns>시퀀스 요소중 검사할 값과 일치하는 것이 하나라도 있으면 True를 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.SequenceSuperset``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
      <summary>
            source 가 subset의 Sequencial한 superset인지 판단한다. (즉 요소의 순서 및 연속성도 같아야 한다)
            </summary>
      <remarks>See http://weblogs.asp.net/okloeten/archive/2008/04/22/6121373.aspx for more details.</remarks>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Step(System.Int32,System.Int32,System.Int32)">
      <summary>
        <paramref name="fromInclusive" /> ~ <paramref name="toExclusive" /> 범위의 값을 <paramref name="step" /> 단위로 열거합니다.
            </summary>
      <param name="fromInclusive">하한 값(포함)</param>
      <param name="toExclusive">상한 값(제외)</param>
      <param name="step">단계 (1 이상)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Step(System.Int64,System.Int64,System.Int64)">
      <summary>
        <paramref name="fromInclusive" /> ~ <paramref name="toExclusive" /> 범위의 값을 <paramref name="step" /> 단위로 열거합니다.
            </summary>
      <param name="fromInclusive">하한 값(포함)</param>
      <param name="toExclusive">상한 값(제외)</param>
      <param name="step">단계 (1 이상)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Step(System.Single,System.Single,System.Single)">
      <summary>
        <paramref name="fromInclusive" /> ~ <paramref name="toExclusive" /> 범위의 값을 <paramref name="step" /> 단위로 열거합니다.
            </summary>
      <param name="fromInclusive">하한 값(포함)</param>
      <param name="toExclusive">상한 값(제외)</param>
      <param name="step">단계 (1 이상)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Step(System.Double,System.Double,System.Double)">
      <summary>
        <paramref name="fromInclusive" /> ~ <paramref name="toExclusive" /> 범위의 값을 <paramref name="step" /> 단위로 열거합니다.
            </summary>
      <param name="fromInclusive">하한 값(포함)</param>
      <param name="toExclusive">상한 값(제외)</param>
      <param name="step">단계 (1 이상)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.Step(System.Decimal,System.Decimal,System.Decimal)">
      <summary>
        <paramref name="fromInclusive" /> ~ <paramref name="toExclusive" /> 범위의 값을 <paramref name="step" /> 단위로 열거합니다.
            </summary>
      <param name="fromInclusive">하한 값(포함)</param>
      <param name="toExclusive">상한 값(제외)</param>
      <param name="step">단계 (1 이상)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.AsJoinedText``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            시퀀스의 요소를 문자열로 표현하고, 그 문자열로 표현된 요소를 구분자로 결합하여 하나의 문자열로 만듭니다.
            </summary>
      <example>
        <code>
                int[] numbers = new int[] { 1,2,3,4,5 };
                var joinedText = numbers.AsJoinedText("|");  // joinedText is "1|2|3|4|5"
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.EnumerableTool.AsJoinedText``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.String)">
      <summary>
            시퀀스의 요소를 문자열로 표현하고, 그 문자열로 표현된 요소를 구분자로 결합하여 하나의 문자열로 만듭니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="sequence">시퀀스</param>
      <param name="toStringFunc">요소를 문자열로 표현하는 함수</param>
      <param name="delimiter">구분자</param>
      <returns>
      </returns>
      <example>
        <code>
                int[] numbers = new int[] { 1,2,3,4,5 };
                var joinedText = numbers.AsJoinedText("|");  // joinedText is "1|2|3|4|5"
            </code>
      </example>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.EnumerableTool.Node`1">
      <summary>
            A Node in the traversal.
            </summary>
      <typeparam name="T">Type of item in node.</typeparam>
    </member>
    <member name="P:NSoft.NFramework.LinqEx.EnumerableTool.Node`1.Level">
      <summary>
            Level
            </summary>
    </member>
    <member name="P:NSoft.NFramework.LinqEx.EnumerableTool.Node`1.Parent">
      <summary>
            Parent node.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.LinqEx.EnumerableTool.Node`1.Item">
      <summary>
            Item
            </summary>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.ExpandableQuery`1">
      <summary>
            An IQueryable wrapper that allows us to visit the query's expression tree just before LINQ to SQL gets to it.
            This is based on the excellent work of Tomas Petricek: http://tomasp.net/blog/linq-expand.aspx
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpandableQuery`1.GetEnumerator">
      <summary>
            Get enumerator
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpandableQuery`1.ToString">
      <summary>
            Return string represents object.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.ExpressionVisitor">
      <summary>
            This comes from Matt Warren's sample:
            http://blogs.msdn.com/mattwar/archive/2007/07/31/linq-building-an-iqueryable-provider-part-ii.aspx
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
      <summary>
            지정된 Expression의 종류에 따라 Visitor를 생성한다.
            </summary>
      <param name="exp">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitBinding(System.Linq.Expressions.MemberBinding)">
      <summary>
            Visit Binding
            </summary>
      <param name="binding">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitElementInitializer(System.Linq.Expressions.ElementInit)">
      <summary>
            Apply initializer to ElementInit
            </summary>
      <param name="initializer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
      <summary>
            Apply Visitor to UnaryExpression
            </summary>
      <param name="u">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
      <summary>
            Apply Visitor to BinaryExpression
            </summary>
      <param name="b">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitTypeIs(System.Linq.Expressions.TypeBinaryExpression)">
      <summary>
      </summary>
      <param name="b">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
      <summary>
      </summary>
      <param name="c">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
      <summary>
      </summary>
      <param name="c">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
      <summary>
      </summary>
      <param name="p">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitMemberAccess(System.Linq.Expressions.MemberExpression)">
      <summary>
      </summary>
      <param name="m">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
      <summary>
      </summary>
      <param name="m">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitExpressionList(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
      <summary>
      </summary>
      <param name="original">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
      <summary>
      </summary>
      <param name="assignment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
      <summary>
      </summary>
      <param name="binding">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
      <summary>
      </summary>
      <param name="binding">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitBindingList(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.MemberBinding})">
      <summary>
      </summary>
      <param name="original">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitElementInitializerList(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ElementInit})">
      <summary>
      </summary>
      <param name="original">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitLambda(System.Linq.Expressions.LambdaExpression)">
      <summary>
      </summary>
      <param name="lambda">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
      <summary>
      </summary>
      <param name="nex">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
      <summary>
      </summary>
      <param name="init">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
      <summary>
      </summary>
      <param name="init">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
      <summary>
      </summary>
      <param name="na">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
      <summary>
      </summary>
      <param name="iv">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.ExpressionTool">
      <summary>
            Refer to http://www.albahari.com/nutshell/linqkit.html and http://tomasp.net/blog/linq-expand.aspx for more information.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionTool.AsExpandable``1(System.Linq.IQueryable{``0})">
      <summary>
            지정된 IQueriable{T}를 확장이 가능하도록 변환한다. (decoration pattern을 이용하였음)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionTool.Expand``1(System.Linq.Expressions.Expression{``0})">
      <summary>
            Expand a specified expression.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionTool.Expand(System.Linq.Expressions.Expression)">
      <summary>
            Expand a specified expression.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionTool.Invoke``1(System.Linq.Expressions.Expression{System.Func{``0}})">
      <summary>
            Invoke a specified expression.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionTool.Invoke``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},``0)">
      <summary>
            Invoke a specified expression.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionTool.Invoke``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}},``0,``1)">
      <summary>
            Invoke a specified expression.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionTool.Invoke``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}},``0,``1,``2)">
      <summary>
            Invoke a specified expression.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.ExpressionTool.Invoke``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}},``0,``1,``2,``3)">
      <summary>
            Invoke a specified expression.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.IndexableAttribute">
      <summary>
            LINQ 의 검색시에 속도를 빠르게 하기 위해 인덱싱해야 할 속성에 지정한다.
            </summary>
      <remarks>
            http://www.codeplex.com/i4o
            </remarks>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.IndexableCollection`1">
      <summary>
            LINQ 사용시 시퀀스 조작 속도를 높히기 위해 사용하는 컬렉션
            </summary>
      <remarks>
            http://www.codeplex.com/i4o 를 참조할 것.
            속도를 더 높히기 위해 Refactoring을 수행했습니다.
            </remarks>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.IndexableCollection`1.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.IndexableCollection`1.#ctor(System.Collections.Generic.IList{`0})">
      <summary>
            생성자
            </summary>
      <param name="list">초기 요소</param>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.IndexableCollection`1.AddIndex(System.String)">
      <summary>
            동적으로 지정된 속성에 대해 인덱스를 생성한다.
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.IndexableCollection`1.RemoveIndex(System.String)">
      <summary>
            지정된 속성명의 인덱스를 제거합니다.
            </summary>
      <param name="propertyName">인덱스로 등록된 속성명</param>
      <returns>제거 여부. 속성명이 인덱스에 포함되어 있지 않다면 false를 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.IndexableCollection`1.PropertyHasIndex(System.String)">
      <summary>
            속성명이 인덱스로 등록되어 있는지 검사
            </summary>
      <param name="propertyName">검사할 인덱스 명</param>
      <returns>인덱스로 등록되었는지 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.IndexableCollection`1.GetIndexByProperty(System.String)">
      <summary>
            속성명에 따른 인덱스 정보 반환
            </summary>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.IndexableCollection`1.Add(`0)">
      <summary>
            요소 추가
            </summary>
      <param name="itemToAdd">추가할 요소</param>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.IndexableCollection`1.Remove(`0)">
      <summary>
            요소 제거
            </summary>
      <param name="itemToRemove">제거할 요소</param>
      <returns>제거 여부, 제거할 요소가 없으면 False</returns>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.IndexableCollection`1.IndexTable`1">
      <summary>
            Index Table
            </summary>
      <typeparam name="TEntity">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.IndexableCollectionExtension">
      <summary>
            인덱스를 가지는 컬렉션에 대한 확장 메소드를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.IndexableCollectionExtension.Join``4(NSoft.NFramework.LinqEx.IndexableCollection{``0},NSoft.NFramework.LinqEx.IndexableCollection{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>
            인덱싱된 시퀀스에서 일치하는 키를 기준으로 두 시퀀스의 요소를 연관시킵니다. 지정한 IEqualityComparer{TKey}를 사용하여 키를 비교합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.IndexableCollectionExtension.Join``4(NSoft.NFramework.LinqEx.IndexableCollection{``0},NSoft.NFramework.LinqEx.IndexableCollection{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Func{``0,``1,``3})">
      <summary>
            인덱싱된 시퀀스에서 일치하는 키를 기준으로 두 시퀀스의 요소를 연관시킵니다. 지정한 IEqualityComparer{TKey}를 사용하여 키를 비교합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.IndexableCollectionExtension.Where``1(NSoft.NFramework.LinqEx.IndexableCollection{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>
            시퀀스로부터, 조건에 맞는 요소만을 필터링을 수행합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <param name="sourceCollection">
      </param>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.LinqTool.DefaultPartitionCount">
      <summary>
            기본 PartitionCount (=10)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Add``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Numeric 수형의 두 시퀀스의 항목들을 순서대로 더하기(Add)를 수행합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="leftSequence">
      </param>
      <param name="rightSequence">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Subtract``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Numeric 수형의 두 시퀀스의 항목들을 순서대로 빼기(Subtract)를 수행합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="leftSequence">
      </param>
      <param name="rightSequence">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Multiply``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Numeric 수형의 두 시퀀스의 항목들을 순서대로 곱하기(Multiply)를 수행합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="leftSequence">
      </param>
      <param name="rightSequence">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Divide``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Numeric 수형의 두 시퀀스의 항목들을 순서대로 나누기(Divide)를 수행합니다. 단 0으로 나누면 <see cref="T:System.DivideByZeroException" />이 발생합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="leftSequence">
      </param>
      <param name="rightSequence">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Expr``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            지정된 Anonymous Method를 명확한 LambdaExpression으로 반환한다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="TResult">
      </typeparam>
      <param name="expr">
      </param>
      <returns>
      </returns>
      <example>
        <code>
                    // Addition function and expression
            		Func{int, int, int} func = (int a, int b) =&gt; a + b;
                    Expression{Func{int, int, int}} expr = (int a, int b) =&gt; a + b;
               
                    // 다음 코드는 애미하다
            		var func = (int a, int b) =&gt; a + b;
            
            		// 이를 명확하게 하기 위해 
                    var func = LinqTool.Func( (int a, int b) =&gt; a + b);	 // Function
                    var expr = LinqTool.Expr( (int a, int b) =&gt; a + b);  // Expression
            
            
            		// using anonymous types is possible
            		var func = LinqTool.Func( (int a, int b) =&gt; new { Sum = a+b, Mul = a*b } );
            		var func = LinqTool.Expr( (int a, int b) =&gt; new { Sum = a+b, Mul = a*b } );
            	</code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Func``2(System.Func{``0,``1})">
      <summary>
            지정된 Anonymous function을 명확한 Func{T, TResult} delegate로 반환한다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <typeparam name="TResult">
      </typeparam>
      <param name="expr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Evaluate(System.Linq.Expressions.Expression,System.Object[])">
      <summary>
        <paramref name="expression" />을 실행하여, Runtime 시의 값을 반환합니다.
            </summary>
      <param name="expression">실행할 Expression</param>
      <param name="args">실행 시 인자값</param>
      <returns>Expression을 동적으로 실행하여 얻은 값</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.FindMemberName(System.Linq.Expressions.Expression)">
      <summary>
        <paramref name="expression" />에서 속성명을 추출합니다.
            Retrieves the name of the property from a member expression
            NOTE: NHibernate.Impl.ExpressionProcessor 에 있는 것인데, NHibernate을 사용하지 않는 경우에도 사용하기 위해 업어옴
            </summary>
      <param name="expression">An expression tree that can contain either a member, or a conversion from a member.
            If the member is referenced from a null valued object, then the container is treated as an alias.</param>
      <returns>The name of the member property</returns>
      <example>
        <code>
            	Expression&lt;Func&lt;User,object&gt;&gt; expr = u=&gt;u.Name;
            	var propertyName = ExpressionUtil.FindMemberName( expr.Body );
                Assert.AreEqual("Name", propertyName);
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.FindPropertyName(System.Linq.Expressions.Expression)">
      <summary>
        <paramref name="expression" />에서 속성명을 추출합니다. (최종적인 속성명만을 추출합니다. 예: user.Company.Code ==&gt; "Code" )
            Retrieves the name of the property from a member expression (without leading member access)
            NOTE: NHibernate.Impl.ExpressionProcessor 에 있는 것인데, NHibernate을 사용하지 않는 경우에도 사용하기 위해 업어옴
            </summary>
      <example>
        <code>
            	Expression&lt;Func&lt;User,object&gt;&gt; expr = u=&gt;u.Company.Name;
            	var propertyName = ExpressionUtil.FindPropertyName( expr.Body );
                Assert.AreEqual("Name", propertyName);
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Generate``1(System.Int32,System.Func{``0})">
      <summary>
        <paramref name="count" /> 수만큼 <paramref name="generator" />를 호출하여 결과값을 열거합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="count">
      </param>
      <param name="generator">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.OrderedElementAt(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
      <summary>
            시퀀스를 졍렬했을 때, <paramref name="order" />순서에 해당하는 값을 반환합니다.
            </summary>
      <param name="source">시퀀스</param>
      <param name="order">순서 (1..N)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.OrderedElementAtOrDefault(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
      <summary>
            시퀀스를 졍렬했을 때, <paramref name="order" />순서에 해당하는 값을 반환합니다.
            </summary>
      <param name="source">시퀀스</param>
      <param name="order">순서 (1..N)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.OrderedElementAt``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Double},System.Int32)">
      <summary>
            시퀀스를 졍렬했을 때, <paramref name="order" />순서에 해당하는 값을 반환합니다.
            </summary>
      <param name="source">시퀀스</param>
      <param name="orderer">시퀀스 정렬 방식</param>
      <param name="selector">변량중 정렬 및 선택할 요소 선택자</param>
      <param name="order">순서 (1..N)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.OrderedElementAtOrDefault``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Double},System.Int32)">
      <summary>
            시퀀스를 졍렬했을 때, <paramref name="order" />순서에 해당하는 값을 반환합니다.
            </summary>
      <param name="source">시퀀스</param>
      <param name="orderer">시퀀스 정렬 방식</param>
      <param name="selector">변량중 정렬 및 선택할 요소 선택자</param>
      <param name="order">순서 (1..N)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Range``1(``0,``0,``0)">
      <summary>
        <paramref name="fromInclusive" /> ~ <paramref name="toExclusive" /> 구간을 <paramref name="step" /> 간격으로 나열합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="fromInclusive">하한값</param>
      <param name="toExclusive">상한값</param>
      <param name="step">단계</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Repeat``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
        <paramref name="source" /> 시퀀스를 <paramref name="times" /> 만큼 반복해서 열거합니다.
            </summary>
      <typeparam name="T">항목 수형</typeparam>
      <param name="source">시퀀스</param>
      <param name="times">반복 횟수</param>
      <returns>반복된 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.RotateLeft``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
        <paramref name="source" />를 열거할 때, <paramref name="offset" />만큼 왼쪽으로 Shift 해서 열거합니다. 즉 <paramref name="offset" /> 만큼 건너뛰고, 열거하고, 나머지를 열거합니다.
            </summary>
      <typeparam name="T">요소 수형</typeparam>
      <param name="source">원본 시퀀스</param>
      <param name="offset">Rotate할 양</param>
      <returns>
      </returns>
      <example>
        <code>
            	new[] {1,2,3,4,5}.RotateLeft(2); // =&gt; { 3,4,5,1,2} 
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.RotateRight``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
        <paramref name="source" />를 열거할 때, <paramref name="offset" />만큼 오른쪽으로 Shift 해서 열거합니다. 즉 <paramref name="offset" /> 만큼 건너뛰고, 열거하고, 나머지를 열거합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">
      </param>
      <param name="offset">
      </param>
      <returns>
      </returns>
      <example>
        <code>
            	new[] {1,2,3,4,5}.RotateRight(2); // =&gt; { 4,5,1,2,3 } 
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.AsNorm(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            Norm ( 요소의 제곱의 합 )을 구한다. (벡터의 길이, 차원의 가장 짧은 거리)
            </summary>
      <param name="source">변량의 시퀀스</param>
      <returns>Norm</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.AsNormalize(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            지정된 시퀀스를 Normalize 한다. norm[i] = item[i] / sum(items) 이다.
            </summary>
      <param name="source">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.AsStDev(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            변량들의 표준편차를 구한다.
            </summary>
      <param name="source">변량 시퀀스</param>
      <returns>표준편차</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.AsVariance(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            시퀀스의 분산값을 구한다
            </summary>
      <param name="source">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.AsRootMeanSquare(System.Collections.Generic.IEnumerable{System.Double})">
      <summary>
            제곱 평균 (root-mean-square) - 표준편차와 같은 값이다.
            참고: http://en.wikipedia.org/wiki/Root_mean_square
            </summary>
      <param name="source">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.AsRootMeanSquare(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
      <summary>
            제곱 평균 (root-mean-square) - 표준편차와 같은 값이다.
            참고: http://en.wikipedia.org/wiki/Root_mean_square
            </summary>
      <param name="source">
      </param>
      <returns>
      </returns>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.LinqTool.DefaultPartitioningArray">
      <summary>
            기본 Paritioning Data
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Partitioning(NSoft.NFramework.LinqEx.PartitioningMethod,System.Int32,System.Double)">
      <summary>
            분할 방법에 따라 총액(<paramref name="totalAmount" />)을 분할 갯수(<paramref name="partitionCount" />)만큼 분할합니다.
            </summary>
      <param name="method">
      </param>
      <param name="partitionCount">
      </param>
      <param name="totalAmount">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Pipeline``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
        <paramref name="source" />의 항목들을 <paramref name="action" />의 인자로 전달하여 수행하고, 항목을 다시 열거합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">
      </param>
      <param name="action">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Pipeline``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
        <paramref name="source" />의 항목들을 <paramref name="func" />의 인자로 전달하여 수행하고, 결과를 열거합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">
      </typeparam>
      <param name="source">
      </param>
      <param name="func">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Select``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
      <summary>
            원본 Task (<paramref name="source" />) 결과를 <paramref name="selector" />를 이용하여 변환한 값을 반환하는 Task를 제공합니다.
            <paramref name="source" />작업이 취소되지 않아야 작업을 수행합니다.
            </summary>
      <param name="source">원본 작업</param>
      <param name="selector">원본 작업 결과를 변환하는 함수</param>
      <returns>원본 작업 후, 작업결과를 변환하여 반환하는 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.SelectMany``2(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
      <summary>
            원본 Task (<paramref name="source" />) 결과를 변환하는 <paramref name="selector" />를 수행하여, <typeparamref name="TResult" /> 수형을 결과값으로 반환하는 Task를 빌드합니다.
            </summary>
      <param name="source">원본 작업</param>
      <param name="selector">원본 작업 결과를 비동기적으로 변환하는 작업을 반환하는 함수 </param>
      <returns>원본 작업이 완료 후 결과를 <paramref name="selector" />에 의해 변환된 결과물을 반환하는 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.SelectMany``3(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task{``1}},System.Func{``0,``1,``2})">
      <summary>
            원본 Task (<paramref name="source" />) 실행 결과를, 
            <paramref name="collectionSelector" /> 함수를 통해, Task{TCollection} 형태로 만들고, 
            <paramref name="resultSelector" /> 함수를 이용해서, 최종 결과 값을 빌드합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Where``1(System.Threading.Tasks.Task{``0},System.Func{``0,System.Boolean})">
      <summary>
        <paramref name="source" /> 작업 결과가 <paramref name="predicate" />에 만족하는 Task만 필터링합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <param name="source">
      </param>
      <param name="predicate">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.Join``4(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>
            Join
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.GroupJoin``4(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Threading.Tasks.Task{``1},``3},System.Collections.Generic.IEqualityComparer{``2})">
      <summary>
            Group Join
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.GroupBy``3(System.Threading.Tasks.Task{``0},System.Func{``0,``1},System.Func{``0,``2})">
      <summary>
            시퀀스를 지정한 키를 기준으로 그룹핑합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.OrderBy``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
      <summary>
            정렬
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TKey">
      </typeparam>
      <param name="source">
      </param>
      <param name="keySelector">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.OrderByDescending``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
      <summary>
            역순 정렬
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.ThenBy``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
      <summary>
            다음 정렬
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.LinqTool.ThenByDescending``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
      <summary>
            역순 정렬
            </summary>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.LinqTool.Operators`1">
      <summary>
            Lambda Expression을 이용하여, 사칙연산등을 수행하는 함수를 제공합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.PartitioningMethod">
      <summary>
            특정 값을 배분하는 방식
            </summary>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.PartitioningMethod.HorizontaolUniform">
      <summary>
            수평균등
            </summary>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.PartitioningMethod.VerticalBegin">
      <summary>
            수직 전반 부하
            </summary>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.PartitioningMethod.VerticalEnd">
      <summary>
            수직 후반 부하
            </summary>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.PartitioningMethod.TriangleBegin">
      <summary>
            삼각 전반 부하
            </summary>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.PartitioningMethod.TriangleMiddle">
      <summary>
            삼각 중반 부하
            </summary>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.PartitioningMethod.TriangleEnd">
      <summary>
            삼각 후반 부하
            </summary>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.PartitioningMethod.TwoStepBegin">
      <summary>
            2단계 전반 부하
            </summary>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.PartitioningMethod.TwoStepEnd">
      <summary>
            2단계 후반부하
            </summary>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.PartitioningMethod.TrapezoidMiddle">
      <summary>
            사다리 중반 부하
            </summary>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.PartitioningMethod.Normal">
      <summary>
            종형 중반 부하 (정규분포 - NormalDistribution)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.PartitioningMethod.ThreeMiddle">
      <summary>
            3단 중반 부하
            </summary>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.PivotBuilder">
      <summary>
            Pivot Table을 빌드합니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.LinqEx.PivotBuilder.AggregateFunctionNames">
      <summary>
            제공되는 집계함수들입니다. ("AbsAvg", "AbsMax", "AbsMin", "AbsSum", "Avg", "Count", "LongCount", "Max", "Min", "Norm", "RootMeanSquare", "StDev", "Sum", "Variance")
            </summary>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.PivotBuilder.BuildPivotTable``3(System.Collections.Generic.IEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Func{``2,``1,``2},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            지정한 시퀀스 정보로부터, Pivot Table형식의 통계 정보를 추출하도록 합니다.
            </summary>
      <typeparam name="T">원본 정보의 형식</typeparam>
      <typeparam name="TValue">원본 정보 중의 Pivot Table의 값으로 계산하기 위한 대상 컬럼의 수형</typeparam>
      <typeparam name="TResult">Pivot Table의 값의 Aggregate된 결과 값의 형식(SUM, COUNT 등은 컬럼 수형과는 다릅니다)</typeparam>
      <param name="sequence">데이타 시퀀스</param>
      <param name="rowExpr">행을 표현할 속성을 지정하는 Expression (ex. item=&gt;item.EmployeeId)</param>
      <param name="colExpr">컬럼을 표현할 속성을 지정하는 Expression (ex. item=&gt;item.OrderYear)</param>
      <param name="aggregateFunc">PIVOT의 값에 표현할 집계함수 (ex. 합:(s, n)=&gt;s+n, Count:(s, n)=&gt; s+1 )</param>
      <param name="valueExpr">집계를 위한 값을 나타내는 Expression (ex. item=&gt;item.Price)</param>
      <returns>Pivoting된 정보를 담은 DataTable</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.PivotBuilder.BuildPivotTable``3(System.Collections.Generic.IEnumerable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
      <summary>
            지정한 시퀀스 정보로부터, Pivot Table형식의 통계 정보를 추출하도록 합니다.
            </summary>
      <typeparam name="T">원본 정보의 형식</typeparam>
      <typeparam name="TValue">원본 정보 중의 Pivot Table의 값으로 계산하기 위한 대상 컬럼의 수형</typeparam>
      <typeparam name="TResult">Pivot Table의 값의 Aggregate된 결과 값의 형식(SUM, COUNT 등은 컬럼 수형과는 다릅니다)</typeparam>
      <param name="sequence">데이타 시퀀스</param>
      <param name="rowExpr">행을 표현할 속성을 지정하는 Expression (ex. item=&gt;item.EmployeeId)</param>
      <param name="colExpr">컬럼을 표현할 속성을 지정하는 Expression (ex. item=&gt;item.OrderYear)</param>
      <param name="aggregateFuncName">PIVOT의 값에 표현할 집계함수명 (AbsAvg, AbsMax, AbsMin, AbsSum, Avg, Count, LongCount, Max, Min, Norm, RootMeanSquare, StDev, Sum, Variance) </param>
      <param name="valueExpr">집계를 위한 값을 나타내는 Expression (ex. item=&gt;item.Price)</param>
      <returns>Pivoting된 정보를 담은 DataTable</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.PivotBuilder.BuildPivotTable``3(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.String,System.String)">
      <summary>
            지정한 시퀀스 정보로부터, Pivot Table형식의 통계 정보를 추출하도록 합니다.
            </summary>
      <typeparam name="T">원본 정보의 형식</typeparam>
      <typeparam name="TValue">원본 정보 중의 Pivot Table의 값으로 계산하기 위한 대상 컬럼의 수형</typeparam>
      <typeparam name="TResult">Pivot Table의 값의 Aggregate된 결과 값의 형식(SUM, COUNT 등은 컬럼 수형과는 다릅니다)</typeparam>
      <param name="sequence">데이타 시퀀스</param>
      <param name="rowPropertyName">행을 표현할 속성명(ex. "EmployeeId")</param>
      <param name="colPropertyName">컬럼을 표현할 속성명(ex. "OrderYear")</param>
      <param name="aggregateFuncName">PIVOT의 값에 표현할 집계함수명 (AbsAvg, AbsMax, AbsMin, AbsSum, Avg, Count, LongCount, Max, Min, Norm, RootMeanSquare, StDev, Sum, Variance) </param>
      <param name="valuePropertyName">집계를 위한 값을 나타내는 Expression (ex. item=&gt;item.Price)</param>
      <returns>Pivoting된 정보를 담은 DataTable</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.PivotBuilder.BuildPivotTable``3(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.Func{``2,``1,``2},System.String)">
      <summary>
            지정한 시퀀스 정보로부터, Pivot Table형식의 통계 정보를 추출하도록 합니다.
            </summary>
      <typeparam name="T">원본 정보의 형식</typeparam>
      <typeparam name="TValue">원본 정보 중의 Pivot Table의 값으로 계산하기 위한 대상 컬럼의 수형</typeparam>
      <typeparam name="TResult">Pivot Table의 값의 Aggregate된 결과 값의 형식(SUM, COUNT 등은 컬럼 수형과는 다릅니다)</typeparam>
      <param name="sequence">데이타 시퀀스</param>
      <param name="rowPropertyName">행을 표현할 속성명(ex. "EmployeeId")</param>
      <param name="colPropertyName">컬럼을 표현할 속성명(ex. "OrderYear")</param>
      <param name="aggregateFunc">PIVOT의 값에 표현할 집계함수 (ex. 합:(s, n)=&gt;s+n, Count:(s, n)=&gt; s+1 )</param>
      <param name="valuePropertyName">집계를 위한 값을 나타내는 Expression (ex. item=&gt;item.Price)</param>
      <returns>Pivoting된 정보를 담은 DataTable</returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.PivotBuilder.AggregateValues``2(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            지정된 시퀀스에 대해 집계함수를 수행합니다.<br />
            지원하는 집계함수 : <see cref="F:NSoft.NFramework.LinqEx.PivotBuilder.AggregateFunctionNames" /> (AbsAvg, AbsMax, AbsMin, AbsSum, Avg, Count, LongCount, Max, Min, Norm, RootMeanSquare, StDev, Sum, Variance)
            </summary>
      <typeparam name="TValue">
      </typeparam>
      <typeparam name="TResult">
      </typeparam>
      <param name="sequence">
      </param>
      <param name="aggregateFunctionName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.PivotBuilder.AsText(System.Data.DataTable,System.String,System.Boolean)">
      <summary>
            지정한 DataTable의 내용을 문자열로 만듭니다
            </summary>
      <param name="dataTable">문자열로 표현할 데이타 테이블</param>
      <param name="columnDelimiter">컬럼간의 구분 값(",")</param>
      <param name="includeHeader">컬럼 헤더 정보를 포함할 것인자</param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.LinqEx.PredicateBuilder">
      <summary>
            복수의 Predicate용 Expression을 만드는 Predicate 빌더이다. NHibernate의 DetachedCriteria와 유사
            사용할 때 반환받은 Expression을 Compile을 하면 Func{T, bool} 의 predicate 가 만들어진다.
            </summary>
      <remarks>
            참고 및 예제는 http://www.albahari.com/nutshell/predicatebuilder.html 
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.PredicateBuilder.True``1">
      <summary>
            항상 True를 반환하는 Predicate
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.PredicateBuilder.False``1">
      <summary>
            항상 False를 반환하는 Predicate
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.PredicateBuilder.Or``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>
            두 expression의 OR 연산을 하는 Predicate를 빌드한다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="expr1">
      </param>
      <param name="expr2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.LinqEx.PredicateBuilder.And``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
      <summary>
            두 expression의 AND 연산을 하는 Predicate를 빌드한다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="expr1">
      </param>
      <param name="expr2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Networks.FtpAsync">
      <summary>
            FTP 통신을 비동기 방식으로 수행하도록 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.SendRequestOnlyTask(NSoft.NFramework.Networks.FtpClient,System.String,System.String)">
      <summary>
            요청만을 보냅니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="uri">
      </param>
      <param name="method">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.GetRequestStreamTask(NSoft.NFramework.Networks.FtpClient,System.String,System.String)">
      <summary>
            비동기 방식으로 요청 스트림을 구합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="uri">
      </param>
      <param name="method">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.GetResponseTask(NSoft.NFramework.Networks.FtpClient,System.String,System.String)">
      <summary>
        <paramref name="ftpClient" />를 이용하여 비동기 방식으로 웹 응답을 받습니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="uri">
      </param>
      <param name="method">
      </param>
      <returns>
      </returns>
      <example>
        <code>
            	// 특정 파일을 FTP 서버에서 다운로드 받습니다.
            	var responseTask = ftpClient.GetResponseTask(uri, WebRequestMethods.Ftp.DownloadFile);
            	var stream = ((FtpWebResponse)responseTask.Result).GetResponseStream();
            </code>
      </example>
      <seealso cref="M:NSoft.NFramework.Networks.FtpAsync.GetResponseStreamTask(NSoft.NFramework.Networks.FtpClient,System.String,System.String)" />
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.GetResponseTask(NSoft.NFramework.Networks.FtpClient,System.Net.FtpWebRequest)">
      <summary>
        <paramref name="ftpClient" />를 이용하여 비동기 방식으로 웹 응답을 받습니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="request">Ftp 웹 요청 객체</param>
      <returns>
      </returns>
      <example>
        <code>
            	// 특정 파일을 FTP 서버에서 다운로드 받습니다.
            	var responseTask = ftpClient.GetResponseTask(uri, WebRequestMethods.Ftp.DownloadFile);
            	var stream = ((FtpWebResponse)responseTask.Result).GetResponseStream();
            </code>
      </example>
      <seealso cref="M:NSoft.NFramework.Networks.FtpAsync.GetResponseStreamTask(NSoft.NFramework.Networks.FtpClient,System.String,System.String)" />
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.GetResponseStreamTask(NSoft.NFramework.Networks.FtpClient,System.String,System.String)">
      <summary>
            비동기 방식으로 웹 응답을 받고, 그 응답의 스트림을 반환합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="uri">
      </param>
      <param name="method">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.GetResponseStringTask(NSoft.NFramework.Networks.FtpClient,System.String,System.String)">
      <summary>
            응답 스트림을 얻고, 문자열로 변환하여 반환합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="uri">
      </param>
      <param name="method">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.DirectoryExistsTask(NSoft.NFramework.Networks.FtpClient,System.String)">
      <summary>
            FTP 서버에 <paramref name="directory" /> 가 존재하는지 확인합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="directory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.DeleteFileTask(NSoft.NFramework.Networks.FtpClient,System.String)">
      <summary>
            원격 파일을 비동기 방식으로 삭제합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="remoteFilename">삭제할 파일명</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.FileExistsTask(NSoft.NFramework.Networks.FtpClient,System.String)">
      <summary>
            원격 파일이 존재하는지 확인합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="remoteFilename">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.GetFileSizeTask(NSoft.NFramework.Networks.FtpClient,System.String)">
      <summary>
            원격 파일의 크기를 조회합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="remoteFilename">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.RenameFileTask(NSoft.NFramework.Networks.FtpClient,System.String,System.String)">
      <summary>
            FTP 서버의 원격 파일명을 변경합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="srcFilename">
      </param>
      <param name="destFilename">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.DownloadTask(NSoft.NFramework.Networks.FtpClient,System.String,System.String,System.Boolean)">
      <summary>
            FTP 서버의 원격 파일을 로컬로 비동기 방식으로 다운로드 받습니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.DownloadTask(NSoft.NFramework.Networks.FtpClient,System.String,System.IO.FileInfo)">
      <summary>
            FTP 서버의 원격 파일을 로컬로 비동기 방식으로 다운로드 받습니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.DownloadTask(NSoft.NFramework.Networks.FtpClient,System.String,System.IO.Stream)">
      <summary>
            FTP 서버에 있는 원격 파일을 다운로드하여, <paramref name="localStream" />에 씁니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="remoteFilename">
      </param>
      <param name="localStream">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.UploadTask(NSoft.NFramework.Networks.FtpClient,System.String,System.String)">
      <summary>
        <paramref name="ftpClient" />를 이용하여, 로컬 파일 스트림을 FTP 서버로 Upload 합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="localFilename">로컬 파일 경로</param>
      <param name="remoteFilename">원격 파일 경로</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.UploadTask(NSoft.NFramework.Networks.FtpClient,System.IO.FileInfo,System.String)">
      <summary>
        <paramref name="ftpClient" />를 이용하여, 로컬 파일 스트림을 FTP 서버로 Upload 합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="localFi">
      </param>
      <param name="remoteFilename">원격 파일 경로</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.UploadTask(NSoft.NFramework.Networks.FtpClient,System.IO.Stream,System.String)">
      <summary>
        <paramref name="ftpClient" />를 이용하여, 로컬 파일 스트림을 FTP 서버로 Upload 합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="localStream">
      </param>
      <param name="remoteFilename">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.CreateDirectoryTask(NSoft.NFramework.Networks.FtpClient,System.String)">
      <summary>
            FTP 서버에 디렉토리를 비동기 방식으로 생성합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="remoteDir">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.DeleteDirectoryTask(NSoft.NFramework.Networks.FtpClient,System.String)">
      <summary>
            FTP 서버에 디렉토리를 비동기 방식으로 삭제합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="remoteDir">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.DeleteDirectoryTask(NSoft.NFramework.Networks.FtpClient,System.String,System.Boolean)">
      <summary>
            FTP 서버의 지정한 디렉토리를 삭제합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="remoteDir">
      </param>
      <param name="recursive">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.ListDirectoryTask(NSoft.NFramework.Networks.FtpClient)">
      <summary>
            FTP 서버의 디렉토리를 열거합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.ListDirectoryTask(NSoft.NFramework.Networks.FtpClient,System.String)">
      <summary>
            FTP 서버의 <paramref name="directory" />의 하위 디렉토리 및 파일명을 열거합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="directory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.ListDirectoryTask(NSoft.NFramework.Networks.FtpClient,System.String,System.Boolean)">
      <summary>
            FTP 서버의 <paramref name="directory" />의 하위 디렉토리 및 파일명을 열거합니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="directory">
      </param>
      <param name="recursive">재귀 호출 여부</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpAsync.ListDirectoryDetailTask(NSoft.NFramework.Networks.FtpClient,System.String)">
      <summary>
            FTP 서버의 <paramref name="directory" />의 상세 정보를 가져옵니다.
            </summary>
      <param name="ftpClient">
      </param>
      <param name="directory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Networks.FtpClient">
      <summary>
            .NET 2.0 FtpWebRequest, FtpWebResponse를 이용한 FTP Client Class
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.FtpClient.FTP_PATH_DELIMITER">
      <summary>
            Path delimiter used in FTP Protocol
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.FtpClient.FTP_SCHEMA">
      <summary>
            URI Schema for Ftp protocol 
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.FtpClient.FTP_LOCALHOST">
      <summary>
            localhost
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.FtpClient.DEFAULT_USERNAME">
      <summary>
            default ftp login user name (anonymous)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.FtpClient.DEFAULT_PASSWORD">
      <summary>
            default ftp login password
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.FtpClient.FTP_FILE_BUFFER">
      <summary>
            file buffer used in transfer file stream.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.#ctor">
      <summary>
            Initialize a new instance of NSoft.NFramework.Networks.Ftp.FtpClient class.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.#ctor(System.String,System.String,System.String)">
      <summary>
            Initialize a new instance of NSoft.NFramework.Networks.Ftp.FtpClient class with ftp host name and login account information.
            </summary>
      <param name="hostname">ftp server host name</param>
      <param name="username">login username</param>
      <param name="password">login password</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.DirectoryExists(System.String)">
      <summary>
            서버의 모든 디렉토리를 찾는다.
            </summary>
      <param name="directory">검색할 디렉토리 (예 : "/Users/Debop")</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.ListDirectory">
      <summary>
            현재 디렉토리의 서브 디렉토리 이름만 가져온다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.ListDirectory(System.String)">
      <summary>
            지정한 디렉토리의 서브 디렉토리 이름만 가져온다.
            </summary>
      <param name="directory">UNIX 스타일의 경로</param>
      <returns>없으면 길이가 0인 배열을 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.ListDirectory(System.String,System.Collections.Generic.List{System.String},System.Boolean)">
      <summary>
            하위 폴더도 포함하여 디렉토리 목록을 빌드하여 <paramref name="paths" />에 추가한다.
            </summary>
      <param name="directory">
      </param>
      <param name="paths">
      </param>
      <param name="recursive">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.ListDirectoryDetail">
      <summary>
            현재 디렉토리의 서브 디렉토리의 정보를 가져온다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.ListDirectoryDetail(System.String)">
      <summary>
            지정한 디렉토리의 서브 디렉토리의 정보를 가져온다.
            </summary>
      <param name="directory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.Upload(System.String)">
      <summary>
            지정된 로칼 파일을 FTP의 현재 디렉토리에 같은 파일명으로 전송한다.
            </summary>
      <param name="localFilename">file to upload</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.Upload(System.String,System.String)">
      <summary>
            지정된 로칼 파일을 FTP 서버에 지정된 파일명으로 저장한다.
            </summary>
      <param name="localFilename">
      </param>
      <param name="remoteFilename">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.Upload(System.IO.FileInfo)">
      <summary>
            지정된 로칼 파일을 FTP의 현재 디렉토리에 같은 파일명으로 전송한다.
            </summary>
      <param name="fi">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.Upload(System.IO.FileInfo,System.String)">
      <summary>
            지정된 로칼 파일을 FTP 서버에 지정된 파일명으로 저장한다.
            </summary>
      <param name="fi">
      </param>
      <param name="remoteFilename">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.Upload(System.IO.Stream,System.String)">
      <summary>
            지정된 스트림 정보를 FTP서버에 지정된 파일명으로 저장한다.
            </summary>
      <param name="localStream">
      </param>
      <param name="remoteFilename">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.Download(System.String,System.String,System.Boolean)">
      <summary>
            원격 파일을 다운 받아 로칼 파일로 저장한다.
            </summary>
      <param name="remoteFilename">원격 파일 전체 경로 (예: /Users/debop/readme.txt)</param>
      <param name="localFilename">로칼 파일 전체 경로</param>
      <param name="canOverwrite">겹쳐쓰기 여부</param>
      <returns>다운로드 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.Download(NSoft.NFramework.Networks.FtpFileInfo,System.String,System.Boolean)">
      <summary>
            FTP 원격파일을 다운로드 받는다.
            </summary>
      <param name="remoteFI">원격 파일 정보</param>
      <param name="localFilename">로칼 파일 전체 경로</param>
      <param name="canOverwrite">겹쳐쓰기 여부</param>
      <returns>다운로드 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.Download(NSoft.NFramework.Networks.FtpFileInfo,System.IO.FileInfo,System.Boolean)">
      <summary>
      </summary>
      <param name="remoteFI">원격 파일 정보</param>
      <param name="localFI">로칼 파일 정보</param>
      <param name="canOverwrite">겹쳐쓰기 여부</param>
      <returns>다운로드 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.Download(System.String,System.IO.FileInfo,System.Boolean)">
      <summary>
            FTP 원격 파일을 지정한 로칼 파일로 저장한다.
            </summary>
      <param name="remoteFilename">원격 파일 전체 경로 (예: /Users/debop/readme.txt)</param>
      <param name="localFI">로칼 파일 정보</param>
      <param name="canOverwrite">겹쳐쓰기 여부</param>
      <returns>다운로드 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.Download(System.String,System.IO.Stream)">
      <summary>
            원격 파일을 다운받아 지정된 스트림에 쓴다.
            </summary>
      <param name="remoteFilename">원격 파일 전체 경로 (예: /Users/debop/readme.txt)</param>
      <param name="localStream">원격파일 정보를 저장할 Stream 객체</param>
      <returns>다운로드 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.DeleteFile(System.String)">
      <summary>
            FTP 서버에 있는 파일을 삭제한다.
            </summary>
      <param name="remoteFilename">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.FileExists(System.String)">
      <summary>
            FTP 서버에 지정된 파일이 있는지 검사한다.
            </summary>
      <param name="remoteFilename">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.GetFileSize(System.String)">
      <summary>
            지정된 원격 파일의 크기를 가져온다.
            </summary>
      <param name="remoteFilename">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.RenameFile(System.String,System.String)">
      <summary>
            FTP 서버에 있는 파일명을 변경합니다.
            NOTE: .NET 4.0에서는 버그가 있습니다.
            http://stackoverflow.com/questions/4159903/problem-renaming-file-on-ftp-server-in-net-framework-4-0-only/5897531#5897531
            </summary>
      <param name="srcFilename">원본 파일명</param>
      <param name="destFilename">변경할 파일명</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.CreateDirectory(System.String)">
      <summary>
            지정된 경로를 생성한다. (다중 폴더도 생성합니다. 예 : "/사용자/배성혁/개발 자료" )
            </summary>
      <param name="remoteDir">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.DeleteDirectory(System.String)">
      <summary>
            지정된 FTP 경로의 Dirctory를 제거한다.
            </summary>
      <param name="remoteDir">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.DeleteDirectory(System.String,System.Boolean)">
      <summary>
            지정된 FTP 경로 및 하위 디렉토리도 모두 제거한다.
            </summary>
      <param name="remoteDir">remote directory name to delete</param>
      <param name="recursive">delete sub directories with recursive.</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpClient.ExtractPath(System.String)">
      <summary>
            FTP 파일 전체경로에서 파일이름 부분을 뺀 경로만 가져온다.
            </summary>
      <param name="remoteFilename">FTP 서버의 파일 경로</param>
      <returns>path that extracted filename.</returns>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpClient.CurrentDirectory">
      <summary>
            FTP 서버의 현재 디렉토리
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpClient.Hostname">
      <summary>
            URI 형식의 FTP 서버 주소 (예: ftp://localhost )
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpClient.Username">
      <summary>
            FTP 로그인 ID
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpClient.Password">
      <summary>
            FTP 로그인 비밀번호
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpClient.KeepAlive">
      <summary>
            연결을 유지할 것인가 
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Networks.FtpDirectory">
      <summary>
            FTP의 Directory 에 대한 표현 및 관련 작업
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.FtpDirectory.DirectorySeparator">
      <summary>
            Ftp Directory 구분자 ('/')
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpDirectory.#ctor">
      <summary>
            기본생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpDirectory.#ctor(System.String,System.String)">
      <summary>
            Initialize a new instance of FtpDirectory with directory name and remote path
            </summary>
      <param name="dir">directory name</param>
      <param name="path">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpDirectory.FileExists(System.String)">
      <summary>
            현 디렉토리에 지정한 파일 정보가 있는지 검사한다.
            </summary>
      <param name="filename">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpDirectory.GetDirectories">
      <summary>
            현 디렉토리의 서브 디렉토리 목록을 가져온다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpDirectory.GetDirectories(System.String)">
      <summary>
            현 디렉토리의 서브 디렉토리 목록을 가져온다.
            </summary>
      <param name="extension">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpDirectory.GetFiles(System.String)">
      <summary>
            현 디렉토리의 파일 목록
            </summary>
      <param name="extension">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpDirectory.GetParentDirectory(System.String)">
      <summary>
            지정된 디렉토리의 상위 디렉토리를 반환한다.
            </summary>
      <param name="dir">기준이 되는 디렉토리</param>
      <returns>상위 디렉토리가 없다면 null을 반환한다.</returns>
    </member>
    <member name="T:NSoft.NFramework.Networks.FtpEntryKind">
      <summary>
            FTP 엔트리의 종류
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.FtpEntryKind.File">
      <summary>
            File
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.FtpEntryKind.Directory">
      <summary>
            Directory
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Networks.FtpException">
      <summary>
            The exception that is thrown when ftp operation error occurs.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Networks.NetworkException">
      <summary>
            The exception that is thrown when network operation error occurs.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.NetworkException.#ctor">
      <summary>
             Initializes a new instance of the NSoft.NFramework.Networks.NetworkException class 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.NetworkException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the NSoft.NFramework.Networks.NetworkException class with a specified error message.
            </summary>
      <param name="message">error message</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.NetworkException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the NSoft.NFramework.Networks.NetworkException class with a specified error message 
            and a reference to the inner exception that is the cause of this exception
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">
            The exception that is the cause of the current exception. 
            If the innerException parameter is not a null reference, 
            the current exception is raised in a catch block that handles the inner exception.
            </param>
    </member>
    <member name="M:NSoft.NFramework.Networks.NetworkException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the  NSoft.NFramework.Networks.NetworkException class with serialized data.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpException.#ctor">
      <summary>
             Initializes a new instance of the NSoft.NFramework.Networks.Ftp.FtpException class 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the NSoft.NFramework.Networks.Ftp.FtpException class with a specified error message.
            </summary>
      <param name="message">error message</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the NSoft.NFramework.Networks.Ftp.FtpException class with a specified error message 
            and a reference to the inner exception that is the cause of this exception
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">
            The exception that is the cause of the current exception. 
            If the innerException parameter is not a null reference, 
            the current exception is raised in a catch block that handles the inner exception.
            </param>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the NSoft.NFramework.Networks.Ftp.FtpException class with serialized data.
            </summary>
      <param name="info">The object that holds the serialized object data.</param>
      <param name="context">The contextual information about the source or destination.</param>
    </member>
    <member name="T:NSoft.NFramework.Networks.FtpFileInfo">
      <summary>
            FTP 서버의 파일이나 디렉토리 엔트리의 정보를 나타낸다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.FtpFileInfo.#ctor(System.String,System.String)">
      <summary>
            생성자
            </summary>
      <param name="line">FTP에서 전송한 directory 정보</param>
      <param name="path">현재 디렉토리 경로</param>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpFileInfo.FullName">
      <summary>
            파일의 전체 경로 (예 : /Users/debop/readme.txt )
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpFileInfo.Filename">
      <summary>
            원격 파일 명 (예 : readme.txt)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpFileInfo.FilePath">
      <summary>
            원격 파일의 경로 (예 : /Users/debop )
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpFileInfo.FileKind">
      <summary>
            Ftp 엔트리가 파일인가 디렉토리인가 구분
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpFileInfo.Permission">
      <summary>
            FTP 엔트리(파일 또는 디렉토리)에 대한 권한 ( UNIX 스타일 : rw )
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpFileInfo.Size">
      <summary>
            파일 크기
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpFileInfo.FileDateTime">
      <summary>
            파일 생성 날짜
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpFileInfo.Extension">
      <summary>
            파일 확장자 (예 : .txt)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.FtpFileInfo.NameOnly">
      <summary>
            확장자를 제외한 파일 이름만 (예 : readme )
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Networks.HtmlTool">
      <summary>
            Html Document 형식과 관련된 Utility Class
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HtmlTool.PATTERN_MAIL">
      <summary>
            email 주소 추출
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HtmlTool.PATTERN_WWW">
      <summary>
            web 주소 추출 Web 주소 (ex. www.realweb21.com ) 와 같은 것을 앞 뒤로 공백을 줘야 제대로 찾는다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HtmlTool.PATTERN_URL">
      <summary>
            url 주소 추출
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HtmlTool.REPLACE_PATTERN_MAIL">
      <summary>
            mail 주소 변환 형식
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HtmlTool.REPLACE_PATTERN_WWW">
      <summary>
            web site 주소 변환 형식
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HtmlTool.REPLACE_PATTERN_URL">
      <summary>
            URL 변환 형식
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.HtmlEncode(System.String)">
      <summary>
            문자열을 Html 형식으로 Encoding한다.
            </summary>
      <param name="s">문자열</param>
      <returns>Html형식으로 Encoding된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.HtmlEncode(System.IO.Stream)">
      <summary>
            지정된 스트림을 Html 형식으로 Encoding한다.
            </summary>
      <param name="stream">스트림</param>
      <returns>인코딩된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.HtmlEncode(System.String,System.IO.Stream)">
      <summary>
            지정된 스트림을 Html 형식으로 Encoding 한다.
            </summary>
      <param name="s">
      </param>
      <param name="output">인코딩된 문자가 담긴 stream</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.HtmlDecode(System.String)">
      <summary>
            Html 형식으로 인코딩된 문자열을 디코딩을 수행한다.
            </summary>
      <param name="s">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.HtmlDecode(System.IO.Stream)">
      <summary>
            Html 형식으로 인코딩된 스트림을 디코딩한다.
            </summary>
      <param name="stream">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.HtmlDecode(System.String,System.IO.Stream)">
      <summary>
            Html 형식으로 인코딩된 문자열을 디코딩하여 스트림을 반환한다.
            </summary>
      <param name="s">
      </param>
      <param name="output">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.UrlEncode(System.String,System.Text.Encoding)">
      <summary>
            Url을 Encoding한다. 특히 인자가 한글인 경우 문자열이 깨지기 쉽고, 
            연결자 (?, &amp;) 등과 겹쳐서 다른 문자로 해석되어 질 수 있다.
            이를 방지하기 위해 위의 문자들을 제거하여 작업을 수행한다.
            </summary>
      <param name="payload">인코딩할 문자열</param>
      <param name="enc">인코딩 방식</param>
      <returns>UrlEncoded payload.</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.UrlEncode(System.String,System.Byte[]@)">
      <summary>
            Url을 UTF8 방식으로 Encoding한다. 특히 인자가 한글인 경우 문자열이 깨지기 쉽고, 
            연결자 (?, &amp;) 등과 겹쳐서 다른 문자로 해석되어 질 수 있다.
            이를 방지하기 위해 위의 문자들을 제거하여 작업을 수행한다.
            </summary>
      <param name="payload">URL 인자값</param>
      <param name="output">url encoded bytes by <see cref="P:System.Text.Encoding.UTF8" /></param>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.UrlEncode(System.String,System.Text.Encoding,System.Byte[]@)">
      <summary>
            Url을 Encoding한다. 특히 인자가 한글인 경우 문자열이 깨지기 쉽고, 
            연결자 (?, &amp;) 등과 겹쳐서 다른 문자로 해석되어 질 수 있다.
            이를 방지하기 위해 위의 문자들을 제거하여 작업을 수행한다.
            </summary>
      <param name="payload">URL 인자값</param>
      <param name="enc">byte로 변환할 시에 인코더</param>
      <param name="output">url encoded bytes by a specified <paramref name="enc" /></param>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.UrlDecode(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)">
      <summary>
            Url 인코딩된 데이터를 지정된 범위를 지정된 인코딩 방식으로 디코딩을 수행한다.
            </summary>
      <param name="bytes">인코딩된 데이타</param>
      <param name="offset">시작 위치</param>
      <param name="count">변경할 바이트 수</param>
      <param name="enc">인코딩 방식</param>
      <returns>Url 디코딩된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.UrlDecode(System.String,System.Text.Encoding)">
      <summary>
            Url 인코딩된 데이터를 지정된 범위를 지정된 인코딩 방식으로 디코딩을 수행한다.
            </summary>
      <param name="s">string to decoding</param>
      <param name="enc">인코딩 방식</param>
      <returns>Url 디코딩된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.MakeAutoLink(System.String)">
      <summary>
            HTML 문자열중에 web, mail, ftp, news 등과 같은 주소가 있는 경우 link를 만들어 준다.
            </summary>
      <param name="html">
      </param>
      <returns>
      </returns>
      <remarks>
            이부분은 RegularExpression을 사용하여 Web, mail, ftp, news등의 주소를 
            걸러내어서 작업 처리할 수 있도록 한다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.MakeAutoLink(System.String,System.Boolean)">
      <summary>
            게시판 글 들 중에 web address, email 등에 자동으로 link를 생성한다.
            </summary>
      <param name="html">
      </param>
      <param name="displayHtml">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HtmlTool.ConvertToHtml(System.String)">
      <summary>
            일반 문자열을 HTML 문자열로 변환하기 위하여 Environment.NewLine을 &lt;BR&gt;으로 변환한다.
            </summary>
      <param name="src">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Networks.HttpClient">
      <summary>
            Http 통신을 수행하는 Client Class
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.#ctor">
      <summary>
            Initialize a new instance of HttpClient.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.#ctor(System.Uri)">
      <summary>
            Initialize a new instance of HttpClient with baseUri.
            </summary>
      <param name="baseUri">서버주소</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.#ctor(System.Uri,System.Int32,System.String,System.String)">
      <summary>
            Initialize a new instance of HttpClient with baseUri, timeout, user id and password
            </summary>
      <param name="baseUri">서버주소</param>
      <param name="timeout">통신 timeout (msec 단위)</param>
      <param name="userId">사용자 Id</param>
      <param name="passwd">비밀번호</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.#ctor(System.String)">
      <summary>
            Initialize a new instance of HttpClient with uri string.
            </summary>
      <param name="baseUriString">uri string</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.#ctor(System.String,System.Int32,System.String,System.String)">
      <summary>
            Initialize a new instance of HttpClient with uri, timeout, user id and password
            </summary>
      <param name="baseUriString">uri string</param>
      <param name="timeout">time for http communication.</param>
      <param name="userId">user id</param>
      <param name="passwd">password</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.ResponseToArray(System.Net.WebResponse)">
      <summary>
            Response 정보를 byte array로 변환한다.
            </summary>
      <remarks>
            길이가 아주 길고, 실제 크기를 알 수 없을 때 Response 개체의 stream을 처리하는 로직이 있음.
            </remarks>
      <param name="response">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.GetResponse(System.String)">
      <summary>
            응답 객체를 반환한다.
            </summary>
      <param name="method">
        <see cref="T:System.Net.WebRequestMethods.Http" /> 참고</param>
      <returns>
      </returns>
      <remarks>WebResponse는 사용한 후 꼭 Close를 호출해야 한다.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.Head">
      <summary>
            응답 Header 내용을 반환한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.Get">
      <summary>
            URL정보를 기초로 HTTP GET 을 수행한다. 
            </summary>
      <returns>응답 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.Post(System.Collections.Specialized.NameValueCollection,System.Text.Encoding)">
      <summary>
            지정된 서버에 DATA를 POST 방식으로 전송한다.
            </summary>
      <param name="inputs">전송 데이타</param>
      <param name="enc">인코딩 방식</param>
      <returns>응답 결과 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.Post(System.String,System.Text.Encoding)">
      <summary>
            주어진 URL를 기초로 Http Post 를 수행한다.
            ASP.NET 서버인 경우 web.config의 Request/Response Encoding 정보를 잘 보고 해야 한다.
            </summary>
      <param name="payload">전송할 DATA (ex PARAM1=VALUE1&amp;PARAM2=VALUE2)</param>
      <param name="enc">전송할 DATA의 Encoding 방식</param>
      <returns>응답 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.DownloadData">
      <summary>
            해당주소에서 Data를 받습니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.DownloadFile(System.String,System.String)">
      <summary>
            지정한 주소의 내용을 받아서 파일로 저장한다.
            </summary>
      <param name="address">서버 주소</param>
      <param name="filename">로칼 파일 경로</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpClient.UploadFile(System.String,System.String)">
      <summary>
            Client의 지정된 파일을 서버로 전송한다.
            </summary>
      <param name="filename">서버로 전송할 파일명</param>
      <param name="method">Http communication method. (GET, POST, PUT...)</param>
      <returns>파일 전송 결과 Data</returns>
    </member>
    <member name="P:NSoft.NFramework.Networks.HttpClient.BaseUri">
      <summary>
            Base <see cref="T:System.Uri" /></summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.HttpClient.BaseUriString">
      <summary>
            Base <see cref="T:System.Uri" /> String
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.HttpClient.Timeout">
      <summary>
            요청 제한 시간 (단위 : millisecond)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.HttpClient.UserId">
      <summary>
            기본 인증 적용시 사용되는 UserId
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.HttpClient.Password">
      <summary>
            기본 인증 적용시 사용되는 비밀번호
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.HttpClient.Request">
      <summary>
            WebRequest 객체
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.HttpClient.Credentials">
      <summary>
            웹 클라이언트 인증을 위한 자격 증명을 검색할 수 있는 기본 인증 인터페이스를 제공합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.HttpClient.WebProxy">
      <summary>
            Proxy 서버 정보를 가지는 개체
            </summary>
      <value>
      </value>
    </member>
    <member name="P:NSoft.NFramework.Networks.HttpClient.RequestHeaders">
      <summary>
            요청 헤데 정보 컬렉션
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.HttpClient.ResponseHeaders">
      <summary>
            응답 헤더 정보 컬렉션
            </summary>
      <value>
      </value>
    </member>
    <member name="T:NSoft.NFramework.Networks.HttpConsts">
      <summary>
            Http 통신시에 설정되는 기본 값 정의
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HttpConsts.HTTP_CONTENT_BOUNDARY">
      <summary>
            content boundry in http protocol
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HttpConsts.DEFAULT_BUFFER_LENGTH">
      <summary>
            default buffer length
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HttpConsts.DEFAULT_DOWNLOAD_BUFFER">
      <summary>
            default download buffer.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HttpConsts.HTTP_MIN_TIMEOUT">
      <summary>
            최소 통신 제한 시간 (15초)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HttpConsts.HTTP_DEFAULT_TIMEOUT">
      <summary>
            기본 통신 제한 시간 (90초)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HttpConsts.HTTP_LOCALHOST">
      <summary>
            localhost url string.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HttpConsts.HTTP_POST_CONTENT_TYPE">
      <summary>
            content type for http post.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HttpConsts.HTTP_FILE_CONTENT_TYPE">
      <summary>
            content type for http file
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.HttpConsts.HTTP_DEFAULT_FILE_CONTENT_TYPE">
      <summary>
            파일의 기본 컨텐트 타입을 정의한다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Networks.HttpTool">
      <summary>
            HTTP Protocal을 이용한 통신을 수행하기 위한 Utility Class
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpTool.GetString(System.String,System.Text.Encoding,System.Int32,System.String,System.String)">
      <summary>
            주어진 URL에 HTTP GET을 수행한다.
            </summary>
      <param name="url">Server URL</param>
      <param name="enc">Encoding Type</param>
      <param name="timeout">Connection Timeout (milliseconds)</param>
      <param name="userId">UserId for Authentication</param>
      <param name="password">Password for Authentication</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpTool.GetResponse(System.String,System.Int32,System.String,System.String)">
      <summary>
            지정된 Web 주소로부터 Http Get을 이용하여 정보를 다운 받는다.
            </summary>
      <param name="url">서버 주소</param>
      <param name="timeout">제한 시간</param>
      <param name="userId">인증을 위한 사용자 Id</param>
      <param name="password">인증을 위한 비밀번호</param>
      <returns>응답 개체 (<c>WebResponse</c> 개체)</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpTool.PostString(System.String,System.String,System.Text.Encoding,System.Int32,System.String,System.String)">
      <summary>
            지정된 Web 주소로부터 Http Post을 이용하여 정보를 전달하고, 결과 정보를 얻는다.
            </summary>
      <param name="url">서버 주소</param>
      <param name="payload">POST 될 데이타 (형식 : PARAM1=VALUE1&amp;PARAM2=VALUE2&amp;PARAM3=VALUE3)</param>
      <param name="enc">인코딩 방식</param>
      <param name="timeout">제한 시간</param>
      <param name="userId">인증을 위한 사용자 Id</param>
      <param name="password">인증을 위한 비밀번호</param>
      <returns>응답 개체 (<c>WebResponse</c> 개체)</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpTool.GetResponse(System.String,System.String,System.Int32,System.String,System.String)">
      <summary>
            가장 일반적으로 사용할 함수, 서버에 HTTP로 접속하여 Response를 얻는다.
            </summary>
      <param name="method">전송 방법 (<see cref="T:System.Net.WebRequestMethods.Http" />참조)</param>
      <param name="url">서버 주소</param>
      <param name="timeout">제한 시간</param>
      <param name="userId">UserId</param>
      <param name="password">Password</param>
      <returns>결과 <c>WebResponse</c> 인스턴스 개체</returns>
      <remarks>WebResponse는 사용한 후 꼭 Close를 호출해야 한다.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpTool.SimpleDownloadFile(System.String,System.String)">
      <summary>
            주어진 주소에서 Web을 통해 파일을 다운로드 받는다.
            </summary>
      <param name="address">Web 주소</param>
      <param name="localFullFileName">다운 받아 저자할 로칼 파일 전체 경로</param>
      <returns>성공여부</returns>
      <exception cref="T:System.Net.WebException">address 주소 잘못 등</exception>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpTool.SimpleDownloadData(System.String)">
      <summary>
            웹으로부터 Data를 다운로드 받는다.
            </summary>
      <param name="address">주소</param>
      <returns>응답받은 Data, 일차원 바이트 배열입니다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.HttpTool.SimpleUploadFile(System.String,System.String,System.String)">
      <summary>
            지정된 주소로 파일을 전송합니다.
            </summary>
      <param name="address">전송할 URL 주소</param>
      <param name="method">전송 방법 (GET, POST, PUT...)</param>
      <param name="filename">전송활 파일 경로</param>
      <returns>전송 결과</returns>
    </member>
    <member name="T:NSoft.NFramework.Networks.MailSender">
      <summary>
        <see cref="T:System.Net.Mail.SmtpClient" /> 와 <see cref="T:System.Net.Mail.MailMessage" />를 이용한 메일 전송용 Utility Class
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.MailSender.SendMessage(System.String,System.Net.Mail.MailMessage)">
      <summary>
            Mail 보내기
            </summary>
      <param name="host">SMTP Host address.</param>
      <param name="message">mail message</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.MailSender.SendMessage(System.String,System.Int32,System.Net.Mail.MailMessage)">
      <summary>
            Mail 보내기
            </summary>
      <param name="host">SMTP Host address.</param>
      <param name="port">SMTP port</param>
      <param name="message">mail message</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.MailSender.BuildHtmlMessageBody(System.Net.Mail.MailMessage,System.Uri,System.Text.Encoding)">
      <summary>
        <see cref="T:System.Net.Mail.MailMessage" /> 의 본문을 지정된 <see cref="P:System.Uri.AbsoluteUri" />의 컨텐츠로 설정한다.
            </summary>
      <param name="message">메일 메시지 인스턴스</param>
      <param name="uri">본문으로 설정할 내용이 있는 <see cref="T:System.Uri" /></param>
      <param name="bodyEncoding">본문의 인코딩 방식</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.MailSender.BuildAttachments(System.Net.Mail.MailMessage,System.String[])">
      <summary>
            첨부파일 정보를 메일 본문에 추가한다.
            </summary>
      <param name="message">Mail message</param>
      <param name="filenames">array of attached file names.</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.MailSender.BuildAttachments(System.Net.Mail.MailMessage,System.Collections.Generic.IDictionary{System.String,System.IO.Stream})">
      <summary>
            첨부파일 정보를 메일 본문에 추가한다.
            </summary>
      <param name="message">
      </param>
      <param name="files">파일명, FileStream 의 Dictionary</param>
    </member>
    <member name="T:NSoft.NFramework.Networks.XmlHttpClient">
      <summary>
            서버와의 통신을 XML로 수행하는 통신 모듈 (Micosoft의 MSXML 의 IXmlHttp 를 구현한 것)
            </summary>
      <remarks>
            .NET Framework에서는 <see cref="T:System.Net.HttpWebRequest" />, <see cref="T:System.Net.HttpWebResponse" /> class를 사용한다.
            <b>주의사항</b>
            ashx 같은 IHttpHandler에게 PostXml을 보내는 것은 상관없으나, 
            aspx 와 같은 Page에게 PostXml로 Xml 문자열을 보내게 되면, 보안 문제로 에러를 낼 수 있다. 
            이를 방지하기 위해 두가지 방법이 있다.
            1. aspx Page의 RequestValidate=false 로 설정하던가.
            2. web.config에서 전체적으로 RequestValidate = false로 설정해야 한다.
            </remarks>
    </member>
    <member name="F:NSoft.NFramework.Networks.XmlHttpClient.MIN_TIMEOUT">
      <summary>
            XmlHttp 통신시의 최소 Timeout (15000 msec)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.XmlHttpClient.MAX_TIMEOUT">
      <summary>
            XmlHttp 통신시의 최대 Timeout. <see cref="F:System.Threading.Timeout.Infinite" />를 사용
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.XmlHttpClient.POST_CONTENT_TYPE">
      <summary>
            Http Post 방식 전송시의 Content Type
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.XmlHttpClient.UrlDelimeters">
      <summary>
            URL String에서 사용되는 구분자들
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.#ctor(System.String)">
      <summary>
            Constructor
            </summary>
      <param name="uri">통신할 서버 주소</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.#ctor(System.String,System.Boolean,System.Int32,System.String,System.String)">
      <summary>
            생성자
            </summary>
      <param name="uri">통신할 서버 주소</param>
      <param name="isAsync">비동기 여부</param>
      <param name="timeout">제한 시간</param>
      <param name="userID">사용자 계정</param>
      <param name="password">사용자 비밀변호</param>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.GetCredentials">
      <summary>
            Build NetworkCredential by account information.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.EncodePayLoad(System.String)">
      <summary>
            포스트 되는 DATA에 대해 URLEncode를 수행한다.
            </summary>
      <param name="payload">HttpPost되는 DATA</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.Get(System.Text.Encoding)">
      <summary>
            Get방식의 통신으로 서버로부터 XML Stream 객체를 받환받는다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.GetStream">
      <summary>
            POST 방식으로 서버에 접속하여 XML 통신을 수행한다.
            </summary>
      <returns>반환받은 문자열 (UTF8 방식)</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.Post(System.String,System.Text.Encoding)">
      <summary>
            POST 방식으로 서버에 접속하여 응답 문자열을 반환 받는다.
            </summary>
      <param name="payload">
      </param>
      <param name="enc">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.Post(System.Xml.XmlDocument)">
      <summary>
            XmlDocument 객체의 InnerXml string을 POST 방식으로 전송하고 응답 문자열을 반환 받는다.
            </summary>
      <param name="document">보내고자하는 XML 객체</param>
      <returns>서버로부터 반환받은 결과 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.PostStream(System.String)">
      <summary>
            POST 방식으로 서버에 접속하여 응답 Stream을 반환 받는다.
            </summary>
      <param name="payload">Url Encoding된 Parameters</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.PostStream(System.IO.Stream)">
      <summary>
            POST 방식으로 서버에 접속하여 응답 Stream을 반환 받는다.
            </summary>
      <param name="stream">서버에 전달할 내용</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.PostStream(System.Xml.XmlDocument)">
      <summary>
            XmlDocument 객체의 InnerXml string을 POST 방식으로 전송하고 응답 스트림을 반환 받는다.
            </summary>
      <param name="document">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.GetText(System.Text.Encoding)">
      <summary>
            GET 방식의 XML HTTP 통신
            </summary>
      <param name="enc">반환 문자열의 Encoding 방식</param>
      <returns>반환문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.GetXml">
      <summary>
            GET 방식의 XML HTTP 통신
            </summary>
      <returns>XML문자열인 경우 XmlDocument 객체로 만들어서 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.PostText(System.String,System.Text.Encoding)">
      <summary>
            POST 방식의 XML HTTP 통신. text/plain 값을 받는다.
            </summary>
      <param name="payload">
      </param>
      <param name="enc">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.PostXml(System.Xml.XmlDocument)">
      <summary>
            Post 방식의 XmlHttp 통신. XmlDocument를 받는다.
            </summary>
      <param name="document">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.Send(NSoft.NFramework.Xml.XmlDoc)">
      <summary>
            Posting request xml document to server
            </summary>
      <param name="requestDoc">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.GetText(System.String,System.Boolean,System.Int32,System.String,System.String)">
      <summary>
            HTTP GET 방식으로 서버로부터 XML 정보를 얻는다.
            </summary>
      <param name="uri">서버 주소</param>
      <param name="isAsync">비동기 여부</param>
      <param name="timeoutMilliseconds">통신 Timeout (단위:milliseconds)</param>
      <param name="userId">계정 Id</param>
      <param name="password">계정 비밀번호</param>
      <returns>응답 내용 (XML 문자열)</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.GetXml(System.String,System.Boolean,System.Int32,System.String,System.String)">
      <summary>
            HTTP Get 방식으로 응답을 받아 <see cref="T:System.Xml.XmlDocument" /> 의 인스턴스로 빌드하여 반환한다.
            </summary>
      <param name="uri">응답받을 서버 주소</param>
      <param name="isAsync">비동기 여부</param>
      <param name="timeoutMilliseconds">통신 Timeout</param>
      <param name="userId">계정 Id</param>
      <param name="password">계정 비밀번호</param>
      <returns>응답정보를 담은 <see cref="T:System.Xml.XmlDocument" /></returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.PostText(System.String,System.String,System.Boolean,System.Int32,System.String,System.String)">
      <summary>
            HTTP Post 방식으로 응답을 받아 문자열로 반환한다.
            </summary>
      <param name="uri">응답받을 서버 주소</param>
      <param name="payload">응답 요청시의 Parameter 정보</param>
      <param name="isAsync">비동기 여부</param>
      <param name="timeoutMilliseconds">통신 Timeout (단위: milliseconds)</param>
      <param name="userId">계정 Id</param>
      <param name="password">계정 비밀번호</param>
      <returns>응답정보를 담은 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.PostXml(System.String,System.Xml.XmlDocument,System.Boolean,System.Int32,System.String,System.String)">
      <summary>
            HTTP POST 방식으로 응답을 받아 <see cref="T:System.Xml.XmlDocument" /> 의 인스턴스로 빌드하여 반환한다.
            </summary>
      <param name="uri">응답받을 서버 주소</param>
      <param name="document">응답 요청시의 Form Parameter 정보</param>
      <param name="isAsync">비동기 여부</param>
      <param name="timeoutMilliseconds">통신 Timeout (단위: milliseconds)</param>
      <param name="userId">계정 Id</param>
      <param name="password">계정 비밀번호</param>
      <returns>응답정보를 담은 <see cref="T:System.Xml.XmlDocument" /></returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpClient.Send(System.String,NSoft.NFramework.Xml.XmlDoc,System.Boolean,System.Int32,System.String,System.String)">
      <summary>
            RealWeb XML HTTP 통신 모듈 설정이다.
            </summary>
      <param name="uri">서버 URI</param>
      <param name="document">요청용 RclXmlDocument</param>
      <param name="isAsync">비동기 통신 여부</param>
      <param name="timeoutMilliseconds">통신 제한시간 (default : System.Threading.Timeout.Infinite)</param>
      <param name="userId">
      </param>
      <param name="password">
      </param>
      <returns>응답 XmlDocument</returns>
    </member>
    <member name="P:NSoft.NFramework.Networks.XmlHttpClient.Request">
      <summary>
        <see>System.Net.WebRequest</see> 객체를 나타낸다.
            선행 조건으로 URL을 먼저 설정한다.
            </summary>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:NSoft.NFramework.Networks.XmlHttpClient.Uri" />값을 설정 안했을 시</exception>
    </member>
    <member name="P:NSoft.NFramework.Networks.XmlHttpClient.Uri">
      <summary>
            XmlHttpClient로 통신할 서버 URI를 지정한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.XmlHttpClient.IsAsync">
      <summary>
            동기/비동기 통신 방식 지정
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.XmlHttpClient.UserId">
      <summary>
            서버 접속 인증 방법이 Basic Authentication일 경우에는 사용자 아이디를 설정한다. 
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.XmlHttpClient.Password">
      <summary>
            서버 접속 인증 방법이 Basic Authentication일 경우에는 사용자 Password를 설정해 주어야 한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Networks.XmlHttpClient.Timeout">
      <summary>
            서버와의 통신시의 통신 제한 시간 (단위: milliseconds)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Networks.XmlHttpMethods">
      <summary>
            XmlHttp 통신 Method 들
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.XmlHttpMethods.GetText">
      <summary>
            Get Text 
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.XmlHttpMethods.GetXml">
      <summary>
            Get Xml 
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.XmlHttpMethods.PostText">
      <summary>
            Post Text
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Networks.XmlHttpMethods.PostXml">
      <summary>
            Post Xml
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Networks.XmlHttpTool">
      <summary>
            XML 형식의 정보를 HTTP Protocol을 통해 통신 할 때 사용되는 Utility class.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpTool.GetText(System.String,System.Boolean,System.Int32,System.String,System.String)">
      <summary>
            HTTP GET 방식으로 서버로부터 XML 정보를 얻는다.
            </summary>
      <param name="uri">서버 주소</param>
      <param name="isAsync">비동기 여부</param>
      <param name="timeoutMilliseconds">통신 Timeout (단위: milliseconds)</param>
      <param name="userId">계정 Id</param>
      <param name="password">계정 비밀번호</param>
      <returns>응답 내용 (XML 문자열)</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpTool.GetXml(System.String,System.Boolean,System.Int32,System.String,System.String)">
      <summary>
            HTTP Get 방식으로 응답을 받아 <see cref="T:System.Xml.XmlDocument" /> 의 인스턴스로 빌드하여 반환한다.
            </summary>
      <param name="uri">응답받을 서버 주소</param>
      <param name="isAsync">비동기 여부</param>
      <param name="timeoutMilliseconds">통신 Timeout</param>
      <param name="userId">계정 Id</param>
      <param name="password">계정 비밀번호</param>
      <returns>응답정보를 담은 <see cref="T:System.Xml.XmlDocument" /></returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpTool.PostText(System.String,System.String,System.Boolean,System.Int32,System.String,System.String)">
      <summary>
            HTTP Post 방식으로 응답을 받아 문자열로 반환한다.
            </summary>
      <param name="uri">응답받을 서버 주소</param>
      <param name="payload">응답 요청시의 Parameter 정보</param>
      <param name="isAsync">비동기 여부</param>
      <param name="timeoutMilliseconds">통신 Timeout</param>
      <param name="userId">계정 Id</param>
      <param name="password">계정 비밀번호</param>
      <returns>응답정보를 담은 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpTool.PostXml(System.String,System.Xml.XmlDocument,System.Boolean,System.Int32,System.String,System.String)">
      <summary>
            HTTP POST 방식으로 응답을 받아 <see cref="T:System.Xml.XmlDocument" /> 의 인스턴스로 빌드하여 반환한다.
            </summary>
      <param name="uri">응답받을 서버 주소</param>
      <param name="document">응답 요청시의 Form Parameter 정보</param>
      <param name="isAsync">비동기 여부</param>
      <param name="timeoutMilliseconds">통신 Timeout</param>
      <param name="userId">계정 Id</param>
      <param name="password">계정 비밀번호</param>
      <returns>응답정보를 담은 <see cref="T:System.Xml.XmlDocument" /></returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.XmlHttpTool.Send(System.String,NSoft.NFramework.Xml.XmlDoc,System.Boolean,System.Int32,System.String,System.String)">
      <summary>
            RealWeb XML HTTP 통신 모듈 설정이다.
            </summary>
      <param name="uri">서버 URI</param>
      <param name="document">요청용 RclXmlDocument</param>
      <param name="isAsync">비동기 통신 여부</param>
      <param name="timeoutMilliseconds">통신 제한시간 (default : System.Threading.Timeout.Infinite)</param>
      <param name="userId">
      </param>
      <param name="password">
      </param>
      <returns>응답 XmlDocument</returns>
    </member>
    <member name="T:NSoft.NFramework.Networks.NetTool">
      <summary>
            Network Utility Class
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Networks.NetTool.GetIPAddressAsString(System.String)">
      <summary>
            컴퓨터의 이름을 가지고 IP Adress를 찾아 반환한다.
            </summary>
      <param name="hostName">Computer Name (DNS Name)이 포함된 문자열</param>
      <returns>IPAddress의 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.NetTool.GetIPAddressAsStringList(System.String)">
      <summary>
            컴퓨터 이름을 통해 IP 주소를 검색해서 문자열 배열로 반환한다. (로컬 컴퓨터는 <see cref="M:System.Net.Dns.GetHostName" />을 이용하면됩니다.)
            </summary>
      <param name="hostName">컴퓨터 명</param>
      <returns>컴퓨터의 Ip Address 들의 문자열, 없으면 빈 문자열을 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Networks.NetTool.GetIPAddress(System.String)">
      <summary>
            hostName에 해당하는 IPAddress의 배열을 얻는다. (로컬 컴퓨터는 <see cref="M:System.Net.Dns.GetHostName" />을 이용하면됩니다.)
            </summary>
      <param name="hostName">
      </param>
      <returns>
      </returns>
      <remarks>
        <c>System.Net.Dns.GetHostEntry</c>를 직접이용해도 된다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Nini.Ini.IniReader.Finalize">
      <summary>
            Destructor.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Nini.Ini.IniWriter.Finalize">
      <summary>
            Destructor.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.AsyncAutoResetEvent">
      <summary>
            비동기 <see cref="T:System.Threading.AutoResetEvent" /></summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.AsyncBarrier">
      <summary>
            비동기 Barrier.
            병렬로 특정 메소드를 수행할 때, 초기 지정한 참여자가 모두 신호를 보낼 때까지, 전체 작업 완료를 보류합니다. 즉 장벽을 쳐서, 모두 완료될 때가지 기다립니다. Fork-Join 과 같은 기능입니다.
            참고 : http://msdn.microsoft.com/ko-kr/library/system.threading.barrier.aspx
            </summary>
      <seealso cref="T:System.Threading.Barrier" />
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncBarrier.#ctor">
      <summary>
            생성자
            </summary>
      <param name="participantCount">참여자 수 (0보다 커야 합니다)</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncBarrier.#ctor(System.Int32)">
      <summary>
            생성자
            </summary>
      <param name="participantCount">참여자 수 (0보다 커야 합니다)</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncBarrier.SignalAndWait">
      <summary>
            이 함수를 호출하여, 참여에서 빠져나갔음을 알려주고, 전체 작업이 완료되었는지 알 수 있도록 <see cref="T:System.Threading.Tasks.Task" />를 반환합니다.
            여기서 Task를 반환받아, Wait를 수행하면, 비동기적으로 Barrier에 참여하는 것이 된다.
            </summary>
      <returns>A Task that will be signaled when the current round completes.</returns>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncBarrier.ParticipantCount">
      <summary>
            Participant count
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncBarrier.RemainingCount">
      <summary>
            Remaining participant count
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.AsyncCache`2">
      <summary>
        <see cref="T:System.Threading.Tasks.Task`1" /> 를 이용하여, 비동기적으로 캐시 값을 구하는 클래스입니다.
            기본적으로 캐시에는 값을 계산하는 작업 (<see cref="T:System.Threading.Tasks.Task`1" />)이 Lazy{Task{TValue}} 변수로 정의되어, 
            지연한 작업 생성 및, 비동기적인 값 계산을 하게 됩니다.
            </summary>
      <typeparam name="TKey">캐시 키</typeparam>
      <typeparam name="TValue">캐시 값</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncCache`2.#ctor(System.Func{`0,System.Threading.Tasks.Task{`1}})">
      <summary>
            생성자
            </summary>
      <param name="valueFactory">값을 생성하는 Task를 반환하는 델리게이트입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncCache`2.GetValue(`0)">
      <summary>
            지정한 키에 해당하는 값을 가져옵니다. 없으면, 값 생성 delegate에 의해 생성된 값을 캐시에 저장하고, 반환합니다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncCache`2.SetValue(`0,`1)">
      <summary>
            캐시에 값을 지정하여 저장합니다.
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncCache`2.SetValue(`0,System.Threading.Tasks.Task{`1})">
      <summary>
            캐시에 지정한 값을 저장합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncCache`2.Clear">
      <summary>
            모든 요소를 제거합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncCache`2.Item(`0)">
      <summary>
            해당 키의 값
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncCache`2.Count">
      <summary>
            캐시에 저장된 요소의 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncCache`2.IsEmpty">
      <summary>
            캐시가 비었는지 나타냅니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.AsyncCall">
      <summary>
            비동기 호출 클래스의 팩토리
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncCall.Create``1(System.Action{``0},System.Int32,System.Int32,System.Threading.Tasks.TaskScheduler)">
      <summary>
            비동기 호출을 수행하는 <see cref="T:NSoft.NFramework.Parallelism.DataStructures.AsyncCall`1" />를 생성합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncCall.Create``1(System.Func{``0,System.Threading.Tasks.Task},System.Int32,System.Threading.Tasks.TaskScheduler)">
      <summary>
            비동기 호출을 수행하는 <see cref="T:NSoft.NFramework.Parallelism.DataStructures.AsyncCall`1" />를 생성합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncCall.CreateInTargetAppDomain``1(System.AppDomain,System.Action{``0},System.Int32,System.Int32,System.Threading.Tasks.TaskScheduler)">
      <summary>
            지정한 AppDomain에서 비동기 호출을 수행하는 <see cref="T:NSoft.NFramework.Parallelism.DataStructures.AsyncCall`1" />를 생성합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.AsyncCall`1">
      <summary>
            UI 스레드에 Post 하는 것과 같은 것 들을 비동기 방식으로 호출하도록 합니다. 
            SynchronizationContext.Post() 자체가 비동기 방식입니다만 (Send()와는 달리), 병렬은 아닙니다. 
            AsyncCall은 호출해야 할 Item을 내부 버퍼에 담아두었다가, 스케쥴에 따라, 해당 Handler를 호출해 줍니다.
            </summary>
      <typeparam name="T">처리할 데이타의 수형</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncCall`1.Post(`0)">
      <summary>
            처리할 아이템을 등록합니다. 이 아이템은 미리 지정된 Handler에게 비동기적으로 전달됩니다.
            </summary>
      <param name="item">처리할 항목</param>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.AsyncLock">
      <summary>
            비동기 Lock 객체
            </summary>
      <example>
        <code>
            private static readonly AsyncLock _lock = new AsyncLock();
            
            using(var releaser = _lock.LockAsync())
            {
                ....
            }
            </code>
      </example>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.AsyncManualResetEvent">
      <summary>
            비동기 <see cref="T:System.Threading.ManualResetEvent" /></summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.AsyncProducerConsumerCollection`1">
      <summary>
            비동기 생산자-소비자 패턴의 컬렉션입니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncProducerConsumerCollection`1.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncProducerConsumerCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
      <summary>
            생성자
            </summary>
      <param name="collection">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncProducerConsumerCollection`1.Add(`0)">
      <summary>
            컬렉션에 요소를 추가합니다.
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncProducerConsumerCollection`1.Take">
      <summary>
            컬렉션으로부터 비동기적으로 요소를 취합니다.
            </summary>
      <returns>A Task that represents the element removed from the collection.</returns>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncProducerConsumerCollection`1.Count">
      <summary>
            컬렉션 요소의 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncProducerConsumerCollection`1.IsDisposed">
      <summary>
            컬렉션의 리소스 해제 여부
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.AsyncReaderWriterLock">
      <summary>
      </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.AsyncReaderWriter">
      <summary>
            비동기 방식으로 쓰기 잠금 및 동시 읽기 실행을 지원하는 ReaderWriter입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncReaderWriter.QueueExclusiveWriter(System.Action)">
      <summary>
            쓰기 잠금을 위한 작업을 큐에 추가합니다.
            </summary>
      <param name="action">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncReaderWriter.QueueExclusiveWriter``1(System.Func{``0})">
      <summary>
            쓰기 잠금을 위한 작업을 큐에 추가합니다.
            </summary>
      <param name="valueFactory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncReaderWriter.QueueConcurrentReader(System.Action)">
      <summary>
            읽기 작업을 큐에 대기 시킵니다.
            </summary>
      <param name="action">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncReaderWriter.QueueConcurrentReader``1(System.Func{``0})">
      <summary>
            읽기 작업을 큐에 대기 시킵니다.
            </summary>
      <param name="valueFactory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncReaderWriter.WaitingExclusive">
      <summary>
            대기중인 쓰기 작업의 갯수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncReaderWriter.WaitingConcurrent">
      <summary>
            대기중인 읽기 작업의 갯수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncReaderWriter.CurrentConcurrent">
      <summary>
            현재 실행되는 읽기 작업의 갯수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncReaderWriter.CurrentlyExclusive">
      <summary>
             현재 배타적 잠금 상태인지를 나타낸다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.AsyncSemaphore">
      <summary>
            리소스에 접근할 수 있는 스레드 수를 비동기 방식으로 제한합니다.
            </summary>
      <seealso cref="T:System.Threading.Semaphore" />
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncSemaphore.WaitAsync">
      <summary>
            세마포어에 빈자리가 날때까지 기다린다.
            </summary>
      <returns>완료된 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncSemaphore.Queue(System.Action)">
      <summary>
            실행할 Action을 큐에 보관합니다. 세마포어에 빈 자리가 생기면 실행합니다.
            </summary>
      <param name="action">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncSemaphore.Queue``1(System.Func{``0})">
      <summary>
            실행할 함수를 큐에 보관합니다. 세마포어에 빈 자리가 생기면 실행합니다.
            </summary>
      <typeparam name="TResult">
      </typeparam>
      <param name="function">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AsyncSemaphore.Release">
      <summary>
            Releases a unit of work to the semaphore.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncSemaphore.CurrentCount">
      <summary>
            현재 세마포어 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncSemaphore.MaxCount">
      <summary>
            최대 세마포어 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AsyncSemaphore.WaitingCount">
      <summary>
            현재 세마포어에 들어가기 위해 기다리는 작업 수
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.HtmlAsyncCache">
      <summary>
            웹의 리소스 정보를 비동기 방식으로 다운로드 받아 저장해 놓는 캐시입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.HtmlAsyncCache.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2">
      <summary>
            Future 패턴으로 항목을 캐시하는 클래스입니다.
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2.#ctor(System.Func{`0,`1})">
      <summary>
            생성자
            </summary>
      <param name="valueFactory">캐시할 항목의 값을 생성할 Factory</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2.GetValue(`0)">
      <summary>
            캐시에서 키에 해당하는 값을 구합니다.
            </summary>
      <param name="key">항목 키</param>
      <returns>항목에 해당하는 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2.SetValue(`0,`1)">
      <summary>
            캐시에 값을 직접 설정합니다. (valueFactory를 거치지 않고, 설정할 수 있도록 합니다)
            </summary>
      <param name="key">키</param>
      <param name="value">값</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2.SetValue(`0,System.Threading.Tasks.Task{`1})">
      <summary>
            캐시에 값을 도출하는 Task를 직접 설정합니다. (valueFactory를 거치지 않고, 설정할 수 있도록 합니다)
            </summary>
      <param name="key">키</param>
      <param name="task">값을 도출하는 Task</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2.ContainsKey(`0)">
      <summary>
            캐시에 해당 키가 존재하는지 확인합니다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2.Remove(`0)">
      <summary>
            해당 키를 제거합니다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2.TryRemove(`0,System.Threading.Tasks.Task{`1}@)">
      <summary>
        <paramref name="key" />에 해당하는 항목을 삭제하려고 합니다.
            </summary>
      <param name="key">
      </param>
      <param name="valueTask">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2.GetAllItems">
      <summary>
            캐시에 있는 모든 요소를 열거합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            항목을 추가합니다.
            </summary>
      <param name="item">추가할 항목</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2.Clear">
      <summary>
            모든 항목을 제거합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2.Item(`0)">
      <summary>
            인덱서
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2.Count">
      <summary>
            항목 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.FutureCache`2.IsReadOnly">
      <summary>
            읽기 전용인가?
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.FutureSpeculativeCache`2">
      <summary>
            값을 제공하는 여러가지 방법을 준비하도록 하고, 최초 결과를 캐시에 사용하도록 합니다.
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureSpeculativeCache`2.#ctor(System.Func{`0,`1},System.Func{`0,System.Collections.Generic.IEnumerable{`0}})">
      <summary>
            생성자
            </summary>
      <param name="valueFactory">
      </param>
      <param name="speculativeKeyFactory">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureSpeculativeCache`2.GetValue(`0)">
      <summary>
            지정된 키에 해당하는 값을 반환합니다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureSpeculativeCache`2.SetValue(`0,System.Threading.Tasks.Task{`1})">
      <summary>
            지정된 키의 항목의 값을 설정합니다.
            </summary>
      <param name="key">
      </param>
      <param name="task">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.FutureWebCache">
      <summary>
            특정 웹 주소의 컨텐츠 내용을 캐시합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.FutureWebCache.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.AbstractStream">
      <summary>
            Thread-safe 한 Stream의 기본 클래스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AbstractStream.Flush">
      <summary>
            파생 클래스에서 재정의될 때 이 스트림에 대해 모든 버퍼를 지우고 버퍼링된 데이터가 내부 장치에 쓰여지도록 합니다.
            </summary>
      <exception cref="T:System.IO.IOException">I/O 오류가 발생하는 경우 </exception>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AbstractStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            파생 클래스에서 재정의될 때 현재 스트림에서 바이트의 시퀀스를 읽고 읽은 바이트 수만큼 스트림 내에서 앞으로 이동합니다.
            </summary>
      <returns>
            버퍼로 읽어온 총 바이트 수입니다. 이 바이트 수는 현재 바이트가 충분하지 않은 경우 요청된 바이트 수보다 작을 수 있으며 스트림의 끝에 도달하면 0이 됩니다.
            </returns>
      <param name="buffer">바이트 배열입니다. 이 메서드가 반환될 때 버퍼에는 지정된 바이트 배열의 값이 <paramref name="offset" /> 및 (<paramref name="offset" /> + <paramref name="count" /> - 1) 사이에서 현재 소스로부터 읽어온 바이트로 교체된 상태로 포함됩니다. </param>
      <param name="offset">현재 스트림에서 읽은 데이터를 저장하기 시작하는 <paramref name="buffer" />의 바이트 오프셋(0부터 시작)입니다. </param>
      <param name="count">현재 스트림에서 읽을 최대 바이트 수입니다. </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="offset" />와 <paramref name="count" />의 합계가 버퍼 길이보다 큰 경우 </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />가 null인 경우 </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> 또는 <paramref name="count" />가 음수인 경우 </exception>
      <exception cref="T:System.IO.IOException">I/O 오류가 발생하는 경우 </exception>
      <exception cref="T:System.NotSupportedException">스트림이 읽기를 지원하지 않는 경우 </exception>
      <exception cref="T:System.ObjectDisposedException">스트림이 닫힌 후 메서드가 호출된 경우 </exception>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AbstractStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            파생 클래스를 재정의될 때 현재 스트림 내의 위치를 설정합니다.
            </summary>
      <returns>
            현재 스트림 내의 새 위치입니다.
            </returns>
      <param name="offset">
        <paramref name="origin" /> 매개 변수에 상대적인 바이트 오프셋입니다. </param>
      <param name="origin">새 위치를 가져오는 데 사용되는 참조 위치를 나타내는 <see cref="T:System.IO.SeekOrigin" /> 형식의 값입니다. </param>
      <exception cref="T:System.IO.IOException">I/O 오류가 발생하는 경우 </exception>
      <exception cref="T:System.NotSupportedException">예를 들어, 스트림이 파이프 또는 콘솔 출력에서 생성되는 경우 스트림은 검색을 지원하지 않습니다. </exception>
      <exception cref="T:System.ObjectDisposedException">스트림이 닫힌 후 메서드가 호출된 경우 </exception>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AbstractStream.SetLength(System.Int64)">
      <summary>
            파생 클래스에 재정의될 때 현재 스트림의 길이를 설정합니다.
            </summary>
      <param name="value">원하는 현재 스트림의 길이(바이트)입니다. </param>
      <exception cref="T:System.IO.IOException">I/O 오류가 발생하는 경우 </exception>
      <exception cref="T:System.NotSupportedException">예를 들어, 스트림이 파이프 또는 콘솔 출력에서 생성되는 경우처럼 스트림이 쓰기와 검색을 모두 지원하지 않는 경우 </exception>
      <exception cref="T:System.ObjectDisposedException">스트림이 닫힌 후 메서드가 호출된 경우 </exception>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.AbstractStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            파생 클래스를 재정의될 때 현재 스트림에 바이트의 시퀀스를 쓰고 쓰여진 바이트 수만큼 이 스트림 내에서 앞으로 이동합니다.
            </summary>
      <param name="buffer">바이트 배열입니다. 이 메서드는 <paramref name="buffer" />의 <paramref name="count" /> 바이트를 현재 스트림으로 복사합니다. </param>
      <param name="offset">현재 스트림으로 바이트를 복사하기 시작할 <paramref name="buffer" />의 바이트 오프셋(0부터 시작)입니다. </param>
      <param name="count">현재 스트림에 쓰는 바이트 수입니다. </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="offset" />과 <paramref name="count" />의 합계가 버퍼 길이보다 큰 경우 </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />가 null인 경우 </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="offset" /> 또는 <paramref name="count" />가 음수인 경우 </exception>
      <exception cref="T:System.IO.IOException">I/O 오류가 발생하는 경우 </exception>
      <exception cref="T:System.NotSupportedException">스트림이 쓰기를 지원하지 않는 경우 </exception>
      <exception cref="T:System.ObjectDisposedException">스트림이 닫힌 후 메서드가 호출된 경우 </exception>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AbstractStream.CanRead">
      <summary>
            파생 클래스에서 재정의될 때 현재 스트림이 읽기를 지원하는지 여부를 나타내는 값을 가져옵니다.
            </summary>
      <returns>
            스트림이 읽기를 지원하면 true이고, 그렇지 않으면 false입니다.
            </returns>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AbstractStream.CanWrite">
      <summary>
            파생 클래스에서 재정의될 때 현재 스트림이 쓰기를 지원하는지 여부를 나타내는 값을 가져옵니다.
            </summary>
      <returns>
            스트림이 쓰기를 지원하면 true이고, 그렇지 않으면 false입니다.
            </returns>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AbstractStream.CanSeek">
      <summary>
            파생 클래스에서 재정의될 때 현재 스트림이 검색을 지원하는지 여부를 나타내는 값을 가져옵니다.
            </summary>
      <returns>
            스트림이 검색을 지원하면 true이고, 그렇지 않으면 false입니다.
            </returns>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AbstractStream.Length">
      <summary>
            파생 클래스에서 재정의된 경우 스트림 바이트의 길이를 가져옵니다.
            </summary>
      <returns>
            스트림 길이(바이트)를 나타내는 long 값입니다.
            </returns>
      <exception cref="T:System.NotSupportedException">Stream에서 파생된 클래스가 검색을 지원하지 않는 경우 </exception>
      <exception cref="T:System.ObjectDisposedException">스트림이 닫힌 후 메서드가 호출된 경우 </exception>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.AbstractStream.Position">
      <summary>
            파생 클래스에서 재정의되면 현재 스트림 내의 위치를 가져오거나 설정합니다.
            </summary>
      <returns>
            스트림 내의 현재 위치입니다.
            </returns>
      <exception cref="T:System.IO.IOException">I/O 오류가 발생하는 경우 </exception>
      <exception cref="T:System.NotSupportedException">스트림이 검색을 지원하지 않는 경우 </exception>
      <exception cref="T:System.ObjectDisposedException">스트림이 닫힌 후 메서드가 호출된 경우 </exception>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.ActionCountdownEvent">
      <summary>
        <see cref="T:NSoft.NFramework.DisposableAction" />과 유사하게, CountdownEvent가 완료되면 (Countdown 수가 0이 되면), 지정한 Action을 수행합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ActionCountdownEvent.#ctor(System.Int32,System.Action)">
      <summary>
            생성자
            </summary>
      <param name="initialCount">초기 countdown 수 (0보다 크거나 같아야 합니다)</param>
      <param name="action">countdown이 끝나면 (countdown 수가 0가 되면) 수행할 action</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ActionCountdownEvent.AddCount">
      <summary>
            Countdown 수를 하나 늘린다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ActionCountdownEvent.Signal">
      <summary>
            Countdown 수를 하나 감소시키도록, 신호를 보냅니다. Countdown이 완료되면, 지정한 action을 수행합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ActionCountdownEvent.Dispose">
      <summary>
            리소스 해제
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ActionCountdownEvent.Dispose(System.Boolean)">
      <summary>
            리소스 해제
            </summary>
      <param name="disposing">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.ActionCountdownEvent.CurrentCount">
      <summary>
            현재 count 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.ActionCountdownEvent.IsDisposed">
      <summary>
            리소스 해제 여부
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.ConcurrentSortedQueue`2">
      <summary>
            멀티스레드에 안전하며, 키를 기준으로 정렬되는 큐입니다.
            </summary>
      <typeparam name="TKey">정렬을 위한 Key의 수형</typeparam>
      <typeparam name="TValue">요소의 수형</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ConcurrentSortedQueue`2.Enqueue(`0,`1)">
      <summary>
            큐에 요소를 추가합니다.
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ConcurrentSortedQueue`2.Enqueue(System.Collections.Generic.KeyValuePair{`0,`1})">
      <summary>
            큐에 요소를 추가합니다.
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ConcurrentSortedQueue`2.TryDequeue(System.Collections.Generic.KeyValuePair{`0,`1}@)">
      <summary>
            큐에서 요소 꺼내기를 시도합니다.
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ConcurrentSortedQueue`2.TryPeek(System.Collections.Generic.KeyValuePair{`0,`1}@)">
      <summary>
            큐의 첫번째 요소를 Peek 해 봅니다.
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ConcurrentSortedQueue`2.Clear">
      <summary>
            큐를 비웁니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ConcurrentSortedQueue`2.GetEnumerator">
      <summary>
            컬렉션을 반복하는 열거자를 반환합니다.
            </summary>
      <returns>
            컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.Generic.IEnumerator`1" />입니다.
            </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ConcurrentSortedQueue`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
      <summary>
            지정된 인덱스부터 시작하여 <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />의 요소를 <see cref="T:System.Array" />에 복사합니다.
            </summary>
      <param name="array">
        <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />에서 복사한 요소의 대상인 1차원 <see cref="T:System.Array" />입니다. 배열의 인덱스는 0부터 시작해야 합니다.</param>
      <param name="index">
        <paramref name="array" />에서 복사가 시작되는 인덱스(0부터 시작)입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" />는 null 참조(Visual Basic에서는 Nothing)입니다.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" />가 0보다 작은 경우</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="index" />가 <paramref name="array" />의 길이와 같거나 큰 경우 -또는- 소스 <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />의 요소 수가 대상 <paramref name="array" />의 <paramref name="index" />부터 끝까지의 사용 가능한 공간보다 큰 경우.</exception>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ConcurrentSortedQueue`2.ToArray">
      <summary>
        <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />에 포함된 요소를 새 배열에 복사합니다.
            </summary>
      <returns>
        <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />에서 복사된 요소를 포함하는 새 배열입니다.
            </returns>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.ConcurrentSortedQueue`2.IsEmpty">
      <summary>
            큐가 비었는지 알려줍니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.ConcurrentSortedQueue`2.Count">
      <summary>
        <see cref="T:System.Collections.ICollection" />에 포함된 요소 수를 가져옵니다.
            </summary>
      <returns>
        <see cref="T:System.Collections.ICollection" />에 포함된 요소 수입니다.
            </returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.ObjectPool`1">
      <summary>
            Thread-Safe 하면서 Producer-Consumer 패턴을 지원하는 객체 풀을 제공합니다.
            </summary>
      <remarks>
            객체 풀에 객체를 담고, 없다면, 객체를 생성해서 제공할 수 있도록 object factory delegate를 사용합니다.
            아래 요소의 수형이 <see cref="T:System.Threading.Tasks.Task" />라면, 비동기적인 작업의 풀을 가지게 됩니다.
            </remarks>
      <typeparam name="T">요소의 수형</typeparam>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.ProducerConsumerCollectionBase`1">
      <summary>
            생산자-소비자 컬렉션을 래핑하여 부가적인 기능을 제공하도록 하는 생산자-소비자 컬렉션 래퍼입니다. (일종의 Decorator의 기본 클래스입니다.)
            </summary>
      <typeparam name="T">항목의 수형</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ProducerConsumerCollectionBase`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
      <summary>
            생성자
            </summary>
      <param name="innerCollection">내부 버퍼</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ProducerConsumerCollectionBase`1.GetEnumerator">
      <summary>
            열거자 얻기
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ProducerConsumerCollectionBase`1.CopyTo(`0[],System.Int32)">
      <summary>
            요소를 지정한 Array에 복사한다.
            </summary>
      <param name="array">
      </param>
      <param name="index">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ProducerConsumerCollectionBase`1.TryTake(`0@)">
      <summary>
            요소를 내부 버퍼에서 꺼내기를 시도합니다.
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ProducerConsumerCollectionBase`1.ToArray">
      <summary>
            내부 버퍼의 모든 요소를 배열로 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.ProducerConsumerCollectionBase`1.InnerCollection">
      <summary>
            내부 컬렉션
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.ProducerConsumerCollectionBase`1.Count">
      <summary>
            요수 수
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ObjectPool`1.#ctor(System.Func{`0})">
      <summary>
            constructor
            </summary>
      <param name="objectFactory">pool에 요소가 없을 때, 요소를 생성해서 제공하는 함수</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ObjectPool`1.#ctor(System.Func{`0},System.Collections.Concurrent.IProducerConsumerCollection{`0})">
      <summary>
            constructor
            </summary>
      <param name="objectFactory">pool에 요소가 없을 때, 요소를 생성해서 제공하는 함수</param>
      <param name="containedCollection">Pool의 요소들이 저장될 컬렉션</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ObjectPool`1.PutObject(`0)">
      <summary>
            Pool에 요소를 추가합니다.
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ObjectPool`1.GetObject">
      <summary>
            Pool에서 요소를 취한다. 없으면 <see cref="P:NSoft.NFramework.Parallelism.DataStructures.ObjectPool`1.ObjectFactory" />를 통해 생성한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ObjectPool`1.ToArrayAndClear">
      <summary>
            Pool에 있는 모든 요소를 배열로 반환하고, Pool을 비운다
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.ObjectPool`1.ObjectFactory">
      <summary>
            요소 생성 함수
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.ObservableConcurrentCollection`1">
      <summary>
            Data bining 을 위한 Thread-safe 컬렉션을 제공합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <seealso cref="T:System.ComponentModel.AsyncOperationManager" />
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ObservableConcurrentCollection`1.TryAdd(`0)">
      <summary>
            요소 추가를 시도합니다.
            </summary>
      <param name="item">추가할 요소</param>
      <returns>요소 추가 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ObservableConcurrentCollection`1.TryTake(`0@)">
      <summary>
            요소를 내부 버퍼에서 꺼내기를 시도합니다.
            </summary>
      <param name="item">꺼낸 요소</param>
      <returns>꺼내기 성공 여부</returns>
    </member>
    <member name="E:NSoft.NFramework.Parallelism.DataStructures.ObservableConcurrentCollection`1.CollectionChanged">
      <summary>
            Collection 변화에 대한 이벤트
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Parallelism.DataStructures.ObservableConcurrentCollection`1.PropertyChanged">
      <summary>
            속성 변화에 대한 이벤트
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.ObservableConcurrentDictionary`2">
      <summary>
            Data-biding 을 위한 Thread-safe한 Observable dictionary입니다.
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.Pipeline">
      <summary>
            pipeline data processing을 수행하는 <see cref="T:NSoft.NFramework.Parallelism.DataStructures.Pipeline`2" />을 생성시켜주는 Factory class 입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.Pipeline.Create``2(System.Func{``0,``1},System.Int32)">
      <summary>
            병렬 방식의 Pipeline 프로세스를 생성합니다.
            </summary>
      <typeparam name="TInput">
      </typeparam>
      <typeparam name="TOutput">
      </typeparam>
      <param name="func">
      </param>
      <param name="degreeOfParallelism">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.Pipeline`2">
      <summary>
            여러 개의 Mapping를 순차적으로 수행합니다. 이것이 Pipeline을 통과하면서, Data가 변화되는 것과 유사하다고 해서 Pipeline이라 합니다.
            이 클래스는 데이터에 대한 pipeline 작업을 병렬로 수행합하도록 해줍니다.
            </summary>
      <typeparam name="TInput">입력 변수의 수형</typeparam>
      <typeparam name="TOutput">출력 변수의 수형</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.Pipeline`2.Next``1(System.Func{`1,``0},System.Int32)">
      <summary>
            여러 단계의 매핑을 거쳐야 할 때, 매핑함수 chain을 만들도록 해준다.
            </summary>
      <typeparam name="TNextOutput">
      </typeparam>
      <param name="nextFunc">
      </param>
      <param name="degreeOfParallelism">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.Pipeline`2.Process(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            pipeline data processing을 실제 처리하고, 결과를 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.Pipeline`2.Process(System.Collections.Generic.IEnumerable{`0},System.Threading.CancellationToken)">
      <summary>
            pipeline data processing을 실제 처리하고, 결과를 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.Pipeline`2.ProcessInternal(System.Collections.Generic.IEnumerable{`0},System.Threading.CancellationToken,System.Collections.Concurrent.BlockingCollection{`1})">
      <summary>
            병렬로 입력을 출력으로 변화하는 작업을 수행합니다.
            </summary>
      <param name="source">
      </param>
      <param name="cancellationToken">
      </param>
      <param name="outputs">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.ProduceOrConsumeOnlyCollection`1">
      <summary>
            Producer 또는 Consumer 둘 중 하나만 가능한 컬렉션입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ProduceOrConsumeOnlyCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Boolean)">
      <summary>
            생성자
            </summary>
      <param name="containedCollection">초기 요소를 가진 컬렉션</param>
      <param name="produceOnly">Producer만 가능한가? (true라면 <see cref="M:NSoft.NFramework.Parallelism.DataStructures.ProduceOrConsumeOnlyCollection`1.TryAdd(`0)" />만 가능하고, false라면 <see cref="M:NSoft.NFramework.Parallelism.DataStructures.ProduceOrConsumeOnlyCollection`1.TryTake(`0@)" />만 가능하다)</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ProduceOrConsumeOnlyCollection`1.TryAdd(`0)">
      <summary>
            ProducerOnly Collection인 경우 요소를 추가할 수 있습니다.
            </summary>
      <param name="item">추가할 요소</param>
      <returns>추가 여부</returns>
      <exception cref="T:System.InvalidOperationException">ProducerOnly가 False이면, Consumer용 컬렉션이므로, 추가할 수 없습니다.</exception>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ProduceOrConsumeOnlyCollection`1.TryTake(`0@)">
      <summary>
            Consumer Only collection인 경우 요소를 꺼내갈 수 있다.
            </summary>
      <param name="item">꺼낸 요소</param>
      <returns>컬렉션에서 요소를 꺼낸는지 여부</returns>
      <exception cref="T:System.InvalidOperationException">ProducerOnly가 True이면, Producer Only 컬렉션이므로, 요소를 꺼낼 수 없습니다.</exception>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.ProduceOrConsumeOnlyCollection`1.ProducerOnly">
      <summary>
            공급자용 컬렉션이면 True, 소비자용 컬렉션이면 False
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.ReductionVariable`1">
      <summary>
            멀티쓰레드에 걸쳐져 도출되는 데이터를 하나로 취합하기 위한 변수입니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ReductionVariable`1.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ReductionVariable`1.#ctor(System.Func{`0})">
      <summary>
            생성자
            </summary>
      <param name="seedFactory">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ReductionVariable`1.Reduce(System.Func{`0,`0,`0})">
      <summary>
        <paramref name="function" />을 사용하여 다중 스레드의 값들을 취합합니다.
            </summary>
      <param name="function">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.ReductionVariable`1.Reduce``1(``0,System.Func{``0,`0,``0})">
      <summary>
        <paramref name="seed" />값을 초기값으로, <paramref name="function" /> 을 사용하여 다중 스레드의 값들을 취합합니다.
            </summary>
      <typeparam name="TAccumulate">
      </typeparam>
      <param name="seed">
      </param>
      <param name="function">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.ReductionVariable`1.Value">
      <summary>
            Value for the current thread.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.ReductionVariable`1.Values">
      <summary>
            이 인스턴스를 사용하는 모든 쓰레드의 값들을 가져옵니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.SerialTaskQueue">
      <summary>
            큐에 저장된 Task들을 순차적으로 실행하게 합니다. 
            실행할 Task들을 큐에 넣고, Completed().Wait()를 호출하면 큐의 모든 Task가 순차적으로 실행됩니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.SerialTaskQueue.Enqueue(System.Func{System.Threading.Tasks.Task})">
      <summary>
            지정한 작업 생성 함수로 생성되는 작업을 순차 수행을 위한 작업 큐에 넣습니다.
            </summary>
      <param name="taskFactory">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.SerialTaskQueue.Enqueue(System.Threading.Tasks.Task)">
      <summary>
            시작하지 않은 작업을 순차 수행을 위한 작업 큐에 넣습니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.SerialTaskQueue.Completed">
      <summary>
            큐에 남은 모든 작업이 완료되도록 한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.SpinLockClass">
      <summary>
        <see cref="T:System.Threading.SpinLock" /> struct를 단순히 Wrapping한 클래스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.SpinLockClass.#ctor">
      <summary>
            기본 생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.SpinLockClass.#ctor(System.Boolean)">
      <summary>
            생성자
            </summary>
      <param name="enableThreadOwnerTracking">디버깅을 위해 threadID를 Tracking 할 것인지 여부</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.SpinLockClass.Execute(System.Action)">
      <summary>
            지정된 delegate을 lock을 건 상태에서 실행합니다.
            </summary>
      <param name="runUnderLock">실행할 delegate</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.SpinLockClass.Enter(System.Boolean@)">
      <summary>
            Enters the lock. <paramref name="lockTaken" /> 은 입력 시에는 항상 False 값을 가져야 합니다.
            </summary>
      <param name="lockTaken">
            Upon exit of the Enter method, specifies whether the lock was acquired. 
            The variable passed by reference must be initialized to false.
            </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.SpinLockClass.Exit">
      <summary>
            Exit wrapped SpinLock
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.SpinLockClass.Exit(System.Boolean)">
      <summary>
            Exit wrapped SpinLock
            </summary>
      <param name="useMemoryBarrier">
            A Boolean value that indicates whether a memory fence should be issued in
            order to immediately publish the exit operation to other threads.
            </param>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DataStructures.TransferStream">
      <summary>
            Data를 대상 Stream에 Background Thread를 통해 쓰게 하는 Stream입니다. 
            Network 용 Stream 같은데 사용하면, 실제 쓸 데이터가 있는 경우만 쓰기 작업을 수행하고, 나머지 시간은 작업 대기를 하므로, CPU 사용이 거의 없다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.TransferStream.#ctor(System.IO.Stream)">
      <summary>
            생성자
            </summary>
      <param name="writableTargetStream">실제 Data가 쓰일 대상 Stream</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.TransferStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
        <paramref name="buffer" />의 내용을 복사해서 targetStream에 쓰는 작업을 예약합니다.
            </summary>
      <param name="buffer">대상 배열</param>
      <param name="offset">오프셋</param>
      <param name="count">쓸 바이트 수</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DataStructures.TransferStream.Close">
      <summary>
            스트림을 닫고, 모든 관련 리소스를 해제합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.DataStructures.TransferStream.CanWrite">
      <summary>
            쓰기 가능한 Stream 인지를 나타냄 (쓰기 가능함)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Drawing.FastBitmap">
      <summary>
        <see cref="P:NSoft.NFramework.Parallelism.Drawing.FastBitmap.Bitmap" />의 Pixel 처리를 신속하게 하기 위해, 기존 Bitmap을 Wrapping한 클래스입니다.
            lock/unlock을 통해 Bitmap Pixel 조작을 빠르게 수행할 수 있습니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Drawing.FastBitmap.#ctor(System.Drawing.Bitmap)">
      <summary>
            생성자
            </summary>
      <param name="bitmap">실제 처리할 Bitmap 인스턴스</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Drawing.FastBitmap.GetInitialPixelForRow(System.Int32)">
      <summary>
            지정한 Row의 전체 Pixel 정보를 제공하기 위해, 첫번째 컬럼의 PixelData 선두 번지를 제공합니다.
            </summary>
      <param name="rowNumber">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Drawing.FastBitmap.GetColor(System.Int32,System.Int32)">
      <summary>
            지정된 위치의 색상을 구합니다.
            </summary>
      <param name="x">row index</param>
      <param name="y">column index</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Drawing.FastBitmap.SetColor(System.Int32,System.Int32,System.Drawing.Color)">
      <summary>
            지정된 위치의 Pixel의 색상을 설정합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.Drawing.FastBitmap.Bitmap">
      <summary>
            실제 처리할 래핑된 Bitmap
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.Drawing.FastBitmap.Size">
      <summary>
            Bitmap Size
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.Drawing.FastBitmap.Item(System.Int32,System.Int32)">
      <summary>
        <see cref="T:NSoft.NFramework.Parallelism.Drawing.PixelData" />의 Pointer를 제공하는 인덱서입니다.
            </summary>
      <param name="x">row index</param>
      <param name="y">column index</param>
      <returns>
        <see cref="T:NSoft.NFramework.Parallelism.Drawing.PixelData" />의 포인터</returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Drawing.PixelData">
      <summary>
            Pixel RGB Data
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Parallelism.Drawing.PixelData.R">
      <summary>
            Red
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Parallelism.Drawing.PixelData.G">
      <summary>
            Green
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Parallelism.Drawing.PixelData.B">
      <summary>
            Blue
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Partitioners.BlockingCollectionPartitioner`1">
      <summary>
            BlockingCollection{T}의 소비자용 열거자(GetConsumingEnumerable())를 동적으로 배분하는 Partitioner입니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Partitioners.BlockingCollectionPartitioner`1.#ctor(System.Collections.Concurrent.BlockingCollection{`0})">
      <summary>
            생성자
            </summary>
      <param name="collection">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Partitioners.ChunkPartitioner">
      <summary>
            사용자가 제공하는 질의에 따라 컬렉션을 분할하여, 조각으로 제공하는 Static Class입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Partitioners.ChunkPartitioner.Create``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32})">
      <summary>
            사용자가 제공하는 다음 조각 크기를 구하는 함수에 따라, 분할을 수행하는 분할자를 제공합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <param name="source">
      </param>
      <param name="nextChunkSizeFunc">
      </param>
      <returns>
      </returns>
    </member>
    <member name="F:NSoft.NFramework.Parallelism.Partitioners.PartitionerTool.DefaultPartitionCount">
      <summary>
            특정 범위를 분할 할 때 기본 분할 갯수 (시스템의 Process 수와 같다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Partitioners.PartitionerTool.CreateRangePartition(System.Int32,System.Int32)">
      <summary>
            NET-4.0 에서만 지원하는 범위로 분할하는 분할자를 구현하였음. NET-3.5 환경에서만 사용하세요
            </summary>
      <param name="fromInclusive">
      </param>
      <param name="toExclusive">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Partitioners.PartitionerTool.CreateRangePartition(System.Int64,System.Int64)">
      <summary>
            NET-4.0에서만 지원하는 범위로 분할하는 분할자를 구현하였음. NET-3.5 환경에서만 사용하세요
            </summary>
      <param name="fromInclusive">
      </param>
      <param name="toExclusive">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Partitioners.SingleItemPartitioner">
      <summary>
            하나의 단위로 나누는 Partitioner입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.TaskSchedulers.ThreadPerTaskScheduler">
      <summary>
            작업당 하나의 Thread가 할당되는 스케쥴러입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.TaskSchedulers.ThreadPerTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
      <summary>
        <see cref="T:System.Threading.Tasks.Task" />를 스케줄러의 큐에 대기합니다.
            </summary>
      <param name="task">큐에 대기할 <see cref="T:System.Threading.Tasks.Task" />입니다.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="task" /> 인수가 null인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.TaskSchedulers.ThreadPerTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
      <summary>
            제공된 <see cref="T:System.Threading.Tasks.Task" />를 이 호출에서 동기적으로 실행할 수 있는지 확인하고 실행 가능할 경우 실행합니다.
            </summary>
      <returns>
            작업이 인라인으로 실행되었는지 여부를 나타내는 부울 값입니다.
            </returns>
      <param name="task">실행할 <see cref="T:System.Threading.Tasks.Task" />입니다.</param>
      <param name="taskWasPreviouslyQueued">
            작업이 이전에 큐에 대기되었는지 여부를 나타내는 부울입니다.
            이 매개 변수가 True이면 작업이 이전에 큐에 대기된 것일 수 있습니다.
            False이면 작업이 큐에 대기되지 않은 것입니다. 작업을 큐에 대기하지 않고 인라인으로 실행하려면 이 호출을 수행합니다.
            </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="task" /> 인수가 null인 경우</exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="task" />가 이미 실행되었습니다.</exception>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.TaskSchedulers.ThreadPerTaskScheduler.GetScheduledTasks">
      <summary>
            현재 스케줄러의 큐에 대기되어 실행을 기다리고 있는 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스의 열거 가능한 형식을 생성합니다.
            </summary>
      <returns>
            현재 이 스케줄러의 큐에 대기된 작업의 통과를 허용하는 열거 가능한 형식입니다.
            </returns>
      <exception cref="T:System.NotSupportedException">이 스케줄러는 현재 대기 중인 작업 목록을 생성할 수 없습니다.</exception>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.CompressorAsync">
      <summary>
            /// <summary>
            비동기 압축/복원을 지원하는 <see cref="T:NSoft.NFramework.Compressions.ICompressor" />의 확장 메소드를 제공합니다.
            </summary></summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.CompressorAsync.CompressTask(NSoft.NFramework.Compressions.ICompressor,System.Byte[])">
      <summary>
            비동기 방식으로 정보를 <paramref name="compressor" />로 압축합니다.
            </summary>
      <param name="compressor">압축기</param>
      <param name="input">압축할 내용</param>
      <returns>압축 작업</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.CompressorAsync.CompressTask(NSoft.NFramework.Compressions.ICompressor,System.IO.Stream)">
      <summary>
            지정한 <paramref name="stream" />을 비동기적으로 압축하는 Task를 빌드합니다.
            </summary>
      <param name="compressor">Compressor</param>
      <param name="stream">압축할 대상 스트림</param>
      <returns>압축된 스트림을 결과로 제공하는 <see cref="T:System.Threading.Tasks.Task`1" /></returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.CompressorAsync.DecompressTask(NSoft.NFramework.Compressions.ICompressor,System.Byte[])">
      <summary>
            비동기 방식으로 압축된 정보를 <paramref name="compressor" />로 복원합니다.
            </summary>
      <param name="compressor">압축기</param>
      <param name="input">압축 복원을 할 데이터</param>
      <returns>압축해제된 바이트 배열을 결과로 제공하는 <see cref="T:System.Threading.Tasks.Task`1" /></returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.CompressorAsync.DecompressTask(NSoft.NFramework.Compressions.ICompressor,System.IO.Stream)">
      <summary>
            지정한 <paramref name="stream" />을 비동기적으로 압축복원하는 Task를 빌드합니다.
            </summary>
      <param name="compressor">Compressor</param>
      <param name="stream">압축 해제할 스트림</param>
      <returns>압축해제된 스트림을 결과로 제공하는 <see cref="T:System.Threading.Tasks.Task`1" /></returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.DelegateAsync">
      <summary>
            Delegate를 비동기적으로 수행하도록 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DelegateAsync.Run(System.Action,System.Object)">
      <summary>
        <paramref name="action" />을 비동기 방식으로 수행합니다.
            </summary>
      <returns>Task 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DelegateAsync.Run``1(System.Action{``0},``0,System.Object)">
      <summary>
        <paramref name="action" />을 비동기 방식으로 수행합니다.
            </summary>
      <returns>Task 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DelegateAsync.Run``2(System.Action{``0,``1},``0,``1,System.Object)">
      <summary>
        <paramref name="action" />을 비동기 방식으로 수행합니다.
            </summary>
      <returns>Task 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DelegateAsync.Run``3(System.Action{``0,``1,``2},``0,``1,``2,System.Object)">
      <summary>
        <paramref name="action" />을 비동기 방식으로 수행합니다.
            </summary>
      <returns>Task 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DelegateAsync.Run``1(System.Func{``0},System.Object)">
      <summary>
        <paramref name="function" />을 비동기 방식으로 수행하는 Task{TResult} 를 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DelegateAsync.Run``2(System.Func{``0,``1},``0,System.Object)">
      <summary>
        <paramref name="function" />을 비동기 방식으로 수행하는 Task{TResult} 를 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DelegateAsync.Run``3(System.Func{``0,``1,``2},``0,``1,System.Object)">
      <summary>
        <paramref name="function" />을 비동기 방식으로 수행하는 Task{TResult} 를 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DelegateAsync.Run``4(System.Func{``0,``1,``2,``3},``0,``1,``2,System.Object)">
      <summary>
        <paramref name="function" />을 비동기 방식으로 수행하는 Task{TResult} 를 반환합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.DnsAsync">
      <summary>
        <see cref="T:System.Net.Dns" /> 관련 메소드를 비동기 실행할 수 있도록 합니다.
            </summary>
      <remarks>
            참고 사이트 :
            <list><item>http://msdn.microsoft.com/ko-kr/library/ms228963.aspx</item><item>http://msdn.microsoft.com/ko-kr/library/dd997423.aspx</item></list></remarks>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DnsAsync.GetHostAddresses(System.String)">
      <summary>
        <paramref name="hostNameOrAddress" />에 해당하는 <see cref="T:System.Net.IPAddress" /> 들을 비동기적으로 조회합니다.
            </summary>
      <param name="hostNameOrAddress">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DnsAsync.GetHostEntry(System.Net.IPAddress)">
      <summary>
            호스트 이름 또는 IP 주소로 <see cref="T:System.Net.IPHostEntry" />로 빌드합니다.
            </summary>
      <param name="address">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DnsAsync.GetHostEntry(System.String)">
      <summary>
            호스트 이름 또는 IP 주소로 <see cref="T:System.Net.IPHostEntry" />로 빌드합니다.
            </summary>
      <param name="hostNameOrAddress">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.FileAsync">
      <summary>
            APM 방식의 비동기 파일 작업을 제공합니다.
            </summary>
      <remarks>
            참고 사이트 :
            <list><item>http://msdn.microsoft.com/ko-kr/library/ms228963.aspx</item><item>http://msdn.microsoft.com/ko-kr/library/dd997423.aspx</item></list></remarks>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.FileAsync.OpenRead(System.String)">
      <summary>
            비동기적으로 읽기 위한 FileStream 을 생성합니다.
            </summary>
      <param name="path">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.FileAsync.OpenWrite(System.String)">
      <summary>
            지정한 파일을 비동기적으로 쓰기 위한 FileStream을 생성합니다.
            </summary>
      <param name="path">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.FileAsync.ReadAllBytes(System.String)">
      <summary>
            지정한 파일을 비동기적으로 읽어 byte[] 을 반환하는 <see cref="T:System.Threading.Tasks.Task" />를 빌드합니다.
            </summary>
      <param name="path">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.FileAsync.ReadAllText(System.String,System.Text.Encoding)">
      <summary>
            지정한 경로의 파일 내용을 비동기적으로 모두 읽어 문자열로 반환하는 Task를 빌드합니다.
            </summary>
      <param name="path">읽을 파일 전체경로</param>
      <param name="encoding">파일 내용 인코딩 방식</param>
      <returns>파일 내용을 문자열로 반환하는 작업</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.FileAsync.WriteAllBytes(System.String,System.Byte[])">
      <summary>
            비동기적으로 <paramref name="bytes" /> 내용을 파일에 씁니다.
            </summary>
      <param name="path">
      </param>
      <param name="bytes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.FileAsync.WriteAllText(System.String,System.String,System.Text.Encoding)">
      <summary>
            비동기적으로 지정된 내용을 지정된 인코딩 방식으로 파일에 씁니다.
            </summary>
      <param name="path">경로</param>
      <param name="contents">쓸 내용</param>
      <param name="encoding">인코딩 방식</param>
      <returns>파일 쓰기 작업</returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.StreamAsync">
      <summary>
            비동기적 스트림 작업에 쓰이는 Extension Method 들입니다.
            </summary>
      <remarks>
            참고 사이트 :
            <list><item>http://msdn.microsoft.com/ko-kr/library/ms228963.aspx</item><item>http://msdn.microsoft.com/ko-kr/library/dd997423.aspx</item></list></remarks>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.StreamAsync.ReadAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
      <summary>
            지정된 스트림을 비동기 방식으로 읽어, <paramref name="buffer" />에 채웁니다. 작업의 결과는 읽은 바이트 수입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.StreamAsync.WriteAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
      <summary>
        <paramref name="buffer" /> 내용을 지정된 스트림에 비동기 방식으로 씁니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.StreamAsync.ReadAllBytesAsync(System.IO.Stream)">
      <summary>
        <paramref name="stream" />의 모든 Data를 비동기 방식으로 읽는 작업을 생성합니다.
            </summary>
      <param name="stream">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.StreamAsync.ReadBufferAsync(System.IO.Stream,System.Int32,System.Action{System.Byte[],System.Int32})">
      <summary>
        <paramref name="stream" /> 을 비동기 방식으로 반복해서 읽어드리는 Task를 빌드합니다.
            </summary>
      <param name="stream">읽을 스트림 객체</param>
      <param name="bufferSize">한번에 읽을 버퍼 크기</param>
      <param name="bufferAvailable">읽은 버퍼가 유효한 것인지 판단하는 델리게이트</param>
      <returns>비동기 방식의 읽기 작업</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.StreamAsync.CopyStreamToFileAsync(System.IO.Stream,System.String)">
      <summary>
        <paramref name="source" />를 읽어 <paramref name="destinationPath" /> 의 파일에 비동기적으로 씁니다.
            </summary>
      <param name="source">
      </param>
      <param name="destinationPath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.StreamAsync.CopyStreamToStreamAsync(System.IO.Stream,System.IO.Stream)">
      <summary>
        <paramref name="source" />를 읽어 <paramref name="destination" />에 비동기적으로 씁니다.
            </summary>
      <param name="source">
      </param>
      <param name="destination">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.WebRequestAsync">
      <summary>
        <see cref="T:System.Net.WebRequest" />를 APM (Asynchronous Programming Model-비동기 프로그래밍 모델) 방식으로 수행하는 Extension Method를 제공합니다.
            </summary>
      <remarks>
            참고 사이트 :
            <list><item>http://msdn.microsoft.com/ko-kr/library/ms228963.aspx</item><item>http://msdn.microsoft.com/ko-kr/library/dd997423.aspx</item></list></remarks>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebRequestAsync.GetResponseAsync(System.Net.WebRequest)">
      <summary>
        <paramref name="webRequest" />를 비동기적으로 실행하여, <see cref="T:System.Net.WebResponse" />를 얻는 <see cref="T:System.Threading.Tasks.Task" />를 생성합니다.
            응답 결과가 gzip, deflate 방식으로 압축되어서 올 수 있습니다. Response Header의 Content-Encoding을 확인하여 처리하셔야 합니다.
            아니면 DownloadDataAsync를 사용하세요.
            </summary>
      <param name="webRequest">Http 요청 객체</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebRequestAsync.GetResponseStreamAsync(System.Net.WebRequest)">
      <summary>
        <paramref name="webRequest" />로부터 요청 스트림을 비동기적으로 얻는 <see cref="T:System.Threading.Tasks.Task" />를 생성합니다.
            </summary>
      <param name="webRequest">Http 요청 객체</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebRequestAsync.DownloadDataAsync(System.Net.WebRequest)">
      <summary>
        <paramref name="webRequest" />로부터 데이타를 비동기적으로 다운받는 <see cref="T:System.Threading.Tasks.Task" />를 생성합니다.
            압축된 결과가 왔을 경우, 복원하여 데이타를 전달합니다.
            </summary>
      <param name="webRequest">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebRequestAsync.GetResponseStreamByContentEncoding(System.Net.WebResponse)">
      <summary>
            응답 정보의 헤더에 압축이 되어 있다면, 압축을 풀어서 제공하고, 아니면, 그냥 제공한다.
            </summary>
      <param name="response">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebRequestAsync.GetResponseDataByContentEncoding(System.Net.WebResponse)">
      <summary>
            응답 정보의 헤더에 압축이 되어 있다면, 압축을 풀어서 제공하고, 아니면, 그냥 제공한다.
            </summary>
      <param name="response">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.EventAsyncPattern">
      <summary>
            EAP (Event-based Asynchronous Pattern : 이벤트기반 비동기 패턴) 작업에서, 작업 완료에 따른 후속조치를 정의하는 함수를 제공합니다.
            </summary>
      <remarks>
            참고사이트:
            <list><item>http://msdn.microsoft.com/ko-kr/library/wewwczdw.aspx</item><item>http://msdn.microsoft.com/ko-kr/library/dd997423.aspx</item></list></remarks>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.EventAsyncPattern.HandleCompletion``1(System.Threading.Tasks.TaskCompletionSource{``0},System.ComponentModel.AsyncCompletedEventArgs,System.Func{``0},System.Action)">
      <summary>
            EAP (Event-based Asynchronous Pattern : 이벤트기반 비동기 패턴) 작업에서, 작업 완료시의 후속조치를 정의합니다.
            </summary>
      <typeparam name="T">비동기 작업 결과물의 수형</typeparam>
      <param name="tcs">비동기 작업을 표현하는 delegate</param>
      <param name="e">비동기 작업완료 이벤트 인자</param>
      <param name="getResult">작업완료 시에 결과 반환 메소드</param>
      <param name="unregisterHandler">작업완료 이벤트 핸들러를 등록취소하는 Action</param>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.PingAsync">
      <summary>
            "Ping" 을 EAP (Event-based Asynchronous Pattern-이벤트 기반 비동기 패턴) 방식의 작업으로 수행하는 Extension Methods입니다.
            </summary>
      <remarks>
            참고사이트:
            <list><item>http://msdn.microsoft.com/ko-kr/library/wewwczdw.aspx</item><item>http://msdn.microsoft.com/ko-kr/library/dd997423.aspx</item></list></remarks>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PingAsync.SendTask(System.Net.NetworkInformation.Ping,System.Net.IPAddress,System.Int32,System.Byte[],System.Net.NetworkInformation.PingOptions,System.Object)">
      <summary>
            Internet Control Message Protocol (ICMP) echo message 를 비동기적으로 보냅니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PingAsync.SendTask(System.Net.NetworkInformation.Ping,System.Net.IPAddress,System.Int32,System.Byte[],System.Object)">
      <summary>
            Internet Control Message Protocol (ICMP) echo message 를 비동기적으로 보냅니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PingAsync.SendTask(System.Net.NetworkInformation.Ping,System.Net.IPAddress,System.Int32,System.Object)">
      <summary>
            Internet Control Message Protocol (ICMP) echo message 를 비동기적으로 보냅니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PingAsync.SendTask(System.Net.NetworkInformation.Ping,System.Net.IPAddress,System.Object)">
      <summary>
            Internet Control Message Protocol (ICMP) echo message 를 비동기적으로 보냅니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PingAsync.SendTask(System.Net.NetworkInformation.Ping,System.String,System.Int32,System.Byte[],System.Net.NetworkInformation.PingOptions,System.Object)">
      <summary>
            Internet Control Message Protocol (ICMP) echo message 를 비동기적으로 보냅니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PingAsync.SendTask(System.Net.NetworkInformation.Ping,System.String,System.Int32,System.Byte[],System.Object)">
      <summary>
            Internet Control Message Protocol (ICMP) echo message 를 비동기적으로 보냅니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PingAsync.SendTask(System.Net.NetworkInformation.Ping,System.String,System.Int32,System.Object)">
      <summary>
            Internet Control Message Protocol (ICMP) echo message 를 비동기적으로 보냅니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PingAsync.SendTask(System.Net.NetworkInformation.Ping,System.String,System.Object)">
      <summary>
            Internet Control Message Protocol (ICMP) echo message 를 비동기적으로 보냅니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.SmtpClientAsync">
      <summary>
        <see cref="T:System.Net.Mail.SmtpClient" />를 EAP (이벤트 기반 비동기 패턴)으로 수행하는 확장 메소드를 제공합니다.
            </summary>
      <remarks>
            참고사이트:
            <list><item>http://msdn.microsoft.com/ko-kr/library/wewwczdw.aspx</item><item>http://msdn.microsoft.com/ko-kr/library/dd997423.aspx</item></list></remarks>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.SmtpClientAsync.SendTask(System.Net.Mail.SmtpClient,System.String,System.String,System.String,System.String,System.Object)">
      <summary>
            메일을 비동기적으로 전송하는 Task{bool}을 빌드합니다.
            </summary>
      <param name="client">smtp client</param>
      <param name="from">메일 발송자</param>
      <param name="recipients">메일 수신자들, 구분을 세미콜론(';') 또는 콤마(',')로 구분합니다.</param>
      <param name="subject">메일 제목</param>
      <param name="body">메일 본문</param>
      <param name="userToken">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.SmtpClientAsync.SendTask(System.Net.Mail.SmtpClient,System.Threading.CancellationToken,System.String,System.String,System.String,System.String,System.Object)">
      <summary>
            메일을 비동기적으로 전송하는 Task{bool}을 빌드합니다.
            </summary>
      <param name="client">smtp client</param>
      <param name="token">작업 취소용 Token</param>
      <param name="from">메일 발송자</param>
      <param name="recipients">메일 수신자들, 구분을 세미콜론(';') 또는 콤마(',')로 구분합니다.</param>
      <param name="subject">메일 제목</param>
      <param name="body">메일 본문</param>
      <param name="userToken">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.SmtpClientAsync.SendTask(System.Net.Mail.SmtpClient,System.Net.Mail.MailMessage,System.Object)">
      <summary>
            메일을 비동기적으로 전송하는 Task{bool}을 빌드합니다.
            </summary>
      <param name="client">smtp client</param>
      <param name="message">mail message</param>
      <param name="userToken">
      </param>
      <returns>비동기 작업을 수행하는 Task{bool}</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.SmtpClientAsync.SendTask(System.Net.Mail.SmtpClient,System.Threading.CancellationToken,System.Net.Mail.MailMessage,System.Object)">
      <summary>
            메일을 비동기적으로 전송하는 Task{bool}을 빌드합니다.
            </summary>
      <param name="client">smtp client</param>
      <param name="token">작업 취소용 Token</param>
      <param name="message">mail message</param>
      <param name="userToken">
      </param>
      <returns>비동기 작업을 수행하는 Task{bool}</returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.WebClientAsync">
      <summary>
        <see cref="T:System.Net.WebClient" />를 EAP (Event-driven Asynchronous Pattern) 방식의 비동기 작업을 수행하는 확장 메소드를 제공합니다.<br /></summary>
      <remarks>
            참고사이트:
            <list><item>http://msdn.microsoft.com/ko-kr/library/wewwczdw.aspx</item><item>http://msdn.microsoft.com/ko-kr/library/dd997423.aspx</item></list></remarks>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadDataTask(System.Net.WebClient,System.String)">
      <summary>
        <paramref name="address" />의 리소스를 비동기적으로 다운받아 byte array로 반환하는 Task{byte[]}를 빌드합니다.
            </summary>
      <param name="webClient">
        <see cref="T:System.Net.WebClient" /> 인스턴스</param>
      <param name="address">리소스 위치</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadDataTask(System.Net.WebClient,System.Uri)">
      <summary>
        <paramref name="address" />의 리소스를 비동기적으로 다운받아 byte array로 반환하는 Task{byte[]}를 빌드합니다.
            </summary>
      <param name="webClient">
        <see cref="T:System.Net.WebClient" /> 인스턴스</param>
      <param name="address">리소스 위치</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadDataTask(System.Net.WebClient,System.Threading.CancellationToken,System.String)">
      <summary>
        <paramref name="address" />의 리소스를 비동기적으로 다운받아 byte array로 반환하는 Task{byte[]}를 빌드합니다.
            </summary>
      <param name="webClient">
        <see cref="T:System.Net.WebClient" /> 인스턴스</param>
      <param name="token">작업 취소를 위한 Token</param>
      <param name="address">리소스 위치</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadDataTask(System.Net.WebClient,System.Threading.CancellationToken,System.Uri)">
      <summary>
        <paramref name="address" />의 리소스를 비동기적으로 다운받아 byte array로 반환하는 Task{byte[]}를 빌드합니다.
            </summary>
      <param name="webClient">
        <see cref="T:System.Net.WebClient" /> 인스턴스</param>
      <param name="token">작업 취소를 위한 Token</param>
      <param name="address">리소스 위치</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadFileTask(System.Net.WebClient,System.String,System.String)">
      <summary>
        <paramref name="address" />의 리소스 정보를 파일로 저장합니다.
            </summary>
      <param name="webClient">
      </param>
      <param name="address">다운 받을 리소스의 주소</param>
      <param name="filename">다운로드 리소스를 저장할 로컬 파일명</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadFileTask(System.Net.WebClient,System.Uri,System.String)">
      <summary>
        <paramref name="address" />의 리소스 정보를 비동기적으로 다운받아 파일로 저장합니다.
            </summary>
      <param name="webClient">
      </param>
      <param name="address">다운 받을 리소스의 주소</param>
      <param name="filename">다운로드 리소스를 저장할 로컬 파일명</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadFileTask(System.Net.WebClient,System.Threading.CancellationToken,System.String,System.String)">
      <summary>
        <paramref name="address" />의 리소스 정보를 비동기적으로 다운받아 파일로 저장합니다.
            </summary>
      <param name="webClient">
      </param>
      <param name="token">작업 취소용 Token</param>
      <param name="address">다운 받을 리소스의 주소</param>
      <param name="filename">다운로드 리소스를 저장할 로컬 파일명</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadFileTask(System.Net.WebClient,System.Threading.CancellationToken,System.Uri,System.String)">
      <summary>
        <paramref name="address" />의 리소스 정보를 비동기적으로 다운받아 파일로 저장합니다.
            </summary>
      <param name="webClient">
      </param>
      <param name="token">작업 취소용 Token</param>
      <param name="address">다운 받을 리소스의 주소</param>
      <param name="filename">다운로드 리소스를 저장할 로컬 파일명</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadStringTask(System.Net.WebClient,System.String)">
      <summary>
            지정된 Uri로부터, 리소스를 문자열로 비동기적으로 다운 받습니다. 
            인코딩 문제가 있을 때에는 <see cref="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadDataTask(System.Net.WebClient,System.String)" />를 이용하여 Encoding을 직접 설정해 주시기 바랍니다.
            </summary>
      <param name="webClient">
      </param>
      <param name="address">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadStringTask(System.Net.WebClient,System.Uri)">
      <summary>
            지정된 Uri로부터, 리소스를 문자열로 비동기적으로 다운 받습니다. 
            인코딩 문제가 있을 때에는 <see cref="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadDataTask(System.Net.WebClient,System.Uri)" />를 이용하여 Encoding을 직접 설정해 주시기 바랍니다.
            </summary>
      <param name="webClient">
        <see cref="T:System.Net.WebClient" /> 인스턴스</param>
      <param name="address">리소스 위치</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadStringTask(System.Net.WebClient,System.Threading.CancellationToken,System.String)">
      <summary>
            지정된 Uri로부터, 리소스를 문자열로 비동기적으로 다운 받습니다. 
            인코딩 문제가 있을 때에는 <see cref="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadDataTask(System.Net.WebClient,System.Uri)" />를 이용하여 Encoding을 직접 설정해 주시기 바랍니다.
            </summary>
      <param name="webClient">
        <see cref="T:System.Net.WebClient" /> 인스턴스</param>
      <param name="token">작업 취소를 위한 Token</param>
      <param name="address">리소스 위치</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadStringTask(System.Net.WebClient,System.Threading.CancellationToken,System.Uri)">
      <summary>
            지정된 Uri로부터, 리소스를 문자열로 비동기적으로 다운 받습니다. 
            인코딩 문제가 있을 때에는 <see cref="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.DownloadDataTask(System.Net.WebClient,System.Uri)" />를 이용하여 Encoding을 직접 설정해 주시기 바랍니다.
            </summary>
      <param name="webClient">
        <see cref="T:System.Net.WebClient" /> 인스턴스</param>
      <param name="token">작업 취소를 위한 Token</param>
      <param name="address">리소스 위치</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.OpenReadTask(System.Net.WebClient,System.String)">
      <summary>
        <paramref name="address" />의 리소스 정보를 읽기 위해 <see cref="T:System.IO.Stream" />을 비동기적으로 엽니다.
            </summary>
      <param name="webClient">WebClient 인스턴스</param>
      <param name="address">리소스의 주소</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.OpenReadTask(System.Net.WebClient,System.Uri)">
      <summary>
        <paramref name="address" />의 리소스 정보를 읽기 위해 <see cref="T:System.IO.Stream" />을 비동기적으로 엽니다.
            </summary>
      <param name="webClient">WebClient 인스턴스</param>
      <param name="address">리소스의 주소</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.OpenReadTask(System.Net.WebClient,System.Threading.CancellationToken,System.String)">
      <summary>
        <paramref name="address" />의 리소스 정보를 읽기 위해 <see cref="T:System.IO.Stream" />을 비동기적으로 엽니다.
            </summary>
      <param name="webClient">WebClient 인스턴스</param>
      <param name="token">작업 취소를 위한 Token</param>
      <param name="address">리소스의 주소</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.OpenReadTask(System.Net.WebClient,System.Threading.CancellationToken,System.Uri)">
      <summary>
        <paramref name="address" />의 리소스 정보를 읽기 위해 <see cref="T:System.IO.Stream" />을 비동기적으로 엽니다.
            </summary>
      <param name="webClient">WebClient 인스턴스</param>
      <param name="token">작업 취소를 위한 Token</param>
      <param name="address">리소스의 주소</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.OpenWriteTask(System.Net.WebClient,System.String,System.String)">
      <summary>
        <paramref name="address" />에 비동기적으로 data를 전송하기 위한 쓰기용 Stream을 반환합니다.
            </summary>
      <param name="webClient">WebClient 인스턴스</param>
      <param name="address">리소스의 주소</param>
      <param name="method">전송 방법 : Http인 경우는 POST, FTP인 경우는 STOR입니다.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.OpenWriteTask(System.Net.WebClient,System.Uri,System.String)">
      <summary>
        <paramref name="address" />에 비동기적으로 data를 전송하기 위한 쓰기용 Stream을 반환합니다.
            </summary>
      <param name="webClient">WebClient 인스턴스</param>
      <param name="address">리소스의 주소</param>
      <param name="method">전송 방법 : Http인 경우는 POST, FTP인 경우는 STOR입니다.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.OpenWriteTask(System.Net.WebClient,System.Threading.CancellationToken,System.String,System.String)">
      <summary>
        <paramref name="address" />에 비동기적으로 data를 전송하기 위한 쓰기용 Stream을 반환합니다.
            </summary>
      <param name="webClient">WebClient 인스턴스</param>
      <param name="token">작업 취소를 위한 Token</param>
      <param name="address">리소스의 주소</param>
      <param name="method">전송 방법 : Http인 경우는 POST, FTP인 경우는 STOR입니다.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.OpenWriteTask(System.Net.WebClient,System.Threading.CancellationToken,System.Uri,System.String)">
      <summary>
        <paramref name="address" />에 비동기적으로 data를 전송하기 위한 쓰기용 Stream을 반환합니다.
            </summary>
      <param name="webClient">WebClient 인스턴스</param>
      <param name="token">작업 취소를 위한 Token</param>
      <param name="address">리소스의 주소</param>
      <param name="method">전송 방법 : Http인 경우는 POST, FTP인 경우는 STOR입니다.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.UploadDataTask(System.Net.WebClient,System.String,System.String,System.Byte[])">
      <summary>
        <paramref name="address" />에 <paramref name="data" />를 비동기적으로 전송합니다.
            </summary>
      <param name="webClient">
      </param>
      <param name="address">데이타를 전송할 주소</param>
      <param name="method">데이타 전송 방법 (HTTP는 POST, FTP는 STOR)</param>
      <param name="data">전송할 데이타</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.UploadDataTask(System.Net.WebClient,System.Uri,System.String,System.Byte[])">
      <summary>
        <paramref name="address" />에 <paramref name="data" />를 비동기적으로 전송합니다.
            </summary>
      <param name="webClient">
      </param>
      <param name="address">데이타를 전송할 주소</param>
      <param name="method">데이타 전송 방법 (HTTP는 POST, FTP는 STOR)</param>
      <param name="data">전송할 데이타</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.UploadFileTask(System.Net.WebClient,System.String,System.String,System.String)">
      <summary>
        <paramref name="address" />에 <paramref name="filename" />의 파일을 전송합니다. (HTTP나 FTP나 같습니다)
            </summary>
      <param name="webClient">
        <see cref="T:System.Net.WebClient" /> 인스턴스</param>
      <param name="address">전송할 주소</param>
      <param name="method">전송 방법 (HTTP는 POST, FTP는 STOR)</param>
      <param name="filename">전송할 파일의 전체경로</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.UploadFileTask(System.Net.WebClient,System.Uri,System.String,System.String)">
      <summary>
        <paramref name="address" />에 <paramref name="filename" />의 파일을 전송합니다. (HTTP나 FTP나 같습니다)
            </summary>
      <param name="webClient">
        <see cref="T:System.Net.WebClient" /> 인스턴스</param>
      <param name="address">전송할 주소</param>
      <param name="method">전송 방법 (HTTP는 POST, FTP는 STOR)</param>
      <param name="filename">전송할 파일의 전체경로</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.UploadStringTask(System.Net.WebClient,System.String,System.String,System.String)">
      <summary>
        <paramref name="address" />에 <paramref name="data" /> 문자열을 전송합니다. (HTTP나 FTP나 같습니다)
            </summary>
      <param name="webClient">
        <see cref="T:System.Net.WebClient" /> 인스턴스</param>
      <param name="address">전송할 주소</param>
      <param name="method">전송 방법 (HTTP는 POST, FTP는 STOR)</param>
      <param name="data">전송할 문자열</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.WebClientAsync.UploadStringTask(System.Net.WebClient,System.Uri,System.String,System.String)">
      <summary>
        <paramref name="address" />에 <paramref name="data" /> 문자열을 전송합니다. (HTTP나 FTP나 같습니다)
            </summary>
      <param name="webClient">
        <see cref="T:System.Net.WebClient" /> 인스턴스</param>
      <param name="address">전송할 주소</param>
      <param name="method">전송 방법 (HTTP는 POST, FTP는 STOR)</param>
      <param name="data">전송할 문자열</param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.AggregateExceptionTool">
      <summary>
        <see cref="T:System.AggregateException" />을 위한 확장 메소드 들입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.AggregateExceptionTool.Handle(System.AggregateException,System.Func{System.Exception,System.Boolean},System.Boolean)">
      <summary>
        <see cref="T:System.AggregateException" />이 가진 모든 Exception에 대해 handler를 호출합니다.
            </summary>
      <param name="aggregateException">
      </param>
      <param name="predicate">
      </param>
      <param name="leaveStructureIntact">AggregateException의 내부 Exception이 AggregateException인 경우, 재귀호출을 통해 점검할 것인가 여부</param>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.CancellationTokenTool">
      <summary>
        <see cref="T:System.Threading.CancellationTokenSource" />에 대한 Extension Method를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.CancellationTokenTool.CancelAndThrow(System.Threading.CancellationTokenSource)">
      <summary>
        <paramref name="source" />를 취소하고, <see cref="T:System.OperationCanceledException" />을 발생시키도록 합니다.
            </summary>
      <param name="source">The source to be canceled.</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.CancellationTokenTool.CreateLinkedSource(System.Threading.CancellationToken)">
      <summary>
        <paramref name="token" />이 취소 요청을 받았을 때, 같이 취소되게끔 연결된(Linked) <see cref="T:System.Threading.CancellationTokenSource" />를 생성합니다.
            </summary>
      <param name="token">The token.</param>
      <returns>The created CancellationTokenSource.</returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.CompletedTask">
      <summary>
            이미 완료된 Task (CompletedTask)에 대한 접근을 제공합니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Parallelism.Tools.CompletedTask.Default">
      <summary>
            기본 작업
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.CompletedTask`1">
      <summary>
            이미 완료된 Task (CompletedTask)에 대한 접근을 제공합니다.
            </summary>
      <typeparam name="TResult">작업 결과 값의 수형</typeparam>
    </member>
    <member name="F:NSoft.NFramework.Parallelism.Tools.CompletedTask`1.Default">
      <summary>
            기본 작업
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.DelegateTool">
      <summary>
            Delegate를 병렬방식으로 수행하는 메소드를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DelegateTool.ParallelDynamicInvoke(System.Delegate,System.Object[])">
      <summary>
        <paramref name="multicastDelegate" />의 delegate들을 병렬로 DynamicInvoke() 를 수행하고, 제일 마지막 수행 결과를 반환합니다. (WaitAll)
            Speculative Processing (WaitAny)의 반대이지요. 
            </summary>
      <param name="multicastDelegate">호출할 델리게이트</param>
      <param name="args">호출 시 인자값</param>
      <returns>호출 결과 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DelegateTool.WithFailFast(System.Action)">
      <summary>
        <paramref name="action" />을 수행할 때, 예외가 발생하면 try-finally block이나 종료자를 수행하지 않고 빠져나가도록 Wrapping합니다. 
            (이런 수행 방식을 Fail Fast라고 합니다.)
            </summary>
      <param name="action">수행할 action</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.DelegateTool.WithFailFast``1(System.Func{``0})">
      <summary>
        <paramref name="function" />을 수행할 때, 예외가 발생하면 try-finally block이나 종료자를 수행하지 않고 빠져나가도록 Wrapping합니다. 
            (이런 수행 방식을 Fail Fast라고 합니다.)
            </summary>
      <typeparam name="T">함수의 반환 값의 수형</typeparam>
      <param name="function">수행할 함수</param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.LazyTool">
      <summary>
            Lazy{T} 를 위한 Extension Methods 입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.LazyTool.Force``1(System.Lazy{``0})">
      <summary>
            지정된 Lazy{T} 인스턴스의 실제 값을 현 시점에서 생성하는 작업을 수행하도록 한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.LazyTool.GetValueAsync``1(System.Lazy{``0})">
      <summary>
            Future Pattern을 사용하여 Lazy{T}의 실제 값을 구하는 Task{T}를 빌드합니다.
            Lazy 자체가 그 일을 하는 것인데 뭔말인가? 궁금해 하는 사람들에게... 
            Lazy.Value를 구하는 작업이 많은 부하를 가질 때, 다른 작업으로 분리해서 비동기적으로 수행하도록 하면, 전체적으로 더 좋은 결과를 얻을 수 있다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.LazyTool.GetValueTask``1(System.Lazy{``0})">
      <summary>
            Lazy{T} 값 계산이 많은 시간이 걸릴 경우, 비동기 델리게이트 호출 이용한 계산에 의해 값을 구하는 Task{T} 를 빌드합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="lazy">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.LazyTool.CreateLazy``1(``0,System.Boolean)">
      <summary>
            Thread-safe 한 <paramref name="value" /> 값으로 초기화된 Lazy{T} 인스턴스를 생성합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="value">
      </param>
      <param name="isThreadSafe">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.ParallelTool">
      <summary>
            병렬 프로그래밍 관련 알고리즘을 제공하는 클래스입니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Parallelism.Tools.ParallelTool.DefaultParallelOptions">
      <summary>
            기본 속성을 가지는 <see cref="T:System.Threading.Tasks.ParallelOptions" /> 인스턴스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Filter``1(System.Collections.Generic.IList{``0},System.Func{``0,System.Boolean})">
      <summary>
            컬렉션에서 검사자를 만족하는 요소들만 병렬로 필터링합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Filter``1(System.Collections.Generic.IList{``0},System.Threading.Tasks.ParallelOptions,System.Func{``0,System.Boolean})">
      <summary>
            컬렉션에서 검사자를 만족하는 요소들만 병렬로 필터링합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.For(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Action{System.Numerics.BigInteger})">
      <summary>
        <see cref="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />의 BigInteger 버전
            </summary>
      <param name="fromInclusive">
      </param>
      <param name="toExclusive">
      </param>
      <param name="body">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.For(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Threading.Tasks.ParallelOptions,System.Action{System.Numerics.BigInteger})">
      <summary>
        <see cref="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />의 BigInteger 버전
            </summary>
      <param name="fromInclusive">
      </param>
      <param name="toExclusive">
      </param>
      <param name="options">
      </param>
      <param name="body">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForWithStep(System.Int32,System.Int32,System.Int32,System.Action{System.Int32})">
      <summary>
        <paramref name="step" />이 있는 for loop 를 병렬 수행합니다. for(i=fromInclusive; i &lt; toExclusive; i+=step)
            </summary>
      <param name="fromInclusive">loop 하한 인덱스</param>
      <param name="toExclusive">loop 상한 인덱스</param>
      <param name="step">반복 인덱스 Step</param>
      <param name="body">병렬 실행할 메소드</param>
      <returns>/실행 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForWithStep(System.Int32,System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})">
      <summary>
        <paramref name="step" />이 있는 for loop 를 병렬 수행합니다.	for(i=fromInclusive; i &lt; toExclusive; i+=step)
            </summary>
      <param name="fromInclusive">loop 하한 인덱스</param>
      <param name="toExclusive">loop 상한 인덱스</param>
      <param name="step">반복 인덱스 Step</param>
      <param name="parallelOptions">병렬 옵션</param>
      <param name="body">병렬 실행할 메소드</param>
      <returns>/실행 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForWithStep(System.Int32,System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})">
      <summary>
        <paramref name="step" />이 있는 for loop 를 병렬 수행합니다.	for(i=fromInclusive; i &lt; toExclusive; i+=step)
            </summary>
      <param name="fromInclusive">loop 하한 인덱스</param>
      <param name="toExclusive">loop 상한 인덱스</param>
      <param name="step">반복 인덱스 Step</param>
      <param name="body">병렬 실행할 메소드</param>
      <returns>/실행 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForWithStep(System.Int32,System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})">
      <summary>
        <paramref name="step" />이 있는 for loop 를 병렬 수행합니다.	for(i=fromInclusive; i &lt; toExclusive; i+=step)
            </summary>
      <param name="fromInclusive">loop 하한 인덱스</param>
      <param name="toExclusive">loop 상한 인덱스</param>
      <param name="step">반복 인덱스 Step</param>
      <param name="parallelOptions">병렬 옵션</param>
      <param name="body">병렬 실행할 메소드</param>
      <returns>/실행 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForWithStep``1(System.Int32,System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <summary>
        <paramref name="step" />이 있는 for loop 를 병렬 수행합니다.	for(i=fromInclusive; i &lt; toExclusive; i+=step)
            </summary>
      <param name="fromInclusive">loop 하한 인덱스</param>
      <param name="toExclusive">loop 상한 인덱스</param>
      <param name="step">반복 인덱스 Step</param>
      <param name="localInit">로컬 변수값 초기화</param>
      <param name="body">로컬값을 반환하는 병렬 실행할 함수</param>
      <param name="localFinally">최종 로컬 정리 action</param>
      <returns>/실행 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForWithStep``1(System.Int32,System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <summary>
        <paramref name="step" />이 있는 for loop 를 병렬 수행합니다.	for(i=fromInclusive; i &lt; toExclusive; i+=step)
            </summary>
      <param name="fromInclusive">loop 하한 인덱스</param>
      <param name="toExclusive">loop 상한 인덱스</param>
      <param name="step">반복 인덱스 Step</param>
      <param name="parallelOptions">병렬 옵션</param>
      <param name="localInit">로컬 변수값 초기화</param>
      <param name="body">로컬값을 반환하는 병렬 실행할 함수</param>
      <param name="localFinally">최종 로컬 정리 action</param>
      <returns>/실행 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Reduce``1(System.Collections.Generic.IList{``0},``0,System.Func{``0,``0,``0})">
      <summary>Reduces the input data using the specified aggregation operation.</summary>
      <typeparam name="T">Specifies the type of data being aggregated.</typeparam>
      <param name="inputs">The input data to be reduced.</param>
      <param name="seed">The seed to use to initialize the operation; this seed may be used multiple times.</param>
      <param name="associativeCommutativeOperation">The reduction operation.</param>
      <returns>The reduced value.</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Reduce``1(System.Collections.Generic.IList{``0},System.Threading.Tasks.ParallelOptions,``0,System.Func{``0,``0,``0})">
      <summary>Reduces the input data using the specified aggregation operation.</summary>
      <typeparam name="T">Specifies the type of data being aggregated.</typeparam>
      <param name="inputs">The input data to be reduced.</param>
      <param name="parallelOptions">A ParallelOptions instance that configures the behavior of this operation.</param>
      <param name="seed">The seed to use to initialize the operation; this seed may be used multiple times.</param>
      <param name="associativeCommutativeOperation">The reduction operation.</param>
      <returns>The reduced value.</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Reduce``1(System.Int32,System.Int32,System.Func{System.Int32,``0},``0,System.Func{``0,``0,``0})">
      <summary>Reduces the input range using the specified aggregation operation.</summary>
      <typeparam name="T">Specifies the type of data being aggregated.</typeparam>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="mapOperation">The function used to retrieve the data to be reduced for a given index.</param>
      <param name="seed">The seed to use to initialize the operation; this seed may be used multiple times.</param>
      <param name="associativeCommutativeOperation">The reduction operation.</param>
      <returns>The reduced value.</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Reduce``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{System.Int32,``0},``0,System.Func{``0,``0,``0})">
      <summary>Reduces the input range using the specified aggregation operation.</summary>
      <typeparam name="T">Specifies the type of data being aggregated.</typeparam>
      <param name="fromInclusive">The start index, inclusive.</param>
      <param name="toExclusive">The end index, exclusive.</param>
      <param name="parallelOptions">A ParallelOptions instance that configures the behavior of this operation.</param>
      <param name="mapOperation">The function used to retrieve the data to be reduced for a given index.</param>
      <param name="seed">The seed to use to initialize the operation; this seed may be used multiple times.</param>
      <param name="associativeCommutativeOperation">The reduction operation.</param>
      <returns>The reduced value.</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Scan``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})">
      <summary>
            Computes a parallel prefix scan over the source enumerable using the specified function.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Scan``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0},System.Boolean)">
      <summary>
            Computes a parallel prefix scan over the source enumerable using the specified function.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Sort``1(``0[])">
      <summary>
            Parallel merge sort by dividing the array into N buckets, where N is the total number of threads, each thread will either sort its bucket using QickSort or MergeSort
            (QuickSort shows slightly better performance) all threads are synchronized using a System.Threading.Barrier. When all threads sort their partitions, half of the threads (the 
            odd threads will be removed) and the even threads will merge its chunck with the removed thread's chunk, then the odd threads are moved again, after Log(N) iterations,
            The sorted array will be in one chunk in the first thread
            </summary>
      <typeparam name="T">Array type</typeparam>
      <param name="array">The array object</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Sort``1(``0[],System.Collections.Generic.IComparer{``0})">
      <summary>
            Parallel merge sort by dividing the array into N buckets, where N is the total number of threads, each thread will either sort its bucket using QickSort or MergeSort
            (QuickSort shows slightly better performance) all threads are synchronized using a System.Threading.Barrier. When all threads sort their partitions, half of the threads (the 
            odd threads will be removed) and the even threads will merge its chunck with the removed thread's chunk, then the odd threads are moved again, after Log(N) iterations,
            The sorted array will be in one chunk in the first thread
            </summary>
      <typeparam name="T">Array type</typeparam>
      <param name="array">The array object</param>
      <param name="comparer">Comparer object, if null the default comparer will be used</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForRange(System.Int32,System.Int32,System.Action{System.Int32,System.Int32})">
      <summary>
            특정 범위를 분할해서 병렬로 로컬 작업을 수행합니다 (병렬 작업을 너무 세분화 시키지 않고, 분할해서 작업하면 효과적이다.)
            </summary>
      <param name="fromInclusive">시작 인덱스</param>
      <param name="toExclusive">종료 인덱스</param>
      <param name="body">구간 단위의 실행을 담당하는 delegate</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForRange(System.Int32,System.Int32,System.Action{System.Int32,System.Int32,System.Threading.Tasks.ParallelLoopState})">
      <summary>
            특정 범위를 분할해서 병렬로 로컬 작업을 수행합니다 (병렬 작업을 너무 세분화 시키지 않고, 분할해서 작업하면 효과적이다.)
            </summary>
      <param name="fromInclusive">시작 인덱스</param>
      <param name="toExclusive">종료 인덱스</param>
      <param name="body">구간 단위의 실행을 담당하는 delegate</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForRange``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <summary>
            특정 범위를 분할해서 병렬로 로컬 작업을 수행합니다 (병렬 작업을 너무 세분화 시키지 않고, 분할해서 작업하면 효과적이다.)
            </summary>
      <typeparam name="TLocal">
      </typeparam>
      <param name="fromInclusive">시작 인덱스</param>
      <param name="toExclusive">종료 인덱스</param>
      <param name="localInit">구간 단위의 초기화 값을 제공하는 delegate</param>
      <param name="localBody">구간 단위의 실행을 담당하는 delegate</param>
      <param name="localFinally">구간별 실행 결과 합치는 delegate</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForRange(System.Int64,System.Int64,System.Action{System.Int64,System.Int64})">
      <summary>
            특정 범위를 분할해서 병렬로 로컬 작업을 수행합니다 (병렬 작업을 너무 세분화 시키지 않고, 분할해서 작업하면 효과적이다.)
            </summary>
      <param name="fromInclusive">시작 인덱스</param>
      <param name="toExclusive">종료 인덱스</param>
      <param name="body">구간 단위의 실행을 담당하는 delegate</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForRange(System.Int64,System.Int64,System.Action{System.Int64,System.Int64,System.Threading.Tasks.ParallelLoopState})">
      <summary>
            특정 범위를 분할해서 병렬로 로컬 작업을 수행합니다 (병렬 작업을 너무 세분화 시키지 않고, 분할해서 작업하면 효과적이다.)
            </summary>
      <param name="fromInclusive">시작 인덱스</param>
      <param name="toExclusive">종료 인덱스</param>
      <param name="body">구간 단위의 실행을 담당하는 delegate</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForRange``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <summary>
            특정 범위를 분할해서 병렬로 로컬 작업을 수행합니다 (병렬 작업을 너무 세분화 시키지 않고, 분할해서 작업하면 효과적이다.)
            </summary>
      <typeparam name="TLocal">
      </typeparam>
      <param name="fromInclusive">시작 인덱스</param>
      <param name="toExclusive">종료 인덱스</param>
      <param name="localInit">구간 단위의 초기화 값을 제공하는 delegate</param>
      <param name="localBody">구간 단위의 실행을 담당하는 delegate</param>
      <param name="localFinally">구간별 실행 결과 합치는 delegate</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForRange(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Int32})">
      <summary>
            특정 범위를 분할해서 병렬로 로컬 작업을 수행합니다 (병렬 작업을 너무 세분화 시키지 않고, 분할해서 작업하면 효과적이다.)
            </summary>
      <param name="fromInclusive">시작 인덱스</param>
      <param name="toExclusive">종료 인덱스</param>
      <param name="parallelOptions">병렬 실행 옵션</param>
      <param name="body">구간 단위의 실행을 담당하는 delegate</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForRange(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Int32,System.Threading.Tasks.ParallelLoopState})">
      <summary>
            특정 범위를 분할해서 병렬로 로컬 작업을 수행합니다 (병렬 작업을 너무 세분화 시키지 않고, 분할해서 작업하면 효과적이다.)
            </summary>
      <param name="fromInclusive">시작 인덱스</param>
      <param name="toExclusive">종료 인덱스</param>
      <param name="parallelOptions">병렬 실행 옵션</param>
      <param name="body">구간 단위의 실행을 담당하는 delegate</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForRange``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <summary>
            특정 범위를 분할해서 병렬로 로컬 작업을 수행합니다 (병렬 작업을 너무 세분화 시키지 않고, 분할해서 작업하면 효과적이다.)
            </summary>
      <typeparam name="TLocal">
      </typeparam>
      <param name="fromInclusive">시작 인덱스</param>
      <param name="toExclusive">종료 인덱스</param>
      <param name="parallelOptions">병렬 실행 옵션</param>
      <param name="localInit">구간 단위의 초기화 값을 제공하는 delegate</param>
      <param name="localBody">구간 단위의 실행을 담당하는 delegate</param>
      <param name="localFinally">구간별 실행 결과 합치는 delegate</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForRange(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Int64})">
      <summary>
            특정 범위를 분할해서 병렬로 로컬 작업을 수행합니다 (병렬 작업을 너무 세분화 시키지 않고, 분할해서 작업하면 효과적이다.)
            </summary>
      <param name="fromInclusive">시작 인덱스</param>
      <param name="toExclusive">종료 인덱스</param>
      <param name="parallelOptions">병렬 실행 옵션</param>
      <param name="body">구간 단위의 실행을 담당하는 delegate</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForRange(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Int64,System.Threading.Tasks.ParallelLoopState})">
      <summary>
            특정 범위를 분할해서 병렬로 로컬 작업을 수행합니다 (병렬 작업을 너무 세분화 시키지 않고, 분할해서 작업하면 효과적이다.)
            </summary>
      <param name="fromInclusive">시작 인덱스</param>
      <param name="toExclusive">종료 인덱스</param>
      <param name="parallelOptions">병렬 실행 옵션</param>
      <param name="body">구간 단위의 실행을 담당하는 delegate</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.ForRange``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})">
      <summary>
            특정 범위를 분할해서 병렬로 로컬 작업을 수행합니다 (병렬 작업을 너무 세분화 시키지 않고, 분할해서 작업하면 효과적이다.)
            </summary>
      <typeparam name="TLocal">
      </typeparam>
      <param name="fromInclusive">시작 인덱스</param>
      <param name="toExclusive">종료 인덱스</param>
      <param name="parallelOptions">병렬 실행 옵션</param>
      <param name="localInit">구간 단위의 초기화 값을 제공하는 delegate</param>
      <param name="localBody">구간 단위의 실행을 담당하는 delegate</param>
      <param name="localFinally">구간별 실행 결과 합치는 delegate</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.MapAsEnumerable``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
        <paramref name="inputs" /> 시퀀스를 매핑 함수인 <paramref name="transform" />을 통해 매핑한 결과를 반환합니다. 이러한 매핑 작업을 병렬로 수행합니다.
            </summary>
      <typeparam name="TInput">매핑 입력 값의 수형</typeparam>
      <typeparam name="TOutput">매핑 출력 값의 수형</typeparam>
      <param name="inputs">입력 값의 시퀀스</param>
      <param name="transform">매핑 함수</param>
      <returns>매핑된 출력 값의 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.MapAsEnumerable``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``0,``1})">
      <summary>
        <paramref name="inputs" /> 시퀀스를 매핑 함수인 <paramref name="transform" />을 통해 매핑한 결과를 반환합니다. 이러한 매핑 작업을 병렬로 수행합니다.
            </summary>
      <typeparam name="TInput">매핑 입력 값의 수형</typeparam>
      <typeparam name="TOutput">매핑 출력 값의 수형</typeparam>
      <param name="inputs">입력 값의 시퀀스</param>
      <param name="parallelOptions">병렬 처리 옵션</param>
      <param name="transform">매핑 함수</param>
      <returns>매핑된 출력 값의 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Map``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
      <summary>
        <paramref name="inputs" /> 시퀀스를 <paramref name="mapFunc" /> 함수를 이용하여 TOutput 수형의 시퀀스로 매핑합니다. 매핑 작업을 병렬로 수행합니다.
            </summary>
      <typeparam name="TInput">입력 데이타 수형</typeparam>
      <typeparam name="TOutput">반환 데이타 수형</typeparam>
      <param name="inputs">입력 데이타</param>
      <param name="mapFunc">입력을 출력으로 변환하는 함수</param>
      <returns>Mapping된 출력 데이타</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Map``2(System.Collections.Generic.IList{``0},System.Threading.Tasks.ParallelOptions,System.Func{``0,``1})">
      <summary>
        <paramref name="inputs" /> 시퀀스를 <paramref name="tranform" /> 함수를 이용하여 TOutput 수형의 시퀀스로 매핑합니다. 매핑 작업을 병렬로 수행합니다.
            </summary>
      <typeparam name="TInput">입력 데이타 수형</typeparam>
      <typeparam name="TOutput">반환 데이타 수형</typeparam>
      <param name="inputs">입력 데이타</param>
      <param name="parallelOptions">병렬 처리 옵션</param>
      <param name="tranform">입력을 출력으로 변환하는 함수</param>
      <returns>Mapping된 출력 데이타</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.MapProperty``2(System.Collections.Generic.IList{``0})">
      <summary>
            TInput 수형의 인스턴스의 속성 정보를 기반으로 TOutput 수형의 인스턴스를 생성하고, 같은 속성은 매핑합니다.
            서로 다른 형식이지만, 속성이 비슷한 형식끼리 값을 복사할 때 편리합니다. (DTO 사용 시)
            </summary>
      <typeparam name="TInput">입력 데이타 수형</typeparam>
      <typeparam name="TOutput">반환 데이타 수형</typeparam>
      <param name="inputs">입력 데이타</param>
      <returns>Mapping된 출력 데이타</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.MapProperty``2(System.Collections.Generic.IList{``0},System.Threading.Tasks.ParallelOptions)">
      <summary>
        <paramref name="inputs" /> 시퀀스의 TInput 수형의 속성값으로 새로 생성한 TOutput 수형의 인스턴스의 속성값에 매핑하여 시퀀스로 반환합니다.
            즉 다른 수형끼리 속성 값을 같게 하여 수행하도록 합니다.
            </summary>
      <typeparam name="TInput">입력 데이타 수형</typeparam>
      <typeparam name="TOutput">반환 데이타 수형</typeparam>
      <param name="inputs">입력 데이타</param>
      <param name="parallelOptions">병렬 처리 옵션</param>
      <returns>Mapping된 출력 데이타</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.MapProperty``2(System.Collections.Generic.IList{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1})">
      <summary>
      </summary>
      <typeparam name="TInput">
      </typeparam>
      <typeparam name="TOutput">
      </typeparam>
      <param name="inputs">
      </param>
      <param name="parallelOptions">
      </param>
      <param name="outputFactory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.SpeculativeFor``1(System.Int32,System.Int32,System.Func{System.Int32,``0},System.Threading.Tasks.ParallelOptions)">
      <summary>
            지정한 범위의 값에 대해 <paramref name="function" />을 병렬로 실행시키고, 제일 먼저 반환된 값을 반환합니다. 나머지 실행은 모두 취소합니다.
            </summary>
      <typeparam name="TResult">결과 값 수형</typeparam>
      <param name="fromInclusive">범위의 시작</param>
      <param name="toExclusive">범위의 끝</param>
      <param name="options">병렬 옵션</param>
      <param name="function">수행할 함수</param>
      <returns>최초 반환 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.SpeculativeForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Threading.Tasks.ParallelOptions)">
      <summary>
            여러가지 입력값에 대해 동시에 함수를 수행하고, 선착순으로 제일 먼저 결과를 반환하는 값을 취합니다. 나머지 실행들은 모두 취소합니다.
            </summary>
      <typeparam name="TSource">입력 수형</typeparam>
      <typeparam name="TResult">출력 수형</typeparam>
      <param name="source">입력 데이타 시퀀스</param>
      <param name="options">병렬 옵션</param>
      <param name="function">실행할 함수</param>
      <returns>선착순 최초 반환 결과 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.SpeculativeForEach``2(System.Collections.Generic.IEnumerable{System.Func{``0,``1}},``0,System.Threading.Tasks.ParallelOptions)">
      <summary>
            주어진 여러 함수들을 모두 실행시켜봐서, 제일 먼저 결과를 반환하는 값을 취하고, 나머지 실행은 취소시킵니다.
            이렇게 하는 이유는, 입력값에 따라 계산방식에 차이에 따른 수행 시간을 예상할 수 없을 때, 
            모든 방식의 수행을 시도하고, 그 중 가장 먼저 완료하는 수행방식의 결과값을 취합니다.
            </summary>
      <typeparam name="TSource">입력 수형</typeparam>
      <typeparam name="TResult">출력 수형</typeparam>
      <param name="funcs">실행 함수들</param>
      <param name="options">병렬 옵션</param>
      <param name="source">입력 값</param>
      <returns>선착순 최초 반환 결과 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.SpeculativeInvoke``1(System.Threading.Tasks.ParallelOptions,System.Func{``0}[])">
      <summary>
            지정된 여러 함수들을 모두 병렬로 실행시켜, 최초 결과 값을 얻으면, 나머지 함수들은 실행 중지 시키고 결과값을 반환한다.
            </summary>
      <typeparam name="T">반환 값의 수형</typeparam>
      <param name="options">병렬 실행 옵션</param>
      <param name="functions">실행할 함수의 컬렉션</param>
      <returns>최초 결과 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.SpeculativeInvoke``1(System.Func{``0}[])">
      <summary>
            지정된 여러 함수들을 모두 병렬로 실행시켜, 최초 결과 값을 얻으면, 나머지 함수들은 실행 중지 시키고 결과값을 반환한다.
            </summary>
      <typeparam name="T">반환 값의 수형</typeparam>
      <param name="functions">실행할 함수의 컬렉션</param>
      <returns>최초 결과 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.SpeculativeInvoke``2(``0,System.Func{``0,``1}[])">
      <summary>
            지정된 여러 함수들을 모두 병렬로 실행시켜, 최초 결과 값을 얻으면, 나머지 함수들은 실행 중지 시키고 결과값을 반환한다.
            </summary>
      <typeparam name="TSource">입력 값의 수형</typeparam>
      <typeparam name="TResult">반환 값의 수형</typeparam>
      <param name="source">입력 값</param>
      <param name="functions">실행할 함수의 컬렉션</param>
      <returns>최초 결과 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Wavefront(System.Int32,System.Int32,System.Int32,System.Int32,System.Action{System.Int32,System.Int32,System.Int32,System.Int32})">
      <summary>
            Matrix 연산 중에 현재 행보다 아래와 현재 열보다 오른쪽의 요소에 대해 작업을 Wavefront라 한다. 이를 병렬로 수행할 수 있도록 합니다.
            </summary>
      <param name="rows">매트릭스 행 수</param>
      <param name="cols">매트릭스 열 수</param>
      <param name="blocksPerRow">매트릭스 행 분할 수</param>
      <param name="blocksPerCol">매트릭스 열 분할 수</param>
      <param name="processBlock">매트릭스의 분할된 서브매트릭스를 처리할 델리게이트. processBlock(startRow, endRow, startCol, endCol);</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.Wavefront(System.Int32,System.Int32,System.Action{System.Int32,System.Int32})">
      <summary>
            매트릭스에서 각 Cell의 연산을 Wavefront (물결)과 같이, 상위 Cell, 좌측 Cell의 작업이 완료한 후에, 작업하도록 합니다.
            </summary>
      <param name="rows">매트릭스 행 수</param>
      <param name="cols">매트릭스 열 수</param>
      <param name="processCell">매트릭스의 각 셀을 처리할 델리게이트</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.While(System.Func{System.Boolean},System.Action,System.Threading.Tasks.ParallelOptions)">
      <summary>
            조건이 참을 반환하는 동안에는 반복해서 body 함수를 병렬로 호출합니다.
            </summary>
      <param name="options">병렬 처리 옵션</param>
      <param name="condition">While문의 평가할 조건</param>
      <param name="body">실행할 메소드</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.WhileNotEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Action{``0}},System.Threading.Tasks.ParallelOptions)">
      <summary>
            지정된 초기값(<paramref name="initialValues" />)들이 <paramref name="body" /> 를 병렬 수행하면서, 모두 다 처리가 될 때까지, 계속 수행합니다.
            <paramref name="body" />메소드 내에서, 처리된 요소는 제거해야만, 끝나게 됩니다.
            꼭 쌀에서 쌀겨를 찾아내는 방식처럼, 오른손, 왼손 번갈아가며 쌀알들을 옮기면서, 쌀겨가 없을 때까지 실행하는 것과 같다.
            </summary>
      <typeparam name="T">함수 인자의 수형</typeparam>
      <param name="options">병렬 옵션</param>
      <param name="initialValues">추기 값의 컬렉션</param>
      <param name="body">수행할 함수 (인자로 값과 값에 대한 처리를 담는 메소드를 가진다)</param>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.PLinqTool">
      <summary>
            Parallel LINQ Extensions
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PLinqTool.TakeTop``2(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Int32)">
      <summary>
            정렬이 되었다면, 지정된 갯수의 최상위 요소중 <paramref name="count" /> 수만큼 반환합니다.
            </summary>
      <typeparam name="TSource">요소의 수형</typeparam>
      <typeparam name="TKey">요소 비교를 위한 Key의 수형</typeparam>
      <param name="source">요소 집합</param>
      <param name="keySelector">요소로부터 Key를 추출하는 Selector</param>
      <param name="count">취할 요소의 수</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PLinqTool.MapReduce``4(System.Linq.ParallelQuery{``0},System.Func{``0,``1},System.Func{``1,``2},System.Func{System.Linq.IGrouping{``2,``1},``3})">
      <summary>
            병렬로 Map-Reduce를 수행합니다.
            </summary>
      <typeparam name="TSource">souece 요소의 수형</typeparam>
      <typeparam name="TMapped">mapped 요소의 수형</typeparam>
      <typeparam name="TKey">key 수형</typeparam>
      <typeparam name="TResult">결과 시퀀스의 요소의 수형</typeparam>
      <param name="source">원본 시퀀스</param>
      <param name="mapper">source 요소를 mapped 요소로 변환하는 함수</param>
      <param name="keySelector">mapped 요소로부터 key 를 선택하는 함수, 그룹핑을 위해 사용된다.</param>
      <param name="reducer">key로 그룹핑된 정보를 바탕으로 결과를 도출하는 함수</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PLinqTool.MapReduce``4(System.Linq.ParallelQuery{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``1,``2},System.Func{System.Linq.IGrouping{``2,``1},System.Collections.Generic.IEnumerable{``3}})">
      <summary>
            병렬로 Map-Reduce를 수행합니다.
            </summary>
      <typeparam name="TSource">souece 요소의 수형</typeparam>
      <typeparam name="TMapped">mapped 요소의 수형</typeparam>
      <typeparam name="TKey">key 수형</typeparam>
      <typeparam name="TResult">결과 시퀀스의 요소의 수형</typeparam>
      <param name="source">원본 시퀀스</param>
      <param name="mapper">원본 요소로부터 mapped 요소의 시퀀스로 변환하는 mapper</param>
      <param name="keySelector">mapped 요소로부터 key 를 선택하는 함수, 그룹핑을 위해 사용된다.</param>
      <param name="reducer">key로 그룹핑된 정보를 바탕으로 TResult수형의 요소의 시퀀스를 반환하는 함수</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PLinqTool.OutputToProducerConsumerCollection``1(System.Linq.ParallelQuery{``0},System.Collections.Concurrent.IProducerConsumerCollection{``0})">
      <summary>
        <paramref name="source" />를 모두 병렬로 실행하여, 결과를 <paramref name="target" /> 컬렉션에 요소로 추가한다.
            </summary>
      <typeparam name="TSource">요소의 수형</typeparam>
      <param name="source">병렬 시퀀스</param>
      <param name="target">공급자/소비자 패턴의 컬렉션</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PLinqTool.AsParallel``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions)">
      <summary>
        <paramref name="options" />에 따라 ParallelQuery{TSource} 를 빌드합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <param name="source">
      </param>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PLinqTool.AsParallel``1(System.Collections.Generic.IEnumerable{``0},NSoft.NFramework.Parallelism.ParallelLinqOptions)">
      <summary>
        <paramref name="options" />에 따라 ParallelQuery{TSource} 를 빌드합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <param name="source">
      </param>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PLinqTool.Generate``1(System.Int32,System.Func{``0})">
      <summary>
        <paramref name="count" /> 수만큼 <paramref name="generator" />를 호출하여 결과값을 열거합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="count">
      </param>
      <param name="generator">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PLinqTool.PipeAsParallel``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
      <summary>
        <paramref name="source" />의 항목들을 <paramref name="action" />의 인자로 전달하여 수행하고, 항목을 다시 열거합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="source">
      </param>
      <param name="action">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.PLinqTool.PipeAsParallel``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
      <summary>
        <paramref name="source" />의 항목들을 <paramref name="func" />의 인자로 전달하여 수행하고, 결과를 열거합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">
      </typeparam>
      <param name="source">
      </param>
      <param name="func">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.TaskCompletionSourceTool">
      <summary>
        <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />에 대한 확장 메소드들입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskCompletionSourceTool.SetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task)">
      <summary>
        <paramref name="task" />의 상태에 따라 <paramref name="resultSetter" />의 작업 결과를 설정합니다.
            </summary>
      <typeparam name="TResult">작업 결과의 수형</typeparam>
      <param name="resultSetter">작업 결과를 설정할 인스턴스</param>
      <param name="task">작업</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskCompletionSourceTool.SetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task{``0})">
      <summary>
        <paramref name="task" />의 상태에 따라 <paramref name="resultSetter" />의 작업 결과를 설정합니다.
            </summary>
      <typeparam name="TResult">작업 결과의 수형</typeparam>
      <param name="resultSetter">작업 결과를 설정할 인스턴스</param>
      <param name="task">작업</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskCompletionSourceTool.TrySetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task)">
      <summary>
        <paramref name="task" />의 상태에 따라 <paramref name="resultSetter" />의 작업 결과를 설정을 시도합니다.
            </summary>
      <typeparam name="TResult">작업 결과의 수형</typeparam>
      <param name="resultSetter">작업 결과를 설정할 인스턴스</param>
      <param name="task">작업</param>
      <returns>설정 성공 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskCompletionSourceTool.TrySetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task{``0})">
      <summary>
        <paramref name="task" />의 상태에 따라 <paramref name="resultSetter" />의 작업 결과를 설정을 시도합니다.
            </summary>
      <typeparam name="TResult">작업 결과의 수형</typeparam>
      <param name="resultSetter">작업 결과를 설정할 인스턴스</param>
      <param name="task">작업</param>
      <returns>설정 성공 여부</returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool">
      <summary>
        <see cref="T:System.Threading.Tasks.TaskFactory" />의 확장 메소드를 제공하는 클래스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.ToGeneric``1(System.Threading.Tasks.TaskFactory)">
      <summary>
            Non-generic task factory의 속성 값을 기초로, Generic task factory를 생성합니다.
            </summary>
      <typeparam name="TResult">
      </typeparam>
      <param name="factory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.ToNonGeneric``1(System.Threading.Tasks.TaskFactory{``0})">
      <summary>
            Generic TaskFactory의 속성값을 기초로, Non-generic TaskFactory를 생성합니다.
            </summary>
      <typeparam name="TResult">
      </typeparam>
      <param name="factory">Generic Task Factory</param>
      <returns>Non-generic TaskFactory</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.GetTargetScheduler(System.Threading.Tasks.TaskFactory)">
      <summary>
            Task의 schedule을 관리하는 <see cref="T:System.Threading.Tasks.TaskScheduler" />의 인스턴스를 제공합니다. factory의 Scheduler가 없을 시에 <see cref="P:System.Threading.Tasks.TaskScheduler.Current" />를 제공합니다.
            </summary>
      <param name="factory">TaskFactory</param>
      <returns>TaskScheduler의 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.GetTargetScheduler``1(System.Threading.Tasks.TaskFactory{``0})">
      <summary>
            Task의 schedule을 관리하는 <see cref="T:System.Threading.Tasks.TaskScheduler" />의 인스턴스를 제공합니다. factory의 Scheduler가 없을 시에 <see cref="P:System.Threading.Tasks.TaskScheduler.Current" />를 제공합니다.
            </summary>
      <typeparam name="TResult">Task 결과 값의 수형</typeparam>
      <param name="factory">TaskFactory</param>
      <returns>TaskScheduler의 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.WhenAll(System.Threading.Tasks.TaskFactory,System.Threading.Tasks.Task[])">
      <summary>
            제공된 Task들이 모두 완료되었을 때에, 완료된 Task들을 결과로 제공하는 Task를 빌드합니다. Fork-Join에 해당합니다.
            </summary>
      <param name="factory">TaskFactory</param>
      <param name="tasks">실행할 Task 들</param>
      <returns>실행 완료된 Task들을 결과로 가지는 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.WhenAll``1(System.Threading.Tasks.TaskFactory,System.Threading.Tasks.Task{``0}[])">
      <summary>
            제공된 Task들이 모두 완료되었을 때에, 완료된 Task들을 결과로 제공하는 Task를 빌드합니다. Fork-Join에 해당합니다.
            </summary>
      <typeparam name="TAntecedentResult">실행할 Task의 결과값의 수형</typeparam>
      <param name="factory">TaskFactory</param>
      <param name="tasks">실행할 Task 들</param>
      <returns>실행 완료된 Task들을 결과로 가지는 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.WhenAny(System.Threading.Tasks.TaskFactory,System.Threading.Tasks.Task[])">
      <summary>
            제공된 Task들 중에 하나라도 완료하면, 제일 처음 완료된 Task를 결과로 제공하는 Task를 빌드합니다. 
            선착순 작업 완료와 의미가 같습니다만, 나머지 작업들에 대한 취소는 하지 않습니다. 
            <see cref="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.SpeculativeInvoke``1(System.Func{``0}[])" /> 참고.
            </summary>
      <param name="factory">TaskFactory</param>
      <param name="tasks">실행할 Task들</param>
      <returns>제일 처음 실행한 Task를 결과로 가지는 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.WhenAny``1(System.Threading.Tasks.TaskFactory,System.Threading.Tasks.Task{``0}[])">
      <summary>
            제공된 Task들 중에 하나라도 완료하면, 제일 처음 완료된 Task를 결과로 제공하는 Task를 빌드합니다. 
            선착순 작업 완료와 의미가 같습니다만, 나머지 작업들에 대한 취소는 하지 않습니다. 
            <see cref="M:NSoft.NFramework.Parallelism.Tools.ParallelTool.SpeculativeInvoke``2(``0,System.Func{``0,``1}[])" /> 참고.
            </summary>
      <param name="factory">TaskFactory</param>
      <param name="tasks">실행할 Task들</param>
      <returns>제일 처음 실행한 Task를 결과로 가지는 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.ContinueWithActions(System.Threading.Tasks.TaskFactory,System.Action[])">
      <summary>
            여러 Action들을 순차적으로 실행하도록 Task 실행 프로세스를 구성합니다
            </summary>
      <param name="factory">TaskFactory</param>
      <param name="actions">실행할 Action</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.ContinueWithActions(System.Threading.Tasks.TaskFactory,System.Threading.Tasks.TaskContinuationOptions,System.Action[])">
      <summary>
            여러 Action들을 순차적으로 실행하도록 Task 실행 프로세스를 구성합니다
            </summary>
      <param name="factory">TaskFactory</param>
      <param name="taskContinuationOptions">작업 간의 연속 시의 옵션</param>
      <param name="actions">실행할 Action</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.Create(System.Threading.Tasks.TaskFactory,System.Action,System.Nullable{System.Threading.Tasks.TaskCreationOptions})">
      <summary>
        <paramref name="factory" /> 환경하에서, <paramref name="action" />을 수행하는 Task를 생성합니다.
            </summary>
      <param name="factory">TaskFactory 인스턴스</param>
      <param name="action">수행할 메소드</param>
      <param name="creationOptions">Task 생성 옵션</param>
      <returns>생성된 Task 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.Create(System.Threading.Tasks.TaskFactory,System.Action{System.Object},System.Object,System.Nullable{System.Threading.Tasks.TaskCreationOptions})">
      <summary>
        <paramref name="action" />을 수행하는 Task를 생성합니다.
            </summary>
      <param name="factory">TaskFactory 인스턴스</param>
      <param name="action">수행할 메소드</param>
      <param name="state">메소드 인자값</param>
      <param name="creationOptions">Task 생성 옵션</param>
      <returns>생성된 Task 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.Create``1(System.Threading.Tasks.TaskFactory,System.Func{``0},System.Nullable{System.Threading.Tasks.TaskCreationOptions})">
      <summary>
        <paramref name="function" />을 수행할 Task를 생성합니다.
            </summary>
      <typeparam name="TResult">function의 반환 값의 수형</typeparam>
      <param name="factory">TaskFactory</param>
      <param name="function">실행할 함수</param>
      <param name="creationOptions">Task 생성 옵션</param>
      <returns>
        <paramref name="function" />을 수행할 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.Create``1(System.Threading.Tasks.TaskFactory,System.Func{System.Object,``0},System.Object,System.Nullable{System.Threading.Tasks.TaskCreationOptions})">
      <summary>
        <paramref name="function" />을 수행할 Task를 생성합니다.
            </summary>
      <typeparam name="TResult">function의 반환 값의 수형</typeparam>
      <param name="factory">TaskFactory</param>
      <param name="function">실행할 함수</param>
      <param name="state">함수의 입력 인자</param>
      <param name="creationOptions">Task 생성 옵션</param>
      <returns>
        <paramref name="function" />을 수행할 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.Create``1(System.Threading.Tasks.TaskFactory{``0},System.Func{``0},System.Nullable{System.Threading.Tasks.TaskCreationOptions})">
      <summary>
        <paramref name="function" />을 수행할 Task를 생성합니다.
            </summary>
      <typeparam name="TResult">function의 반환 값의 수형</typeparam>
      <param name="factory">TaskFactory</param>
      <param name="function">실행할 함수</param>
      <param name="creationOptions">Task 생성 옵션</param>
      <returns>
        <paramref name="function" />을 수행할 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.Create``1(System.Threading.Tasks.TaskFactory{``0},System.Func{System.Object,``0},System.Object,System.Nullable{System.Threading.Tasks.TaskCreationOptions})">
      <summary>
        <paramref name="function" />을 수행할 Task를 생성합니다.
            </summary>
      <typeparam name="TResult">function의 반환 값의 수형</typeparam>
      <param name="factory">TaskFactory</param>
      <param name="function">실행할 함수</param>
      <param name="state">함수의 입력 인자</param>
      <param name="creationOptions">Task 생성 옵션</param>
      <returns>
        <paramref name="function" />을 수행할 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.Iterate(System.Threading.Tasks.TaskFactory,System.Collections.Generic.IEnumerable{System.Object},System.Object,System.Nullable{System.Threading.CancellationToken},System.Nullable{System.Threading.Tasks.TaskCreationOptions},System.Threading.Tasks.TaskScheduler)">
      <summary>
        <paramref name="source" />의 요소들 (Task/TaskScheduler)을 비동기적으로 반복하도록 합니다.
            </summary>
      <param name="factory">대상 TaskFactory</param>
      <param name="source">반복할 Task나 TaskScheduler를 요소로 가진 열거자</param>
      <param name="state">반환할 Task의 비동기적 상태 값</param>
      <param name="cancellationToken">취소를 위한 CancellationToken</param>
      <param name="creationOptions">Task 생성 옵션</param>
      <param name="scheduler">실행할 Task들의 스케쥴러 </param>
      <returns>비동기 반복 작업의 표현하는 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.TrackedSequence(System.Threading.Tasks.TaskFactory,System.Func{System.Threading.Tasks.Task}[])">
      <summary>
            Task를 반환하는 함수의 시퀀스를 순차적으로 비동기 방식으로 실행하고, 그 결과(Task들)를 반환하도록 합니다.
            </summary>
      <param name="factory">TaskFactory</param>
      <param name="functions">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.StartNewDelayed(System.Threading.Tasks.TaskFactory,System.Int32,System.Threading.CancellationToken)">
      <summary>
        <paramref name="millisecondsDelay" />만큼 아무 작업없이 지연하다가, 작업을 끝냅니다. 
            반환되는 작업의 후속 작업으로 실제 작업을 정의하여 사용하면 작업 전에 Delay를 주는 효과가 있습니다.
            </summary>
      <param name="factory">TaskFactory</param>
      <param name="millisecondsDelay">지연할 시간 (밀리초)</param>
      <param name="cancellationToken">취소 토큰</param>
      <returns>지연 작업</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.StartNewDelayed(System.Threading.Tasks.TaskFactory,System.Int32,System.Action{System.Object},System.Object,System.Nullable{System.Threading.CancellationToken},System.Nullable{System.Threading.Tasks.TaskCreationOptions},System.Threading.Tasks.TaskScheduler)">
      <summary>
        <paramref name="millisecondsDelay" />만큼 시간을 지연 시킨 후, <paramref name="action" />을 실행시키는 Task를 빌드합니다.
            </summary>
      <param name="factory">TaskFactory</param>
      <param name="millisecondsDelay">지연 시간 (밀리초)</param>
      <param name="action">실행할 Action</param>
      <param name="state">실행할 Action의 인자 값</param>
      <param name="cancellationToken">작업 취소 토큰</param>
      <param name="creationOptions">작업 생성 옵션</param>
      <param name="scheduler">작업 스케쥴러</param>
      <returns>지연 작업 후 실제 작업을 수행하는 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.StartNewDelayed``1(System.Threading.Tasks.TaskFactory{``0},System.Int32,System.Func{``0},System.Nullable{System.Threading.CancellationToken},System.Nullable{System.Threading.Tasks.TaskCreationOptions},System.Threading.Tasks.TaskScheduler)">
      <summary>
        <paramref name="millisecondsDelayed" /> 이후에 <paramref name="function" />을 수행하는 작업을 생성합니다.
            </summary>
      <typeparam name="TResult">작업 결과 수형</typeparam>
      <param name="factory">Task Factory</param>
      <param name="millisecondsDelayed">실행 전에 지연할 시간(밀리초)</param>
      <param name="function">실행할 함수</param>
      <param name="cancellationToken">작업 취소용 토큰</param>
      <param name="creationOptions">작업 생성 옵션</param>
      <param name="scheduler">작업 스케쥴러</param>
      <returns>일정 시간 이후에 함수를 실행하는 작업</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.StartNewDelayed``1(System.Threading.Tasks.TaskFactory{``0},System.Int32,System.Func{System.Object,``0},System.Object,System.Nullable{System.Threading.CancellationToken},System.Nullable{System.Threading.Tasks.TaskCreationOptions},System.Threading.Tasks.TaskScheduler)">
      <summary>
        <paramref name="millisecondsDelayed" /> 이후에 <paramref name="function" />을 수행하는 작업을 생성합니다.
            </summary>
      <typeparam name="TResult">작업 결과 수형</typeparam>
      <param name="factory">Task Factory</param>
      <param name="millisecondsDelayed">실행 전에 지연할 시간(밀리초)</param>
      <param name="function">실행할 함수</param>
      <param name="state">함수 인자 값</param>
      <param name="cancellationToken">작업 취소용 토큰</param>
      <param name="creationOptions">작업 생성 옵션</param>
      <param name="scheduler">작업 스케쥴러</param>
      <returns>일정 시간 이후에 함수를 실행하는 작업</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromException(System.Threading.Tasks.TaskFactory,System.Exception)">
      <summary>
        <paramref name="exception" /> 예외를 Fault 상태인 작업을 생성합니다.
            </summary>
      <param name="factory">Task Factory 인스턴스</param>
      <param name="exception">예외</param>
      <returns>예외로 Fault 상태인 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromException``1(System.Threading.Tasks.TaskFactory,System.Exception)">
      <summary>
        <paramref name="exception" /> 예외를 Fault 상태인 작업을 생성합니다.
            </summary>
      <typeparam name="TResult">Task의 결과 값 형식</typeparam>
      <param name="factory">Task Factory 인스턴스</param>
      <param name="exception">예외 정보</param>
      <returns>예외로 Fault 상태인 <see cref="T:System.Threading.Tasks.Task`1" /> 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromException``1(System.Threading.Tasks.TaskFactory{``0},System.Exception)">
      <summary>
        <paramref name="exception" /> 예외를 Fault 상태인 작업을 생성합니다.
            </summary>
      <typeparam name="TResult">Task의 결과 값 형식</typeparam>
      <param name="factory">Task Factory 인스턴스</param>
      <param name="exception">예외</param>
      <returns>예외로 Fault 상태인 <see cref="T:System.Threading.Tasks.Task" /> 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromResult``1(System.Threading.Tasks.TaskFactory,``0)">
      <summary>
        <paramref name="result" />를 결과값으로 가지는 완료된 Task{TResult} 인스턴스를 반환합니다.
            </summary>
      <typeparam name="TResult">Task의 결과 값 형식</typeparam>
      <param name="factory">Task Factory 인스턴스</param>
      <param name="result">Task의 결과 값</param>
      <returns>
        <paramref name="result" /> 결과 값이 설정된 <see cref="T:System.Threading.Tasks.Task`1" /> 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromResult``1(System.Threading.Tasks.TaskFactory{``0},``0)">
      <summary>
        <paramref name="result" />를 결과값으로 가지는 완료된 Task{TResult} 인스턴스를 반환합니다.
            </summary>
      <typeparam name="TResult">Task의 결과 값 형식</typeparam>
      <param name="factory">Task Factory 인스턴스</param>
      <param name="result">Task의 결과 값</param>
      <returns>
        <paramref name="result" /> 결과 값이 설정된 <see cref="T:System.Threading.Tasks.Task`1" /> 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromAsync(System.Threading.Tasks.TaskFactory,System.Threading.WaitHandle)">
      <summary>
            지정된 wait handle이 signal이 켜졌을 때 완료하는 Task를 빌드합니다.
            비동기 방식의 작업 중 WaitHandle만 있을 경우, Task로 Wrapping하여, 후속 작업 등을 정의할 수 있도록 할 수 있습니다.
            </summary>
      <param name="factory">target factory</param>
      <param name="waitHandle">작업 완료를 결정하는 wait handle</param>
      <returns>
        <paramref name="waitHandle" />에 신호가 들어오면, 완료되는 작업</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromAsync(System.Threading.Tasks.TaskFactory,System.Action,System.Object)">
      <summary>
        <paramref name="action" />을 비동기 방식으로 실행하는 <see cref="T:System.Threading.Tasks.Task" />를 빌드합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromAsync``1(System.Threading.Tasks.TaskFactory,System.Action{``0},``0,System.Object)">
      <summary>
        <paramref name="action" />을 비동기 방식으로 실행하는 <see cref="T:System.Threading.Tasks.Task" />를 빌드합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromAsync``2(System.Threading.Tasks.TaskFactory,System.Action{``0,``1},``0,``1,System.Object)">
      <summary>
        <paramref name="action" />을 비동기 방식으로 실행하는 <see cref="T:System.Threading.Tasks.Task" />를 빌드합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromAsync``3(System.Threading.Tasks.TaskFactory,System.Action{``0,``1,``2},``0,``1,``2,System.Object)">
      <summary>
        <paramref name="action" />을 비동기 방식으로 실행하는 <see cref="T:System.Threading.Tasks.Task" />를 빌드합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromAsync``1(System.Threading.Tasks.TaskFactory,System.Func{``0},System.Object)">
      <summary>
        <paramref name="func" />을 비동기 방식으로 실행하는 <see cref="T:System.Threading.Tasks.Task`1" />를 빌드합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromAsync``2(System.Threading.Tasks.TaskFactory,System.Func{``0,``1},``0,System.Object)">
      <summary>
        <paramref name="func" />을 비동기 방식으로 실행하는 <see cref="T:System.Threading.Tasks.Task`1" />를 빌드합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromAsync``3(System.Threading.Tasks.TaskFactory,System.Func{``0,``1,``2},``0,``1,System.Object)">
      <summary>
        <paramref name="func" />을 비동기 방식으로 실행하는 <see cref="T:System.Threading.Tasks.Task`1" />를 빌드합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskFactoryTool.FromAsync``4(System.Threading.Tasks.TaskFactory,System.Func{``0,``1,``2,``3},``0,``1,``2,System.Object)">
      <summary>
        <paramref name="func" />을 비동기 방식으로 실행하는 <see cref="T:System.Threading.Tasks.Task`1" />를 빌드합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.TaskSchedulerTool">
      <summary>
        <see cref="T:System.Threading.Tasks.TaskScheduler" /> 를 위한 확장 메소드들입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskSchedulerTool.ToSynchronizationContext(System.Threading.Tasks.TaskScheduler)">
      <summary>
        <paramref name="scheduler" />에 의해 메시지 전달 요청 작업이 스케쥴링되는 <see cref="T:System.Threading.SynchronizationContext" />를 빌드합니다.
            </summary>
      <param name="scheduler">
      </param>
      <returns>
      </returns>
      <seealso cref="T:NSoft.NFramework.Parallelism.TaskSchedulerSynchronizationContext" />
    </member>
    <member name="T:NSoft.NFramework.Parallelism.Tools.TaskTool">
      <summary>
        <see cref="T:System.Threading.Tasks.Task" />와 <see cref="T:System.Threading.Tasks.Task`1" />에 대한 확장 메소드 들입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.ContinueWith(System.Threading.Tasks.Task,System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskFactory)">
      <summary>
        <paramref name="task" />의 후속 작업으로 <paramref name="continuationAction" />을 설정합니다. 
            후속 작업에 대한 옵션은 <paramref name="factory" />의 속성을 사용합니다.
            </summary>
      <param name="task">작업 본체</param>
      <param name="continuationAction">후속 작업의 delegate</param>
      <param name="factory">후속 작업 연속에 대한 옵션을 설정하기 위한 정보를 담은 TaskFactory</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.ContinueWith``1(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskFactory)">
      <summary>
        <paramref name="task" />의 후속 작업으로 <paramref name="continuationFunction" />을 설정합니다. 
            후속 작업에 대한 옵션은 <paramref name="factory" />의 속성을 사용합니다.
            </summary>
      <param name="task">작업 본체</param>
      <param name="continuationFunction">후속 작업의 delegate</param>
      <param name="factory">후속 작업 연속에 대한 옵션을 설정하기 위한 정보를 담은 TaskFactory</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.ContinueWith``1(System.Threading.Tasks.Task{``0},System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskFactory{``0})">
      <summary>
        <paramref name="task" />의 후속 작업으로 <paramref name="continuationAction" />을 설정합니다. 
            후속 작업에 대한 옵션은 <paramref name="factory" />의 속성을 사용합니다.
            </summary>
      <param name="task">작업 본체</param>
      <param name="continuationAction">후속 작업의 delegate</param>
      <param name="factory">후속 작업 연속에 대한 옵션을 설정하기 위한 정보를 담은 TaskFactory</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.ContinueWith``2(System.Threading.Tasks.Task{``0},System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskFactory{``0})">
      <summary>
        <paramref name="task" />의 후속 작업으로 <paramref name="continuationFunction" />을 설정합니다. 
            후속 작업에 대한 옵션은 <paramref name="factory" />의 속성을 사용합니다.
            </summary>
      <param name="task">작업 본체</param>
      <param name="continuationFunction">후속 작업의 delegate</param>
      <param name="factory">후속 작업 연속에 대한 옵션을 설정하기 위한 정보를 담은 TaskFactory</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.ToAsync(System.Threading.Tasks.Task,System.AsyncCallback,System.Object)">
      <summary>
        <paramref name="task" />가 완료되면, <paramref name="callback" />을 호출하도록 예약된 새로운 Task를 생성하여, 
            <paramref name="task" />의 수행 결과를 설정한 후 제공합니다.
            </summary>
      <param name="task">실제 수행할 작업</param>
      <param name="callback">작업 후 호출할 callback 함수</param>
      <param name="state">callback 함수 호출 시 인자값</param>
      <returns>작업 완료와 callback 호출까지 모두를 포함한 작업</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.ToAsync``1(System.Threading.Tasks.Task{``0},System.AsyncCallback,System.Object)">
      <summary>
        <paramref name="task" />가 완료되면, <paramref name="callback" />을 호출하도록 예약된 새로운 Task를 생성하여, 
            <paramref name="task" />의 수행 결과를 설정한 후 제공합니다.
            </summary>
      <param name="task">실제 수행할 작업</param>
      <param name="callback">작업 후 호출할 callback 함수</param>
      <param name="state">callback 함수 호출 시 인자값</param>
      <returns>작업 완료와 callback 호출까지 모두를 포함한 작업</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.IgnoreExceptions(System.Threading.Tasks.Task)">
      <summary>
            지정한 Task 작업 중에 발생하는 예외를 무시하도록, 작업을 생성합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.IgnoreExceptions``1(System.Threading.Tasks.Task{``0})">
      <summary>
            지정한 Task 작업 중에 발생하는 예외를 무시하도록, 작업을 생성합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.FailFastOnException(System.Threading.Tasks.Task)">
      <summary>
            지정한 Task 작업 중 예외가 발생했을 경우, finally 블럭을 수행하지 않고, 빠져나오도록 하는 작업을 생성합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.FailFastOnException``1(System.Threading.Tasks.Task{``0})">
      <summary>
            지정한 Task 작업 중 예외가 발생했을 경우, finally 블럭을 수행하지 않고, 빠져나오도록 하는 작업을 생성합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.PropagateExceptions(System.Threading.Tasks.Task)">
      <summary>
            지정한 Task 작업 중 발생한 예외를 전파시킵니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.PropagateExceptions(System.Threading.Tasks.Task[])">
      <summary>
            지정한 Task 작업 중 발생한 예외를 전파시킵니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.ToObservable``1(System.Threading.Tasks.Task{``0})">
      <summary>
            작업 완료를 감시하는 <see cref="T:NSoft.NFramework.Parallelism.Tools.TaskTool.TaskObservable`1" />로 변환합니다.
            </summary>
      <typeparam name="TResult">
      </typeparam>
      <param name="task">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.WithTimeout(System.Threading.Tasks.Task,System.TimeSpan)">
      <summary>
            지정한 Task가 제한 시간이 지난 후에도 완료되지 못했다면, 작업을 취소하도록 하는 Task로 래핑합니다.
            </summary>
      <param name="task">실행할 Task</param>
      <param name="timeout">제한 시간</param>
      <returns>제한 시간이 설정된 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.WithTimeout``1(System.Threading.Tasks.Task{``0},System.TimeSpan)">
      <summary>
            지정한 Task가 제한 시간이 지난 후에도 완료되지 못했다면, 작업을 취소하도록 하는 Task로 래핑합니다.
            </summary>
      <param name="task">실행할 Task</param>
      <param name="timeout">제한 시간</param>
      <returns>제한 시간이 설정된 Task</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.AttachToParent(System.Threading.Tasks.Task)">
      <summary>
            지정한 Task가 완료 상태로 되기 전까지는, Parent Task가 완료 상태가 되는 것을 막습니다.
            </summary>
      <param name="task">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.WaitWithPumping(System.Threading.Tasks.Task)">
      <summary>
            지정한 Task가 WPF의 실행 루프에서 완전히 완료되었을 때까지 기다립니다. (WPF Dispatcher 가 실행완료 될 때까지 기다립니다)
            </summary>
      <param name="task">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.WaitAsync(System.Threading.Tasks.Task)">
      <summary>
            지정한 Task 가 완료될 때까지 CPU 및 Thread Context Changing에 영향을 안주면서, 기다렸다가, 작업 완료 상태를 반환합니다. (완료/취소/예외)
            </summary>
      <remarks>
            Wait() 함수와는 달리 작업 결과가 취소/예외 시에 <see cref="T:System.AggregateException" />을 발생시키지 않습니다.
            Wait() 나 Result 를 호출하면, Thread가 blocking이 된다. 
            AsyncWaitHandle.WaitOne()을 사용하면, CPU Cycle에는 영향을 주지 않는다.
            </remarks>
      <param name="task">실행할 Task</param>
      <returns>작업 완료 상태</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.WaitAsync(System.Threading.Tasks.Task,System.Int32)">
      <summary>
            지정한 Task 가 완료될 때까지 기다렸다가, 작업 완료 상태를 반환합니다. (완료/취소/예외)
            </summary>
      <remarks>
            Wait() 함수와는 달리 작업 결과가 취소/예외 시에 <see cref="T:System.AggregateException" />을 발생시키지 않습니다.
            Wait() 나 Result 를 호출하면, Thread가 blocking이 된다. 
            AsyncWaitHandle.WaitOne()을 사용하면, CPU Cycle에는 영향을 주지 않는다.
            </remarks>
      <param name="task">실행할 Task</param>
      <param name="msecTimeout">실행 제한 시간</param>
      <returns>작업 완료 상태</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.WaitAsync(System.Threading.Tasks.Task,System.TimeSpan)">
      <summary>
            지정한 Task 가 완료될 때까지 기다렸다가, 작업 완료 상태를 반환합니다. (완료/취소/예외)
            </summary>
      <remarks>
            Wait() 함수와는 달리 작업 결과가 취소/예외 시에 <see cref="T:System.AggregateException" />을 발생시키지 않습니다.
            Wait() 나 Result 를 호출하면, Thread가 blocking이 된다. 
            AsyncWaitHandle.WaitOne()을 사용하면, CPU Cycle에는 영향을 주지 않는다.
            </remarks>
      <param name="task">실행할 Task</param>
      <param name="timeSpan">실행 제한 시간</param>
      <returns>작업 완료 상태</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.WaitForCompletionStatus(System.Threading.Tasks.Task)">
      <summary>
            지정한 Task 가 완료될 때까지 기다렸다가, 작업 완료 상태를 반환합니다. (완료/취소/예외)
            </summary>
      <remarks>
            Wait() 함수와는 달리 작업 결과가 취소/예외 시에 <see cref="T:System.AggregateException" />을 발생시키지 않습니다.
            Wait() 나 Result 를 호출하면, Thread가 blocking이 된다. 
            AsyncWaitHandle.WaitOne()을 사용하면, CPU Cycle에는 영향을 주지 않는다.
            </remarks>
      <param name="task">실행할 Task</param>
      <returns>작업 완료 상태</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.WaitForCompletionStatus(System.Threading.Tasks.Task,System.Int32)">
      <summary>
            지정한 Task 가 완료될 때까지 기다렸다가, 작업 완료 상태를 반환합니다. (완료/취소/예외)
            </summary>
      <remarks>
            Wait() 함수와는 달리 작업 결과가 취소/예외 시에 <see cref="T:System.AggregateException" />을 발생시키지 않습니다.
            Wait() 나 Result 를 호출하면, Thread가 blocking이 된다. 
            AsyncWaitHandle.WaitOne()을 사용하면, CPU Cycle에는 영향을 주지 않는다.
            </remarks>
      <param name="task">실행할 Task</param>
      <param name="millisecondTimeout">실행 제한 시간</param>
      <returns>작업 완료 상태</returns>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.Tools.TaskTool.WaitForCompletionStatus(System.Threading.Tasks.Task,System.TimeSpan)">
      <summary>
            지정한 Task 가 완료될 때까지 기다렸다가, 작업 완료 상태를 반환합니다. (완료/취소/예외)
            </summary>
      <remarks>
            Wait() 함수와는 달리 작업 결과가 취소/예외 시에 <see cref="T:System.AggregateException" />을 발생시키지 않습니다.
            Wait() 나 Result 를 호출하면, Thread가 blocking이 된다. 
            AsyncWaitHandle.WaitOne()을 사용하면, CPU Cycle에는 영향을 주지 않는다.
            </remarks>
      <param name="task">실행할 Task</param>
      <param name="timeSpan">실행 제한 시간</param>
      <returns>작업 완료 상태</returns>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.DelegateBaseObserver`1">
      <summary>
            델리게이트 기반의 관찰자입니다. 관찰 대상의 이벤트에 따라 지정된 델리게이트를 수행합니다.
            </summary>
      <typeparam name="T">관찰대상 앤티티</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.DelegateBaseObserver`1.#ctor(System.Action{`0},System.Action{System.Exception},System.Action)">
      <summary>
            생성자
            </summary>
      <param name="onNext">관찰대상이 onNext 일때 수행할 delegate</param>
      <param name="onError">관찰대상이 예외를 발생시켰을 때 수행할 delegate</param>
      <param name="onCompleted">관찰 대상이 완료했을 때, 수행할 delegate</param>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.ParallelLinqOptions">
      <summary>
        <see cref="T:System.Threading.Tasks.ParallelOptions" />에 grouping 기능을 추가하였습니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.ParallelLinqOptions.CreateFrom(System.Threading.Tasks.ParallelOptions)">
      <summary>
        <see cref="T:System.Threading.Tasks.ParallelOptions" />로부터 <see cref="T:NSoft.NFramework.Parallelism.ParallelLinqOptions" />를 생성합니다.
            </summary>
      <param name="options">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.ParallelLinqOptions.ExecutionMode">
      <summary>
            쿼리 실행 모드는 쿼리를 병렬화할 때 시스템에서 성능 저하를 처리하는 방식을 지정하는 힌트입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.ParallelLinqOptions.MergeOptions">
      <summary>
            쿼리에 사용할 출력 병합의 기본 형식을 지정합니다.이것은 힌트일 뿐이며 모든 쿼리를 병렬화하는 경우 시스템에서 무시될 수 있습니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Parallelism.ParallelLinqOptions.Ordered">
      <summary>
            요소가 정렬되어 있어야 하는지를 나타냅니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Parallelism.TaskSchedulerSynchronizationContext">
      <summary>
        <see cref="T:System.Threading.Tasks.TaskScheduler" />에 의해 동기화 컨텍스트에 Post, Send 작업을 스케쥴링합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.TaskSchedulerSynchronizationContext.#ctor(System.Threading.Tasks.TaskScheduler)">
      <summary>
            생성자
            </summary>
      <param name="scheduler">작업 스케쥴러</param>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.TaskSchedulerSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary>
            파생 클래스에서 재정의될 때 비동기 메시지를 동기화 컨텍스트로 디스패치합니다.
            </summary>
      <param name="callback">호출할 <see cref="T:System.Threading.SendOrPostCallback" /> 대리자입니다.</param>
      <param name="state">대리자에 전달된 개체입니다.</param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:NSoft.NFramework.Parallelism.TaskSchedulerSynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary>
            파생 클래스에서 재정의될 때 동기 메시지를 동기화 컨텍스트로 디스패치합니다.
            </summary>
      <param name="callback">호출할 <see cref="T:System.Threading.SendOrPostCallback" /> 대리자입니다.</param>
      <param name="state">대리자에 전달된 개체입니다.</param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="T:NSoft.NFramework.Reflections.DynamicAccessor">
      <summary>
            인스턴스의 필드와 속성 정보에 동적으로 조작이 가능하도록 한다. (Reflection보다 속도가 빠르다.)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Reflections.IDynamicAccessor">
      <summary>
            Reflection을 이용하는 것보다 Emit을 이용하여 인스턴스의 객체 정보를 조작하는 것이 성능이 좋다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor.GetFieldValue(System.Object,System.String)">
      <summary>
            지정한 인스턴스의 필드 값을 가져온다.
            </summary>
      <param name="target">인스턴스</param>
      <param name="fieldName">필드명</param>
      <returns>필드 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor.TryGetFieldValue(System.Object,System.String,System.Object@)">
      <summary>
            인스턴스의 지정한 필드명의 값을 가져옵니다. 해당 필드가 없다면, false를 반환합니다.
            </summary>
      <param name="target">인스턴스</param>
      <param name="fieldName">필드명</param>
      <param name="fieldValue">필드 값</param>
      <returns>조회 성공 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor.SetFieldValue(System.Object,System.String,System.Object)">
      <summary>
            지정한 인스턴스의 필드 값을 설정한다.
            </summary>
      <param name="target">
      </param>
      <param name="fieldName">
      </param>
      <param name="fieldValue">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor.GetPropertyValue(System.Object,System.String)">
      <summary>
            지정한 인스턴스의 속성 값을 가져온다.
            </summary>
      <param name="target">인스턴스</param>
      <param name="propertyName">속성 명</param>
      <returns>속성 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor.TryGetPropertyValue(System.Object,System.String,System.Object@)">
      <summary>
            인스턴스의 지정한 속성 명의 값을 가져옵니다. 해당 속성이 없다면, false를 반환합니다.
            </summary>
      <param name="target">인스턴스</param>
      <param name="propertyName">속성 명</param>
      <param name="propertyValue">속성 값</param>
      <returns>조회 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor.SetPropertyValue(System.Object,System.String,System.Object)">
      <summary>
            지정한 인스턴스의 속성 값을 설정한다.
            </summary>
      <param name="target">
      </param>
      <param name="propertyName">
      </param>
      <param name="propertyValue">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor.GetPropertyNames">
      <summary>
            Get property names
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor.GetFieldNames">
      <summary>
            Get field names
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor.GetFieldType(System.String)">
      <summary>
            지정된 속성의 형식을 반환한다.
            </summary>
      <param name="fieldName">Field name</param>
      <returns>Type of Field</returns>
      <exception cref="T:System.InvalidOperationException">필드가 존재하지 않을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor.GetPropertyType(System.String)">
      <summary>
            지정된 속성의 형식을 반환한다.
            </summary>
      <param name="propertyName">Property name</param>
      <returns>Type of Property</returns>
      <exception cref="T:System.InvalidOperationException">속성이 존재하지 않을 때</exception>
    </member>
    <member name="P:NSoft.NFramework.Reflections.IDynamicAccessor.TargetType">
      <summary>
            동적으로 정보에 접근하고자하는 수형
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.IDynamicAccessor.Item(System.Object,System.String)">
      <summary>
            Indexer
            </summary>
      <param name="target">
      </param>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Reflections.IDynamicAccessor.FieldMap">
      <summary>
            필드 정보
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.IDynamicAccessor.PropertyMap">
      <summary>
            속성 정보
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor.GetFieldValue(System.Object,System.String)">
      <summary>
            지정한 인스턴스의 필드 값을 가져온다.
            </summary>
      <param name="target">인스턴스</param>
      <param name="fieldName">필드명</param>
      <returns>필드 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor.TryGetFieldValue(System.Object,System.String,System.Object@)">
      <summary>
            인스턴스의 지정한 필드명의 값을 가져옵니다. 해당 필드가 없다면, false를 반환합니다.
            </summary>
      <param name="target">인스턴스</param>
      <param name="fieldName">필드명</param>
      <param name="fieldValue">필드 값</param>
      <returns>조회 성공 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor.SetFieldValue(System.Object,System.String,System.Object)">
      <summary>
            지정한 인스턴스의 필드 값을 설정한다.
            </summary>
      <param name="target">
      </param>
      <param name="fieldName">
      </param>
      <param name="fieldValue">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor.GetPropertyValue(System.Object,System.String)">
      <summary>
            지정한 인스턴스의 속성 값을 가져온다.
            </summary>
      <param name="target">인스턴스</param>
      <param name="propertyName">속성 명</param>
      <returns>속성 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor.TryGetPropertyValue(System.Object,System.String,System.Object@)">
      <summary>
            인스턴스의 지정한 속성 명의 값을 가져옵니다. 해당 속성이 없다면, false를 반환합니다.
            </summary>
      <param name="target">인스턴스</param>
      <param name="propertyName">속성 명</param>
      <param name="propertyValue">속성 값</param>
      <returns>조회 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor.SetPropertyValue(System.Object,System.String,System.Object)">
      <summary>
            지정한 인스턴스의 속성 값을 설정한다.
            </summary>
      <param name="target">
      </param>
      <param name="propertyName">
      </param>
      <param name="propertyValue">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor.GetPropertyNames">
      <summary>
            Get property names
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor.GetFieldNames">
      <summary>
            Get field names
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor.GetFieldType(System.String)">
      <summary>
            지정된 속성의 형식을 반환한다.
            </summary>
      <param name="fieldName">Field name</param>
      <returns>Type of Field</returns>
      <exception cref="T:System.InvalidOperationException">필드가 존재하지 않을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor.GetPropertyType(System.String)">
      <summary>
            지정된 속성의 형식을 반환한다.
            </summary>
      <param name="propertyName">Property name</param>
      <returns>Type of Property</returns>
      <exception cref="T:System.InvalidOperationException">속성이 존재하지 않을 때</exception>
    </member>
    <member name="P:NSoft.NFramework.Reflections.DynamicAccessor.SuppressError">
      <summary>
            예외 발생 시 rethrow를 시킬것인가 억제할 것인가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.DynamicAccessor.IgnoreCase">
      <summary>
            속성명/필드명의 대소문자 구분 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.DynamicAccessor.TargetType">
      <summary>
            동적으로 정보에 접근하고자하는 수형
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.DynamicAccessor.Item(System.Object,System.String)">
      <summary>
            Indexer
            </summary>
      <param name="target">
      </param>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Reflections.DynamicAccessor.FieldMap">
      <summary>
            필드 정보
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.DynamicAccessor.PropertyMap">
      <summary>
            속성 정보
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Reflections.DynamicAccessorFactory">
      <summary>
            Factory for <see cref="T:NSoft.NFramework.Reflections.IDynamicAccessor" />. <br />
            DynamicAccessorFactory is thread-safe
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessorFactory.CreateDynamicAccessor(System.Type,System.Boolean,System.Boolean)">
      <summary>
            create <see cref="T:NSoft.NFramework.Reflections.IDynamicAccessor" /> for accessing specified instance.
            </summary>
      <param name="type">속성/필드값을 얻고자하는 인스턴스의 형식</param>
      <param name="suppressError">예외 발생시 무시할 것인가 여부</param>
      <param name="ignoreCase">속성명, 필드명의 대소문자를 구분할 것인가?</param>
      <returns>생성된 Dynamic Accessor 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessorFactory.CreateDynamicAccessor(System.Type,NSoft.NFramework.Reflections.MapPropertyOptions)">
      <summary>
            지정한 수형의 속성/필드 정보를 동적으로 접근하고 설정할 수 있는 <see cref="T:NSoft.NFramework.Reflections.IDynamicAccessor" />를 빌드합니다.
            </summary>
      <param name="type">대상 객체의 수형</param>
      <param name="mapOption">속성명/필드명 매핑 옵션</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessorFactory.CreateDynamicAccessor(System.Type,System.Func{System.Type,NSoft.NFramework.Reflections.IDynamicAccessor})">
      <summary>
            create <see cref="T:NSoft.NFramework.Reflections.IDynamicAccessor" /> for accessing specified instance.
            </summary>
      <param name="type">속성/필드값을 얻고자하는 인스턴스의 형식</param>
      <param name="accessorFactory">IDynamicAccessor 인스턴스 생성 함수</param>
      <returns>생성된 Dynamic Accessor 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessorFactory.CreateDynamicAccessor``1(System.Boolean,System.Boolean)">
      <summary>
            Create Instance of <see cref="T:NSoft.NFramework.Reflections.IDynamicAccessor`1" /></summary>
      <typeparam name="T">속성/필드값을 얻고자하는 인스턴스의 형식</typeparam>
      <param name="suppressError">indicate to supppress to raise exception when access to target object.</param>
      <param name="ignoreCase">속성명, 필드명의 대소문자를 구분할 것인가?</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessorFactory.CreateDynamicAccessor``1(NSoft.NFramework.Reflections.MapPropertyOptions)">
      <summary>
            지정한 수형의 속성/필드 정보를 동적으로 접근하고 설정할 수 있는 <see cref="T:NSoft.NFramework.Reflections.IDynamicAccessor`1" />를 빌드합니다.
            </summary>
      <typeparam name="T">대상 객체의 수형</typeparam>
      <param name="mapOption">속성명/필드명 매핑 옵션</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessorFactory.CreateDynamicAccessor``1(System.Func{NSoft.NFramework.Reflections.IDynamicAccessor{``0}})">
      <summary>
            create <see cref="T:NSoft.NFramework.Reflections.IDynamicAccessor`1" /> for accessing specified instance.
            </summary>
      <typeparam name="T">속성/필드값을 얻고자하는 인스턴스의 형식</typeparam>
      <param name="accessorFactory">IDynamicAccessor 인스턴스 생성 함수</param>
      <returns>생성된 Dynamic Accessor 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessorFactory.ResetCache">
      <summary>
        <see cref="T:NSoft.NFramework.Reflections.IDynamicAccessor" /> 캐시를 메모리에서 제거한다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Reflections.DynamicAccessor`1">
      <summary>
            Dynamic Method를 이용하여, 객체의 속성, 필드 정보를 조회/설정할 수 있는 Class
            </summary>
      <remarks>
        <see cref="T:NSoft.NFramework.Reflections.DynamicAccessor`1" />를 생성할 때 직접하지 말고 <see cref="!:DynamicAccessorFactory.CreateDynamicAccessor&lt;T&gt;()" />를 사용하세요.
            </remarks>
      <typeparam name="T">대상 객체의 형식</typeparam>
      <see cref="T:NSoft.NFramework.Reflections.IDynamicAccessor`1" />
      <see cref="T:NSoft.NFramework.Reflections.DynamicAccessorFactory" />
      <see cref="T:NSoft.NFramework.Reflections.DynamicAccessor" />
    </member>
    <member name="T:NSoft.NFramework.Reflections.IDynamicAccessor`1">
      <summary>
            Dynamic Method를 이용하여, 객체의 속성, 필드 정보를 조회/설정할 수 있는 인터페이스
            </summary>
      <typeparam name="T">대상 객체의 형식</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor`1.GetFieldValue(`0,System.String)">
      <summary>
            지정한 인스턴스의 필드 값을 가져온다.
            </summary>
      <param name="target">{T}의 인스턴스</param>
      <param name="fieldName">필드명</param>
      <returns>인스턴스의 필드명에 해당하는 값</returns>
      <exception cref="T:System.InvalidOperationException">해당 인스턴스가 필드 명에 해당하는 필드가 없을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor`1.TryGetFieldValue(`0,System.String,System.Object@)">
      <summary>
            지정한 인스턴스의 필드 값을 가져온다.
            </summary>
      <param name="target">{T}의 인스턴스</param>
      <param name="fieldName">필드 명</param>
      <param name="fieldValue">필드 값</param>
      <returns>필드 값 조회 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor`1.SetFieldValue(`0,System.String,System.Object)">
      <summary>
            지정한 인스턴스의 필드 값을 설정한다.
            </summary>
      <param name="target">대상 객체</param>
      <param name="fieldName">필드 명</param>
      <param name="fieldValue">필드 값</param>
      <exception cref="T:System.InvalidOperationException">해당 인스턴스가 필드 명에 해당하는 필드가 없을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor`1.GetPropertyValue(`0,System.String)">
      <summary>
            지정한 인스턴스의 속성 값을 가져온다.
            </summary>
      <param name="target">대상 객체</param>
      <param name="propertyName">속성 명</param>
      <returns>대상 객체의 속성명에 해당하는 속성의 값</returns>
      <exception cref="T:System.InvalidOperationException">해당 인스턴스가 속성명에 해당하는 속성이 정의되어 있지 않을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor`1.TryGetPropertyValue(`0,System.String,System.Object@)">
      <summary>
            지정한 인스턴스의 속성 명에 해당하는 값을 조회합니다.
            </summary>
      <param name="target">대상 인스턴스</param>
      <param name="propertyName">속성 명</param>
      <param name="propertyValue">속성 값</param>
      <returns>조회 성공 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor`1.SetPropertyValue(`0,System.String,System.Object)">
      <summary>
            지정한 인스턴스의 속성 값을 설정한다.
            </summary>
      <param name="target">대상 객체</param>
      <param name="propertyName">속성 명</param>
      <param name="propertyValue">설정할 속성 값</param>
      <exception cref="T:System.InvalidOperationException">해당 인스턴스가 속성명에 해당하는 속성이 정의되어 있지 않을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor`1.GetPropertyNames">
      <summary>
            Public Property들의 속성명들을 가져온다
            </summary>
      <returns>해당 형식의 Public 속성명 리스트</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor`1.GetPropertyNames(System.Reflection.BindingFlags)">
      <summary>
            해당 형식의 지정된 BindingFlag에 의해 조사된 속성명들을 반환한다.
            </summary>
      <param name="bindingFlags">Reflection BindingFlags</param>
      <returns>속성명 리스트</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor`1.GetFieldNames">
      <summary>
            Public Field들의 속성명을 가져온다
            </summary>
      <returns>Collection of Field names</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor`1.GetFieldNames(System.Reflection.BindingFlags)">
      <summary>
            해당 형식의 지정된 BindingFlag에 의해 조사된 필드명들을 반환한다.
            </summary>
      <param name="bindingFlags">
      </param>
      <returns>Collectio of Field names</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor`1.GetFieldType(System.String)">
      <summary>
            지정된 속성의 형식을 반환한다.
            </summary>
      <param name="fieldName">Field name</param>
      <returns>Type of Field</returns>
      <exception cref="T:System.InvalidOperationException">필드가 존재하지 않을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Reflections.IDynamicAccessor`1.GetPropertyType(System.String)">
      <summary>
            지정된 속성의 형식을 반환한다.
            </summary>
      <param name="propertyName">Property name</param>
      <returns>Type of Property</returns>
      <exception cref="T:System.InvalidOperationException">속성이 존재하지 않을 때</exception>
    </member>
    <member name="P:NSoft.NFramework.Reflections.IDynamicAccessor`1.TargetType">
      <summary>
            대상 수형
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.IDynamicAccessor`1.Item(`0,System.String)">
      <summary>
            Indexer
            </summary>
      <param name="target">
      </param>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Reflections.IDynamicAccessor`1.FieldMap">
      <summary>
            필드 정보
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.IDynamicAccessor`1.PropertyMap">
      <summary>
            속성 정보
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor`1.GetFieldValue(`0,System.String)">
      <summary>
            지정한 인스턴스의 필드 값을 가져온다.
            </summary>
      <param name="target">{T}의 인스턴스</param>
      <param name="fieldName">필드명</param>
      <returns>인스턴스의 필드명에 해당하는 값</returns>
      <exception cref="T:System.InvalidOperationException">해당 인스턴스가 필드 명에 해당하는 필드가 없을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor`1.TryGetFieldValue(`0,System.String,System.Object@)">
      <summary>
            지정한 인스턴스의 필드 값을 가져온다.
            </summary>
      <param name="target">{T}의 인스턴스</param>
      <param name="fieldName">필드 명</param>
      <param name="fieldValue">필드 값</param>
      <returns>필드 값 조회 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor`1.SetFieldValue(`0,System.String,System.Object)">
      <summary>
            지정한 인스턴스의 필드 값을 설정한다.
            </summary>
      <param name="target">대상 객체</param>
      <param name="fieldName">필드 명</param>
      <param name="fieldValue">필드 값</param>
      <exception cref="T:System.InvalidOperationException">해당 인스턴스가 필드 명에 해당하는 필드가 없을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor`1.GetPropertyValue(`0,System.String)">
      <summary>
            지정한 인스턴스의 속성 값을 가져온다.
            </summary>
      <param name="target">대상 객체</param>
      <param name="propertyName">속성 명</param>
      <returns>대상 객체의 속성명에 해당하는 속성의 값</returns>
      <exception cref="T:System.InvalidOperationException">해당 인스턴스가 속성명에 해당하는 속성이 정의되어 있지 않을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor`1.TryGetPropertyValue(`0,System.String,System.Object@)">
      <summary>
            지정한 인스턴스의 속성 명에 해당하는 값을 조회합니다.
            </summary>
      <param name="target">대상 인스턴스</param>
      <param name="propertyName">속성 명</param>
      <param name="propertyValue">속성 값</param>
      <returns>조회 성공 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor`1.SetPropertyValue(`0,System.String,System.Object)">
      <summary>
            지정한 인스턴스의 속성 값을 설정한다.
            </summary>
      <param name="target">대상 객체</param>
      <param name="propertyName">속성 명</param>
      <param name="propertyValue">설정할 속성 값</param>
      <exception cref="T:System.InvalidOperationException">해당 인스턴스가 속성명에 해당하는 속성이 정의되어 있지 않을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor`1.GetPropertyNames">
      <summary>
            Public Property들의 속성명들을 가져온다
            </summary>
      <returns>해당 형식의 Public 속성명 리스트</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor`1.GetPropertyNames(System.Reflection.BindingFlags)">
      <summary>
            해당 형식의 지정된 BindingFlag에 의해 조사된 속성명들을 반환한다.
            </summary>
      <param name="bindingFlags">Reflection BindingFlags</param>
      <returns>속성명 리스트</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor`1.GetFieldNames">
      <summary>
            Public Field들의 속성명을 가져온다
            </summary>
      <returns>Collection of Field names</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor`1.GetFieldNames(System.Reflection.BindingFlags)">
      <summary>
            해당 형식의 지정된 BindingFlag에 의해 조사된 필드명들을 반환한다.
            </summary>
      <param name="bindingFlags">
      </param>
      <returns>Collectio of Field names</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor`1.GetFieldType(System.String)">
      <summary>
            지정된 속성의 형식을 반환한다.
            </summary>
      <param name="fieldName">Field name</param>
      <returns>Type of Field</returns>
      <exception cref="T:System.InvalidOperationException">필드가 존재하지 않을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessor`1.GetPropertyType(System.String)">
      <summary>
            지정된 속성의 형식을 반환한다.
            </summary>
      <param name="propertyName">Property name</param>
      <returns>Type of Property</returns>
      <exception cref="T:System.InvalidOperationException">속성이 존재하지 않을 때</exception>
    </member>
    <member name="P:NSoft.NFramework.Reflections.DynamicAccessor`1.SuppressError">
      <summary>
            예외 발생 시 rethrow를 시킬것인가 억제할 것인가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.DynamicAccessor`1.IgnoreCase">
      <summary>
            속성명/필드명의 대소문자 구분 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.DynamicAccessor`1.Item(`0,System.String)">
      <summary>
            Indexer
            </summary>
      <param name="target">
      </param>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Reflections.DynamicAccessor`1.FieldMap">
      <summary>
            필드 정보
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.DynamicAccessor`1.PropertyMap">
      <summary>
            속성 정보
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Reflections.DynamicAccessorTool">
      <summary>
            DynamicAccessor에 대한 확장 메소드를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessorTool.GetFieldNameValueCollection(NSoft.NFramework.Reflections.IDynamicAccessor,System.Object)">
      <summary>
            객체의 모든 필드 정보를 필드명-필드값 형식으로 반환합니다.
            </summary>
      <param name="accessor">IDynamicAccessor 인스턴스</param>
      <param name="target">대상 객체</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessorTool.GetFieldNameValueCollection``1(NSoft.NFramework.Reflections.IDynamicAccessor{``0},``0)">
      <summary>
            객체의 모든 필드 정보를 필드명-필드값 형식으로 반환합니다.
            </summary>
      <typeparam name="T">대상 객체의 수형</typeparam>
      <param name="accessor">IDynamicAccessor{T} 인스턴스</param>
      <param name="target">대상 객체</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessorTool.GetPropertyNameValueCollection(NSoft.NFramework.Reflections.IDynamicAccessor,System.Object)">
      <summary>
            객체의 모든 속성에 대해 속성명-속성값 형식을 반환합니다.
            </summary>
      <param name="accessor">IDynamicAccessor 인스턴스</param>
      <param name="target">대상 객체</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicAccessorTool.GetPropertyNameValueCollection``1(NSoft.NFramework.Reflections.IDynamicAccessor{``0},``0)">
      <summary>
            객체의 모든 속성에 대해 속성명-속성값 형식을 반환합니다.
            </summary>
      <typeparam name="T">대상 객체의 수형</typeparam>
      <param name="accessor">IDynamicAccessor{T} 인스턴스</param>
      <param name="target">대상 객체</param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Reflections.DynamicPropertyComparer`1">
      <summary>
            지정된 형식의 특정 속성을 비교하는 <see cref="T:System.Collections.Generic.IComparer`1" />을 만든다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicPropertyComparer`1.#ctor(System.String)">
      <summary>
            기본 생성자
            </summary>
      <param name="propertyName">비교할 속성 또는 필드명</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.DynamicPropertyComparer`1.Compare(`0,`0)">
      <summary>
            두 값을 비교합니다.
            </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Reflections.FasterflectTool">
      <summary>
            Reflection을 더 빠르게 수행해 Fasterflect 라이브러리를 쉽게 이용할 수 있는 Helper Class 입니다.
            참고 : http://fasterflect.codeplex.com
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Reflections.FasterflectTool.DefaultFlags">
      <summary>
            Reflection을 위한 기본 Binding Flags (Static 만 빼고 다 있다!!!)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.GetConstructorInvoker(System.Type)">
      <summary>
            특정 형식의 기본 생성자에 델리게이트를 생성해줍니다.
            </summary>
      <param name="targetType">생성하고자 하는 수형</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.GetConstructorInvoker(System.Type,System.Type[])">
      <summary>
            특정 형식의 기본 생성자에 델리게이트를 생성해줍니다.
            </summary>
      <param name="targetType">생성하고자 하는 수형</param>
      <param name="parameterTypes">생성자 메소드의 Parameter의 수형들</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.GetConstructorInvoker(System.Type,System.Reflection.BindingFlags,System.Type[])">
      <summary>
            특정 형식의 기본 생성자에 델리게이트를 생성해줍니다.
            </summary>
      <param name="targetType">생성하고자 하는 수형</param>
      <param name="bindingFlags">BindingFlags</param>
      <param name="parameterTypes">생성자 메소드의 Parameter의 수형들</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.RetriveFieldMap(System.Type)">
      <summary>
            특정 수형의 필드 정보를 조회합니다.
            </summary>
      <param name="targetType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.RetrievePropertyMap(System.Type)">
      <summary>
            특정 수형의 속성 정보를 조회합니다.
            </summary>
      <param name="targetType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.GetOrAddFieldGetter(System.Collections.Generic.IDictionary{System.String,Fasterflect.MemberGetter},System.Type,System.String,System.Action{System.Exception})">
      <summary>
            특정 수형의 필드 값를 조회하기 위한 <see cref="T:Fasterflect.MemberGetter" />를 가져옵니다. 없으면 새로 추가합니다.
            </summary>
      <param name="fieldGetters">필드 값을 조회하는 MemberGetter들의 Dictionary</param>
      <param name="targetType">대상 형식</param>
      <param name="fieldName">필드명</param>
      <param name="exceptionAction">예외 시 수행할 Action</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.GetOrAddFieldSetter(System.Collections.Generic.IDictionary{System.String,Fasterflect.MemberSetter},System.Type,System.String,System.Action{System.Exception})">
      <summary>
            특정 수형의 필드 값을 설정하기 위한 <see cref="T:Fasterflect.MemberSetter" />를 가져옵니다. 없으면 새로 추가합니다.
            </summary>
      <param name="fieldSetters">필드 값을 조회하는 MemberGetter들의 Dictionary</param>
      <param name="targetType">대상 형식</param>
      <param name="fieldName">필드명</param>
      <param name="exceptionAction">예외 시 수행할 Action</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.GetOrAddPropertyGetter(System.Collections.Generic.IDictionary{System.String,Fasterflect.MemberGetter},System.Type,System.String,System.Action{System.Exception})">
      <summary>
            특정 수형의 속성 값을 가져오기 위한 <see cref="T:Fasterflect.MemberGetter" />를 가져옵니다. 없으면 새로 추가합니다.
            </summary>
      <param name="propertyGetters">
      </param>
      <param name="targetType">대상 객체</param>
      <param name="propertyName">조회할 속성명</param>
      <param name="exceptionAction">예외 발생 시 처리할 Action</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.GetOrAddPropertySetter(System.Collections.Generic.IDictionary{System.String,Fasterflect.MemberSetter},System.Type,System.String,System.Action{System.Exception})">
      <summary>
            특정 수형의 속성 값을 설정하기 위한 <see cref="T:Fasterflect.MemberSetter" />를 가져옵니다. 없으면 새로추가합니다.
            </summary>
      <param name="propertySetters">속성 설정 Setter들의 Dictionary</param>
      <param name="targetType">대상 형식</param>
      <param name="propertyName">속성 명</param>
      <param name="exceptionAction">예외 시 실행할 Action</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.GetMemberName(System.String,NSoft.NFramework.MemberNamingRule)">
      <summary>
            Class 멤버명을 명명규칙에 따라 변경하게 됩니다.
            </summary>
      <param name="name">
      </param>
      <param name="namingRule">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.InvokeMethod(System.Type,System.Action{Fasterflect.MethodInvoker},System.String,System.Type[])">
      <summary>
            특정 수형의 특정 메소드를 호출할 수 있는 <see cref="T:Fasterflect.MethodInvoker" />를 입력 받아 <paramref name="action" />을 수행합니다.
            </summary>
      <param name="instanceType">
      </param>
      <param name="action">
      </param>
      <param name="methodName">
      </param>
      <param name="parameterTypes">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.InvokeMethodAsync(System.Type,System.Action{Fasterflect.MethodInvoker},System.String,System.Type[])">
      <summary>
            특정 수형의 특정 메소드를 호출할 수 있는 <see cref="T:Fasterflect.MethodInvoker" />를 입력 받아 <paramref name="action" />을 수행합니다.
            </summary>
      <param name="instanceType">
      </param>
      <param name="action">
      </param>
      <param name="methodName">
      </param>
      <param name="parameterTypes">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.InvokeMethodAsParallel(System.Type,System.Int32,System.Int32,System.Action{System.Int32,Fasterflect.MethodInvoker},System.String,System.Type[])">
      <summary>
            특정 수형의 특정 메소드를 호출할 수 있는 <see cref="T:Fasterflect.MethodInvoker" />를 입력 받아 <paramref name="action" />을 수행합니다.
            </summary>
      <param name="instanceType">
      </param>
      <param name="fromInclusive">
      </param>
      <param name="toExclusive">
      </param>
      <param name="action">
      </param>
      <param name="methodName">
      </param>
      <param name="parameterTypes">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.InvokeMethodAsParallel(System.Type,System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,Fasterflect.MethodInvoker},System.String,System.Type[])">
      <summary>
            특정 수형의 특정 메소드를 호출할 수 있는 <see cref="T:Fasterflect.MethodInvoker" />를 입력 받아 <paramref name="action" />을 수행합니다.
            </summary>
      <param name="instanceType">
      </param>
      <param name="fromInclusive">
      </param>
      <param name="toExclusive">
      </param>
      <param name="parallelOptions">
      </param>
      <param name="action">
      </param>
      <param name="methodName">
      </param>
      <param name="parameterTypes">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.GetMethodInvoker(System.Type,System.String,System.Type[])">
      <summary>
            특정 수형의 특정 메소드를 호출할 수 있는 델리게이트를 제공합니다.
            </summary>
      <seealso cref="M:Fasterflect.MethodExtensions.DelegateForCallMethod(System.Type,System.String,System.Type[])" />
    </member>
    <member name="M:NSoft.NFramework.Reflections.FasterflectTool.GetMethodInvoker(System.Type,System.String,System.Reflection.BindingFlags,System.Type[])">
      <summary>
            특정 수형의 특정 메소드를 호출할 수 있는 델리게이트를 제공합니다.
            </summary>
      <seealso cref="M:Fasterflect.MethodExtensions.DelegateForCallMethod(System.Type,System.String,Fasterflect.Flags,System.Type[])" />
    </member>
    <member name="T:NSoft.NFramework.Reflections.MapPropertyOptions">
      <summary>
            속성 매핑 시에 사용할 옵션들
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Reflections.MapPropertyOptions.Default">
      <summary>
            기본 옵션, 모든 옵션을 False로 한다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Reflections.MapPropertyOptions.Safety">
      <summary>
            안전하게 매핑을 수행하기 위해 예외 발생을 억제하고, 대소문자 구분을 하지 않습니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.MapPropertyOptions.SuppressException">
      <summary>
            예외발생 시 Exception을 발생시키는 것을 억제할 것인가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.MapPropertyOptions.IgnoreCase">
      <summary>
            속성의 대소문자 구분 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Reflections.MapPropertyOptions.SkipAlreadyExistValue">
      <summary>
            대상 객체에 이미 값이 존재할 경우에 Skip할 것인가?
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Reflections.ObjectDumper">
      <summary>
            Lambda Expression으로 만들어진 object를 Dump 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectDumper.Write(System.Object)">
      <summary>
            지정된 인스턴스의 정보를 Dump 뜹니다.
            </summary>
      <param name="o">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectDumper.Write(System.Object,System.Int32)">
      <summary>
            지정된 인스턴스의 정보를 Dump 뜹니다.
            </summary>
      <param name="o">
      </param>
      <param name="depth">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Reflections.ObjectMapper">
      <summary>
            형식이 다른 두 인스턴스에서 원본 인스턴스와 대상 인스턴스가 같은 이름을 가진 속성 값을 복사한다.
            </summary>
      <remarks>
            형식은 다르지만, 일치하는 속성명이 많은 경우 속성 값 복사를 DynamicMethod를 사용하여 빠르게 할 수 있다.
            원본 인스턴스 정보를 DTO (Data Transfer Object)로 변환할 때 사용한다.
            </remarks>
    </member>
    <member name="F:NSoft.NFramework.Reflections.ObjectMapper.DefaultOptions">
      <summary>
            기본 속성 매핑 옵션
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.Map(System.Collections.IDictionary,System.Object,System.String[])">
      <summary>
            원본 속성명-속성값 정보를 대상 인스턴스의 속성명에 값을 설정한다.
            </summary>
      <param name="source">원본 정보 (Name-Value)</param>
      <param name="target">복사 대상 인스턴스</param>
      <param name="propertyNamesToExclude">복사 제외 속성 명</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.Map(System.Collections.IDictionary,System.Object,System.Boolean,System.String[])">
      <summary>
            원본 속성명-속성값 정보를 대상 인스턴스의 속성명에 값을 설정한다.
            </summary>
      <param name="source">원본 정보 (Name-Value)</param>
      <param name="target">복사 대상 인스턴스</param>
      <param name="suppressException">예외 무시 여부</param>
      <param name="propertyNamesToExclude">복사 제외 속성 명</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.Map(System.Collections.IDictionary,System.Object,System.Boolean,System.Boolean,System.String[])">
      <summary>
            원본 속성명-속성값 정보를 대상 인스턴스의 속성명에 값을 설정한다.
            </summary>
      <param name="source">원본 정보 (Name-Value)</param>
      <param name="target">복사 대상 인스턴스</param>
      <param name="suppressException">예외 무시 여부</param>
      <param name="ignoreCase">원본과 대상의 속성명 매칭 시에 대소문자 구분을 할 것인가 여부 (기본적으로 대소문자 구분을 한다)</param>
      <param name="propertyNamesToExclude">복사 제외 속성 명</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.Map(System.Collections.IDictionary,System.Func{System.Object},System.String[])">
      <summary>
            원본 속성명-속성값 정보를 대상 인스턴스의 속성명에 값을 설정한다.
            </summary>
      <param name="source">원본 정보 (Name-Value)</param>
      <param name="targetFactory">복사 대상 인스턴스 생성 델리게이트</param>
      <param name="propertyNamesToExclude">복사 제외 속성 명</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.Map(System.Collections.IDictionary,System.Func{System.Object},NSoft.NFramework.Reflections.MapPropertyOptions,System.String[])">
      <summary>
            원본 속성명-속성값 정보를 대상 인스턴스의 속성명에 값을 설정한다.
            </summary>
      <param name="source">원본 정보 (Name-Value)</param>
      <param name="targetFactory">복사 대상 인스턴스 생성 델리게이트</param>
      <param name="mapOptions">매핑 옵션</param>
      <param name="propertyNamesToExclude">복사 제외 속성 명</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.Map(System.Object,System.Object,System.Boolean,System.Boolean,System.String[])">
      <summary>
            원본 인스턴스의 속성 값을 읽어와 대상 인스턴스의 같은 속성명에 값을 설정한다.
            </summary>
      <param name="source">원본 객체</param>
      <param name="target">대상 객체</param>
      <param name="suppressException">예외 발생 전파 억제</param>
      <param name="ignoreCase">원본과 대상의 속성명 매칭 시에 대소문자 구분을 할 것인가 여부 (기본적으로 대소문자 구분을 한다)</param>
      <param name="propertyNamesToExclude">매핑시 제외할 속석명들</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapObject``2(``0,System.Func{``1},NSoft.NFramework.Reflections.MapPropertyOptions,System.Action{``0,``1},System.String[])">
      <summary>
            원본 객체 정보를 대상 객체를 생성하여, 같은 속성명의 값을 매핑하여 반환합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="source">원본 인스턴스</param>
      <param name="targetFactory">대상 인스턴스 생성 팩토리</param>
      <param name="mapOptions">매핑 시의 옵션</param>
      <param name="additionalMapping">추가 매핑 작업</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapObject``2(``0,``1,System.String[])">
      <summary>
            원본 객체 정보를 대상 객체를 생성하여, 같은 속성명의 값을 매핑합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="source">원본 인스턴스</param>
      <param name="target">대상 인스턴스</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapObject``2(``0,``1,NSoft.NFramework.Reflections.MapPropertyOptions,System.String[])">
      <summary>
            원본 객체 정보를 대상 객체를 생성하여, 같은 속성명의 값을 매핑합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="source">원본 인스턴스</param>
      <param name="target">대상 인스턴스</param>
      <param name="mapOptions">매핑 시의 옵션</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapObject``2(``0,``1,System.Action{``0,``1},System.String[])">
      <summary>
            원본 객체 정보를 대상 객체를 생성하여, 같은 속성명의 값을 매핑합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="source">원본 인스턴스</param>
      <param name="target">대상 인스턴스</param>
      <param name="additionalMapping">추가 매핑 작업</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapObject``2(``0,``1,NSoft.NFramework.Reflections.MapPropertyOptions,System.Action{``0,``1},System.String[])">
      <summary>
            원본 객체 정보를 대상 객체를 생성하여, 같은 속성명의 값을 매핑합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="source">원본 인스턴스</param>
      <param name="target">대상 인스턴스</param>
      <param name="mapOptions">매핑 시의 옵션</param>
      <param name="additionalMapping">추가 매핑 작업</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapObjects``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.String[])">
      <summary>
            원본 시퀀스를 이용하여 대상 객체를 생성한 후, 속성 값을 매핑하여 반환합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="sources">원본 인스턴스 시퀀스</param>
      <param name="targetFactory">대상 인스턴스 생성 팩토리</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 객체 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapObjects``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},NSoft.NFramework.Reflections.MapPropertyOptions,System.String[])">
      <summary>
            원본 시퀀스를 이용하여 대상 객체를 생성한 후, 속성 값을 매핑하여 반환합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="sources">원본 인스턴스 시퀀스</param>
      <param name="targetFactory">대상 인스턴스 생성 팩토리</param>
      <param name="mapOptions">매핑 시의 옵션</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 객체 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapObjects``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Action{``0,``1},System.String[])">
      <summary>
            원본 시퀀스를 이용하여 대상 객체를 생성한 후, 속성 값을 매핑하여 반환합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="sources">원본 인스턴스 시퀀스</param>
      <param name="targetFactory">대상 인스턴스 생성 팩토리</param>
      <param name="additionalMapping">추가 매핑 작업</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 객체 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapObjects``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},NSoft.NFramework.Reflections.MapPropertyOptions,System.Action{``0,``1},System.String[])">
      <summary>
            원본 시퀀스를 이용하여 대상 객체를 생성한 후, 속성 값을 매핑하여 반환합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="sources">원본 인스턴스 시퀀스</param>
      <param name="targetFactory">대상 인스턴스 생성 팩토리</param>
      <param name="mapOptions">매핑 시의 옵션</param>
      <param name="additionalMapping">추가 매핑 작업</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 객체 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapObjectsAsParallel``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.String[])">
      <summary>
            원본 시퀀스를 이용하여 대상 객체를 생성한 후, 병렬 방식으로 속성 값을 매핑하여 반환합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="sources">원본 인스턴스 시퀀스</param>
      <param name="targetFactory">대상 인스턴스 생성 팩토리</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 객체 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapObjectsAsParallel``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},NSoft.NFramework.Reflections.MapPropertyOptions,System.String[])">
      <summary>
            원본 시퀀스를 이용하여 대상 객체를 생성한 후, 병렬 방식으로 속성 값을 매핑하여 반환합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="sources">원본 인스턴스 시퀀스</param>
      <param name="targetFactory">대상 인스턴스 생성 팩토리</param>
      <param name="mapOptions">매핑 시의 옵션</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 객체 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapObjectsAsParallel``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Action{``0,``1},System.String[])">
      <summary>
            원본 시퀀스를 이용하여 대상 객체를 생성한 후, 병렬 방식으로 속성 값을 매핑하여 반환합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="sources">원본 인스턴스 시퀀스</param>
      <param name="targetFactory">대상 인스턴스 생성 팩토리</param>
      <param name="additionalMapping">추가 매핑 작업</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 객체 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapObjectsAsParallel``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},NSoft.NFramework.Reflections.MapPropertyOptions,System.Action{``0,``1},System.String[])">
      <summary>
            원본 시퀀스를 이용하여 대상 객체를 생성한 후, 병렬 방식으로 속성 값을 매핑하여 반환합니다.
            </summary>
      <typeparam name="TSource">
      </typeparam>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="sources">원본 인스턴스 시퀀스</param>
      <param name="targetFactory">대상 인스턴스 생성 팩토리</param>
      <param name="mapOptions">매핑 시의 옵션</param>
      <param name="additionalMapping">추가 매핑 작업</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 객체 시퀀스</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapProperty``1(System.Object,System.Boolean,System.Boolean,System.String[])">
      <summary>
            원본 인스턴스의 속성 값을 읽어와 새로 생성한 인스턴스의 속성에 값을 설정하여 반환합니다.
            서로 다른 형식이지만, 속성이 비슷한 형식끼리 값을 복사할 때 편리합니다. (DTO 사용 시)
            </summary>
      <typeparam name="TTarget">매핑될 대상 형식</typeparam>
      <param name="source">매핑정보를 제공할 인스턴스</param>
      <param name="suppressException">속성 복사시에 발생하는 예외를 무시할 것인가 여부</param>
      <param name="ignoreCase">원본과 대상의 속성명 매칭 시에 대소문자 구분을 할 것인가 여부 (기본적으로 대소문자 구분을 한다)</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapProperty``1(System.Object,System.Func{``0},System.Boolean,System.Boolean,System.String[])">
      <summary>
            원본 인스턴스의 속성 값을 기준으로, 새로 생성한 TTarget 수형의 인스턴스의 속성 값에 매핑합니다. Data Transfer Object 를 이용할 때 상당히 유용한 함수입니다.
            </summary>
      <typeparam name="TTarget">매핑될 대상 형식</typeparam>
      <param name="source">매핑정보를 제공할 인스턴스</param>
      <param name="targetFactory">대상 형식의 인스턴스를 생성해주는 Factory 메소드</param>
      <param name="suppressException">속성 복사시에 발생하는 예외를 무시할 것인가 여부</param>
      <param name="ignoreCase">원본과 대상의 속성명 매칭 시에 대소문자 구분을 할 것인가 여부 (기본적으로 대소문자 구분을 한다)</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <returns>매핑된 대상 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapProperty``1(System.Object,``0,System.Boolean,System.Boolean,System.String[])">
      <summary>
            원본 인스턴스의 속성 값을 읽어와 대상 인스턴스의 같은 속성명에 값을 설정한다.
            서로 다른 형식이지만, 속성이 비슷한 형식끼리 값을 복사할 때 편리합니다. (DTO 사용 시)
            </summary>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="source">원본 인스턴스</param>
      <param name="target">대상 인스턴스</param>
      <param name="suppressException">속성값 Get/Set 시 예외 처리를 무시할 것인가 여부</param>
      <param name="ignoreCase">원본과 대상의 속성명 매칭 시에 대소문자 구분을 할 것인가 여부 (기본적으로 대소문자 구분을 한다)</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapProperty``1(System.Object,System.Func{``0},NSoft.NFramework.Reflections.MapPropertyOptions,System.String[])">
      <summary>
            원본 인스턴스의 속성 값을 읽어와 대상 인스턴스의 속성에 매핑합니다.
            </summary>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="source">원본 인스턴스</param>
      <param name="targetFactory">대상 인스턴스 생성 함수</param>
      <param name="mapOptions">매핑 시의 옵션</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
      <result>매핑 대상 인스턴스</result>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectMapper.MapProperty``1(System.Object,``0,NSoft.NFramework.Reflections.MapPropertyOptions,System.String[])">
      <summary>
            원본 인스턴스의 속성 값을 읽어와 대상 인스턴스의 속성 값을 매핑합니다.
            </summary>
      <typeparam name="TTarget">대상 인스턴스 수형</typeparam>
      <param name="source">원본 인스턴스</param>
      <param name="target">대상 인스턴스</param>
      <param name="mapOptions">매핑 시의 옵션</param>
      <param name="propertyNamesToExclude">제외할 속성명</param>
    </member>
    <member name="T:NSoft.NFramework.Reflections.ObjectExtensions">
      <summary>
            Object를 위한 Extension Methods
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectExtensions.GetDynamicAccessor(System.Type)">
      <summary>
            지정된 수형의 인스턴스의 필드와 속성 정보를 동적으로 접근할 수 있는 <see cref="T:NSoft.NFramework.Reflections.IDynamicAccessor" />를 제공해줍니다.
            </summary>
      <param name="instanceType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectExtensions.GetDynamicAccessor(System.Object)">
      <summary>
            지정된 인스턴스에 대해 필드, 속성 값을 조작할 수 있는 <see cref="T:NSoft.NFramework.Reflections.IDynamicAccessor" />를 생성합니다.
            </summary>
      <param name="instance">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectExtensions.GetProperty(System.Object,System.String)">
      <summary>
            인스턴스의 속성명에 해당하는 값을 반환한다.
            </summary>
      <param name="instance">
      </param>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectExtensions.GetProperty``1(System.Object,System.String)">
      <summary>
            인스턴스의 속성명에 해당하는 값을 반환한다.
            </summary>
      <typeparam name="T">Type of property value</typeparam>
      <param name="instance">
      </param>
      <param name="propertyName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectExtensions.SetProperty(System.Object,System.String,System.Object)">
      <summary>
            인스턴스의 속성에 지정된 속성 값을 설정합니다.
            </summary>
      <param name="instance">
      </param>
      <param name="propertyName">
      </param>
      <param name="propertyValue">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectExtensions.SetProperty``1(System.Object,System.String,``0)">
      <summary>
            인스턴스의 속성에 지정된 속성 값을 설정합니다.
            </summary>
      <typeparam name="T">type of property value</typeparam>
      <param name="instance">
      </param>
      <param name="propertyName">
      </param>
      <param name="propertyValue">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectExtensions.GetField(System.Object,System.String)">
      <summary>
            인스턴스의 필드 값을 반환합니다.
            </summary>
      <param name="instance">필드 값을 가져올 인스턴스</param>
      <param name="fieldName">값을 조회할 필드 명</param>
      <returns>인스턴스의 필드 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectExtensions.GetField``1(System.Object,System.String)">
      <summary>
            인스턴스의 필드 값을 반환합니다.
            </summary>
      <param name="instance">필드 값을 가져올 인스턴스</param>
      <param name="fieldName">값을 조회할 필드 명</param>
      <returns>인스턴스의 필드 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectExtensions.SetField(System.Object,System.String,System.Object)">
      <summary>
            인스턴스의 필드에 값을 지정합니다.
            </summary>
      <param name="instance">필드 값을 설정할 인스턴스</param>
      <param name="fieldName">값을 조회할 필드 명</param>
      <param name="fieldValue">필드 값</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ObjectExtensions.SetField``1(System.Object,System.String,``0)">
      <summary>
            인스턴스의 필드에 값을 지정합니다.
            </summary>
      <param name="instance">필드 값을 설정할 인스턴스</param>
      <param name="fieldName">값을 조회할 필드 명</param>
      <param name="fieldValue">필드 값</param>
    </member>
    <member name="T:NSoft.NFramework.Reflections.ReflectionTool">
      <summary>
            Reflection 관련 Helper class
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Reflections.ReflectionTool.ItemDelimiter">
      <summary>
            Item 구분자 (',')
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Reflections.ReflectionTool.OpenBrace">
      <summary>
            컬렉션 시작 구분자 ('{')
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Reflections.ReflectionTool.CloseBrace">
      <summary>
            컬렉션 끝 구분자 ('}')
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Reflections.ReflectionTool.PublicKeyTokenLiteral">
      <summary>
            Public Key Token
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.LoadAssembly(System.String)">
      <summary>
            현 어플리케이션 도메인 안에서 지정한 어셈블리명을 가진 Assembly를 로드한다.	(예: LoadAssembly("NSoft.NFramework.dll"); )
            </summary>
      <param name="assemblyName">어셈블리명</param>
      <returns>지정된 이름을 가진 Assembly 객체를 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.LoadAssembly(System.String,System.AppDomain)">
      <summary>
            지정된 어플리케이션 도메인에서 지정한 어셈블리명을 가진 Assembly를 로드한다. (예: LoadAssembly("NSoft.NFramework.dll"); )
            </summary>
      <param name="assemblyName">어셈블리명</param>
      <param name="domain">어플리케이션 도메인</param>
      <returns>해당 어셈블리</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetNamespaces(System.Type,System.Collections.Generic.ICollection{System.String})">
      <summary>
            지정한 Type이 속한 Assembly에 있는 모든 Namespace 정보를 추출한다.
            </summary>
      <param name="type">Type 인스턴스</param>
      <param name="namespaces">Namespace 컬렉션</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetNamespaces(System.AppDomain,System.Collections.Generic.ICollection{System.String})">
      <summary>
            지정한 Application Domain에 속한 Assembly에 있는 모든 Namespace 정보를 추출한다.
            </summary>
      <param name="domain">
      </param>
      <param name="namespaces">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetNamespaces(System.Reflection.Assembly,System.Collections.Generic.ICollection{System.String})">
      <summary>
            지정한 어셈블리에 속한 Assembly에 있는 모든 Namespace 정보를 추출한다.
            </summary>
      <param name="assembly">
      </param>
      <param name="namespaces">어셈블리에 있는 모든 Namespace의 컬렉션</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetType(System.Reflection.Assembly,System.String)">
      <summary>
            지정된 어셈블리에 있는 지정된 형식 이름의 형식을 구한다.
            </summary>
      <param name="assembly">형식이 정의된 어셈블리명</param>
      <param name="typeFullName">형식의 전체 이름</param>
      <returns>존재하면 Type 반환, 없을 시에는 null값 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetNestedTypes(System.Type)">
      <summary>
            지정된 형식에 내재된(Nested) 형식을 찾는다.
            </summary>
      <param name="type">조사할 Type 인스턴스</param>
      <returns>내재된 (Nested) 형식 목록</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetSerializableTypeNames(System.Reflection.Assembly,System.Collections.Generic.ICollection{System.String})">
      <summary>
            지정된 Assembly에 SerializableAttribute를 지정한 Type의 Full Name을 얻는다.
            </summary>
      <param name="assembly">어셈블리</param>
      <param name="typeNames">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.IsSerializable(System.Type)">
      <summary>
            지정된 Class가 SerializableAttribute 를 가지고 있는지 검사한다.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetReferencedAssemblyNames(System.String,System.Collections.Generic.ICollection{System.String})">
      <summary>
            해당 어셈블리의 참조 어셈블리들의 이름을 가져온다.
            </summary>
      <param name="assemblyPath">
      </param>
      <param name="dependList">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetDrivedClasses(System.String,System.Type,System.Collections.IList)">
      <summary>
            기본 Class를 상속 받은 클래스 형식들을 가져온다.
            </summary>
      <param name="assemblyPath">
      </param>
      <param name="baseType">
      </param>
      <param name="drivedClasses">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.CanCasting(System.Object,System.Type)">
      <summary>
            Obsoleted - <see cref="M:NSoft.NFramework.Reflections.ReflectionTool.CanAssign(System.Object,System.Type)" />을 사용하세요.
            </summary>
      <param name="o">
      </param>
      <param name="castingType">
      </param>
      <returns>
      </returns>
      <seealso cref="M:NSoft.NFramework.Reflections.ReflectionTool.CanAssign(System.Object,System.Type)" />
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.CanAssign(System.Object,System.Type)">
      <summary>
            지정된 오브젝트 객체를 원하는 타입으로 형변환이 가능한지 알아본다.
            </summary>
      <param name="o">대상 객체</param>
      <param name="assignType">변경할 타입</param>
      <returns>변경 가능 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.CanAssign``1(System.Object)">
      <summary>
            지정된 오브젝트 객체를 원하는 타입으로 형변환이 가능한지 알아본다.
            </summary>
      <param name="o">대상 객체</param>
      <typeparam name="T">변경할 타입</typeparam>
      <returns>변경 가능 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.IsSameOrSubclassOf(System.Object,System.Type)">
      <summary>
            지정된 오브젝트 객체의 타입이 기본 타입과 같거나 상속한 타입인지 검사한다.
            </summary>
      <param name="o">검사할 객체</param>
      <param name="baseType">기본 타입</param>
      <returns>검사할 객체가 기본 타입과 같거나 상속된 타입이면 True, 아니면 False 이다. </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.IsSameOrSubclassOf(System.Type,System.Type)">
      <summary>
            지정된 srcType이 baseType과 같거나 상속받은 클래스인가를 검사한다.
            </summary>
      <param name="srcType">검사할 타입</param>
      <param name="baseType">기본 타입</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.HasCustomAttributes(System.Reflection.MethodInfo,System.Type,System.Boolean)">
      <summary>
            지정된 Method에 지정된 Attribute 형식이 적용되었는지 확인한다.
            </summary>
      <param name="mi">메소드 정보 개체</param>
      <param name="attributeType">사용자 정의 Attribute</param>
      <param name="inherit">메소드의 상속 Chain도 검사할 것인지 여부를 지정합니다.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.HasCustomAttributes(System.Reflection.FieldInfo,System.Type,System.Boolean)">
      <summary>
            지정된 속성에 해당 Attribute 속성의 지정 여부를 검사한다.
            </summary>
      <param name="fi">속성 정보</param>
      <param name="attributeType">Attribute 타입</param>
      <param name="inherit">상속 Chain도 검사할 것인지 여부를 지정합니다.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetInheritanceAttribute(System.ComponentModel.Component)">
      <summary>
            지정된 컴포넌트의 Attribute 정보중에 기본 클래스에서 상속되었는지 여부를 알 수 있는 <c>InheritanceAttrbute</c> 클래스를 가져온다.
            </summary>
      <param name="component">
      </param>
      <returns>상속여부를 알 수 있는 Attribute가 없다면 null을 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetPropertyInfos(System.Type)">
      <summary>
            지정된 인스턴스의 속성 정보를 가져온다.
            </summary>
      <param name="objectType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.IsIndexedProperty(System.Reflection.PropertyInfo)">
      <summary>
            지정된 속성정보가 Index를 가지는 속성인지 판단합니다.
            </summary>
      <param name="pi">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetPropertyType(System.Type)">
      <summary>
            Nullable{T} 를 고려해서 속성 형식을 가져온다.
            </summary>
      <param name="propertyType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetPublicKeyToken(System.Type)">
      <summary>
            지정된 형식이 정의된 어셈블리의 공개키 토큰을 구한다.
            </summary>
      <param name="type">타입</param>
      <returns>공개 키 토큰</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetPublicKeyToken(System.Reflection.Assembly)">
      <summary>
            지정된 어셈블리의 Public Key 토큰을 가져온다.
            </summary>
      <param name="assembly">어셈블리</param>
      <returns>공개 키 토큰</returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.GetMemberUnderlyingType(System.Reflection.MemberInfo)">
      <summary>
      </summary>
      <param name="member">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.ObjectToString(System.Object,System.Boolean)">
      <summary>
            지정된 객체의 속성 정보를 "속성명=속성값" 형태의 문자열로 빌드한다.
            </summary>
      <param name="instance">
      </param>
      <param name="showCollections">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.CollectionToString(System.Collections.IEnumerable,System.Boolean,System.String,System.String,System.String)">
      <summary>
            지정된 형식의 <see cref="T:System.Collections.IEnumerable" /> 의 요소들을 집합형태의 문자열로 표현한다.
            </summary>
      <param name="collection">표현할 컬렉션 객체</param>
      <param name="delimiter">요소 구분자</param>
      <param name="openBrace">컬렉션의 시작 구분자. 예: '{', '['</param>
      <param name="closeBrace">컬렉션의 끝 구분자. 예: '}', ']'</param>
      <param name="detailValues">요소의 값 정보를 자세히 보일것인가 여부</param>
      <returns>집합 표현형태의 문자열</returns>
      <example>
            요소가 1, 2, 3 이 있을 때 
            <code>
            string s = RwCollection.AsString&lt;int&gt;(collection, ",", "{", "}");
            ==&gt; {1,2,3}   // 이렇게 나온다.
            </code></example>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.DictionaryToString(System.Collections.IDictionary,System.Boolean,System.String,System.String,System.String)">
      <summary>
            지정된 형식의 <see cref="T:System.Collections.IDictionary" /> 의 요소들을 집합형태의 문자열로 표현한다.
            </summary>
      <param name="dictionary">표현할 <see cref="T:System.Collections.IDictionary" />객체</param>
      <param name="delimiter">요소 구분자</param>
      <param name="openBrace">Dictionary의 시작 구분자. 예: '{', '['</param>
      <param name="closeBrace">Dictionary의 끝 구분자. 예: '}', ']'</param>
      <param name="detailValues">요소의 값 정보를 자세히 보일것인가 여부</param>
      <returns>집합 표현형태의 문자열</returns>
      <example>
            A=1, B=2, C=3
            <code>
            string s = RwCollection.AsString&lt;int&gt;(dictionary, ",", "{", "}");
            ==&gt; {A=1,B=2,C=3}   // 이렇게 나온다.
            </code></example>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.CollectionToString``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,System.String,System.String,System.String)">
      <summary>
            지정된 형식의 <see cref="T:System.Collections.Generic.IEnumerable`1" /> 의 요소들을 집합형태의 문자열로 표현한다.
            </summary>
      <param name="collection">표현할 컬렉션 객체</param>
      <param name="delimiter">요소 구분자</param>
      <param name="openBrace">컬렉션의 시작 구분자. 예: '{', '['</param>
      <param name="closeBrace">컬렉션의 끝 구분자. 예: '}', ']'</param>
      <param name="showDetail">요소의 값 정보를 자세히 보일것인가 여부</param>
      <returns>집합 표현형태의 문자열</returns>
      <example>
            요소가 1, 2, 3 이 있을 때 
            <code>
            string s = RwCollection.AsString&lt;int&gt;(collection, ",", "{", "}");
            ==&gt; {1,2,3}   // 이렇게 나온다.
            </code></example>
    </member>
    <member name="M:NSoft.NFramework.Reflections.ReflectionTool.DictionaryToString``2(System.Collections.Generic.IDictionary{``0,``1},System.Boolean,System.String,System.String,System.String)">
      <summary>
            지정된 형식의 <see cref="T:System.Collections.Generic.IDictionary`2" /> 의 요소들을 집합형태의 문자열로 표현한다.
            </summary>
      <param name="dictionary">표현할 <see cref="T:System.Collections.IDictionary" />객체</param>
      <param name="delimiter">요소 구분자</param>
      <param name="openBrace">Dictionary의 시작 구분자. 예: '{', '['</param>
      <param name="closeBrace">Dictionary의 끝 구분자. 예: '}', ']'</param>
      <param name="showDetail">요소의 값 정보를 자세히 보일것인가 여부</param>
      <returns>집합 표현형태의 문자열</returns>
      <example>
            A=1, B=2, C=3
            <code>
            string s = RwCollection.AsString&lt;int&gt;(dictionary, ",", "{", "}");
            ==&gt; {A=1,B=2,C=3}   // 이렇게 나온다.
            </code></example>
    </member>
    <member name="T:NSoft.NFramework.Reflections.TypeConvertableDynamicAccessor">
      <summary>
        <see cref="T:NSoft.NFramework.Reflections.DynamicAccessor" />는 속성, 필드의 수형에 엄격합니다. 이 클래스는 유연한 수형 변환을 자동으로 해줍니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Reflections.TypeConvertableDynamicAccessor.#ctor(System.Type)">
      <summary>
            생성자
            </summary>
      <param name="type">대상 수형</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.TypeConvertableDynamicAccessor.#ctor(System.Type,System.Boolean)">
      <summary>
            생성자
            </summary>
      <param name="type">대상 수형</param>
      <param name="suppressError">객체 접근 수행시의 예외 발생을 시킬 것인가 여부. true이면 예외 발생을 하지 않는다.</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.TypeConvertableDynamicAccessor.#ctor(System.Type,System.Boolean,System.Boolean)">
      <summary>
            생성자
            </summary>
      <param name="type">대상 수형</param>
      <param name="suppressError">예외 발생을 억제할 것인가?</param>
      <param name="ignoreCase">속성명, 필드명의 대소문자를 구분할 것인가?</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.TypeConvertableDynamicAccessor.SetFieldValue(System.Object,System.String,System.Object)">
      <summary>
            지정된 인스턴스의 필드에 지정된 값을 필드 수형에 맞게 변환하여 설정합니다. 기존 <see cref="T:NSoft.NFramework.Reflections.DynamicAccessor" />는 수형이 정확히 일치하지 않으면 예외를 발생시킵니다.
            </summary>
      <param name="target">대상 객체</param>
      <param name="fieldName">필드 변수 명</param>
      <param name="fieldValue">설정할 필드 값</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.TypeConvertableDynamicAccessor.SetPropertyValue(System.Object,System.String,System.Object)">
      <summary>
            지정된 인스턴스의 속성에 지정된 값을 속성의 수형에 맞게 변환하여 설정합니다. 기존 <see cref="T:NSoft.NFramework.Reflections.DynamicAccessor" />는 수형이 정확히 일치하지 않으면 예외를 발생시킵니다.
            </summary>
      <param name="target">대상 객체</param>
      <param name="propertyName">속성 명</param>
      <param name="propertyValue">속성 값</param>
    </member>
    <member name="T:NSoft.NFramework.Reflections.TypeConvertableDynamicAccessor`1">
      <summary>
            대상 수형에 맞게, 설정 값의 수형을 변환시켜, 설정할 수 있는 DynamicAccessor입니다.
            </summary>
      <typeparam name="T">접근할 대상 수형</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Reflections.TypeConvertableDynamicAccessor`1.#ctor">
      <summary>
            기본 생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Reflections.TypeConvertableDynamicAccessor`1.#ctor(System.Boolean)">
      <summary>
            생성자
            </summary>
      <param name="suppressError">객체 접근 수행시의 예외 발생을 시킬 것인가 여부. true이면 예외발생을 하지 않는다.</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.TypeConvertableDynamicAccessor`1.#ctor(System.Boolean,System.Boolean)">
      <summary>
            생성자
            </summary>
      <param name="suppressError">객체 접근 수행시의 예외 발생을 시킬 것인가 여부. true이면 예외 발생을 하지 않는다.</param>
      <param name="ignoreCase">속성명, 필드명의 대소문자를 구분할 것인가?</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.TypeConvertableDynamicAccessor`1.SetFieldValue(`0,System.String,System.Object)">
      <summary>
            지정된 인스턴스의 필드에 지정된 값을 필드 수형에 맞게 변환하여 설정합니다. 기존 <see cref="T:NSoft.NFramework.Reflections.DynamicAccessor" />는 수형이 정확히 일치하지 않으면 예외를 발생시킵니다.
            </summary>
      <param name="target">대상 객체</param>
      <param name="fieldName">필드 변수 명</param>
      <param name="fieldValue">설정할 필드 값</param>
    </member>
    <member name="M:NSoft.NFramework.Reflections.TypeConvertableDynamicAccessor`1.SetPropertyValue(`0,System.String,System.Object)">
      <summary>
            지정된 인스턴스의 속성에 지정된 값을 속성의 수형에 맞게 변환하여 설정합니다. 기존 <see cref="T:NSoft.NFramework.Reflections.DynamicAccessor" />는 수형이 정확히 일치하지 않으면 예외를 발생시킵니다.
            </summary>
      <param name="target">대상 객체</param>
      <param name="propertyName">속성 명</param>
      <param name="propertyValue">속성 값</param>
    </member>
    <member name="T:NSoft.NFramework.ResourceProviders.IResourceProvider">
      <summary>
            리소스 정보를 제공하는 Provider입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.ResourceProviders.IResourceProvider.GetString(System.String)">
      <summary>
            리소스 문자열을 로드합니다.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ResourceProviders.IResourceProvider.GetString(System.String,System.Object[])">
      <summary>
            리소스 문자열을 로드합니다.
            </summary>
      <param name="name">
      </param>
      <param name="values">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ResourceProviders.IResourceProvider.GetObject(System.String)">
      <summary>
            리소스 키에 해당하는 정보를 로드합니다.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ResourceProviders.IResourceProvider.GetObject``1(System.String)">
      <summary>
            리소스 키에 해당하는 정보를 로드합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.ResourceProviders.ResourceProvider">
      <summary>
            어셈블리의 리소스의 정보를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.ResourceProviders.ResourceProviderBase.GetString(System.String)">
      <summary>
        <paramref name="name" />에 해당하는 리소스 문자열을 얻습니다.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ResourceProviders.ResourceProviderBase.GetString(System.String,System.Object[])">
      <summary>
        <paramref name="name" />에 해당하는 리소스 문자열을 얻어, string.Format()을 수행하여 반환합니다.
            </summary>
      <param name="name">
      </param>
      <param name="values">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ResourceProviders.ResourceProviderBase.GetObject(System.String)">
      <summary>
        <paramref name="name" />에 해당하는 리소스 객체를 얻습니다.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ResourceProviders.ResourceProviderBase.GetObject``1(System.String)">
      <summary>
        <paramref name="name" />에 해당하는 객체를 얻습니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.ResourceProviders.ResourceProvider`1">
      <summary>
            해당 클래스가 속한 Assembly에서 리소스 로더를 생성합니다.
            </summary>
      <typeparam name="TClass">리소스를 찾고자 하는 어셈블리의 해당 클래스</typeparam>
    </member>
    <member name="M:NSoft.NFramework.ResourceProviders.ResourceProvider`1.GetString(System.String)">
      <summary>
        <paramref name="name" />에 해당하는 리소스 문자열을 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.ResourceProviders.ResourceProvider`1.GetString(System.String,System.Object[])">
      <summary>
        <paramref name="name" />에 해당하는 리소스 문자열을 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.ResourceProviders.ResourceProvider`1.GetObject(System.String)">
      <summary>
        <paramref name="name" />에 해당하는 리소스 객체를 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.ResourceProviders.ResourceProvider`1.GetObject``1(System.String)">
      <summary>
        <paramref name="name" />에 해당하는 리소스 객체를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.ResourceProviders.ResourceProvider`1.Instance">
      <summary>
            Singleton Instance
            </summary>
    </member>
    <member name="P:NSoft.NFramework.ResourceProviders.ResourceProvider`1.ResourceManager">
      <summary>
            리소스 매니저
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Serializations.SerializedObjects.AbstractSerializedObject">
      <summary>
            객체를 직렬화한 결과 정보 (Binary, JSON, XML, SOAP 등)의 기본 클래스 (원본 객체의 수형과 직렬화된 결과물을 가진다)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Serializations.ISerializedObject">
      <summary>
            객체를 직렬화한 결과 정보 (Binary, JSON, XML, SOAP 등)의 기본 인터페이스 (원본 객체의 수형과 직렬화된 결과물을 가진다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.ISerializedObject.GetDeserializedObject">
      <summary>
            역직렬화를 통해, 객체를 반환한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Serializations.ISerializedObject.Method">
      <summary>
            직렬화 방법 (Binary|Xml|Soap|Json 등)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Serializations.ISerializedObject.ObjectTypeName">
      <summary>
            원본 객체 수형 명 (역직렬화 시에 필요)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Serializations.ISerializedObject.SerializedValue">
      <summary>
            원본 객체를 직렬화된 정보
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializedObjects.AbstractSerializedObject.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializedObjects.AbstractSerializedObject.#ctor(System.Object)">
      <summary>
            생성자
            </summary>
      <param name="graph">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializedObjects.AbstractSerializedObject.GetDeserializedObject">
      <summary>
            역직렬화를 통해, 객체를 반환한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializedObjects.AbstractSerializedObject.Equals(NSoft.NFramework.Serializations.ISerializedObject)">
      <summary>
            현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다.
            </summary>
      <returns>
            현재 개체가 <paramref name="other" /> 매개 변수와 같으면 true이고, 그렇지 않으면 false입니다.
            </returns>
      <param name="other">이 개체와 비교할 개체입니다.</param>
    </member>
    <member name="P:NSoft.NFramework.Serializations.SerializedObjects.AbstractSerializedObject.Method">
      <summary>
            직렬화 방법 (Binary|Xml|Soap|Json 등)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Serializations.SerializedObjects.AbstractSerializedObject.ObjectTypeName">
      <summary>
            원본 객체 수형 명 (역직렬화 시에 필요)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Serializations.SerializedObjects.AbstractSerializedObject.SerializedValue">
      <summary>
            원본 객체를 직렬화된 정보
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Serializations.SerializedObjects.BinarySerializedObject">
      <summary>
            객체를 Binary 방식으로 직렬화하여 보관할 수 있도록 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializedObjects.BinarySerializedObject.GetDeserializedObject">
      <summary>
            역직렬화를 통해, 객체를 반환한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Serializations.SerializedObjects.BsonSerializedObject">
      <summary>
            객체를 BSON 직렬화하여 보관할 수 있도록 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializedObjects.BsonSerializedObject.GetDeserializedObject">
      <summary>
            역직렬화를 통해, 객체를 반환한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Serializations.SerializedObjects.JsonSerializedObject">
      <summary>
            객체를 JSON 포맷으로 직렬화/역직렬화를 수행합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializedObjects.JsonSerializedObject.GetDeserializedObject">
      <summary>
            역직렬화를 통해, 객체를 반환한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializedObjects.SoapSerializedObject.GetDeserializedObject">
      <summary>
            역직렬화를 통해, 객체를 반환한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Serializations.SerializedObjects.XmlSerializedObject">
      <summary>
            객체를 XML 직렬화하여 보관할 수 있도록 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializedObjects.XmlSerializedObject.GetDeserializedObject">
      <summary>
            역직렬화를 통해, 객체를 반환한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Serializations.Serializers.BinarySerializer">
      <summary>
            object를 binary 형식으로 serialize를 수행한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.BinarySerializer.Serialize(System.Object)">
      <summary>
            지정된 객체를 Binary 형식으로 Serialize를 수행합니다.
            </summary>
      <param name="graph">
      </param>
      <returns>직렬화된 객체, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.BinarySerializer.Deserialize(System.Byte[])">
      <summary>
            Binary 형식으로 Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">직렬화된 정보</param>
      <returns>역직렬화 객체</returns>
    </member>
    <member name="P:NSoft.NFramework.Serializations.Serializers.BinarySerializer.Instance">
      <summary>
            BinarySerializer의 Singleton Instance
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.BinarySerializer`1.Serialize(`0)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">object to be serialized.</param>
      <returns>직렬화된 객체, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.BinarySerializer`1.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">serialized data to be deserialized.</param>
      <returns>deserialized object</returns>
    </member>
    <member name="P:NSoft.NFramework.Serializations.Serializers.BinarySerializer`1.Instance">
      <summary>
            BinarySerializer{T} 의 Singleton Instance
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Serializations.Serializers.CloneSerializer.Instance">
      <summary>
            CloneSerializer의 Singleton Instance
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Serializations.Serializers.CompressSerializer">
      <summary>
            Decorator 패턴을 이용하여, 직렬화 후 압축해주는 Decorator 입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.CompressSerializer.Serialize(System.Object)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">object to be serialized.</param>
      <returns>직렬화된 객체, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.CompressSerializer.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">serialized data to be deserialized.</param>
      <returns>deserialized object</returns>
    </member>
    <member name="P:NSoft.NFramework.Serializations.Serializers.CompressSerializer.Serializer">
      <summary>
            실제 Serializer
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Serializations.Serializers.CompressSerializer.Compressor">
      <summary>
            Compressor
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.EncryptSerializer.Serialize(System.Object)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">직렬화할 객체</param>
      <returns>직렬화된 객체 정보, graph가 null이면, 길이가 0인 byte[] 반환</returns>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="graph" />의 형식이 byte[] 가 아닌 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.EncryptSerializer.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">객체를 직렬화한 정보</param>
      <returns>역직렬화한 객체</returns>
    </member>
    <member name="P:NSoft.NFramework.Serializations.Serializers.EncryptSerializer.Serializer">
      <summary>
            실제 Serializer
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Serializations.Serializers.EncryptSerializer.Encryptor">
      <summary>
            대칭형 암호화 기
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Serializations.Serializers.EncryptSerializer`1">
      <summary>
            Decorator 패턴을 이용하여, 직렬화 수행 후 암호화를 수행합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.EncryptSerializer`1.Serialize(`0)">
      <summary>
            지정된 객체를 Serialize를 수행하고, 암호화를 합니다.
            </summary>
      <param name="graph">직렬화할 객체</param>
      <returns>직렬화된 객체 정보, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.Serializers.EncryptSerializer`1.Deserialize(System.Byte[])">
      <summary>
            암호화된 Serialized 된 정보를 복호화하고, Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">객체를 직렬화한 정보</param>
      <returns>역직렬화한 객체</returns>
    </member>
    <member name="P:NSoft.NFramework.Serializations.Serializers.EncryptSerializer`1.Encryptor">
      <summary>
            암호기. 기본암호기는 <see cref="T:NSoft.NFramework.Cryptography.Encryptors.AriaSymmetricEncryptor" /> 입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Serializations.SerializationMethod">
      <summary>
            객체를 직렬화/역직렬화 하는 방식
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Serializations.SerializationMethod.None">
      <summary>
            직렬화 없음
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Serializations.SerializationMethod.Binary">
      <summary>
            이진 방식
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Serializations.SerializationMethod.Xml">
      <summary>
            Xml
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Serializations.SerializationMethod.Soap">
      <summary>
            Soap
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Serializations.SerializationMethod.Json">
      <summary>
            JSON
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Serializations.SerializationMethod.Bson">
      <summary>
            Binary JSON
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Serializations.SerializationOptions">
      <summary>
            직렬화 옵션
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Serializations.SerializationOptions.Method">
      <summary>
            직렬화 방법 (JSON, BSON, XML 등)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Serializations.SerializationOptions.IsCompress">
      <summary>
            압축 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Serializations.SerializationOptions.IsEncrypt">
      <summary>
            암호화 여부
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializedObjectTool.Create(NSoft.NFramework.Serializations.SerializationMethod,System.String,System.Byte[])">
      <summary>
            지정된 직렬화 정보들을 가지고 <see cref="T:NSoft.NFramework.Serializations.ISerializedObject" />의 Concrete Class의 인스턴스를 생성합니다.
            </summary>
      <param name="method">
      </param>
      <param name="typename">
      </param>
      <param name="serializedValue">
      </param>
      <returns>
      </returns>
    </member>
    <member name="F:NSoft.NFramework.Serializations.SerializerTool.EmptyBytes">
      <summary>
            길이가 0인 바이트 배열
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Serializations.SerializerTool.DefaultSerializationOp">
      <summary>
            기본 직렬화 옵션 (Json)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializerTool.Serialize(System.Object,System.IO.Stream,System.Runtime.Serialization.IFormatter)">
      <summary>
            Serialize specified <paramref name="graph" /> with specified <paramref name="formatter" />, then save to stream.
            </summary>
      <param name="graph">serializing target object.</param>
      <param name="stream">where put serialization data.</param>
      <param name="formatter">serialization format</param>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializerTool.Deserialize``1(System.IO.Stream,System.Runtime.Serialization.IFormatter,System.Runtime.Serialization.SerializationBinder)">
      <summary>
            Deserialize from stream at current position.
            </summary>
      <remarks>
            Stream의 현재 위치부터 읽어서, 역직렬화를 수행하므로, 
            이 함수 호출전에 꼭 Position을 원하는 위치에 이동시켜 놓아야 한다.
            </remarks>
      <typeparam name="T">역직렬화된 인스턴스의 형식</typeparam>
      <param name="stream">target stream to deserialize</param>
      <param name="formatter">Deserialization Formatter</param>
      <param name="binder">Serialization binder</param>
      <returns>
            deserialized object, 
            if stream is null or fail to deserialize, return default(T)
            </returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializerTool.DeepCopy``1(``0,System.Runtime.Serialization.SerializationBinder)">
      <summary>
            인스턴스를 Deep Copy 수행한다.
            </summary>
      <typeparam name="T">Type of object to deep copy</typeparam>
      <param name="source">source object</param>
      <param name="binder">Serialization binder</param>
      <returns>copied object, if source is default(T), return default(T).</returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializerTool.IsSafelySerializable(System.Object)">
      <summary>
            Is specified object can serialize/deserialize safely ?
            </summary>
      <param name="target">target object</param>
      <returns>if target object can serialize/deserialized safely, return true, otherwise return false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializerTool.IsSafelySerializable(System.Type)">
      <summary>
            Is specified object can serialize/deserialize safely ?
            </summary>
      <param name="objectType">Type of object to serialze/deserialize</param>
      <returns>if target object can serialize/deserialized safely, return true, otherwise return false.</returns>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializerTool.Serialize``1(``0,NSoft.NFramework.Serializations.SerializationOptions)">
      <summary>
            객체를 <paramref name="serializationOp" /> 방식으로 직렬화합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializerTool.Deserialize``1(System.Byte[],NSoft.NFramework.Serializations.SerializationOptions)">
      <summary>
            직렬화 정보를 <paramref name="serializationOp" />  방식으로 역직렬화하여 객체로 빌드합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Serializations.SerializerTool.CreateSerializer``1(NSoft.NFramework.Serializations.SerializationOptions)">
      <summary>
        <see cref="T:NSoft.NFramework.Serializations.SerializationOptions" />에 맞는 Serializer를 생성합니다.
            </summary>
      <param name="serializationOp">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Threading.AbstractThread">
      <summary>
        <see cref="P:NSoft.NFramework.Threading.AbstractThread.InternalThread" />를 Wrapping 한 Abstract InternalThread Class 입니다.
            </summary>
      <remarks>
            쓰레드 진행과 관련된 event 들을 추가하여, 스레드 내부 상황을 알 수 있도록 했다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.Sleep(System.Int32)">
      <summary>
        <see cref="T:System.Threading.Monitor" />.Wait 를 이용하여 Sleep 함수를 구현한 것이다. 앞으로는 <see cref="M:NSoft.NFramework.Threading.ThreadTool.Sleep(System.Int32)" /> 함수를 이용하세요
            </summary>
      <param name="millisecondsTimeout">timeout</param>
      <seealso cref="M:NSoft.NFramework.Threading.ThreadTool.Sleep(System.Int32)" />
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.#ctor(System.String)">
      <summary>
            Initialize a new instance of AbstractThread with thread name.
            </summary>
      <param name="name">쓰레드 이름</param>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.#ctor(System.Int32)">
      <summary>
            Initialize a new instance of AbstractThread with max stack size.
            </summary>
      <param name="maxStackSize">최대 스택 크기</param>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.#ctor(System.String,System.Int32)">
      <summary>
            Initialize a new instance of AbstractThread with thread name and max stack size
            </summary>
      <param name="name">쓰레드 명</param>
      <param name="maxStackSize">최대 스택 크기</param>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.OnStarted">
      <summary>
            쓰레드 시작시 호출된다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.OnProgressChanged(System.Int32)">
      <summary>
            쓰레드의 진행 상황이 변경되었을 시에 발생한다.
            </summary>
      <param name="progressPercentage">진행 정보</param>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.OnFinished">
      <summary>
            쓰레드가 완료되었을 시에 발생한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.Run">
      <summary>
            ThreadStart Delegate용 함수
            이 함수를 재정의하여 사용한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.op_Explicit(NSoft.NFramework.Threading.AbstractThread)~System.Threading.Thread">
      <summary>
            Wapping 한 <c>InternalThread</c> 인스턴스로 캐스팅하여 가져오게 하기 위해 사용
            </summary>
      <param name="m">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.Abort">
      <summary>
             이 메서드가 호출되는 스레드에서 System.Threading.ThreadAbortException을 발생시켜
             스레드 종료 프로세스를 시작합니다. 이 메서드를 호출하면 대개 스레드가 종료됩니다.
            </summary>
      <exception cref="T:System.Security.SecurityException">호출자에게 필요한 권한이 없는 경우</exception>
      <exception cref="T:System.Threading.ThreadStateException">중단 중인 스레드가 현재 일시 중단된 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.Abort(System.Object)">
      <summary>
            이 메서드가 호출되는 스레드에서 System.Threading.ThreadAbortException을 발생시켜 스레드 종료 프로세스를
            시작하고, 스레드 종료에 대한 예외 정보를 제공합니다. 이 메서드를 호출하면 대개 스레드가 종료됩니다.
            </summary>
      <param name="stateInfo">상태와 같이 중단 중인 스레드에서 사용할 수 있는 응용 프로그램 관련 정보를 포함하는 개체입니다.</param>
      <exception cref="T:System.Security.SecurityException">
            호출자에게 필요한 권한이 없는 경우
            </exception>
      <exception cref="T:System.Threading.ThreadStateException">
            중단 중인 스레드가 현재 일시 중단된 경우
            </exception>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.GetApartmentState">
      <summary>
            아파트 상태를 나타내는 <see cref="T:System.Threading.ApartmentState" /> 값을 반환합니다.
            </summary>
      <returns>
            관리되는 스레드의 아파트 상태를 나타내는 System.Threading.ApartmentState 값 중 하나입니다.
            기본값은 System.Threading.ApartmentState.Unknown입니다.
            </returns>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.GetHashCode">
      <summary>
            현재 스레드의 해시 코드를 반환합니다.
            </summary>
      <returns>정수 해시 코드 값입니다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.Interrupt">
      <summary>
            WaitSleepJoin 스레드 상태에 있는 스레드를 중단합니다.
            </summary>
      <exception cref="T:System.Security.SecurityException">
            호출자에게 해당 System.Security.Permissions.SecurityPermission이 없는 경우
            </exception>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.Join">
      <summary>
            표준 COM 및 SendMessage 펌프를 계속 수행하면서 스레드가 종료될 때까지 호출 스레드를 차단합니다.
            </summary>
      <exception cref="T:System.Threading.ThreadStateException">호출자가 System.Threading.ThreadState.Unstarted 상태의 스레드에 참여하려고 시도한 경우</exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">대기 중에 스레드가 중단된 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.Join(System.Int32)">
      <summary>
            표준 COM 및 SendMessage 펌프를 계속 수행하면서 스레드가 종료되거나 지정된 시간이 경과할 때까지 호출 스레드를 차단합니다.
            </summary>
      <param name="millisecondsTimeout">스레드가 종료되기를 기다릴 밀리초 수입니다.</param>
      <returns>
            스레드가 종료되면 true이고, 
            millisecondsTimeout 매개 변수에서 지정한 기간이 경과된 후에도 스레드가 종료되지 않으면 false입니다.
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
             millisecondsTimeout 값이 음수이고 System.Threading.Timeout.Infinite(밀리초)와 같지 않은 경우
            </exception>
      <exception cref="T:System.Threading.ThreadStateException">스레드가 시작되지 않은 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.Join(System.TimeSpan)">
      <summary>
            표준 COM 및 SendMessage 펌프를 계속 수행하면서 스레드가 종료되거나 지정된 시간이 경과할 때까지 호출 스레드를 차단합니다.
            </summary>
      <param name="timeout">스레드가 종료되기를 기다릴 시간으로 설정된 <see cref="T:System.TimeSpan" /></param>
      <returns>
            스레드가 종료되면 true이고, 
            millisecondsTimeout 매개 변수에서 지정한 기간이 경과된 후에도 스레드가 종료되지 않으면 false입니다.
            </returns>
      <exception cref="T:System.Threading.ThreadStateException">
            호출자가 System.Threading.ThreadState.Unstarted 상태의 스레드에 참여하려고 시도한 경우
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
             timeout 값이 음수이고 System.Threading.Timeout.Infinite(밀리초)와 같지 않거나 System.Int32.MaxValue(밀리초)보다 큰 경우
            </exception>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.SetApartmentState(System.Threading.ApartmentState)">
      <summary>
            스레드를 시작하기 전에 스레드의 아파트 상태를 설정합니다.
            </summary>
      <param name="state"> 새 아파트 상태입니다.</param>
      <exception cref="T:System.InvalidOperationException">
            아파트의 상태가 이미 초기화된 경우
            </exception>
      <exception cref="T:System.Threading.ThreadStateException">스레드가 이미 시작된 경우</exception>
      <exception cref="T:System.ArgumentException">state가 잘못된 아파트 상태인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.Start">
      <summary>
            운영 체제에서 현재 인스턴스의 상태를 System.Threading.ThreadState.Running으로 변경하도록 합니다.
            </summary>
      <exception cref="T:System.Threading.ThreadStateException">스레드가 이미 시작된 경우</exception>
      <exception cref="T:System.OutOfMemoryException"> 이 스레드를 시작할 충분한 메모리가 없는 경우</exception>
      <exception cref="T:System.Security.SecurityException">호출자에게 해당 System.Security.Permissions.SecurityPermission이 없는 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.Start(System.Object)">
      <summary>
            운영 체제에서 현재 인스턴스의 상태를 System.Threading.ThreadState.Running으로 변경하도록 하며 경우에
            따라 스레드가 실행하는 메서드에 사용될 데이터가 들어 있는 개체를 제공합니다.
            </summary>
      <param name="parameter">스레드가 실행하는 메서드에 사용될 데이터가 들어 있는 개체입니다.</param>
      <exception cref="T:System.Threading.ThreadStateException">스레드가 이미 시작된 경우</exception>
      <exception cref="T:System.OutOfMemoryException"> 이 스레드를 시작할 충분한 메모리가 없는 경우</exception>
      <exception cref="T:System.Security.SecurityException">호출자에게 해당 System.Security.Permissions.SecurityPermission이 없는 경우</exception>
      <exception cref="T:System.InvalidOperationException">
            System.Threading.ParameterizedThreadStart 대리자 대신 System.Threading.ThreadStart
                대리자를 사용하여 이 메서드를 만든 경우
            </exception>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractThread.TrySetApartmentState(System.Threading.ApartmentState)">
      <summary>
            스레드를 시작하기 전에 스레드의 아파트 상태를 설정합니다.
            </summary>
      <param name="state">새 아파트 상태입니다.</param>
      <returns>아파트 상태가 설정되어 있으면 true이고, 그렇지 않으면 false입니다.</returns>
      <exception cref="T:System.Threading.ThreadStateException">트랜잭션이 이미 시작된 경우</exception>
      <exception cref="T:System.ArgumentException">state가 잘못된 아파트 상태인 경우</exception>
    </member>
    <member name="P:NSoft.NFramework.Threading.AbstractThread.InternalThread">
      <summary>
            Wrapping 한 <c>InternalThread</c> 인스턴스
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Threading.AbstractThread.ThreadStarted">
      <summary>
            InternalThread 시작시 발생하는 이벤트
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Threading.AbstractThread.ThreadFinished">
      <summary>
            InternalThread 완료시 발생하는 이벤트
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Threading.AbstractThread.ThreadProgressChanged">
      <summary>
             InternalThread 가 수행될 때, 진행상황을 알 수있도록 하는 이벤트
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Threading.AbstractThread.ApartmentState">
      <summary>
             이 스레드의 아파트 상태를 가져오거나 설정합니다.
            </summary>
      <value>
        <c>System.Threading.ApartmentState</c> 값 중 하나입니다. 초기 값은 Unknown입니다.</value>
      <exception cref="T:System.ArgumentException">이 속성을 유효하지 않은 아파트 상태, 즉 단일 스레드 아파트(STA)나 다중 스레드 아파트(MTA) 이외의 아파트 상태로 설정하려고 시도한 경우</exception>
    </member>
    <member name="P:NSoft.NFramework.Threading.AbstractThread.CurrentCulture">
      <summary>
            현재 스레드에 대한 culture를 가져오거나 설정합니다.
            </summary>
      <value>현재 스레드에 대한 culture를 나타내는 System.Globalization.CultureInfo입니다.</value>
    </member>
    <member name="P:NSoft.NFramework.Threading.AbstractThread.CurrentUICulture">
      <summary>
            리소스 관리자가 런타임에 culture 관련 리소스를 찾기 위해 사용하는 현재 culture를 가져오거나 설정합니다.
            </summary>
      <value>현재 culture를 나타내는 System.Globalization.CultureInfo입니다.</value>
      <exception cref="T:System.ArgumentNullException">속성 값이 null인 경우</exception>
    </member>
    <member name="P:NSoft.NFramework.Threading.AbstractThread.ExecutionContext">
      <summary>
            현재 스레드의 다양한 컨텍스트 정보를 포함하는 System.Threading.ExecutionContext 개체를 가져옵니다.
            </summary>
      <value>
            현재 스레드의 컨텍스트 정보를 통합하는 System.Threading.ExecutionContext 개체입니다.
            </value>
    </member>
    <member name="P:NSoft.NFramework.Threading.AbstractThread.IsAlive">
      <summary>
            현재 스레드의 실행 상태를 나타내는 값을 가져옵니다.
            </summary>
      <value>이 스레드가 시작되었으며 정상적으로 종료 또는 중단되지 않았으면 true이고, 그렇지 않으면 false입니다.</value>
    </member>
    <member name="P:NSoft.NFramework.Threading.AbstractThread.IsBackground">
      <summary>
            스레드가 배경 스레드인지 여부를 나타내는 값을 가져오거나 설정합니다.
            </summary>
      <value>이 스레드가 배경 스레드이거나 배경 스레드가 될 예정이면 true이고, 그렇지 않으면 false입니다.</value>
      <exception cref="T:System.Threading.ThreadStateException">스레드가 비활성화된 경우</exception>
    </member>
    <member name="P:NSoft.NFramework.Threading.AbstractThread.IsThreadPoolThread">
      <summary>
            스레드가 관리되는 스레드 풀에 속하는지 여부를 나타내는 값을 가져옵니다.
            </summary>
      <value>이 스레드가 관리되는 스레드 풀에 속하면 true이고, 그렇지 않으면 false입니다.</value>
    </member>
    <member name="P:NSoft.NFramework.Threading.AbstractThread.ManagedThreadId">
      <summary>
            현재 관리되는 스레드의 고유 식별자를 가져옵니다.
            </summary>
      <value>이 스레드의 고유 식별자를 나타내는 정수입니다.</value>
    </member>
    <member name="P:NSoft.NFramework.Threading.AbstractThread.Name">
      <summary>
            스레드의 이름을 가져오거나 설정합니다.
            </summary>
      <value>스레드의 이름을 포함하는 문자열이며 설정된 이름이 없으면 null입니다.</value>
    </member>
    <member name="P:NSoft.NFramework.Threading.AbstractThread.Priority">
      <summary>
            스레드의 예약 우선 순위를 나타내는 값을 가져오거나 설정합니다.
            </summary>
      <value>
        <c>System.Threading.ThreadPriority</c> 값 중 하나입니다. 기본값은 Normal입니다.
            </value>
      <exception cref="T:System.Threading.ThreadStateException">
            스레드가 System.Threading.ThreadState.Aborted와 같은 최종 상태에 도달한 경우
            </exception>
      <exception cref="T:System.ArgumentException">
            set 작업에 대해 지정된 값이 유효한 ThreadPriority 값이 아닌 경우
            </exception>
    </member>
    <member name="P:NSoft.NFramework.Threading.AbstractThread.ThreadState">
      <summary>
            현재 스레드의 상태를 포함하는 값을 가져옵니다.
            </summary>
      <value>
            현재 스레드의 상태를 나타내는 System.Threading.ThreadState 값 중 하나입니다. 초기 값은 Unstarted입니다.
            </value>
    </member>
    <member name="T:NSoft.NFramework.Threading.AbstractWorkerThread">
      <summary>
            Worker Thread 의 기본 클래스
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractWorkerThread.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractWorkerThread.#ctor(System.String)">
      <summary>
            생성자
            </summary>
      <param name="name">스레드 이름</param>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractWorkerThread.#ctor(System.Int32)">
      <summary>
            생성자
            </summary>
      <param name="maxStackSize">스레드가 사용할 최대 Stack 크기</param>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractWorkerThread.#ctor(System.String,System.Int32)">
      <summary>
            생성자
            </summary>
      <param name="name">스레드 이름</param>
      <param name="maxStackSize">스레드가 사용할 최대 Stack 크기</param>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractWorkerThread.OnShutDowned">
      <summary>
            스레드가 종료되었을 시 호출되는 함수. 내부적으로 <see cref="E:NSoft.NFramework.Threading.AbstractWorkerThread.ShutDownRequested" /> 이벤트를 호출한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractWorkerThread.OnShutDownRequested">
      <summary>
            스레드가 종료되었을 시 호출되는 함수. 내부적으로 <see cref="E:NSoft.NFramework.Threading.AbstractWorkerThread.ShutDownRequested" /> 이벤트를 호출한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractWorkerThread.ShutDown">
      <summary>
            InternalThread 중지를 요청합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractWorkerThread.Run">
      <summary>
            Two-phase termination이 가능하도록 내부에서 항상 shutdown요청을 감시하면서 단위작업을 수행한다.
            <see cref="T:System.Threading.ThreadInterruptedException" />이 발생해도 내부적으로 무시하고 진행한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractWorkerThread.DoWork">
      <summary>
            InternalThread 내에서 작업하고자 하는 코드를 구현한다.
            <see cref="T:NSoft.NFramework.Threading.AbstractWorkerThread" />.RunEach() 메소드에서 Shutdown 요청이 들어오기 전까지는 반복적으로 DoWork 메소드를 호출하므로,
            실제 작업하고자 하는 단위 작업만 작성하면 됩니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractWorkerThread.DoShutDown">
      <summary>
            종료 요청시 뒷 정리를 담당하는 함수입니다.
            뒷 정리에 관련된 내용을 구현해야 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.AbstractWorkerThread.Interrupt">
      <summary>
            스레드를 중지시킵니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Threading.AbstractWorkerThread.IsShutdownRequested">
      <summary>
            중지 요청 여부
            </summary>
    </member>
    <member name="E:NSoft.NFramework.Threading.AbstractWorkerThread.ShutDownRequested">
      <summary>
            InternalThread 중지 요청시
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Threading.CountdownLatch">
      <summary>
            Master Thread에 소속된 Sub Thread들의 모두 작업이 완료될 때까지 Master Thread를 기다리게 하는 작업을 수행한다.
            </summary>
      <remarks>
            참고: http://msdn.microsoft.com/ko-kr/magazine/cc163427.aspx
            </remarks>
      <example>
        <code>
            // wait 5 events with 5 millisecond timeout.
            using(CountdownLatch countdown = new CountdownLatch(5))
            {
            	bool result = countdown.WaitOne(TimeSpan.FromMilliseconds(5));
            	Assert.IsFalse(result);
            }
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Threading.CountdownLatch.#ctor(System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="numberOfCustomers">Sub thread의 수</param>
    </member>
    <member name="M:NSoft.NFramework.Threading.CountdownLatch.WaitOne">
      <summary>
            하나의 작업이 끝나기를 기다린다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Threading.CountdownLatch.WaitOne(System.TimeSpan)">
      <summary>
            Timeout 기간동안만 하나의 작업이 끝나기를 기다린다. timeout이 되면 false를 반환한다.
            </summary>
      <param name="timeout">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Threading.CountdownLatch.Set">
      <summary>
            CountdownLatch가 대기상태이면 계속 진행할 수있도록 Event 상태를 신호 받음으로 설정한다.
            </summary>
      <returns>대기중인 자식 Thread 수</returns>
    </member>
    <member name="M:NSoft.NFramework.Threading.CountdownLatch.Reset(System.Int32)">
      <summary>
            자식 Thread수가 0이면 스레드가 차단되도록 이벤트 상태를 신호 없음으로 설정합니다.
            </summary>
      <param name="numberOfCustomers">자식 Thread 수</param>
    </member>
    <member name="M:NSoft.NFramework.Threading.CountdownLatch.Finalize">
      <summary>
            Finalizer
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.CountdownLatch.Dispose">
      <summary>
            Release resources. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.CountdownLatch.Dispose(System.Boolean)">
      <summary>
            Release resources.  
            </summary>
      <param name="disposing">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Threading.CountdownLatch.IsDisposed">
      <summary>
            리소스 해제 여부
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Threading.ThinEvent">
      <summary>
            경량의 Event 객체를 표현합니다. Set, Reset, Wait를 사용합니다.
            </summary>
      <remarks>
            참고: http://msdn.microsoft.com/ko-kr/magazine/cc163427.aspx
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Threading.ThinEvent.Set">
      <summary>
            Set Event State
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.ThinEvent.Reset">
      <summary>
            Reset Event	State
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.ThinEvent.Wait">
      <summary>
            Wait Event State to Set 
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Threading.ThreadSafeRandom">
      <summary>
            Thread-safe	한 Random Number Generator입니다. (Thread 별로 Random 객체가 따로 제공되고, seed 값 또한 랜덤하므로, ramdom 값 분포가 넓게 퍼지게 됩니다.)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.ThreadSafeRandom.Next">
      <summary>
            음수가 아닌 난수를 반환합니다.
            </summary>
      <returns>
            0보다 크거나 같고 <see cref="F:System.Int32.MaxValue" />보다 작은 부호 있는 32비트 정수입니다.
            </returns>
    </member>
    <member name="M:NSoft.NFramework.Threading.ThreadSafeRandom.Next(System.Int32)">
      <summary>
            지정된 최대값보다 작은 음수가 아닌 난수를 반환합니다.
            </summary>
      <returns>
            0보다 크거나 같고 <paramref name="maxValue" />보다 작은 부호 있는 32비트 정수이므로 반환 값의 범위에는 대개 0이 포함되지만 <paramref name="maxValue" />는 포함되지 않습니다. 하지만 <paramref name="maxValue" />가 0과 같으면 <paramref name="maxValue" />가 반환됩니다.
            </returns>
      <param name="maxValue">생성되는 난수의 상한(제외)입니다. <paramref name="maxValue" />는 0보다 크거나 같아야 합니다. </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maxValue" />가 0 미만인 경우 </exception>
    </member>
    <member name="M:NSoft.NFramework.Threading.ThreadSafeRandom.Next(System.Int32,System.Int32)">
      <summary>
            지정된 범위 내의 난수를 반환합니다.
            </summary>
      <returns>
        <paramref name="minValue" />보다 크거나 같고 <paramref name="maxValue" />보다 작은 부호 있는 32비트 정수이므로 반환 값의 범위에는 <paramref name="minValue" />가 포함되지만 <paramref name="maxValue" />는 포함되지 않습니다. <paramref name="minValue" />가 <paramref name="maxValue" />와 같은 경우에는 <paramref name="minValue" />가 반환됩니다.
            </returns>
      <param name="minValue">반환되는 난수의 하한(포함)입니다. </param>
      <param name="maxValue">반환되는 난수의 상한(제외)입니다. <paramref name="maxValue" />는 <paramref name="minValue" />보다 크거나 같아야 합니다. </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="minValue" />가 <paramref name="maxValue" />보다 큰 경우 </exception>
    </member>
    <member name="M:NSoft.NFramework.Threading.ThreadSafeRandom.NextBytes(System.Byte[])">
      <summary>
            지정된 바이트 배열의 요소를 난수로 채웁니다.
            </summary>
      <param name="buffer">난수를 포함하는 바이트 배열입니다. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" />가 null인 경우 </exception>
    </member>
    <member name="M:NSoft.NFramework.Threading.ThreadSafeRandom.NextDouble">
      <summary>
            0.0과 1.0 사이의 난수를 반환합니다.
            </summary>
      <returns>
            0.0보다 크거나 같고 1.0보다 작은 배정밀도 부동 소수점 숫자입니다.
            </returns>
    </member>
    <member name="T:NSoft.NFramework.Threading.ThreadTool">
      <summary>
            Thread 관련 Utility Class 입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.ThreadTool.Sleep(System.Int32)">
      <summary>
        <see cref="T:System.Threading.Monitor" />.Wait 를 이용하여 Sleep 함수를 구현한 것이다.
            </summary>
      <param name="millisecondsTimeout">timeout (msec)</param>
    </member>
    <member name="M:NSoft.NFramework.Threading.ThreadTool.CreateRandom">
      <summary>
            Seed 값이 호출할 때마다 다른 Random 인스턴스를 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Threading.WorkerProgressChangedEventArgs">
      <summary>
        <see cref="T:System.Threading.Thread" /> 진행정보를 담은 EventArgs
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Threading.WorkerThreadEventArgs">
      <summary>
        <see cref="T:NSoft.NFramework.Threading.AbstractThread" />의 Event Handler에서 사용하는 기본 EventArgs
            </summary>
    </member>
    <member name="T:NSoft.NFramework.EventArgs`1">
      <summary>
            Event argument has item which type is T
            </summary>
      <typeparam name="T">Item type</typeparam>
    </member>
    <member name="M:NSoft.NFramework.EventArgs`1.#ctor(`0)">
      <summary>
            생성자
            </summary>
      <param name="item">Event 정보를 가진 객체</param>
    </member>
    <member name="M:NSoft.NFramework.EventArgs`1.#ctor(`0,System.Object)">
      <summary>
            생성자
            </summary>
      <param name="item">Event 정보를 가진 객체</param>
      <param name="data">부가 데이터</param>
    </member>
    <member name="P:NSoft.NFramework.EventArgs`1.Item">
      <summary>
            represent data in event argument
            </summary>
    </member>
    <member name="P:NSoft.NFramework.EventArgs`1.Data">
      <summary>
            부가 데이터
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Threading.WorkerProgressChangedEventArgs.#ctor(System.Threading.Thread,System.Int32)">
      <summary>
            생성자
            </summary>
      <param name="thread">
      </param>
      <param name="processPercentage">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Threading.WorkerProgressChangedEventArgs.ProgressPercentage">
      <summary>
            진행률 (0 ~ 100) 사이의 값을 가진다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.Calendars.CalendarVisitor`2">
      <summary>
            특정 기간에 대한 필터링 정보를 기반으로 기간들을 필터링 할 수 있도록 특정 기간을 탐색하는 Visitor입니다.
            </summary>
      <typeparam name="TFilter">
      </typeparam>
      <typeparam name="TContext">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.Seekers.DaySeeker.FindDay(NSoft.NFramework.TimePeriods.TimeRanges.DayRange,System.Int32)">
      <summary>
        <paramref name="start" /> 일부터 <paramref name="offset" /> 만큼의 일수가 지난 후의 날짜를 구합니다.
            </summary>
      <param name="start">기준 일자</param>
      <param name="offset">오프셋</param>
      <returns>기준일자로부터 오프셋만큼 떨어진 일자</returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.Calendars.CalendarDateAdd">
      <summary>
            특정 Calendar 기준으로 특정 시각과 기간(Duration)을 이용하여 상대 시각을 구합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.Calendars.DateAdd">
      <summary>
            특정 시각과 기간(Duration)을 이용하여 상대 시각을 구합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.DateAdd.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.DateAdd.Add(System.DateTime,System.TimeSpan,NSoft.NFramework.TimePeriods.SeekBoundaryMode)">
      <summary>
        <paramref name="start" /> 시각으로부터 <paramref name="offset" /> 기간이 지난 시각을 계산합니다.
            </summary>
      <param name="start">시작 시각</param>
      <param name="offset">기간(Duration)</param>
      <param name="seekBoundaryMode">검색시 경계에 대한 모드</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.DateAdd.Subtract(System.DateTime,System.TimeSpan,NSoft.NFramework.TimePeriods.SeekBoundaryMode)">
      <summary>
        <paramref name="start" /> 시각으로부터 <paramref name="offset" /> 기간을 뺀 (즉 이전의) 시각을 계산합니다.
            </summary>
      <param name="start">시작 시각</param>
      <param name="offset">기간(Duration)</param>
      <param name="seekBoundaryMode">검색시 경계에 대한 모드</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.DateAdd.CalculateEnd(System.DateTime,System.TimeSpan,NSoft.NFramework.TimePeriods.SeekDirection,NSoft.NFramework.TimePeriods.SeekBoundaryMode,System.Nullable{System.TimeSpan}@)">
      <summary>
        <paramref name="start" />시각으로부터 <paramref name="offset" /> 만큼 떨어진 시각을 구합니다.
            </summary>
      <param name="start">기준 시각</param>
      <param name="offset">기간</param>
      <param name="seekDirection">검색 방향 (이전|이후)</param>
      <param name="seekBoundaryMode">검색 값 포함 여부</param>
      <param name="remaining">짜투리 기간</param>
      <returns>기준 시각으로터 오프셋만큼 떨어진 시각</returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateAdd.IncludePeriods">
      <summary>
            Date 기간 합산 연산 시에 포함되어야 할 기간
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateAdd.ExcludePeriods">
      <summary>
            Date 기간 연산 (Add, Subtract) 시에 포함하지 말아야 할 기간
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarDateAdd.AddWorkingWeekDays">
      <summary>
            주중 (월~금) 을 Working Day로 추가합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarDateAdd.AddWeekendWeekDays">
      <summary>
            주말 (토,일) 을 Working Day로 추가합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarDateAdd.Add(System.DateTime,System.TimeSpan,NSoft.NFramework.TimePeriods.SeekBoundaryMode)">
      <summary>
        <paramref name="start" /> 시각으로부터 <paramref name="offset" /> 기간이 지난 시각을 계산합니다.
            </summary>
      <param name="start">시작 시각</param>
      <param name="offset">기간(Duration)</param>
      <param name="seekBoundaryMode">검색시 경계에 대한 모드</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarDateAdd.Subtract(System.DateTime,System.TimeSpan,NSoft.NFramework.TimePeriods.SeekBoundaryMode)">
      <summary>
        <paramref name="start" /> 시각으로부터 <paramref name="offset" /> 기간을 뺀 (즉 이전의) 시각을 계산합니다.
            </summary>
      <param name="start">시작 시각</param>
      <param name="offset">기간(Duration)</param>
      <param name="seekBoundaryMode">검색시 경계에 대한 모드</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarDateAdd.CalculateEnd(System.DateTime,System.TimeSpan,NSoft.NFramework.TimePeriods.SeekDirection,NSoft.NFramework.TimePeriods.SeekBoundaryMode)">
      <summary>
        <paramref name="start" />시각으로부터 <paramref name="offset" /> 만큼 떨어진 시각을 구합니다.
            </summary>
      <param name="start">기준 시각</param>
      <param name="offset">기간</param>
      <param name="seekDirection">검색 방향 (이전|이후)</param>
      <param name="seekBoundaryMode">검색 값 포함 여부</param>
      <returns>기준 시각으로터 오프셋만큼 떨어진 시각</returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.CalendarDateAdd.TimeCalendar">
      <summary>
            기준 <see cref="T:NSoft.NFramework.TimePeriods.ITimeCalendar" /></summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.CalendarDateAdd.WeekDays">
      <summary>
            작업 요일들
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.CalendarDateAdd.WorkingHours">
      <summary>
            하루중 작업시간 기간들 (오전/오후/야간 등으로 나뉠 수 있으므로)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.CalendarDateAdd.IncludePeriods">
      <summary>
            포함 기간은 지원하지 않습니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.Calendars.CalendarDateDiff">
      <summary>
            특정 Calendar 기준으로 특정 기간의 기간 (TimeSpan)을 구합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarDateDiff.AddWorkingWeekDays">
      <summary>
            주중 (월~금) 을 Working Day로 추가합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarDateDiff.AddWeekendWeekDays">
      <summary>
            주말 (토,일) 을 Working Day로 추가합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarDateDiff.AddWeekDays(System.DayOfWeek[])">
      <summary>
        <paramref name="dayOfWeeks" />를 WorkingDay에 추가합니다.
            </summary>
      <param name="dayOfWeeks">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarDateDiff.Difference(System.DateTime)">
      <summary>
        <paramref name="moment" /> 부터 현재 시각까지의 WorkingTime의 기간을 구합니다.
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarDateDiff.Difference(System.DateTime,System.DateTime)">
      <summary>
        <paramref name="fromTime" /> ~ <paramref name="toTime" /> 기간의 WorkingTime 의 기간을 구합니다.
            </summary>
      <param name="fromTime">
      </param>
      <param name="toTime">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.Calendars.CalendarExtensions">
      <summary>
            Calendar 관련 Extensions
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarExtensions.AsString(NSoft.NFramework.TimePeriods.Calendars.ICalendarVisitorFilter)">
      <summary>
        <paramref name="filter" /> 정보를 문자열로 표현합니다.
            </summary>
      <param name="filter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.Calendars.CalendarPeriodCollector">
      <summary>
            칼렌다 기준으로 특정 기간(limits)에서 필터(filter)에 해당하는 기간을 추출합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarPeriodCollector.CollectYears">
      <summary>
            필터에 해당하는 Year 단위의 기간(<see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.YearRange" />)를 수집합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarPeriodCollector.CollectMonths">
      <summary>
            필터에 해당하는 Month 단위의 기간(<see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.MonthRange" />)를 수집합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarPeriodCollector.CollectDays">
      <summary>
            필터에 해당하는 Day 단위의 기간(<see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.DayRange" />)를 수집합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarPeriodCollector.CollectHours">
      <summary>
            필터에 해당하는 Hour 단위의 기간(<see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.HourRange" />)를 수집합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.Calendars.CalendarVisitorFilter">
      <summary>
            Calendar 탐색 시의 필터 정보 (예외 기간, 포함 일자 정보를 가진다)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.Calendars.ICalendarVisitorFilter">
      <summary>
            Calendar 탐색 시의 필터 정보 (예외 기간, 포함 일자 정보를 가진다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.ICalendarVisitorFilter.AddWorkingWeekDays">
      <summary>
            주중 (월~금) 을 Working Day로 추가합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.ICalendarVisitorFilter.AddWeekendWeekDays">
      <summary>
            주말 (토,일) 을 Working Day로 추가합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.ICalendarVisitorFilter.AddWeekDays(System.DayOfWeek[])">
      <summary>
            지정한 요일들을 탐색 필터에 포함시킨다.
            </summary>
      <param name="dayOfWeeks">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.ICalendarVisitorFilter.Clear">
      <summary>
            탐색 필터 및 예외 필터에 등록된 모든 내용을 삭제합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.ICalendarVisitorFilter.ExcludePeriods">
      <summary>
            탐색 시 제외할 기간들
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.ICalendarVisitorFilter.Years">
      <summary>
            포함 년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.ICalendarVisitorFilter.Months">
      <summary>
            포함 월
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.ICalendarVisitorFilter.Days">
      <summary>
            포함 일
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.ICalendarVisitorFilter.WeekDays">
      <summary>
            포함 요일(DayOfWeek) (예: 월, 수, 금)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.ICalendarVisitorFilter.Hours">
      <summary>
            포함 시(Hour)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.ICalendarVisitorFilter.Minutes">
      <summary>
            포함 분(Minute)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarVisitorFilter.AddWorkingWeekDays">
      <summary>
            주중 (월~금) 을 Working Day로 추가합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarVisitorFilter.AddWeekendWeekDays">
      <summary>
            주말 (토,일) 을 Working Day로 추가합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarVisitorFilter.AddWeekDays(System.DayOfWeek[])">
      <summary>
            지정한 요일들을 탐색 필터에 포함시킨다.
            </summary>
      <param name="dayOfWeeks">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.CalendarVisitorFilter.Clear">
      <summary>
            탐색 필터 및 예외 필터에 등록된 모든 내용을 삭제합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.CalendarVisitorFilter.ExcludePeriods">
      <summary>
            탐색 시 제외할 기간들
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.CalendarVisitorFilter.Years">
      <summary>
            포함 년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.CalendarVisitorFilter.Months">
      <summary>
            포함 월
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.CalendarVisitorFilter.Days">
      <summary>
            포함 일
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.CalendarVisitorFilter.WeekDays">
      <summary>
            포함 요일(DayOfWeek) (예: 월, 수, 금)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.CalendarVisitorFilter.Hours">
      <summary>
            포함 시(Hour)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.CalendarVisitorFilter.Minutes">
      <summary>
            포함 분(Minute)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.Calendars.DateDiff">
      <summary>
            특정한 두 시각 사이의 Calendar, 예외 시각등을 고려한 기간을 계산합니다.
            </summary>
      <seealso cref="T:NSoft.NFramework.TimePeriods.Calendars.DateAdd" />
      <seealso cref="T:NSoft.NFramework.TimePeriods.Calendars.CalendarDateAdd" />
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.DateDiff.#ctor(System.DateTime)">
      <summary>
            현재 시각 - <paramref name="moment" /> 을 계산합니다.
            </summary>
      <param name="moment">선행시각</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.DateDiff.#ctor(System.DateTime,System.Globalization.Calendar,System.DayOfWeek)">
      <summary>
            현재 시각 - <paramref name="date1" /> 을 <paramref name="calendar" /> 기준으로 계산합니다.
            </summary>
      <param name="date1">선행 시각</param>
      <param name="calendar">기준 Calendar</param>
      <param name="firstDayOfWeek">한 주의 첫번째 요일</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.DateDiff.#ctor(System.DateTime,System.Globalization.Calendar,System.DayOfWeek,System.Int32)">
      <summary>
        <paramref name="date1" />와 현재시각의 차이를 <paramref name="calendar" /> 기준으로 계산합니다.
            </summary>
      <param name="date1">선행 시각</param>
      <param name="calendar">기준 Calendar</param>
      <param name="firstDayOfWeek">한 주의 첫번째 요일</param>
      <param name="yearBaseMonth">한해의 시작 월</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.DateDiff.#ctor(System.DateTime,System.DateTime)">
      <summary>
        <paramref name="date2" />-<paramref name="date1" /> 을 계산합니다.
            </summary>
      <param name="date1">선행 시각</param>
      <param name="date2">후행 시각</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.DateDiff.#ctor(System.DateTime,System.DateTime,System.Globalization.CultureInfo)">
      <summary>
        <paramref name="date2" />-<paramref name="date1" /> 을 <paramref name="culture" /> 기준으로 계산합니다.
            </summary>
      <param name="date1">선행 시각</param>
      <param name="date2">후행 시각</param>
      <param name="culture">문화권</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.DateDiff.#ctor(System.DateTime,System.DateTime,System.Globalization.CultureInfo,System.Int32)">
      <summary>
        <paramref name="date2" />-<paramref name="date1" /> 을 <paramref name="culture" /> 기준으로 계산합니다.
            </summary>
      <param name="date1">선행 시각</param>
      <param name="date2">후행 시각</param>
      <param name="culture">문화권</param>
      <param name="yearBaseMonth">한해의 시작 월</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.DateDiff.#ctor(System.DateTime,System.DateTime,System.Globalization.Calendar,System.DayOfWeek)">
      <summary>
        <paramref name="date2" />-<paramref name="date1" /> 을 <paramref name="calendar" /> 기준으로 계산합니다.
            </summary>
      <param name="date1">선행 시각</param>
      <param name="date2">후행 시각</param>
      <param name="calendar">기준 Calendar</param>
      <param name="firstDayOfWeek">한 주의 첫번째 요일</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.Calendars.DateDiff.#ctor(System.DateTime,System.DateTime,System.Globalization.Calendar,System.Nullable{System.DayOfWeek},System.Nullable{System.Int32})">
      <summary>
        <paramref name="date2" />-<paramref name="date1" /> 을 <paramref name="calendar" /> 기준으로 계산합니다.
            </summary>
      <param name="date1">선행 시각</param>
      <param name="date2">후행 시각</param>
      <param name="calendar">기준 Calendar</param>
      <param name="firstDayOfWeek">한 주의 첫번째 요일</param>
      <param name="yearBaseMonth">한해의 시작 월</param>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.Calendar">
      <summary>
            기준 Calendar
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.YearBaseMonth">
      <summary>
            한 해의 첫번째 월 (보통 1월)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.FirstDayOfWeek">
      <summary>
            한 주의 첫번째 요일 (한국, 미국은 일요일, ISO8601은 월요일)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.Difference">
      <summary>
        <see cref="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.Date2" />-<see cref="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.Date1" /> 을 계산한 값
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.IsEmpty">
      <summary>
            시간 차가 없는지 여부?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.Years">
      <summary>
            두 시각의 년 단위의 차이
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.Quarters">
      <summary>
            두 시각의 분기 단위의 차이
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.Months">
      <summary>
            두 시각의 월 단위의 차이
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.Weeks">
      <summary>
            두 시각의 주 단위의 차이
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.Days">
      <summary>
            두 시각의 일 단위의 차이
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.WeekDays">
      <summary>
            두 시각의 요일 단위의 차이
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.Hours">
      <summary>
            두 시각의 시간 단위의 차이
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.Minutes">
      <summary>
            두 시각의 분 단위의 차이
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.Seconds">
      <summary>
            두 시각의 초 단위의 차이
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.ElapsedYears">
      <summary>
            두 시각의 시간 간격의 총 년 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.ElapsedQuarter">
      <summary>
            두 시각의 시간 간격의 총 분기 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.ElapsedMonths">
      <summary>
            두 시각의 시간 간격의 총 월 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.ElapsedDays">
      <summary>
            두 시각의 시간 간격의 총 일 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.ElapsedHours">
      <summary>
            두 시각의 시간 간격의 총 시간 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.ElapsedMinutes">
      <summary>
            두 시각의 시간 간격의 총 분수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.Calendars.DateDiff.ElapsedSeconds">
      <summary>
            두 시각의 시간 간격의 총 초수
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.AbstractClock">
      <summary>
            기본 Clock
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.IClock">
      <summary>
             참고 : http://stackoverflow.com/questions/43711/whats-a-good-way-to-overwrite-datetime-now-during-testing
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.IClock.Now">
      <summary>
            현재 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.IClock.Today">
      <summary>
            오늘 (현재 시각의 날짜부분만)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.IClock.TimeOfDay">
      <summary>
            현재 시각의 시간부분만
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.AbstractClock.Now">
      <summary>
            현재 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.AbstractClock.Today">
      <summary>
            오늘 (현재 시각의 날짜부분만)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.AbstractClock.TimeOfDay">
      <summary>
            현재 시각의 시간부분만
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ClockProxy">
      <summary>
            Clock에 대한 Proxy입니다. 기본적으로 <see cref="T:NSoft.NFramework.TimePeriods.SystemClock" />을 제공합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ClockProxy.Clock">
      <summary>
            Clock
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.StaticClock">
      <summary>
            생성자에 의해 지정된 시간을 현재 시간으로 제공합니다. (단위 테스트 실행 시마다 현재 시각이 변경되는 것을 방지하기 위해서 사용합니다)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.SystemClock">
      <summary>
            시스템에서 제공하는 현재 시각을 제공합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.DayHourRange">
      <summary>
            특정 요일의 시간을 표현합니다. (예: 금요일 1시~5시)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.HourRangeInDay">
      <summary>
            하루 24시간 내의 시간단위의 기간을 나타냅니다. ( 예: 09시~16시 )
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.HourRangeInDay.Start">
      <summary>
            시작 <see cref="T:NSoft.NFramework.TimeValue" /></summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.HourRangeInDay.End">
      <summary>
            완료 <see cref="T:NSoft.NFramework.TimeValue" /></summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.HourRangeInDay.IsMoment">
      <summary>
            시작 시각과 완료 시각이 같은 값이면, 순간이라 표현한다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.DayRangeInMonth">
      <summary>
            같은 Month 내에서의 Day 만의 기간을 나타냅니다. (예: 5일에서 21일까지)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.DayRangeInMonth.Min">
      <summary>
            시작 <see cref="T:NSoft.NFramework.TimeValue" /></summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.DayRangeInMonth.Max">
      <summary>
            완료 <see cref="T:NSoft.NFramework.TimeValue" /></summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.MonthRangeInYear">
      <summary>
            같은 년도 내에서의 최대 최소 기간
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.MonthRangeInYear.Min">
      <summary>
            하한 값
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.MonthRangeInYear.Max">
      <summary>
            상한 값
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.YearAndHalfyear">
      <summary>
            년도와 반기를 표현합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.YearAndHalfyear.Year">
      <summary>
            년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.YearAndHalfyear.Halfyear">
      <summary>
            반기 (전반기|후반기)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.YearAndMonth">
      <summary>
            년도와 월을 나타냅니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.YearAndMonth.Year">
      <summary>
            년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.YearAndMonth.Month">
      <summary>
            월
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.YearAndQuarter">
      <summary>
            년도와 분기를 나타내는 구조체입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.YearAndQuarter.Year">
      <summary>
            년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.YearAndQuarter.Quarter">
      <summary>
            분기
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.YearAndWeek">
      <summary>
            년도와 주차를 나타냅니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.YearAndWeek.Year">
      <summary>
            년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.YearAndWeek.Week">
      <summary>
            주차
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.DurationFormatKind">
      <summary>
            기간 (Duration)을 문자열로 표현하는 방식 (Compact|Detailed)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.DurationFormatKind.Compact">
      <summary>
            약식으로 표현
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.DurationFormatKind.Detailed">
      <summary>
            상세하게 표현
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.IntervalEdge">
      <summary>
            Interval의 경계의 상태
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.IntervalEdge.Closed">
      <summary>
            폐구간
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.IntervalEdge.Open">
      <summary>
            개구간
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.MonthKind">
      <summary>
            월 (Month) 종류
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.MonthKind.January">
      <summary>
            1월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.MonthKind.Feburary">
      <summary>
            2월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.MonthKind.March">
      <summary>
            3월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.MonthKind.April">
      <summary>
            4월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.MonthKind.May">
      <summary>
            5월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.MonthKind.June">
      <summary>
            6월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.MonthKind.July">
      <summary>
            7월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.MonthKind.August">
      <summary>
            8월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.MonthKind.September">
      <summary>
            9월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.MonthKind.October">
      <summary>
            10월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.MonthKind.November">
      <summary>
            11월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.MonthKind.December">
      <summary>
            12월
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.PeriodFlags">
      <summary>
            기간에 대한 여러가지 복합체를 만들어 냅니다. <see cref="T:NSoft.NFramework.TimePeriods.PeriodKind" />와는 달리 Bit 연산을 수행합니다.
            Gantt Chart 등에서 기간을 축 (Axis) 로 나타낼때, 여러 단위로 지정할 때 사용합니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.None">
      <summary>
            없음
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.Year">
      <summary>
            년 (Year)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.HalfYear">
      <summary>
            반기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.Quarter">
      <summary>
            분기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.Month">
      <summary>
            월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.Week">
      <summary>
            주
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.Day">
      <summary>
            일
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.Hour">
      <summary>
            시간
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.YearMonth">
      <summary>
            년/월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.YearMonthDay">
      <summary>
            년/월/일
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.YearMonthDayHour">
      <summary>
            년/월/일/시
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.YearQuarter">
      <summary>
            년/분기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.YearQuarterMonth">
      <summary>
            년/분기/월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.YearQuarterMonthDay">
      <summary>
            년/분기/월/일
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.YearQuarterMonthDayHour">
      <summary>
            년/분기/월/일/시
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.YearWeek">
      <summary>
            년/주
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.YearWeekDay">
      <summary>
            년/주/일
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.YearWeekDayHour">
      <summary>
            년/주/일/시
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.MonthDay">
      <summary>
            월/일
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodFlags.MonthDayHour">
      <summary>
            월/일/시
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.PeriodKind">
      <summary>
            기간의 단위를 나타냅니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodKind.Unknown">
      <summary>
            알 수 없음 (수시)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodKind.Year">
      <summary>
            년
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodKind.Halfyear">
      <summary>
            반기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodKind.Quarter">
      <summary>
            분기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodKind.Month">
      <summary>
            월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodKind.Week">
      <summary>
            주
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodKind.Day">
      <summary>
            일
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodKind.Hour">
      <summary>
            시
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodKind.Minute">
      <summary>
            분
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodKind.Second">
      <summary>
            초
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodKind.Millisecond">
      <summary>
            밀리초
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.PeriodRelation">
      <summary>
            두 개의 <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />의 관계를 표현합니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.NoRelation">
      <summary>
            알 수 없음 (두개의 기간이 모두 AnyTime 일 경우
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.After">
      <summary>
            현 ITimeRange 이후에 대상 ITimeRange가 있을 때
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.StartTouching">
      <summary>
            현 ITimePeriod의 완료 시각이 대상 ITimePeriod의 시작 시각과 같습니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.StartInside">
      <summary>
            현 ITimePeriod 기간 안에 대상 ITimePeriod의 시작 시각만 포함될 때
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.InsideStartTouching">
      <summary>
            현 ITimePeriod의 시작 시각과 대상 ITimePeriod의 시작 시각이 일치하고, 대상 ITimePeriod 가 현 ITimePeriod에 포함될 때
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.EnclosingStartTouching">
      <summary>
            현 ITimePeriod의 시작 시각과 대상 ITimePeriod의 시작 시각이 일치하고, 현 ITimePeriod 가 대상 ITimePeriod에 포함될 때
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.Enclosing">
      <summary>
            현 ITimePeriod가 대상 ITimePeriod 기간에 포함될 때
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.EnclosingEndTouching">
      <summary>
            현 ITimePeriod의 완료 시각과 대상 ITimePeriod의 완료 시각이 일치하고, 현 ITimePeriod 가 대상 ITimePeriod에 포함될 때
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.ExactMatch">
      <summary>
            현 ITimePeriod 기간과 대상 ITimePeriod의 기간이 일치할 때, 둘 다 AnyTime이라도 ExactMath가 된다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.Inside">
      <summary>
            현 기간안에 대상 기간이 내부에 포함될 때
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.InsideEndTouching">
      <summary>
            현 기간 안에 대상 기간이 포함되는데, 완료시각만 같을 때
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.EndInside">
      <summary>
            현 기간 안에 대상 기간의 완료 시각만 포함될 때
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.EndTouching">
      <summary>
            현 기간의 시작 시각이 대상 기간의 완료 시각과 일치할 때
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.PeriodRelation.Before">
      <summary>
            대상 기간의 완료 시각이 현 기간의 시작시간 전에 있을 때
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.QuarterKind">
      <summary>
            분기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.QuarterKind.First">
      <summary>
            1분기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.QuarterKind.Second">
      <summary>
            2분기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.QuarterKind.Third">
      <summary>
            3분기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.QuarterKind.Fourth">
      <summary>
            4분기
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.SeekBoundaryMode">
      <summary>
            날짜 검색 시, 해당 검색이 완료 경계까지 인가 그 다음에 해당하는 부분인가를 정의한다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.SeekBoundaryMode.Fill">
      <summary>
            DateTime 검색 시 검색한 값을 반환하도록 한다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.SeekBoundaryMode.Next">
      <summary>
            DateTime 검색 시 검색한 다음 값을 반환하도록 한다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.SeekDirection">
      <summary>
            검색 방향
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.SeekDirection.Forward">
      <summary>
            미래로 (시간 값을 증가 시키는 방향)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.SeekDirection.Backward">
      <summary>
            과거로 (시간 값을 감소 시키는 방향)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.WeekOfYearRuleKind">
      <summary>
            주차 (WeekOfYear) 계산을 위한 룰의 종류<br /><br />
            
            해당일자의 주차를 구한다. 문화권(Culture) 및 새해 첫주차에 대한 정의에 따라 주차가 달라진다.
            ref : http://www.simpleisbest.net/archive/2005/10/27/279.aspx
            ref : http://en.wikipedia.org/wiki/ISO_8601#Week_dates
            </summary>
      <remarks>
        <see cref="T:System.Globalization.CalendarWeekRule" /> 값에 따라 WeekOfYear 가 결정된다.
            
            FirstDay : 1월1일이 포함된 주를 무조건 첫째 주로 삼는다. (우리나라, 미국 등의 기준) : .NET의 설정대로 하면 이렇게 된다.
            FirstFourDayWeek : 1월1일이 포함된 주가 4일 이상인 경우에만 그 해의 첫 번째 주로 삼는다. (ISO 8601)
            				   예) 한 주의 시작 요일이 일요일이고 1월1일이 일/월/화/수 중 하나이면 1월1일이 포함된 주는 해당 해의 첫 번째 주이다.
            				   예) 한 주의 시작 요일이 일요일이고 1월1일이 목/금/토 중 하나이면 1월1일이 포함된 주는 해당 해의 첫 번째 주로 간주하지 않는다.
            				   예) 2005년 1월 1일은 토요일이므로 1월1일이 포함된 주는 2005년의 첫 번째 주로 간주하지 않는다.
            FirstFullWeek : 1월의 첫 번째 주가 7일이 아니면 해당 해의 첫 번째 주로 삼지 않는다.
            			    예) 한 주의 시작 요일이 일요일인 경우, 1월1일이 일요일이 아니라면 1월1일이 포함된 주는 해당 해의 첫 번째 주로 간주하지 않는다.
            </remarks>
      <seealso cref="T:NSoft.NFramework.TimePeriods.WeekTool" />
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.WeekOfYearRuleKind.Calendar">
      <summary>
            문화권의 <see cref="T:System.Globalization.DateTimeFormatInfo" />의 
            <see cref="P:System.Globalization.DateTimeFormatInfo.CalendarWeekRule" />, 
            <see cref="P:System.Globalization.DateTimeFormatInfo.FirstDayOfWeek" />를 기준으로 주차를 결정한다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.WeekOfYearRuleKind.Iso8601">
      <summary>
            ISO 8601 규칙 (FirstDayOfWeek는 DayOfWeek.Monday, CalendarWeekRule은 CalendarWeekRule.FourWeekDay)로 주차를 결정합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.HalfyearKind">
      <summary>
            반기 (Halfyear) 종류
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.HalfyearKind.First">
      <summary>
            상반기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.HalfyearKind.Second">
      <summary>
            하반기
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.YearKind">
      <summary>
            년도 종류 (년의 종류에 따라 시작일이 달라집니다) (예: 회계년도의 시작월은 2월이고, 한국의 학기는 3월에 시작입니다)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.YearKind.SystemYear">
      <summary>
            설치된 OS의 문화권에 해당하는 Year
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.YearKind.CalendarYear">
      <summary>
            현 ThreadContext에 지정된 문화권의 Calendar의 Year
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.YearKind.FiscalYear">
      <summary>
            회계 년 (2월 시작)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.YearKind.SchoolYear">
      <summary>
            교육년 (3월 시작, 9월 시작)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.YearKind.CustomYear">
      <summary>
            사용자 정의 년
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeLines.TimeGapCalculator`1">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" /> 컬렉션의 항목 기간에 포함되지 않는 빈 기간 (TimeGap) 을 계산해 줍니다.
            </summary>
      <typeparam name="T">기간을 나타내는 수형 (<see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />의 자식 수형)</typeparam>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeLines.TimeGapCalculator`1.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeLines.TimeGapCalculator`1.#ctor(NSoft.NFramework.TimePeriods.ITimePeriodMapper)">
      <summary>
            생성자
            </summary>
      <param name="mapper">시작/완료 시각에 대한 매퍼</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeLines.TimeGapCalculator`1.GetGaps(NSoft.NFramework.TimePeriods.ITimePeriodContainer,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="limits" /> 기간내에서 <paramref name="excludedPeriods" /> 컬렉션의 기간들을 제외한 기간(Gap)을 계산해 낸다.
            </summary>
      <param name="excludedPeriods">제외할 기간들을 나타냅니다.</param>
      <param name="limits">전체 범위를 나타냅니다 (null이면 무한대의 범위를 나타냅니다)</param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeLines.TimeLine`1">
      <summary>
            여러 <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />들을 시간의 흐름별로 펼쳐서 표현합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ITimeLine">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />의 컬렉션인 <see cref="P:NSoft.NFramework.TimePeriods.ITimeLine.Periods" />를 가지며, 이를 통해 여러 기간에 대한 Union, Intersection, Gap 등을 구할 수 있도록 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeLines.TimeLine`1.CombinePeriods">
      <summary>
        <see cref="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLine`1.Periods" />의 기간들의 합집합에 해당하는 기간들을 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeLines.TimeLine`1.IntersectPeriods">
      <summary>
        <see cref="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLine`1.Periods" />의 기간들의 교집합에 해당하는 기간들을 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeLines.TimeLine`1.CalcuateGaps">
      <summary>
        <see cref="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLine`1.Periods" />들의 Gap 부분들만을 기간 컬렉션으로 반환합니다.
            </summary>
      <returns>Gap 기간들의 컬렉션</returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLine`1.Periods">
      <summary>
            TimeLine 연산을 위한 Period 의 컬렉션입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLine`1.Limits">
      <summary>
            Period 컬렉션의 전체 경계를 나타냅니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLine`1.PeriodMapper">
      <summary>
            Period 연산 결과에 대한 Start, End에 대한 Mapping을 수행할 Mapper (Start, End의 Offset을 적용한다)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMoment">
      <summary>
            특정 기준 시각에 대한 필터링을 수행합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ITimeLineMoment">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />의 컬렉션인 <see cref="P:NSoft.NFramework.TimePeriods.ITimeLineMoment.Periods" />를 가지며, <see cref="P:NSoft.NFramework.TimePeriods.ITimeLineMoment.Moment" />를 기준으로 선행 기간의 수와 후행 기간의 수를 파악합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMoment.Moment">
      <summary>
            기준 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMoment.Periods">
      <summary>
            기간 컬렉션
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMoment.StartCount">
      <summary>
        <see cref="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMoment.Periods" />중에 기간의 시작 시각과 <see cref="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMoment.Moment" />가 같은 기간의 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMoment.EndCount">
      <summary>
        <see cref="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMoment.Periods" />중에 기간 완료 시각과 <see cref="P:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMoment.Moment" />가 같은 기간의 수
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMomentCollection">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />를 시작 시각, 완료 시각을 키로 가지고, 
            <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />를 Value로 가지는 MultiMap{DateTime, ITimePeriod} 을 생성합니다. <b>단 시각(DateTime)으로 정렬됩니다.</b></summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ITimeLineMomentCollection">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />를 시작시각,완료시각을 키로 가지고, <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />를 Value로 가지는 MultiMap{DateTime, ITimePeriod} 을 생성합니다. 단 시각으로 정렬됩니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMomentCollection.Find(System.DateTime)">
      <summary>
        <paramref name="moment" />와 같은 값을 가진 <see cref="T:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMoment" />를 찾습니다.
            </summary>
      <param name="moment">찾고자하는 moment</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMomentCollection.Contains(System.DateTime)">
      <summary>
        <paramref name="moment" />와 같은 값을 가진 <see cref="T:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMoment" />가 존재하는지 파악합니다.
            </summary>
      <param name="moment">찾고자하는 moment</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMomentCollection.AddPeriod(System.DateTime,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="moment" />를 나타내는 TimeLineMoment를 키로 하고, Value로 <paramref name="period" /> 를 추가합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMomentCollection.RemovePeriod(System.DateTime,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="moment" />를 나타내는 TimeLineMoment를 키로 하고, Value로 <paramref name="period" /> 를 삭제합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeLines.TimeLineMomentComparer">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimeLineMoment" /> 비교자
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeLines.TimeLineTool">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimeLine" />, <see cref="T:NSoft.NFramework.TimePeriods.ITimeLineMoment" />, <see cref="T:NSoft.NFramework.TimePeriods.ITimeLineMomentCollection" />에 대한 확장 메소드를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeLines.TimeLineTool.CombinePeriods``1(NSoft.NFramework.TimePeriods.ITimeLineMomentCollection)">
      <summary>
            ITimeLineMoment 컬렉션의 모든 기간의 합집합을 구합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="timeLineMoments">결합할 기간들</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeLines.TimeLineTool.IntersectPeriods``1(NSoft.NFramework.TimePeriods.ITimeLineMomentCollection)">
      <summary>
            ITimeLineMomentCollection으로부터 교집합에 해당하는 기간들을 구합니다
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="timeLineMoments">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeLines.TimeLineTool.CalculateGaps``1(NSoft.NFramework.TimePeriods.ITimeLineMomentCollection,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="timeLineMoments" />가 가진 모든 ITimePeriod 들의 Gap을 계산합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="timeLineMoments">
      </param>
      <param name="range">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange">
      <summary>
        <see cref="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.TimeCalendar" /> 기준의 기간을 나타냅니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRange">
      <summary>
            기간을 표현하는 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimePeriodBase">
      <summary>
            시작일자와 완료일자로 기간을 표현하는 기본 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ITimePeriod">
      <summary>
            기간 (시작시각~완료시각) 을 나타내는 Interface입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriod.Setup(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
      <summary>
            기간을 설정합니다.
            </summary>
      <param name="newStart">
      </param>
      <param name="newEnd">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriod.Copy(System.TimeSpan)">
      <summary>
            현재 기간에서 오프셋만큼 Shift 한 <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />정보를 반환합니다.
            </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriod.Move(System.TimeSpan)">
      <summary>
            기간을 오프셋만큼 이동
            </summary>
      <param name="offset">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriod.IsSamePeriod(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간이 같은 기간을 나타내는지 검사합니다
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriod.HasInside(System.DateTime)">
      <summary>
            지정된 시각이 기간에 속하는지 검사합니다.
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriod.HasInside(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            지정한 기간이 현 기간 내에 속하는지 검사합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriod.IntersectsWith(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            지정한 기간이 현 기간과 겹치는 부분이 있는지 검사합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriod.OverlapsWith(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            지정한 기간이 현 기간과 겹치는 부분이 있는지 검사합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriod.Reset">
      <summary>
            기간을 미정으로 초기화합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriod.GetRelation(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            다른 TimePeriod와의 관계를 나타냅니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriod.GetDescription(NSoft.NFramework.TimePeriods.ITimeFormatter)">
      <summary>
            TimePeriod의 설명을 표현합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriod.GetIntersection(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 겹치는 기간을 반환합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriod.GetUnion(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 합집합 기간을 반환합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriod.Start">
      <summary>
            기간의 시작 시각. 시작 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MinPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriod.End">
      <summary>
            기간의 완료 시각. 완료 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriod.StartAsNullable">
      <summary>
            기간의 시작 시각. 시작 시각을 정해지지 않은 경우 null을 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriod.EndAsNullable">
      <summary>
            기간의 완료 시각. 미정인 경우 null을 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriod.Duration">
      <summary>
            기간을 TimeSpan으료 표현, 기간이 정해지지 않았다면 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodDuration" /> 을 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriod.DurationDescription">
      <summary>
            기간에 대한 문자열 표현
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriod.HasStart">
      <summary>
            시작 시각이 지정되었는가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriod.HasEnd">
      <summary>
            완료 시각이 지정되었는가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriod.HasPeriod">
      <summary>
            정해진 기간이 있는지 표시합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriod.IsMoment">
      <summary>
            시작 시각과 완료 시각의 값이 같은가? 
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriod.IsAnytime">
      <summary>
            시작 시각도 없고, 완료 시각도 없는 구간 (전체 구간)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriod.IsReadOnly">
      <summary>
            읽기 전용
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.#ctor(System.Boolean)">
      <summary>
            생성자
            </summary>
      <param name="isReadOnly">일기 전용 여부</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.#ctor(System.DateTime)">
      <summary>
            생성자
            </summary>
      <param name="moment">기준 일자 (시작일자와 완료일자에 해당)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.#ctor(System.DateTime,System.Boolean)">
      <summary>
            생성자
            </summary>
      <param name="moment">기준 일자 (시작일자와 완료일자에 해당)</param>
      <param name="isReadOnly">일기 전용 여부</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.#ctor(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
      <summary>
            생성자
            </summary>
      <param name="start">시작 일자</param>
      <param name="end">완료 일자</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.#ctor(System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Boolean)">
      <summary>
            생성자
            </summary>
      <param name="start">시작 일자</param>
      <param name="end">완료 일자</param>
      <param name="isReadOnly">읽기 전용 여부</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.#ctor(System.DateTime,System.TimeSpan)">
      <summary>
            생성자
            </summary>
      <param name="start">시작일자</param>
      <param name="duration">시간 간격</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.#ctor(System.DateTime,System.TimeSpan,System.Boolean)">
      <summary>
            생성자
            </summary>
      <param name="start">시작일자</param>
      <param name="duration">시간 간격</param>
      <param name="isReadOnly">읽기 전용 여부</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.#ctor(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            Copy Constructor
            </summary>
      <param name="source">복사할 원본 ITimePeriod</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.#ctor(NSoft.NFramework.TimePeriods.ITimePeriod,System.Boolean)">
      <summary>
            Copy Constructor
            </summary>
      <param name="source">복사할 원본 ITimePeriod</param>
      <param name="isReadOnly">읽기 전용 여부</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.Setup(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
      <summary>
            기간을 설정합니다.
            </summary>
      <param name="newStart">설정할 시작 시각</param>
      <param name="newEnd">설정할 완료 시각</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.Copy">
      <summary>
            현 TimePeriod 의 속성을 복사하여, 새로운 TimePeriod를 생성하여 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.Copy(System.TimeSpan)">
      <summary>
            현 ITimePeriod 에서 <paramref name="offset" /> 만큼 Shift 한 <see cref="T:NSoft.NFramework.TimePeriods.ITimeRange" />정보를 반환합니다.
            </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.Move(System.TimeSpan)">
      <summary>
            기간을 오프셋만큼 이동
            </summary>
      <param name="offset">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.IsSamePeriod(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간이 같은 기간을 나타내는지 검사합니다
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.HasInside(System.DateTime)">
      <summary>
            지정된 시각이 기간에 속하는지 검사합니다.
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.HasInside(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            지정한 기간이 현 기간 내에 속하는지 검사합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.IntersectsWith(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            지정한 기간이 현 기간과 겹치는 부분이 있는지 검사합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.OverlapsWith(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            지정한 기간이 현 기간과 겹치는 부분이 있는지 검사합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.Reset">
      <summary>
            기간을 미정으로 초기화합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.GetRelation(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            다른 TimePeriod와의 관계를 나타냅니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.GetDescription(NSoft.NFramework.TimePeriods.ITimeFormatter)">
      <summary>
            TimePeriod의 설명을 표현합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.GetIntersection(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 겹치는 기간을 반환합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.GetUnion(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 합집합 기간을 반환합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.Format(NSoft.NFramework.TimePeriods.ITimeFormatter)">
      <summary>
        <paramref name="formatter" />를 이용하여 기간 내용을 문자열로 표현합니다.
            </summary>
      <param name="formatter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.AssertMutable">
      <summary>
            변경가능한 (읽기전용이 아닌) 객체인지 확인합니다. 읽기 전용일 경우 예외를 발생시킵니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.Equals(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다. (StartTime, EndTime, IsReadOnly가 같아야 True를 반환합니다)
            </summary>
      <returns>
            현재 개체가 <paramref name="other" /> 매개 변수와 같으면 true이고, 그렇지 않으면 false입니다.
            </returns>
      <param name="other">이 개체와 비교할 개체입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodBase.Equals(System.Object)">
      <summary>
            현재 개체가 동일한 형식의 다른 개체와 같은지 여부를 나타냅니다. (StartTime, EndTime, IsReadOnly가 같아야 True를 반환합니다)
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodBase.Start">
      <summary>
            기간의 시작 시각. 시작 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MinPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodBase.End">
      <summary>
            기간의 완료 시각. 완료 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodBase.StartAsNullable">
      <summary>
            기간의 시작 시각. null 인 경우 시작 시각을 정하지 않은 것입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodBase.EndAsNullable">
      <summary>
            기간의 완료 시각. null인 경우 완료 시각을 정하지 않은 것입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodBase.Duration">
      <summary>
            기간을 TimeSpan으료 표현, 기간이 정해지지 않았다면 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodDuration" /> 을 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodBase.HasStart">
      <summary>
            시작 시각이 지정되었는가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodBase.HasEnd">
      <summary>
            완료 시각이 지정되었는가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodBase.HasPeriod">
      <summary>
            정해진 기간이 있는지 표시합니다. 즉 의미있는 기간으로 설정되어 있는가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodBase.IsMoment">
      <summary>
            시작 시각과 완료 시각의 값이 같은가? 
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodBase.IsAnytime">
      <summary>
            시작 시각도 없고, 완료 시각도 없는 기간인가? (즉 AnyTime)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodBase.IsReadOnly">
      <summary>
            읽기 전용
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ITimeRange">
      <summary>
            시작 시각 ~ 완료시각이라는 시간의 범위를 나타내는 자료구조이고, 기간(Duration) 값은 계산됩니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeRange.ExpandStartTo(System.DateTime)">
      <summary>
            시작 시각을 지정된 시각으로 변경합니다. 시작 시각 이후가 되면 안됩니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeRange.ExpandEndTo(System.DateTime)">
      <summary>
            완료 시각을 지정된 시각으로 변경합니다. 완료 시각 이전이 되면 안됩니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeRange.ExpandTo(System.DateTime)">
      <summary>
            시작 시각과 완료시각을 지정된 시각으로 설정합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeRange.ExpandTo(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            시작시각과 완료시각을 지정된 기간 정보를 기준으로 변경합니다.
            </summary>
      <param name="period">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeRange.ShrinkStartTo(System.DateTime)">
      <summary>
            시작 시각을 지정된 시각으로 변경합니다. 시작시각보다 이후 시각이여야 합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeRange.ShrinkEndTo(System.DateTime)">
      <summary>
            완료 시각을 지정된 시각으로 당깁니다. 완료시각보다 이전 시각이여야 합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeRange.ShrinkTo(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            기간을 지정한 기간으로 축소시킵니다.
            </summary>
      <param name="period">
      </param>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeRange.Start">
      <summary>
            기간의 시작 시각. 시작 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MinPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeRange.End">
      <summary>
            기간의 완료 시각. 완료 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeRange.Duration">
      <summary>
            기간을 TimeSpan으료 표현, 기간이 정해지지 않았다면 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodDuration" /> 을 반환합니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeRange.Anytime">
      <summary>
            시작 시각이 NULL, 완료 시각이 NULL인 OPEN 구간을 가지는 기간을 뜻한다. (그래서 AnyTime 이다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRange.op_Implicit(NSoft.NFramework.TimePeriods.TimeRange)~NSoft.NFramework.TimePeriods.TimeBlock">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeRange" /> 인스턴스를 암묵적으로 <see cref="T:NSoft.NFramework.TimePeriods.TimeBlock" /> 형식의 인스턴스로 Casting합니다.
            </summary>
      <param name="range">원본 TimeRange 인스턴스</param>
      <returns>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeBlock" /> 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRange.op_Implicit(NSoft.NFramework.TimePeriods.TimeRange)~NSoft.NFramework.TimePeriods.TimeInterval">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeRange" /> 인스턴스를 명시적으로 <see cref="T:NSoft.NFramework.TimePeriods.TimeInterval" /> 형식의 인스턴스로 Casting합니다.
            </summary>
      <param name="range">원본 TimeRange 인스턴스</param>
      <returns>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeBlock" /> 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRange.ExpandStartTo(System.DateTime)">
      <summary>
            시작 시각을 지정된 시각으로 변경합니다. 시작 시각 이후가 되면 안됩니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRange.ExpandEndTo(System.DateTime)">
      <summary>
            완료 시각을 지정된 시각으로 확장합니다. 완료 시각 이전이 되면 안됩니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRange.ExpandTo(System.DateTime)">
      <summary>
            시작 시각과 완료시각을 지정된 시각으로 설정합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRange.ExpandTo(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            시작시각과 완료시각을 지정된 기간 정보를 기준으로 변경합니다.
            </summary>
      <param name="period">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRange.ShrinkStartTo(System.DateTime)">
      <summary>
            시작 시각을 지정된 시각으로 변경합니다. 시작시각보다 이후 시각이여야 합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRange.ShrinkEndTo(System.DateTime)">
      <summary>
            완료 시각을 지정된 시각으로 당깁니다. 완료시각보다 이전 시각이여야 합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRange.ShrinkTo(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            기간을 지정한 기간으로 축소시킵니다.
            </summary>
      <param name="period">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRange.GetIntersection(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 겹치는 기간을 반환합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRange.GetUnion(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 합집합 기간을 반환합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRange.Start">
      <summary>
            기간의 시작 시각. 시작 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MinPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRange.End">
      <summary>
            기간의 완료 시각. 완료 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ICalendarTimeRange">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimeCalendar" />의 설정정보를 바탕으로 하는 <see cref="T:NSoft.NFramework.TimePeriods.ITimeRange" />를 표현합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ICalendarTimeRange.TimeCalendar">
      <summary>
            기간 설정에 사용될 <see cref="T:NSoft.NFramework.TimePeriods.ITimeCalendar" />입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.Copy(System.TimeSpan)">
      <summary>
            현재 기간에서 오프셋만큼 Shift 한 <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />정보를 반환합니다.
            </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.Format(NSoft.NFramework.TimePeriods.ITimeFormatter)">
      <summary>
        <paramref name="formatter" />를 이용하여 기간 내용을 문자열로 표현합니다.
            </summary>
      <param name="formatter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.TimeCalendar">
      <summary>
            기간의 기준이 되는 <see cref="T:NSoft.NFramework.TimePeriods.ITimeCalendar" />입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.StartYear">
      <summary>
            시작 년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.StartMonth">
      <summary>
            시작 월
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.StartDay">
      <summary>
            시작 일
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.StartHour">
      <summary>
            시작 시
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.StartMinute">
      <summary>
            시작 분
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.EndYear">
      <summary>
            완료 년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.EndMonth">
      <summary>
            완료 월
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.EndDay">
      <summary>
            완료 일
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.EndHour">
      <summary>
            완료 시
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.EndMinute">
      <summary>
            완료 분
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.MappedStart">
      <summary>
        <see cref="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.TimeCalendar" />를 기준으로 Mapping된 시작 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.MappedEnd">
      <summary>
        <see cref="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.TimeCalendar" />를 기준으로 Mapping된 완료 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.UnmappedStart">
      <summary>
        <see cref="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.TimeCalendar" />를 기준으로 Unmap 된 시작 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.UnmappedEnd">
      <summary>
        <see cref="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.TimeCalendar" />를 기준으로 Unmap 된 완료 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.StartMonthStart">
      <summary>
            시작 시각이 속한 월의 시작일 (예: 2011-05-01)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.EndMonthStart">
      <summary>
            완료 시각이 속한 월의 시작일 (예: 2011-06-01)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.StartDayStart">
      <summary>
            시작 시각의 시작일 (예: 2011-05-18T00:00:00.000)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.EndDayStart">
      <summary>
            완료 시각의 시작일 (예: 2011-05-25T00:00:00.000)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.StartHourStart">
      <summary>
            시작 시각의 시(Hour) 단위까지 표현 (분단위 버름)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.EndHourStart">
      <summary>
            완료 시각의 시(Hour) 단위까지 표현 (분단위 버림)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.StartMinuteStart">
      <summary>
            시작 시각의 분(Minute) 단위까지 표현 (초단위는 버림)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.EndMinuteStart">
      <summary>
            완료 시각의 분(Minute) 단위까지 표현 (초단위는 버림)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.StartSecondStart">
      <summary>
            시작 시각의 초(Second) 단위까지의 표현
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.CalendarTimeRange.EndSecondStart">
      <summary>
            완료 시각의 초(Second) 단위까지의 표현
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.DayRange">
      <summary>
            일 단위의 기간을 표현합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.DayTimeRange">
      <summary>
            일 단위로 기간을 나타냅니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.DayTimeRange.GetHours">
      <summary>
            일(Day) 단위의 기간에 속한 시간 단위의 기간 정보 (<see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.HourRange" />)의 컬렉션을 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.DayRangeCollection">
      <summary>
            일 단위 기간(<see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.DayRange" />)의 컬렉션에 해당합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.HalfyearRange">
      <summary>
            반기를 기간으로 표현하는 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.HalfyearTimeRange">
      <summary>
            반기(Half Year) 단위의 기간을 표현하는 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.YearCalendarTimeRange">
      <summary>
            년(Year) 단위의 기간을 표현합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.YearCalendarTimeRange.YearBaseMonth">
      <summary>
            Calendar의 시작 월
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.YearCalendarTimeRange.BaseYear">
      <summary>
            Calendar의 시작 년
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.HalfyearTimeRange.GetQuarters">
      <summary>
            기간에 속한 모든 분기를 컬렉션으로 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.HalfyearTimeRange.GetMonths">
      <summary>
            기간에 속한 모든 Month를 컬렉션으로 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.HalfyearTimeRange.MultipleCalendarYears">
      <summary>
            반기(HalfYear) 기간의 시작 년도와 완료 년도가 다른가 여부
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.HalfyearRangeCollection">
      <summary>
            반기(Half year) 단위의 기간의 컬렉션을 표현합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.HourRange">
      <summary>
            시간(Hour) 단위의 기간을 표현합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.HourTimeRange">
      <summary>
            시간(Hour) 단위로 기간을 표현하는 클래스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.HourTimeRange.GetMinutes">
      <summary>
            시작 시각 ~ 완료 시각 사이의 모든 분단위의 기간을 컬렉션으로 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.HourRangeCollection">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.HourRange" />의 컬렉션
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.MinuteRange">
      <summary>
            분(Minute)단위의 기간을 나타냅니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.MinuteTimeRange">
      <summary>
            분(Minute) 단위로 기간을 표현하는 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.MinuteRangeCollection">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.MinuteRange" />의 컬렉션을 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.MinuteRangeCollection.GetMinutes">
      <summary>
            기간에 속한 <see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.MinuteRange" />를 열거합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.MonthRange">
      <summary>
            월(Month) 단위로 기간을 표현하는 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.MonthTimeRange">
      <summary>
            월 (Month) 단위의 기간
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.MonthTimeRange.GetDays">
      <summary>
            기간을 <see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.DayRange" />로 열거합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.MonthRangeCollection">
      <summary>
            월 단위의 컬렉션
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.QuarterRange">
      <summary>
            한 분기를 나타내는 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.QuarterTimeRange">
      <summary>
            분기(Quarter) 단위의 기간을 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.QuarterTimeRange.GetMonths">
      <summary>
            내부의 모든 Month를 열거합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.QuarterTimeRange.MultipleCalendarYears">
      <summary>
            시작 분기와 완료 분기가 다른 년도인지 판단합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.QuarterRange.GetPreviousQuarter">
      <summary>
            전분기
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.QuarterRange.GetNextQuarter">
      <summary>
            다음 분기
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.QuarterRange.AddQuarters(System.Int32)">
      <summary>
            현 분기에서 <paramref name="count" /> 수만큼 분기를 더한다.
            </summary>
      <param name="count">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.QuarterRange.Year">
      <summary>
            해당 년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.QuarterRange.Quarter">
      <summary>
            분기
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.QuarterRange.QuarterName">
      <summary>
            분기명
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.QuarterRange.QuarterOfYearName">
      <summary>
            쿼터 명
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.QuarterRangeCollection">
      <summary>
            분기 단위의 기간에 대한 컬렉션
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.WeekRange">
      <summary>
            한 주(Week)를 기간으로 가지는 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.WeekTimeRange">
      <summary>
            주단위의 기간
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.WeekTimeRange.GetDays">
      <summary>
            주 단위의 기간에 포함된 Day의 컬렉션을 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.WeekTimeRange.Year">
      <summary>
            시작 주차의 년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.WeekTimeRange.StartWeek">
      <summary>
            시작 주차의 주
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.WeekTimeRange.WeekCount">
      <summary>
            주차 수 (기간을 Week의 수로 표현)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.WeekTimeRange.EndWeek">
      <summary>
            마지막 주차 (년도가 바뀔 수 있으므로 같은 해의 주차로 볼 수는 없다)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.WeekRange.MultipleCalendarYears">
      <summary>
            한 주의 시작일과 종료일의 년도가 다른가?
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.WeekRangeCollection">
      <summary>
            주(Week) 단위의 컬렉션입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.WeekRangeCollection.GetWeeks">
      <summary>
            기간 중의 모든 <see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.WeekRange" />를 열거합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.YearRange">
      <summary>
            1년의 기간을 나타냅니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.YearTimeRange">
      <summary>
            년(Year) 단위로 기간을 표현하는 클래스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.YearTimeRange.GetHalfyears">
      <summary>
            현 기간에 속한 반기 단위의 기간들을 열거합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.YearTimeRange.GetQuarters">
      <summary>
            현 기간에 속한 분기들을 열거합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeRanges.YearTimeRange.GetMonths">
      <summary>
            Calendar의 Year의 시작 Month부터 제공합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.YearTimeRange.BaseYear">
      <summary>
            한 해의 시작 월
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.YearTimeRange.YearCount">
      <summary>
            현 기간이 가지는 년의 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.YearTimeRange.StartYearName">
      <summary>
            시작 년의 명칭
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeRanges.YearTimeRange.EndYearName">
      <summary>
            완료 년의 명칭
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeRanges.YearRangeCollection">
      <summary>
            1년 (Year) 단위를 복수 개를 가진 범위를 나타냅니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.DurationUtil">
      <summary>
            기간에 대한 계산 메소드를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DurationUtil.Year(System.Int32,System.Globalization.Calendar)">
      <summary>
            지정된 문화권의 달력 기준으로 1년이라는 기간 (윤달, 이슬람 달력 등등 다 다르지요)
            </summary>
      <param name="calendar">
      </param>
      <param name="year">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DurationUtil.Halfyear(System.Int32,NSoft.NFramework.TimePeriods.HalfyearKind,System.Globalization.Calendar)">
      <summary>
            지정한 달력 기준으로 지정된 년도의 반기(전반기/후반기)의 기간
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DurationUtil.Quarter(System.Int32,NSoft.NFramework.TimePeriods.QuarterKind,System.Globalization.Calendar)">
      <summary>
            지정한 달력 기준으로 지정년도, 분기의 기간을 구합니다.
            </summary>
      <param name="calendar">
      </param>
      <param name="year">
      </param>
      <param name="quarter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DurationUtil.Month(System.Int32,System.Int32,System.Globalization.Calendar)">
      <summary>
            지정한 칼렌다에 의해 년, 월에 해당하는 일 수를 기간(TimeSpan)으로 반환합니다.
            </summary>
      <param name="calendar">
      </param>
      <param name="year">
      </param>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.DurationUtil.Week">
      <summary>
            1주일의 시간 간격
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DurationUtil.Weeks(System.Int32)">
      <summary>
            지정된 Week 수를 TimeSpan으로 표현합니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.DurationUtil.Day">
      <summary>
            1일의 시간 간격
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DurationUtil.Days(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            지정한 일, 시, 분, 초, 밀리초에 의한 기간 (TimeSpan)을 반환합니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.DurationUtil.Hour">
      <summary>
            1시간의 시간 간격
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DurationUtil.Hours(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            지정한 시간, 분, 초, 밀리초 만큼의 시간 간격을 생성합니다.
            </summary>
      <param name="hours">시</param>
      <param name="minutes">분</param>
      <param name="seconds">초</param>
      <param name="milliseconds">밀리초</param>
      <returns>시간 간격</returns>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.DurationUtil.Minute">
      <summary>
            1분의 시간 간격
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DurationUtil.Minutes(System.Int32,System.Int32,System.Int32)">
      <summary>
            지정한 분, 초, 밀리초 만큼의 시간 간격을 생성합니다.
            </summary>
      <param name="minutes">분</param>
      <param name="seconds">초</param>
      <param name="milliseconds">밀리초</param>
      <returns>시간 간격</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DurationUtil.Seconds(System.Int32,System.Int32)">
      <summary>
            지정한 초, 밀리초 만큼의 시간 간격을 생성합니다.
            </summary>
      <param name="seconds">초</param>
      <param name="milliseconds">밀리초</param>
      <returns>시간 간격</returns>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.DurationUtil.Millisecond">
      <summary>
            1 밀리초의 시간 간격
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DurationUtil.Milliseconds(System.Int32)">
      <summary>
            지정한 밀리초 만큼의 시간 간격을 생성합니다.
            </summary>
      <param name="milliseconds">밀리초</param>
      <returns>시간 간격</returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.DurationUtil.CurrentCalendar">
      <summary>
            현 Thread Context의 Calendar
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.DurationUtil.Zero">
      <summary>
            0의 시간 간격
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeTool">
      <summary>
            Time, TimePeriod 관련한 Utility 메소드를 제공합니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.January">
      <summary>
            1월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.Feburary">
      <summary>
            2월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.March">
      <summary>
            3월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.April">
      <summary>
            4월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.May">
      <summary>
            5월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.June">
      <summary>
            6월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.July">
      <summary>
            7월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.August">
      <summary>
            8월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.September">
      <summary>
            9월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.October">
      <summary>
            10월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.November">
      <summary>
            11월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.December">
      <summary>
            12월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.NullString">
      <summary>
            null 을 표현하는 문자열 (NULL) 입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetYearOf(NSoft.NFramework.TimePeriods.ITimeCalendar,System.DateTime)">
      <summary>
            지정된 Calendar 기준으로  <paramref name="moment" />가 속한 년도를 구한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetYearOf(System.DateTime,System.Int32)">
      <summary>
        <paramref name="moment" /> 가 속한 년도를 반환한다.
            </summary>
      <param name="moment">
      </param>
      <param name="yearBaseMonth">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.NextDay(System.DayOfWeek)">
      <summary>
            다음 요일
            </summary>
      <param name="day">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.PreviousDay(System.DayOfWeek)">
      <summary>
            이전 요일
            </summary>
      <param name="day">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.AddDays(System.DayOfWeek,System.Int32)">
      <summary>
            요일 계산을 수행한다.
            </summary>
      <param name="day">
      </param>
      <param name="days">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ToTimePeriodCollection``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
        <paramref name="sequence" />를 <see cref="T:NSoft.NFramework.TimePeriods.TimePeriodCollection" />으로 변환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsSameTime(System.DateTime,System.DateTime,NSoft.NFramework.TimePeriods.PeriodKind)">
      <summary>
            두 날짜 값이 <paramref name="periodKind" /> 단위까지 같은지 판단합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsSameYear(System.DateTime,System.DateTime,System.Int32)">
      <summary>
            두 DateTime 값이 년(Year) 단위까지 같은지 판단합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsSameHalfyear(System.DateTime,System.DateTime,System.Int32)">
      <summary>
            두 DateTime 값이 반기(Half Year) 단위까지 같은지 판단합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsSameQuarter(System.DateTime,System.DateTime,System.Int32)">
      <summary>
            두 DateTime 값이 분기(Quarter) 단위까지 같은지 판단합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsSameMonth(System.DateTime,System.DateTime)">
      <summary>
            두 DateTime 값이 월(Month) 단위까지 같은지 판단합니다.
            </summary>
      <param name="left">
      </param>
      <param name="right">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsSameWeek(System.DateTime,System.DateTime,System.Globalization.CultureInfo,NSoft.NFramework.TimePeriods.WeekOfYearRuleKind)">
      <summary>
            두 DateTime 값이 주(Week) 단위까지 같은지 판단합니다.
            </summary>
      <param name="left">
      </param>
      <param name="right">
      </param>
      <param name="culture">
      </param>
      <param name="weekOfYearRuleKind">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsSameWeek(System.DateTime,System.DateTime,System.Globalization.CultureInfo,System.Globalization.CalendarWeekRule,System.DayOfWeek,NSoft.NFramework.TimePeriods.WeekOfYearRuleKind)">
      <summary>
            두 DateTime 값이 주(Week) 단위까지 같은지 판단합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsSameDay(System.DateTime,System.DateTime)">
      <summary>
            두 DateTime 값이 일(Day) 단위까지 같은지 판단합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsSameHour(System.DateTime,System.DateTime)">
      <summary>
            두 DateTime 값이 시간(Hour) 단위까지 같은지 판단합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsSameMinute(System.DateTime,System.DateTime)">
      <summary>
            두 DateTime 값이 분(Minute) 단위까지 같은지 판단합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsSameSecond(System.DateTime,System.DateTime)">
      <summary>
            두 DateTime 값이 초(Second) 단위까지 같은지 판단합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsSameDateTime(System.DateTime,System.DateTime)">
      <summary>
            두 일자가 같은 값을 가지는지 판단합니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeTool.UnixEpoch">
      <summary>
            Unix 시스템에서 최소시각으로 정한 일자 (1970-01-01)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.AsString(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="period" />를 문자열로 표현합니다.
            </summary>
      <param name="period">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ToDateTime(System.String)">
      <summary>
            DateTime 형식으로 변환한다. 실패시에는 new DateTime(0) 를 반환한다.
            </summary>
      <param name="value">날짜를 나타내는 문자열</param>
      <returns>변환된 DateTime 인스턴스 개체, 실패시에는 Ticks가 0인 DateTime을 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ToDateTime(System.String,System.DateTime)">
      <summary>
            DateTime 형식으로 변환한다.
            </summary>
      <param name="value">날짜를 나타내는 문자열</param>
      <param name="defaultValue">변환 실패시의 기본값</param>
      <returns>변환된 DateTime 인스턴스 개체</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ToDateTime(System.String,System.Func{System.DateTime})">
      <summary>
        <paramref name="value" />를 DateTime 수형으로 변환합니다.
            </summary>
      <param name="value">변환할 문자열</param>
      <param name="defaultValueFactory">변환 실패 시 반환할 값을 제공하는 Factory</param>
      <returns>변환된 DateTime 인스턴스 개체</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.CurrentYear(System.Int32)">
      <summary>
        <paramref name="yearStartMonth" />를 한 해의 시작월로하는 한해의 시작일자를 표현합니다.
            </summary>
      <param name="yearStartMonth">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.CurrentHalfyear(System.Int32)">
      <summary>
            현재 날짜가 속한 반기의 시작 일자를 나타냅니다. 단 한해의 시작 월이 <paramref name="yearStartMonth" />을 기준으로 합니다.
            </summary>
      <param name="yearStartMonth">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.CurrentQuarter(System.Int32)">
      <summary>
            현재 날짜가 속한 분기의 시작 일자를 나타냅니다. 단 한해의 시작 월이 <paramref name="yearStartMonth" />을 기준으로 합니다.
            </summary>
      <param name="yearStartMonth">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.CurrentWeek">
      <summary>
            현재 날짜가 속한 주(Week)의 시작 일자를 나타냅니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.CurrentWeek(System.Globalization.CultureInfo)">
      <summary>
            현재 날짜가 속한 주(Week)의 시작 일자를 나타냅니다. 지정된 문화권에 따른 한주의 시작 요일을 기준으로 한다.
            </summary>
      <param name="culture">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.CurrentWeek(System.DayOfWeek)">
      <summary>
        <paramref name="firstDayOfWeek" />가 한주의 시작 요일일 때, 현재 날짜가 속한 주(Week)의 시작 일자를 나타냅니다. 
            </summary>
      <param name="firstDayOfWeek">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfYear(System.DateTime)">
      <summary>
            Calendar에 대해 <paramref name="dateTime" />이 속한 년의 시작일을 반환합니다.
            </summary>
      <param name="dateTime">검사 일자</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfYear(System.DateTime,System.Int32)">
      <summary>
            시작 월이 <paramref name="yearStartMonth" />인 Calendar에 대해 <paramref name="dateTime" />이 속한 년의 시작일을 반환합니다.
            </summary>
      <param name="dateTime">검사 일자</param>
      <param name="yearStartMonth">년도의 시작월(기본은 1)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfYear(System.Int32,System.Int32)">
      <summary>
            지정한 년도의 시작 시각
            </summary>
      <param name="year">
      </param>
      <param name="yearStartMonth">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfYear(System.DateTime,System.Int32)">
      <summary>
            시작 월이 <paramref name="yearStartMonth" />인 Calendar에 대해 <paramref name="dateTime" />이 속한 년의 마지막 일을 반환합니다.
            </summary>
      <param name="dateTime">검사 일자</param>
      <param name="yearStartMonth">년도의 시작월(기본은 1)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfYear(System.Int32,System.Int32)">
      <summary>
            지졍된 년도의 완료 시각
            </summary>
      <param name="year">
      </param>
      <param name="yearStartMonth">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfLastYear(System.DateTime)">
      <summary>
            전년도 시작 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfLastYear(System.DateTime)">
      <summary>
            전년도 마지막 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfHalfyear(System.DateTime,System.Int32)">
      <summary>
            시작 월이 <paramref name="yearStartMonth" />인 Calendar에 대해 <paramref name="dateTime" />이 속한 반기의 시작일을 반환합니다.
            </summary>
      <param name="dateTime">검사 일자</param>
      <param name="yearStartMonth">년도의 시작월(기본은 1)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfHalfyear(System.DateTime,System.Int32)">
      <summary>
            시작 월이 <paramref name="yearStartMonth" />인 Calendar에 대해 <paramref name="dateTime" />이 속한 반기의 종료일을 반환합니다.
            </summary>
      <param name="dateTime">검사 일자</param>
      <param name="yearStartMonth">년도의 시작월(기본은 1)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfQuarter(System.DateTime,System.Int32)">
      <summary>
            시작 월이 <paramref name="yearStartMonth" />인 Calendar에 대해 <paramref name="dateTime" />이 속한 분기의 시작일을 반환합니다.
            </summary>
      <param name="dateTime">검사 일자</param>
      <param name="yearStartMonth">년도의 시작월(기본은 1)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfQuarter(System.Int32,NSoft.NFramework.TimePeriods.QuarterKind,System.Int32)">
      <summary>
            지정한 년도, 분기의 시작 시각
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfQuarter(System.DateTime,System.Int32)">
      <summary>
            시작 월이 <paramref name="yearStartMonth" />인 Calendar에 대해 <paramref name="dateTime" />이 속한 분기의 종료일을 반환합니다.
            </summary>
      <param name="dateTime">검사 일자</param>
      <param name="yearStartMonth">년도의 시작월(기본은 1)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfQuarter(System.Int32,NSoft.NFramework.TimePeriods.QuarterKind,System.Int32)">
      <summary>
            지정한 년도, 분기의 완료 시각
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartOfLastQuarter(System.DateTime)">
      <summary>
            전(前) 분기의 시작 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndOfLastQuarter(System.DateTime)">
      <summary>
            전(前) 분기의 마지막 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfMonth(System.DateTime)">
      <summary>
        <paramref name="moment" />이 속한 월의 시작일을 구합니다.
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfMonth(System.Int32,NSoft.NFramework.TimePeriods.MonthKind)">
      <summary>
            해당 년, 월의 시작 시각
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfMonth(System.Int32,System.Int32)">
      <summary>
            해당 년, 월의 시작 시각
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfMonth(System.DateTime)">
      <summary>
        <paramref name="moment" />이 속한 월의 완료일을 구합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfMonth(System.Int32,NSoft.NFramework.TimePeriods.MonthKind)">
      <summary>
            해당 년, 월의 마지막 시각
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfMonth(System.Int32,System.Int32)">
      <summary>
            해당 년, 월의 마지막 시각
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfLastMonth(System.DateTime)">
      <summary>
            전(前)월의 시작 시각
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfLastMonth(System.DateTime)">
      <summary>
            전(前)월의 마지막 시각
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfWeek(System.DateTime)">
      <summary>
        <paramref name="dateTime" />이 속한 주(Week)의 첫째 날을 반환합니다.
            </summary>
      <param name="dateTime">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfWeek(System.DateTime,System.Globalization.CultureInfo)">
      <summary>
             지정된 날짜가 속한 주(week)의 첫번째 요일 (예:일요일)의 날짜
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfWeek(System.DateTime,System.Nullable{System.DayOfWeek})">
      <summary>
            지정된 날짜가 속한 주(week)의 첫번째 요일 (예: 일요일)의 날짜
            </summary>
      <param name="time">일자</param>
      <param name="firstDayOfWeek">한 주의 첫번째 요일</param>
      <returns>지정된 일자가 속한 주의 첫번째 요일의 일자를 반환한다. 문화권에 따라 한주의 첫번째 요일은 다르다. 한국은 Sunday, ISO 9601로는 Monday이다.</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfWeek(System.DateTime)">
      <summary>
        <paramref name="dateTime" />이 속한 주(Week)의 첫째 날을 반환합니다.
            </summary>
      <param name="dateTime">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfWeek(System.DateTime,System.Globalization.CultureInfo)">
      <summary>
             지정된 날짜가 속한 주(week)의 첫번째 요일 (예:일요일)의 날짜
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfWeek(System.DateTime,System.Nullable{System.DayOfWeek})">
      <summary>
            지정된 날짜가 속한 주(week)의 마지막 날짜 (한국:토요일, ISO8601:일요일)
            </summary>
      <param name="time">
      </param>
      <param name="firstDayOfWeek">한 주의 첫번째 요일</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfLastWeek(System.DateTime)">
      <summary>
            전(前) 주(week)의 시작 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfLastWeek(System.DateTime)">
      <summary>
            전(前) 주의 마지막 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfDay(System.DateTime)">
      <summary>
            현재 일의 시작 시각
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndTimeOfDay(System.DateTime)">
      <summary>
            현재 일의 마지막 시각
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.StartMonthOfQuarter(NSoft.NFramework.TimePeriods.QuarterKind)">
      <summary>
            해당 분기의 시작월
            </summary>
      <param name="quarter">해당 분기</param>
      <returns>해당분기의 시작월</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.EndMonthOfQuarter(NSoft.NFramework.TimePeriods.QuarterKind)">
      <summary>
            해당 분기의 마지막 월
            </summary>
      <param name="quarter">해당 분기</param>
      <returns>해당 분기의 마지막 월</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.QuarterOf(System.Int32)">
      <summary>
            지정된 월이 속한 분기
            </summary>
      <param name="month">조회할 월</param>
      <returns>월이 속한 분기</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.QuarterOf(System.DateTime)">
      <summary>
            지정된 날짜의 분기를 구한다.
            </summary>
      <param name="date">날짜</param>
      <returns>날짜가 속한 분기</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.LastQuarterOf(System.DateTime)">
      <summary>
            지정된 날짜의 분기의 앞의 분기를 구한다.
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.NextDayOfWeek(System.DateTime)">
      <summary>
            현재 날짜로부터 가장 가까운 지정된 요일을 반환한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.NextDayOfWeek(System.DateTime,System.DayOfWeek)">
      <summary>
            현재 날짜로부터 가장 가까운 지정된 요일을 반환한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.PrevDayOfWeek(System.DateTime)">
      <summary>
            현재 날짜로 지난 날짜 중에 가장 가까운 지정된 요일을 반환한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.PrevDayOfWeek(System.DateTime,System.DayOfWeek)">
      <summary>
            현재 날짜로 지난 날짜 중에 가장 가까운 지정된 요일을 반환한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetDatePart(System.DateTime)">
      <summary>
            지정한 DateTime 에서 시각부분을 뺀 일자만을 반환합니다.
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.HasDatePart(System.DateTime)">
      <summary>
            날짜에 DatePart의 값을 가지는가?
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.SetDatePart(System.DateTime,System.DateTime)">
      <summary>
        <param name="moment" />의 날짜부분을 <param name="datePart" /> 의 날짜부분으로 설정합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.SetDatePart(System.DateTime,System.Int32,System.Int32,System.Int32)">
      <summary>
            지정된 날짜의 년, 월, 일을 새로 설정한다. Time Part는 그대로
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.SetYear(System.DateTime,System.Int32)">
      <summary>
            DateTime의 년도를 지정된 값으로 설정한다.
            </summary>
      <param name="moment">
      </param>
      <param name="year">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.SetMonth(System.DateTime,System.Int32)">
      <summary>
            DateTime의 월만 지정된 월로 바꾼다.
            </summary>
      <param name="moment">
      </param>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.SetDay(System.DateTime,System.Int32)">
      <summary>
            DateTime의 일만 지정된 일로 바꾼다.
            </summary>
      <param name="moment">
      </param>
      <param name="day">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.Combine(System.DateTime,System.DateTime)">
      <summary>
        <paramref name="datePart" />의 날짜부분과, <paramref name="timePart" />의 시간부분을 합친다.
            </summary>
      <param name="datePart">Date 정보만</param>
      <param name="timePart">Time 정보만</param>
      <seealso cref="M:NSoft.NFramework.TimePeriods.TimeTool.SetTimePart(System.DateTime,System.DateTime)" />
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetTimePart(System.DateTime)">
      <summary>
            지정한 DateTime 에서 시각부분만을 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.HasTimePart(System.DateTime)">
      <summary>
            하루중 시간 부분이 존재하면 참을 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.SetTimePart(System.DateTime,System.DateTime)">
      <summary>
        <paramref name="moment" />의 시간 부분을 <paramref name="timepart" />의 시간부분으로 설정합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.SetTimePart(System.DateTime,System.TimeSpan)">
      <summary>
        <paramref name="moment" />의 시간 부분을 <paramref name="timepart" /> 값으로 설정합니다.
             </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.SetTimePart(System.DateTime,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            날짜의 시간 파트를 설정한다.
            </summary>
      <param name="moment">설정할 DateTime</param>
      <param name="hour">시</param>
      <param name="minute">분</param>
      <param name="second">초</param>
      <param name="millisecond">밀리초</param>
      <returns>설정된 DateTime</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.SetHour(System.DateTime,System.Int32)">
      <summary>
            날짜의 시간(Hour)을 설정한다. 나머지 부분은 그대로 둡니다.
            </summary>
      <param name="moment">대상 DateTime</param>
      <param name="hour">시</param>
      <returns>설정된 DateTime</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.SetMinute(System.DateTime,System.Int32)">
      <summary>
            날짜의 분(Minute)을 설정한다. 나머지 부분은 그대로 둡니다.
            </summary>
      <param name="moment">대상 DateTime</param>
      <param name="minute">분</param>
      <returns>설정된 DateTime</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.SetSecond(System.DateTime,System.Int32)">
      <summary>
             날짜의 초(Second)을 설정한다. 나머지 부분은 그대로 둡니다.
            </summary>
      <param name="date">대상 DateTime</param>
      <param name="second">초</param>
      <returns>설정된 DateTime</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.SetMillisecond(System.DateTime,System.Int32)">
      <summary>
            날짜의 밀리초(Millisecond)을 설정한다. 나머지 부분은 그대로 둡니다.
            </summary>
      <param name="date">대상 DateTime</param>
      <param name="millisecond">밀리초</param>
      <returns>설정된 DateTime</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.Noon(System.DateTime)">
      <summary>
            지정된 날짜의 정오를 가르키는 시간을 만든다.
            </summary>
      <param name="moment">기준 DateTime</param>
      <returns>지정된 날짜의 정오를 가르키는 DateTime</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.Ago(System.TimeSpan,System.DateTime)">
      <summary>
        <paramref name="targetMoment" />에 <paramref name="from" />을 뺀 DateTime를 반환한다.
            </summary>
      <param name="from">뺄 TimeSpan</param>
      <param name="targetMoment">대상 일자</param>
      <returns>targetMoment에서 from 값을 뺀 값</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.From(System.TimeSpan,System.DateTime)">
      <summary>
            지정된 일자에 TimeSpan을 더한 날짜를 반환한다.
            </summary>
      <param name="from">더할 TimeSpan</param>
      <param name="targetMoment">대상 DateTime</param>
      <returns>날짜에 TimeSpan을 더한 날짜</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.FromNow(System.TimeSpan)">
      <summary>
            현재 날짜에 지정된 TimeSpan을 더한 날짜를 반환한다.
            </summary>
      <param name="from">더할 TimeSpan</param>
      <returns>현재 날짜에 TimeSpan을 더한 날짜</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.Since(System.TimeSpan,System.DateTime)">
      <summary>
        <paramref name="targetMoment" />에 <paramref name="from" />을 더한 DateTime를 반환한다. <see cref="M:NSoft.NFramework.TimePeriods.TimeTool.From(System.TimeSpan,System.DateTime)" />과 같다.
            </summary>
      <param name="from">더할 TimeSpan</param>
      <param name="targetMoment">대상 DateTime</param>
      <returns>날짜에 TimeSpan을 더한 날짜</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ToSqlPrecision(System.DateTime)">
      <summary>
            .NET DateTime 을 SQL Server DateTime 수형의 정밀도로 표현합니다. (SQL Server의 DateTime의 정밀도가 좀 낮다)
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ForEachYears(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            기간을 년(Year) 단위로 열거자를 제공한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ForEachHalfYears(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            기간을 반기별로 열거자를 제공한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ForEachQuarters(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            기간을 분기단위로 열거한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ForEachMonths(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            기간을 월 단위로 열거자를 제공한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ForEachWeeks(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            기간을 주 단위로 열거자를 제공한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ForEachDays(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            기간을 날짜 단위로 열거합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ForEachHours(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            지정된 기간을 시간 단위로 열거합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ForEachMinutes(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            지정된 기간을 분(Minute) 단위로 열거합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.ForEachPeriods(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.PeriodKind)">
      <summary>
        <paramref name="period" />를 <paramref name="periodKind" /> 단위로 열거합니다.
            </summary>
      <param name="period">전체 기간</param>
      <param name="periodKind">열거할 기간의 단위</param>
      <returns>열거할 기간 단위를 가지는 기간의 컬렉션</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.RunPeriod``1(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.PeriodKind,System.Func{NSoft.NFramework.TimePeriods.ITimePeriod,``0})">
      <summary>
            지정된 기간(<paramref name="period" />)을 <paramref name="periodKind" /> 단위로 열거하면서, <paramref name="runner" />을 실행합니다.
            </summary>
      <typeparam name="T">실행한 결과 값의 수형</typeparam>
      <param name="period">전체 기간</param>
      <param name="periodKind">열거할 기간의 단위</param>
      <param name="runner">각 단위 기간별 실행할 델리게이트</param>
      <returns>각 단위 기간별 실행 결과</returns>
      <example>
        <code>
                var calendar = CultureInfo.CurrentCulture.Calendar;
            	var results = RunEach(new YearRange(DateTime.Now), PeriodKind.Day, (day)=&gt;calendar.GetDaysOfYear(day.Start));
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.RunPeriodAsParallel``1(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.PeriodKind,System.Func{NSoft.NFramework.TimePeriods.ITimePeriod,``0})">
      <summary>
            지정된 기간(<paramref name="period" />)을 <paramref name="periodKind" /> 단위로 열거하면서, 병렬로 <paramref name="runner" />을 실행합니다.
            </summary>
      <typeparam name="T">실행한 결과 값의 수형</typeparam>
      <param name="period">전체 기간</param>
      <param name="periodKind">열거할 기간의 단위</param>
      <param name="runner">각 단위 기간별 실행할 델리게이트</param>
      <returns>각 단위 기간별 실행 결과</returns>
      <example>
        <code>
                var calendar = CultureInfo.CurrentCulture.Calendar;
            	var results = RunEachAsParallel(new YearRange(DateTime.Now), PeriodKind.Day, (day)=&gt;calendar.GetDaysOfYear(day.Start));
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.RunPeriodAsync``1(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.PeriodKind,System.Func{NSoft.NFramework.TimePeriods.ITimePeriod,``0})">
      <summary>
            지정된 기간(<paramref name="period" />)을 <paramref name="periodKind" /> 단위로 열거하면서, <paramref name="runner" />을 비동기 방식으로 실행합니다.
            </summary>
      <typeparam name="T">실행한 결과 값의 수형</typeparam>
      <param name="period">전체 기간</param>
      <param name="periodKind">열거할 기간의 단위</param>
      <param name="runner">각 단위 기간별 실행할 델리게이트</param>
      <returns>각 단위 기간별 실행 결과</returns>
      <example>
        <code>
                var calendar = CultureInfo.CurrentCulture.Calendar;
            	var results = RunEachAsync(new YearRange(DateTime.Now), PeriodKind.Day, (day)=&gt;calendar.GetDaysOfYear(day.Start));
            </code>
      </example>
      <seealso cref="M:NSoft.NFramework.LinqEx.EnumerableTool.RunEachAsync``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.Min(System.DateTime,System.DateTime)">
      <summary>
             두 일자 중 최소 일자를 구한다.
            </summary>
      <param name="a">
      </param>
      <param name="b">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.Max(System.DateTime,System.DateTime)">
      <summary>
            두 일자 중 최대 일자를 구한다.
            </summary>
      <param name="a">
      </param>
      <param name="b">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.Min(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
      <summary>
            두 일자 중 최소 일자를 구한다.
            </summary>
      <param name="a">
      </param>
      <param name="b">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.Max(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
      <summary>
            두 일자 중 최대 일자를 구한다.
            </summary>
      <param name="a">
      </param>
      <param name="b">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.Min(System.TimeSpan,System.TimeSpan)">
      <summary>
            두 시간 간격 중 작은 값을 반환한다.
            </summary>
      <param name="a">
      </param>
      <param name="b">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.Max(System.TimeSpan,System.TimeSpan)">
      <summary>
            두 시간 간격 중 큰 값을 반환한다.
            </summary>
      <param name="a">
      </param>
      <param name="b">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.AdjustPeriod(System.DateTime@,System.DateTime@)">
      <summary>
            기간의 시작 시각과 완료 시각을 순서대로 정렬합니다.
            </summary>
      <param name="start">시작 시각</param>
      <param name="end">완료 시각</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.AdjustPeriod(System.Nullable{System.DateTime}@,System.Nullable{System.DateTime}@)">
      <summary>
            기간의 시작 시각과 완료 시각을 순서대로 정렬합니다.
            </summary>
      <param name="start">시작 시각</param>
      <param name="end">완료 시각</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.AdjustPeriod(System.DateTime@,System.TimeSpan@)">
      <summary>
        <paramref name="duration" />의 부호가 Minus(-) 이면, 
            <paramref name="start" /> 시간을 <paramref name="duration" />만큼 앞으로 이동하고, <paramref name="duration" /> 값을 양수로 변경한다.
            </summary>
      <param name="start">시작 시각</param>
      <param name="duration">시간 간격</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetTimeBlock(System.DateTime,System.TimeSpan)">
      <summary>
        <paramref name="start" />를 시작 시각으로 <paramref name="duration" /> 만큼의 기간을 가지는 시간 범위를 빌드합니다.
            </summary>
      <param name="start">시작시각</param>
      <param name="duration">기간</param>
      <returns>TimeBlock</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetTimeBlock(System.DateTime,System.DateTime)">
      <summary>
        <paramref name="start" /> ~ <paramref name="end" /> 시각을 기간으로 하는 시간 범위를 빌드합니다.
            </summary>
      <param name="start">시작시각</param>
      <param name="end">완료시각</param>
      <returns>TimeBlock</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetTimeRange(System.DateTime,System.TimeSpan)">
      <summary>
        <paramref name="start" />를 시작 시각으로 <paramref name="duration" /> 만큼의 기간을 가지는 시간 범위를 빌드합니다.
            </summary>
      <param name="start">시작시각</param>
      <param name="duration">기간</param>
      <returns>TimeRange</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetTimeRange(System.DateTime,System.DateTime)">
      <summary>
        <paramref name="start" /> ~ <paramref name="end" /> 시각을 기간으로 하는 시간 범위를 빌드합니다.
            </summary>
      <param name="start">시작시각</param>
      <param name="end">완료시각</param>
      <returns>TimeRange</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetRelativeYearPeriod(System.DateTime,System.Int32)">
      <summary>
        <paramref name="start" />부터 상대적으로 <paramref name="years" /> 년수 만큼의 기간
            </summary>
      <param name="start">시작 시각</param>
      <param name="years">시간 간격 (년수)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetRelativeMonthPeriod(System.DateTime,System.Int32)">
      <summary>
        <paramref name="start" />부터 상대적으로 <paramref name="months" /> 개월수 만큼의 기간
            </summary>
      <param name="start">시작 시각</param>
      <param name="months">시간 간격 (월수)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetRelativeWeekPeriod(System.DateTime,System.Int32)">
      <summary>
        <paramref name="start" />부터 상대적으로 <paramref name="weeks" /> 주수 만큼의 기간
            </summary>
      <param name="start">시작 시각</param>
      <param name="weeks">시간 간격 (주수)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetRelativeDayPeriod(System.DateTime,System.Int32)">
      <summary>
        <paramref name="start" />부터 상대적으로 <paramref name="days" /> 일수 만큼의 기간
            </summary>
      <param name="start">시작 시각</param>
      <param name="days">시간 간격 (일수)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetRelativeHourPeriod(System.DateTime,System.Int32)">
      <summary>
        <paramref name="start" />부터 상대적으로 <paramref name="hours" /> 시간수 만큼의 기간
            </summary>
      <param name="start">시작 시각</param>
      <param name="hours">시간 간격 (시간수)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetRelativeMinutePeriod(System.DateTime,System.Int32)">
      <summary>
        <paramref name="start" />부터 상대적으로 <paramref name="minutes" /> 분수 만큼의 기간
            </summary>
      <param name="start">시작 시각</param>
      <param name="minutes">시간 간격 (분수)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetRelativeSecondPeriod(System.DateTime,System.Int32)">
      <summary>
        <paramref name="start" />부터 상대적으로 <paramref name="seconds" /> 초수 만큼의 기간
            </summary>
      <param name="start">시작 시각</param>
      <param name="seconds">시간 간격 (초수)</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetPeriodOf(System.DateTime,NSoft.NFramework.TimePeriods.PeriodKind)">
      <summary>
        <paramref name="moment" />이 속하면서, <paramref name="periodKind" />에 해당하는 <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />을 구합니다.
            </summary>
      <param name="moment">
      </param>
      <param name="periodKind">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetPeriodOf(System.DateTime,NSoft.NFramework.TimePeriods.PeriodKind,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />이 속하면서, <paramref name="periodKind" />에 해당하는 <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />을 반환합니다.
            </summary>
      <param name="moment">
      </param>
      <param name="periodKind">
      </param>
      <param name="timeCalendar">
      </param>
      <returns>
      </returns>
      <seealso cref="M:NSoft.NFramework.TimePeriods.TimeTool.GetPeriodsOf(System.DateTime,NSoft.NFramework.TimePeriods.PeriodKind,System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)" />
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetPeriodsOf(System.DateTime,NSoft.NFramework.TimePeriods.PeriodKind,System.Int32)">
      <summary>
        <paramref name="moment" />이 속하면서, <paramref name="periodKind" />에 해당하는 <see cref="T:NSoft.NFramework.TimePeriods.ICalendarTimeRange" />을 구합니다.
            </summary>
      <param name="moment">
      </param>
      <param name="periodKind">
      </param>
      <param name="periodCount">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetPeriodsOf(System.DateTime,NSoft.NFramework.TimePeriods.PeriodKind,System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />이 속하면서, <paramref name="periodKind" />에 해당하는 <see cref="T:NSoft.NFramework.TimePeriods.ICalendarTimeRange" />을 구합니다.
            </summary>
      <param name="moment">
      </param>
      <param name="periodKind">
      </param>
      <param name="periodCount">
      </param>
      <param name="timeCalendar">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetYearRange(System.DateTime,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 년의 전체 기간
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetYearRanges(System.DateTime,System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 년과 <paramref name="yearCount" /> 만큼의 기간
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetHalfyearRange(System.DateTime,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 분기의 전체 기간 (5월이면, 1월1일 ~ 6월30일)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetHalfyearRanges(System.DateTime,System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 분기부터 <paramref name="halfyearCount" />만큼의 분기
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetQuarterRange(System.DateTime,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 분기의 전체 기간 (5월이면 4월1일부터 6월30일까지)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetQuarterRanges(System.DateTime,System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 분기부터 <paramref name="quarterCount" /> 갯수의 분기까지의 기간
            </summary>
      <param name="moment">기준 일자</param>
      <param name="quarterCount">분기 수</param>
      <param name="timeCalendar">기준 TimeCalendar</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetMonthRange(System.DateTime,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 월의 전체 기간 (5월이면 5월1일~5월31일)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetMonthRanges(System.DateTime,System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 월로부터 <paramref name="monthCount" /> 만큼의 기간
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetWeekRange(System.DateTime,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 한주의 기간을 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetWeekRanges(System.DateTime,System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 주에서 <paramref name="weekCount" />만큼의 주의 기간
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetDayRange(System.DateTime,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 하루의 기간을 반환합니다 (1일)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetDayRanges(System.DateTime,System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 하루서부터 <paramref name="dayCount" />만큼의 일자의 기간
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetHourRange(System.DateTime,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 시간의 기간을 반환합니다 (1시간)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetHourRanges(System.DateTime,System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 하루서부터 <paramref name="hourCount" />만큼의 시간의 기간
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetMinuteRange(System.DateTime,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 분의 기간을 반환합니다 (1분)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetMinuteRanges(System.DateTime,System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="moment" />가 속한 하루서부터 <paramref name="minuteCount" />만큼의 분의 기간
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.HasInside(NSoft.NFramework.TimePeriods.ITimePeriod,System.DateTime)">
      <summary>
            기간안에 대상 시각이 포함되는지 여부
            </summary>
      <param name="period">기간</param>
      <param name="target">대상 일자</param>
      <returns>기간에 포함 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.HasInside(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            현 기간 안에 대상 기간이 포함되는지 여부
            </summary>
      <param name="period">
      </param>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsAnytime(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            기간이 정해지지 않은 TimePeriod인지 파악합니다. (Start와 End가 모두 Null)
            </summary>
      <param name="period">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsNotAnytime(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            기간이 정해지지 않은 TimePeriod가 아닌지 파악합니다. (시작시각 또는 완료시각이 지정되어 있으면 됩니다)
            </summary>
      <param name="period">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetReleation(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="period" />가 <paramref name="target" />과의 시간 축으로 선 후행 관계를 판단합니다.
            </summary>
      <param name="period">
      </param>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IntersectsWith(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간 교차하거나, <paramref name="period" />가 <paramref name="target" /> 의 내부 구간이면 true를 반환합니다.
            </summary>
      <param name="period">
      </param>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.OverlapsWith(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간이 겹치는 구간이 있는지 파악합니다.
            </summary>
      <param name="period">
      </param>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetIntersectionBlock(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 공통되는 기간을 반환한다. (교집합)
            </summary>
      <param name="period">
      </param>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetUnionBlock(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 합집합 기간을 반환한다.
            </summary>
      <param name="period">
      </param>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetIntersectionRange(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 공통되는 기간을 반환한다. (교집합)
            </summary>
      <param name="period">
      </param>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.GetUnionRange(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 합집합 기간을 반환한다.
            </summary>
      <param name="period">
      </param>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.TrimToYear(System.DateTime)">
      <summary>
            Year 하위 단위를 시작값으로 설정합니다. 즉 지정한 날짜가 속한 년도의 첫번째 날짜 (<see cref="M:NSoft.NFramework.TimePeriods.TimeTool.StartTimeOfYear(System.DateTime)" /> 와 같음)
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.TrimToMonth(System.DateTime,System.Int32)">
      <summary>
        <paramref name="moment" />가 속한 년도에 <paramref name="month" />월의 첫번째 날을 반환합니다.
            </summary>
      <param name="moment">
      </param>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.TrimToDay(System.DateTime,System.Int32)">
      <summary>
        <paramref name="moment" />가 속한 년, 월에 <paramref name="day" /> 일의 날짜를 반환합니다.
            </summary>
      <param name="moment">기준 일자</param>
      <param name="day">1 이상 해당 년/월의 최대일 이하여야 합니다.</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.TrimToHour(System.DateTime,System.Int32)">
      <summary>
        <paramref name="moment" />가 속한 날짜에서 <paramref name="hour" /> 시간을 정하고, 그 이하는 0 으로 한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.TrimToMinute(System.DateTime,System.Int32)">
      <summary>
        <paramref name="moment" />가 속한 날짜에서 <paramref name="minute" /> 분을 정하고, 그 이하는 0 으로 한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.TrimToSecond(System.DateTime,System.Int32)">
      <summary>
        <paramref name="moment" />가 속한 날짜에서 <paramref name="second" /> 초을 정하고, 그 이하는 0 으로 한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.TrimToMillisecond(System.DateTime,System.Int32)">
      <summary>
        <paramref name="moment" />가 속한 날짜에서 <paramref name="millisecond" /> 초을 정한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.AssertValidPeriod(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
      <summary>
            기간의 시작 일자가 완료 일자보다 선행되어야 합니다.
            </summary>
      <param name="start">
      </param>
      <param name="end">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.AssertMutable(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="period" />가 수정 가능한가 를 검사합니다. (읽기 전용이면 <see cref="T:System.InvalidOperationException" /> 예외를 발생시킵니다)
            </summary>
      <param name="period">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.AllItemsAreEqual(System.Collections.Generic.IEnumerable{NSoft.NFramework.TimePeriods.ITimePeriod},System.Collections.Generic.IEnumerable{NSoft.NFramework.TimePeriods.ITimePeriod})">
      <summary>
        <paramref name="left" />와 <paramref name="right" /> 시퀀스의 요소들이 모두 같은 지를 판단합니다.
            </summary>
      <param name="left">
      </param>
      <param name="right">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsWeekDay(System.DayOfWeek)">
      <summary>
            요일이 주중인가?
            </summary>
      <param name="dayOfWeek">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeTool.IsWeekEnd(System.DayOfWeek)">
      <summary>
            요일이 주말인가?
            </summary>
      <param name="dayOfWeek">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeTool.CurrentCalendarYear">
      <summary>
            현재 날짜가 속한 년의 시작 일자를 나타냅니다. (올해 1월 1일)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeTool.CurrentCalendarHalfyear">
      <summary>
            현재 날짜가 속한 반기의 시작 일자를 나타냅니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeTool.CurrentCalendarQuarter">
      <summary>
            현재 날짜가 속한 분기의 시작 일자를 나타냅니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeTool.CurrentMonth">
      <summary>
            현재 날짜가 속한 월의 시작 일자를 나타냅니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeTool.CurrentDay">
      <summary>
            오늘
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeTool.CurrentHour">
      <summary>
            현재 시각의 시간
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeTool.CurrentMinute">
      <summary>
            현재 시각의 분단위
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeTool.CurrentSecond">
      <summary>
            현재 시각의 초단위까지만
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.WeekTool">
      <summary>
            WeekOfYear 에 대한 Extension Methods 입니다.
            ref : http://www.simpleisbest.net/archive/2005/10/27/279.aspx
            ref : http://en.wikipedia.org/wiki/ISO_8601#Week_dates
            </summary>
      <remarks>
        <see cref="T:System.Globalization.CalendarWeekRule" /> 값에 따라 WeekOfYear 가 결정된다.
            
            FirstDay : 1월1일이 포함된 주를 무조건 첫째 주로 삼는다. (우리나라, 미국 등의 기준) : .NET의 설정대로 하면 이렇게 된다.
            FirstForDayWeek : 1월1일이 포함된 주가 4일 이상인 경우에만 그 해의 첫 번째 주로 삼는다.	(ISO 8601)
            				   예) 한 주의 시작 요일이 일요일이고 1월1일이 일/월/화/수 중 하나이면 1월1일이 포함된 주는 해당 해의 첫 번째 주이다.
            				   예) 한 주의 시작 요일이 일요일이고 1월1일이 목/금/토 중 하나이면 1월1일이 포함된 주는 해당 해의 첫 번째 주로 간주하지 않는다.
            				   예) 2005년 1월 1일은 토요일이므로 1월1일이 포함된 주는 2005년의 첫 번째 주로 간주하지 않는다.
            FirstFullWeek : 1월의 첫 번째 주가 7일이 아니면 해당 해의 첫 번째 주로 삼지 않는다.
            			    예) 한 주의 시작 요일이 일요일인 경우, 1월1일이 일요일이 아니라면 1월1일이 포함된 주는 해당 해의 첫 번째 주로 간주하지 않는다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetCalendarWeekRuleAndFirstDayOfWeek(System.Globalization.CultureInfo,System.Nullable{NSoft.NFramework.TimePeriods.WeekOfYearRuleKind},System.Globalization.CalendarWeekRule@,System.DayOfWeek@)">
      <summary>
        <paramref name="weekOfYearRule" /> 에 따라 <paramref name="weekRule" />과  <paramref name="firstDayOfWeek" /> 를 결정합니다.
            </summary>
      <param name="culture">문화권</param>
      <param name="weekOfYearRule">주차 계산을 위한 룰</param>
      <param name="weekRule">한해의 첫주를 산정하는 규칙</param>
      <param name="firstDayOfWeek">한주의 첫번째 요일</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetCalendarWeekRule(System.Globalization.CultureInfo,System.Nullable{NSoft.NFramework.TimePeriods.WeekOfYearRuleKind})">
      <summary>
            주차 계산 룰과 문화권에 따른 주차 계산 룰을 구합니다.
            </summary>
      <param name="culture">문화권</param>
      <param name="weekOfYearRule">주차 계산 룰</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetFirstDayOfWeek(System.Globalization.CultureInfo,System.Nullable{NSoft.NFramework.TimePeriods.WeekOfYearRuleKind})">
      <summary>
            주차 계산 룰과 문화권에 따른 한주의 첫번째 요일을 구합니다.
            </summary>
      <param name="culture">문화권</param>
      <param name="weekOfYearRule">주차 계산 룰</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetWeekOfYearRuleKind(System.Nullable{System.Globalization.CalendarWeekRule},System.Nullable{System.DayOfWeek})">
      <summary>
        <paramref name="weekRule" />, <paramref name="firstDayOfWeek" />에 해당하는 <see cref="T:NSoft.NFramework.TimePeriods.WeekOfYearRuleKind" />를 판단합니다.
            </summary>
      <param name="weekRule">한해의 첫주를 산정하는 규칙</param>
      <param name="firstDayOfWeek">한주의 첫번째 요일</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetYearAndWeek(System.DateTime,System.Globalization.CultureInfo,NSoft.NFramework.TimePeriods.WeekOfYearRuleKind,System.Int32)">
      <summary>
            해당일자의 주차를 구한다. 문화권(Culture) 및 새해 첫주차에 대한 정의에 따라 주차가 달라진다.
            ref : http://www.simpleisbest.net/archive/2005/10/27/279.aspx
            ref : http://en.wikipedia.org/wiki/ISO_8601#Week_dates
            </summary>
      <remarks>
        <see cref="T:System.Globalization.CalendarWeekRule" /> 값에 따라 WeekOfYear 가 결정된다.
            
            FirstDay : 1월1일이 포함된 주를 무조건 첫째 주로 삼는다. (우리나라, 미국 등의 기준) : .NET의 설정대로 하면 이렇게 된다.
            FirstForDayWeek : 1월1일이 포함된 주가 4일 이상인 경우에만 그 해의 첫 번째 주로 삼는다.	(ISO 8601)
            				   예) 한 주의 시작 요일이 일요일이고 1월1일이 일/월/화/수 중 하나이면 1월1일이 포함된 주는 해당 해의 첫 번째 주이다.
            				   예) 한 주의 시작 요일이 일요일이고 1월1일이 목/금/토 중 하나이면 1월1일이 포함된 주는 해당 해의 첫 번째 주로 간주하지 않는다.
            				   예) 2005년 1월 1일은 토요일이므로 1월1일이 포함된 주는 2005년의 첫 번째 주로 간주하지 않는다.
            FirstFullWeek : 1월의 첫 번째 주가 7일이 아니면 해당 해의 첫 번째 주로 삼지 않는다.
            			    예) 한 주의 시작 요일이 일요일인 경우, 1월1일이 일요일이 아니라면 1월1일이 포함된 주는 해당 해의 첫 번째 주로 간주하지 않는다.
            </remarks>
      <param name="moment">주차(WeekOfYear)를 산정하기 위한 일자</param>
      <param name="yearStartMonth">한 해의 시작 월</param>
      <param name="culture">해당 Calendar를 얻기위한 문화권</param>
      <param name="weekOfYearRule">주차를 산정하는 방식</param>
      <returns>지정된 일자가 속한 Week Of Year를 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetYearAndWeek(System.DateTime,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
            해당일자의 주차를 구한다. 문화권(Culture) 및 새해 첫주차에 대한 정의에 따라 주차가 달라진다.
            ref : http://www.simpleisbest.net/archive/2005/10/27/279.aspx
            ref : http://en.wikipedia.org/wiki/ISO_8601#Week_dates
            </summary>
      <remarks>
        <see cref="T:System.Globalization.CalendarWeekRule" /> 값에 따라 WeekOfYear 가 결정된다.
            
            FirstDay : 1월1일이 포함된 주를 무조건 첫째 주로 삼는다. (우리나라, 미국 등의 기준) : .NET의 설정대로 하면 이렇게 된다.
            FirstFourDayWeek : 1월1일이 포함된 주가 4일 이상인 경우에만 그 해의 첫 번째 주로 삼는다.	(ISO 8601)
            				   예) 한 주의 시작 요일이 일요일이고 1월1일이 일/월/화/수 중 하나이면 1월1일이 포함된 주는 해당 해의 첫 번째 주이다.
            				   예) 한 주의 시작 요일이 일요일이고 1월1일이 목/금/토 중 하나이면 1월1일이 포함된 주는 해당 해의 첫 번째 주로 간주하지 않는다.
            				   예) 2005년 1월 1일은 토요일이므로 1월1일이 포함된 주는 2005년의 첫 번째 주로 간주하지 않는다.
            FirstFullWeek : 1월의 첫 번째 주가 7일이 아니면 해당 해의 첫 번째 주로 삼지 않는다.
            			    예) 한 주의 시작 요일이 일요일인 경우, 1월1일이 일요일이 아니라면 1월1일이 포함된 주는 해당 해의 첫 번째 주로 간주하지 않는다.
            </remarks>
      <param name="moment">주차(WeekOfYear)를 산정하기 위한 일자</param>
      <param name="timeCalendar">주차 계산을 위한 규칙 정보를 가진 TimeCalendar 인스턴스</param>
      <returns>지정된 일자가 속한 Week Of Year를 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetEndYearAndWeek(System.Int32,System.Globalization.CultureInfo,NSoft.NFramework.TimePeriods.WeekOfYearRuleKind,System.Int32)">
      <summary>
            해당 년도의 주차산정방식에 따라 마지막 주차를 산정합니다. 
            </summary>
      <param name="year">해당 년도</param>
      <param name="yearStartMonth">년의 시작 월</param>
      <param name="culture">문화권</param>
      <param name="weekOfYearRule">한해의 첫번째 주차를 산정하는 방식</param>
      <returns>해당 년도의 마지막 주차</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetEndYearAndWeek(System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
            해당 년도의 주차산정방식에 따라 마지막 주차를 산정합니다. 
            </summary>
      <param name="year">해당 년도</param>
      <param name="timeCalendar">TimeCalendar</param>
      <returns>해당 년도의 마지막 주차</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetWeekRange(NSoft.NFramework.TimePeriods.YearAndWeek,System.Globalization.CultureInfo,NSoft.NFramework.TimePeriods.WeekOfYearRuleKind,System.Int32)">
      <summary>
        <paramref name="yearAndWeek" /> 주차에 해당하는 기간을 <see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.WeekRange" /> 로 반환합니다. (예: 2011년 28주차의 실제 기간)
            </summary>
      <param name="yearAndWeek">년도와 주차 정보</param>
      <param name="yearStartMonth">한 해의 시작 월</param>
      <param name="culture">문하권</param>
      <param name="weekOfYearRule">한해의 첫주를 산정하는 규칙</param>
      <returns>주차에 해당하는 한주의 기간</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetWeekRange(NSoft.NFramework.TimePeriods.YearAndWeek,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="yearAndWeek" /> 주차에 해당하는 기간을 <see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.WeekRange" /> 로 반환합니다. (예: 2011년 28주차의 실제 기간)
            </summary>
      <param name="yearAndWeek">년도와 주차 정보</param>
      <param name="timeCalendar">TimeCalendar 옵션</param>
      <returns>주차에 해당하는 한주의 기간</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetStartWeekRangeOfYear(System.Int32,System.Globalization.CultureInfo,NSoft.NFramework.TimePeriods.WeekOfYearRuleKind,System.Int32)">
      <summary>
            해당 년도의 첫번째 주차에 해당하는 기간을 <see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.WeekRange" />로 반환합니다.
            </summary>
      <param name="year">년도</param>
      <param name="yearStartMonth">한 해의 시작 월</param>
      <param name="culture">문하권</param>
      <param name="weekOfYearRule">한 해의 첫주를 산정하는 룰</param>
      <returns>첫번째 주차에 해당하는 한주의 기간</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetStartWeekRangeOfYear(System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
            해당 년도의 첫번째 주차에 해당하는 기간을 <see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.WeekRange" />로 반환합니다.
            </summary>
      <param name="year">년도</param>
      <param name="timeCalendar">TimeCalendar 옵션</param>
      <returns>첫번째 주차에 해당하는 한주의 기간</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetEndWeekRangeOfYear(System.Int32,System.Globalization.CultureInfo,NSoft.NFramework.TimePeriods.WeekOfYearRuleKind,System.Int32)">
      <summary>
            해당 년도의 마지막 주차에 해당하는 기간을 <see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.WeekRange" />로 반환합니다.
            </summary>
      <param name="year">년도</param>
      <param name="yearStartMonth">한 해의 시작 월</param>
      <param name="culture">문하권</param>
      <param name="weekOfYearRule">한 해의 첫주를 산정하는 룰</param>
      <returns>마지막 주차에 해당하는 한주의 기간</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.GetEndWeekRangeOfYear(System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
            해당 년도의 마지막 주차에 해당하는 기간을 <see cref="T:NSoft.NFramework.TimePeriods.TimeRanges.WeekRange" />로 반환합니다.
            </summary>
      <param name="year">년도</param>
      <param name="timeCalendar">TimeCalendar 옵션</param>
      <returns>마지막 주차에 해당하는 한주의 기간</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.AddWeekOfYears(NSoft.NFramework.TimePeriods.YearAndWeek,System.Int32,System.Globalization.CultureInfo,NSoft.NFramework.TimePeriods.WeekOfYearRuleKind,System.Int32)">
      <summary>
        <paramref name="yearAndWeek" />에 <paramref name="weeks" />만큼의 주차를 더한 주차를 계산합니다.
            </summary>
      <param name="yearAndWeek">기준 주차</param>
      <param name="weeks">더할 주차 값</param>
      <param name="yearStartMonth">한해의 시작 월</param>
      <param name="culture">문화권</param>
      <param name="weekOfYearRule">주차 산정을 위한 룰</param>
      <returns>기준 주차에 주차를 더한 주차 정보</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.WeekTool.AddWeekOfYears(NSoft.NFramework.TimePeriods.YearAndWeek,System.Int32,NSoft.NFramework.TimePeriods.ITimeCalendar)">
      <summary>
        <paramref name="yearAndWeek" />에 <paramref name="weeks" />만큼의 주차를 더한 주차를 계산합니다.
            </summary>
      <param name="yearAndWeek">기준 주차</param>
      <param name="weeks">더할 주차 값</param>
      <param name="timeCalendar">TimeCalendar</param>
      <returns>기준 주차에 주차를 더한 주차 정보</returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.DateTimeSet">
      <summary>
        <see cref="T:System.DateTime" />의 정렬을 수행하여 저장한 컬렉션입니다. (중복은 허용되지 않습니다)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.IDateTimeSet">
      <summary>
            DateTime 을 요소로 가지는 컬렉션입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.IDateTimeSet.AddAll(System.Collections.Generic.IEnumerable{System.DateTime})">
      <summary>
            지정된 컬렉션의 요소들을 모두 추가합니다.
            </summary>
      <param name="moments">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.IDateTimeSet.GetDurations(System.Int32,System.Int32)">
      <summary>
            순번에 해당하는 시각들의 Duration을 구합니다.
            </summary>
      <param name="startIndex">
      </param>
      <param name="count">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.IDateTimeSet.FindPrevious(System.DateTime)">
      <summary>
            지정된 시각의 바로 전의 시각을 찾습니다. 없으면 null을 반환합니다.
            </summary>
      <param name="moment">기준 시각</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.IDateTimeSet.FindNext(System.DateTime)">
      <summary>
            지정된 시각의 바로 후의 시각을 찾습니다. 없으면 null을 반환합니다.
            </summary>
      <param name="moment">기준시각</param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.IDateTimeSet.Item(System.Int32)">
      <summary>
            인덱서
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.IDateTimeSet.Min">
      <summary>
            최소값, 요소가 없으면 null을 반환한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.IDateTimeSet.Max">
      <summary>
            최대값, 요소가 없으면 null을 반환한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.IDateTimeSet.Duration">
      <summary>
            Min~Max의 기간을 나타낸다. 둘 중 하나라도 null이면 null을 반환한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.IDateTimeSet.IsEmpty">
      <summary>
            요소가 없는 컬렉션인가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.IDateTimeSet.IsMoment">
      <summary>
            모든 요소가 같은 시각을 나타내는가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.IDateTimeSet.IsAnytime">
      <summary>
            요소가 모든 시각을 나타내는가? <see cref="P:NSoft.NFramework.TimePeriods.IDateTimeSet.Min" />이 null 이고, <see cref="P:NSoft.NFramework.TimePeriods.IDateTimeSet.Max" />가 <see cref="F:System.DateTime.MaxValue" />이다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DateTimeSet.#ctor">
      <summary>
            기본 생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DateTimeSet.#ctor(System.Collections.Generic.IEnumerable{System.DateTime})">
      <summary>
            생성자
            </summary>
      <param name="moments">추가할 요소들</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DateTimeSet.Add(System.DateTime)">
      <summary>
        <paramref name="moment" />를 요소로 추가합니다. 중복된 요소는 추가하지 않습니다.
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DateTimeSet.AddAll(System.Collections.Generic.IEnumerable{System.DateTime})">
      <summary>
            지정된 컬렉션의 요소들을 모두 추가합니다.
            </summary>
      <param name="moments">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DateTimeSet.GetDurations(System.Int32,System.Int32)">
      <summary>
            순번에 해당하는 시각들의 Duration을 구합니다.
            </summary>
      <param name="startIndex">
      </param>
      <param name="count">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DateTimeSet.FindPrevious(System.DateTime)">
      <summary>
            지정된 시각의 바로 전의 시각을 찾습니다. 없으면 null을 반환합니다.
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.DateTimeSet.FindNext(System.DateTime)">
      <summary>
            지정된 시각의 바로 후의 시각을 찾습니다. 없으면 null을 반환합니다.
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.DateTimeSet.Item(System.Int32)">
      <summary>
            Readonly indexer
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.DateTimeSet.Min">
      <summary>
            최소값, 요소가 없으면 null을 반환한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.DateTimeSet.Max">
      <summary>
            최대값, 요소가 없으면 null을 반환한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.DateTimeSet.Duration">
      <summary>
            Min~Max의 기간을 나타낸다. 둘 중 하나라도 null이면 null을 반환한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.DateTimeSet.IsEmpty">
      <summary>
            요소가 없는 컬렉션인가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.DateTimeSet.IsMoment">
      <summary>
            모든 요소가 같은 시각을 나타내는가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.DateTimeSet.IsAnytime">
      <summary>
            요소가 모든 시각을 나타내는가? <see cref="P:NSoft.NFramework.TimePeriods.IDateTimeSet.Min" />이  <see cref="F:System.DateTime.MinValue" />이고, 
            <see cref="P:NSoft.NFramework.TimePeriods.IDateTimeSet.Max" />가 <see cref="F:System.DateTime.MaxValue" />이다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ITimeBlock">
      <summary>
            Start Time과 Duration이 지정될 수 있고, End Time 은 계산되는 자료구조를 나타냅니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeBlock.Setup(System.DateTime,System.TimeSpan)">
      <summary>
            기간 설정
            </summary>
      <param name="newStart">
      </param>
      <param name="duration">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeBlock.DurationFromStart(System.TimeSpan)">
      <summary>
            시작시각(<see cref="P:NSoft.NFramework.TimePeriods.ITimeBlock.Start" />)은 고정, 기간(duration)으로 완료시각(<see cref="P:NSoft.NFramework.TimePeriods.ITimeBlock.End" />)를 재설정
            </summary>
      <param name="newDuration">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeBlock.DurationFromEnd(System.TimeSpan)">
      <summary>
            완료시각(<see cref="P:NSoft.NFramework.TimePeriods.ITimeBlock.End" />)은 고정 이전 기간(duration)으로 시작시간을 계산하여, 기간으로 재설정
            </summary>
      <param name="newDuration">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeBlock.GetPreviousBlock(System.TimeSpan)">
      <summary>
             지정된 Offset만큼 기간이 이전 시간으로 이동한 TimeBlock을 반환한다.
            </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeBlock.GetNextBlock(System.TimeSpan)">
      <summary>
            지정된 Offset만큼 기간이 이후 시간으로 이동한 TimeBlock을 반환한다.
            </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeBlock.Start">
      <summary>
            기간의 시작 시각. 시작 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MinPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeBlock.End">
      <summary>
            기간의 완료 시각. 완료 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeBlock.Duration">
      <summary>
            기간을 TimeSpan으료 표현, 기간이 정해지지 않았다면 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodDuration" /> 을 반환합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ITimeCalendar">
      <summary>
            문화권에 따른 날짜 표현, 날짜 계산 등을 제공하는 Calendar 입니다. (ISO 8601, Korean 등)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ITimePeriodMapper">
      <summary>
            기간의 시작시각, 완료시각에 대해 영역의 포함여부를 조절할 수 있도록 Offset에 대한 처리를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodMapper.MapStart(System.DateTime)">
      <summary>
        <paramref name="moment" />를 StartOffset 을 적용하여 매핑합니다.
            </summary>
      <param name="moment">대상 일자</param>
      <returns>매핑된 일자</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodMapper.MapEnd(System.DateTime)">
      <summary>
        <paramref name="moment" />를 EndOffset 을 적용하여 매핑합니다.
            </summary>
      <param name="moment">대상 일자</param>
      <returns>매핑된 일자</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodMapper.UnmapStart(System.DateTime)">
      <summary>
        <paramref name="moment" />를 StartOffset 적용을 해제합니다.
            </summary>
      <param name="moment">Offset이 적용된 일자</param>
      <returns>Offset 적용을 제거한 일자</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodMapper.UnmapEnd(System.DateTime)">
      <summary>
        <paramref name="moment" />를 EndOffset 적용을 해제합니다.
            </summary>
      <param name="moment">Offset이 적용된 일자</param>
      <returns>Offset 적용을 제거한 일자</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetYear(System.DateTime)">
      <summary>
            지정된 일자의 년
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetMonth(System.DateTime)">
      <summary>
            지정된 일자의 월
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetHour(System.DateTime)">
      <summary>
            지정된 시각의 시간
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetMinute(System.DateTime)">
      <summary>
            지정된 시각의 분
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetDayOfMonth(System.DateTime)">
      <summary>
            지정된 날짜의 월 몇번째 일인지
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetDayOfWeek(System.DateTime)">
      <summary>
            지정된 날짜의 요일
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetDaysInMonth(System.Int32,System.Int32)">
      <summary>
            지정된 년,월의 날짜수
            </summary>
      <param name="year">
      </param>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetYearName(System.Int32)">
      <summary>
            년도 이름
            </summary>
      <param name="year">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetHalfYearName(NSoft.NFramework.TimePeriods.HalfyearKind)">
      <summary>
            반기를 표현하는 문자열을 반환합니다.
            </summary>
      <param name="halfyear">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetHalfYearOfYearName(System.Int32,NSoft.NFramework.TimePeriods.HalfyearKind)">
      <summary>
            지정한 년도의 반기를 표현하는 문자열을 반환합니다.
            </summary>
      <param name="year">
      </param>
      <param name="halfyear">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetQuarterName(NSoft.NFramework.TimePeriods.QuarterKind)">
      <summary>
            분기를 표현하는 문자열을 반환합니다. (2사분기)
            </summary>
      <param name="quarter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetQuarterOfYearName(System.Int32,NSoft.NFramework.TimePeriods.QuarterKind)">
      <summary>
            특정년도의 분기를 표현하는 문자열을 반환합니다. (2011년 2사분기)
            </summary>
      <param name="year">
      </param>
      <param name="quarter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetMonthName(System.Int32)">
      <summary>
            월을 표현하는 문자열을 반환합니다.
            </summary>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetMonthOfYearName(System.Int32,System.Int32)">
      <summary>
            특정 년, 월을 표현하는 문자열을 반환합니다.
            </summary>
      <param name="year">
      </param>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetWeekOfYearName(System.Int32,System.Int32)">
      <summary>
            년,주차를 문자열로 표현합니다.
            </summary>
      <param name="year">
      </param>
      <param name="weekOfYear">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetDayName(System.DayOfWeek)">
      <summary>
            지정한 요일을 문자열로 표현합니다.
            </summary>
      <param name="dayOfWeek">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetWeekOfYear(System.DateTime)">
      <summary>
            지정된 일자의 주차(Week of Year)를 반환합니다. (<see cref="P:NSoft.NFramework.TimePeriods.ITimeCalendar.CalendarWeekRule" />, <see cref="P:NSoft.NFramework.TimePeriods.ITimeCalendar.FirstDayOfWeek" />에 따라 달라집니다)
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeCalendar.GetStartOfYearWeek(System.Int32,System.Int32)">
      <summary>
            지정된 년, 주차에 해당하는 주의 첫번째 일자를 반환한다. (예: 2011년 3주차의 첫번째 일자는?) (<see cref="P:NSoft.NFramework.TimePeriods.ITimeCalendar.CalendarWeekRule" />, <see cref="P:NSoft.NFramework.TimePeriods.ITimeCalendar.FirstDayOfWeek" />에 따라 달라집니다)
            </summary>
      <param name="year">
      </param>
      <param name="weekOfYear">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeCalendar.Culture">
      <summary>
            문화권 정보 (문화권에 따라 달력에 대한 규칙 및 명칭이 달라집니다.)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeCalendar.YearKind">
      <summary>
            년 종류
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeCalendar.StartOffset">
      <summary>
            시작 오프셋 (시작일자가 1월 1일이 아닌 경우) 
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeCalendar.EndOffset">
      <summary>
            종료 오프셋
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeCalendar.YearBaseMonth">
      <summary>
            년의 기준 월 (한국 교육년은 3월, 미국은 9월, 회계년은 2월 등 다양하다)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeCalendar.WeekOfYearRule">
      <summary>
            년의 주차 계산 방식
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeCalendar.CalendarWeekRule">
      <summary>
            Calendar Week Rule
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeCalendar.FirstDayOfWeek">
      <summary>
            한 주의 시작 요일 (한국, 미국: Sunday, ISO-8601: Monday)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ITimeFormatter">
      <summary>
            시간 정보를 여러가지 문자 포맷으로 제공하기 위한 Formatter입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetCollection(System.Int32)">
      <summary>
            컬렉션의 index를 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetCollectionPeriod(System.Int32,System.DateTime,System.DateTime,System.TimeSpan)">
      <summary>
            컬렉션의 기간 정보를 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetDateTime(System.DateTime)">
      <summary>
            지정된 DateTime을 문자열로 표현합니다.
            </summary>
      <param name="dateTime">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetShortDate(System.DateTime)">
      <summary>
            지정된 DateTime을 Short Date 형식으로 문자열을 만듭니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetLongTime(System.DateTime)">
      <summary>
        <paramref name="dateTime" />을 Long Time 형식의 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetShortTime(System.DateTime)">
      <summary>
        <paramref name="dateTime" />을 Short Time 형식의 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetDuration(System.TimeSpan)">
      <summary>
        <paramref name="timeSpan" />을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetDuration(System.TimeSpan,System.Nullable{NSoft.NFramework.TimePeriods.DurationFormatKind})">
      <summary>
        <paramref name="timeSpan" />을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetDuration(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            지정된 기간을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetPeriod(System.DateTime,System.DateTime)">
      <summary>
            시작-완료 시각을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetPeriod(System.DateTime,System.DateTime,System.TimeSpan)">
      <summary>
            시작-완료 | 기간 을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetInterval(System.DateTime,System.DateTime,NSoft.NFramework.TimePeriods.IntervalEdge,NSoft.NFramework.TimePeriods.IntervalEdge,System.TimeSpan)">
      <summary>
            시간 간격을 문자열로 표현합니다.
            </summary>
      <param name="start">
      </param>
      <param name="end">
      </param>
      <param name="startEdge">
      </param>
      <param name="endEdge">
      </param>
      <param name="duration">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetCalendarPeriod(System.String,System.String,System.TimeSpan)">
      <summary>
        <see cref="T:System.Globalization.Calendar" />기준으로 시작-완료 | 기간을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetCalendarPeriod(System.String,System.String,System.String,System.TimeSpan)">
      <summary>
        <see cref="T:System.Globalization.Calendar" />기준으로 시작-완료 | 기간을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeFormatter.GetCalendarPeriod(System.String,System.String,System.String,System.String,System.TimeSpan)">
      <summary>
        <see cref="T:System.Globalization.Calendar" />기준으로 시작-완료 | 기간을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeFormatter.Culture">
      <summary>
            문화권
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeFormatter.ListSeparator">
      <summary>
            목록 구분자
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeFormatter.ContextSeparator">
      <summary>
            요소 구분자
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeFormatter.StartEndSeparator">
      <summary>
            기간의 시작과 완료 시각의 구분자
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeFormatter.DurationSeparator">
      <summary>
            기간(Duration) 구분자
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeFormatter.DateTimeFormat">
      <summary>
            시각 포맷
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeFormatter.ShortDateFormat">
      <summary>
            단순 날짜 포맷
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeFormatter.LongTimeFormat">
      <summary>
            긴 시간 포맷
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeFormatter.ShortTimeFormat">
      <summary>
            짧은 시간 포맷
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeFormatter.DurationKind">
      <summary>
            기간을 문자열로 표현하는 방식
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeFormatter.UseDurationSeconds">
      <summary>
            기간을 초단위로 표시할 것인가?
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ITimeInterval">
      <summary>
            시간 간격을 나타냅니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeInterval.ExpandStartTo(System.DateTime)">
      <summary>
            시작 시각을 지정된 시각으로 변경합니다. 시작 시각 이후가 되면 안됩니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeInterval.ExpandEndTo(System.DateTime)">
      <summary>
            완료 시각을 지정된 시각으로 변경합니다. 완료 시각 이전이 되면 안됩니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeInterval.ExpandTo(System.DateTime)">
      <summary>
            시작 시각과 완료시각을 지정된 시각으로 확장 합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeInterval.ExpandTo(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            시작시각과 완료시각을 지정된 기간 정보를 기준으로 변경합니다.
            </summary>
      <param name="period">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeInterval.ShrinkStartTo(System.DateTime)">
      <summary>
            시작 시각을 지정된 시각으로 변경합니다. 시작시각보다 이후 시각이여야 합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeInterval.ShrinkEndTo(System.DateTime)">
      <summary>
            완료 시각을 지정된 시각으로 당깁니다. 완료시각보다 이전 시각이여야 합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeInterval.ShrinkTo(System.DateTime)">
      <summary>
            시작 시각과 완료시각을 지정된 시각으로 축소 합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeInterval.ShrinkTo(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            기간을 지정한 기간으로 축소시킵니다.
            </summary>
      <param name="period">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimeInterval.Copy(System.TimeSpan)">
      <summary>
            현재 IInterval에서 오프셋만큼 이동한 <see cref="T:NSoft.NFramework.TimePeriods.ITimeInterval" />정보를 반환합니다.
            </summary>
      <param name="offset">이동할 오프셋</param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeInterval.IsStartOpen">
      <summary>
            시작 시각이 열린 구간인가 (즉 StartTime이 지정되지 않았음)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeInterval.IsEndOpen">
      <summary>
            완료 시각이 열린 구간인가 (즉 EndTime이 지정되지 않았음)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeInterval.IsOpen">
      <summary>
            개구간인가? (StartTime, EndTime 모두 설정되어 있지 않을 때)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeInterval.IsStartClosed">
      <summary>
            시작시각이 폐구간인지 여부 (시작 시각이 지정되어 있다)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeInterval.IsEndClosed">
      <summary>
            완료 시각이 폐구간인지 여부 (완료 시각이 지정되어 있다)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeInterval.IsClosed">
      <summary>
            폐구간인가? (StartTime, EndTime 모두 의미있는 값으로 설정되어 있다)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeInterval.IsEmpty">
      <summary>
            빈 간격인가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeInterval.IsDegenerate">
      <summary>
            인터발로 쓸 수 없는 경우 (IsMoment 이면서, IsClosed 인 경우)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeInterval.IsIntervalEnabled">
      <summary>
            사용가능한 시간간격인가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeInterval.StartInterval">
      <summary>
            시작 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeInterval.EndInterval">
      <summary>
            완료 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeInterval.StartEdge">
      <summary>
            시작 시각의 걔/폐구간 종류
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimeInterval.EndEdge">
      <summary>
            완료 시각의 개/폐구간 종류
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ITimePeriodChain">
      <summary>
            ITimePeriod 요소들을 LinkedList 방식으로 연속해서 나열하여 관리하는 컬렉션입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ITimePeriodContainer">
      <summary>
            기간이 존재하는 <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" /> 들을 소유할 수 있는 컨테이너 역할을 수행합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodContainer.ContainsPeriod(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            대상 기간을 포함하고 있는지 검사합니다.
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodContainer.AddAll(System.Collections.Generic.IEnumerable{NSoft.NFramework.TimePeriods.ITimePeriod})">
      <summary>
            기간이 존재하는 (HasPeriod가 true인) <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />들을 추가합니다.
            </summary>
      <param name="periods">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodContainer.SortByStart(NSoft.NFramework.OrderDirection)">
      <summary>
            ITimePeriod 요소들의 Start 속성 값을 기준으로 정렬을 수행합니다.
            </summary>
      <param name="sortDir">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodContainer.SortByEnd(NSoft.NFramework.OrderDirection)">
      <summary>
            ITimePeriod 요소들의 End 속성 값을 기준으로 정렬을 수행합니다.
            </summary>
      <param name="sortDir">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodContainer.SortByDuration(NSoft.NFramework.OrderDirection)">
      <summary>
            ITimePeriod 요소들의 Duration 속성 값을 기준으로 정렬을 수행합니다.
            </summary>
      <param name="sortDir">
      </param>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriodContainer.Start">
      <summary>
            요소 기간 중의 첫 시작 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriodContainer.End">
      <summary>
            요소 기간 중의 마지막 완료 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriodContainer.IsReadOnly">
      <summary>
            읽기 전용 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriodChain.Start">
      <summary>
            Chain의 시작 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriodChain.End">
      <summary>
            Chain의 완료 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriodChain.First">
      <summary>
            첫번째  TimePeriod
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.ITimePeriodChain.Last">
      <summary>
            마지막 TimePeriod
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.ITimePeriodCollection">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" /> 요소들을 컬렉션
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodCollection.HasInsidePeriods(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            대상 TimePeriod 를 포함하는 TimePeriod 요소가 존재하는가?
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodCollection.HasOverlapPeriods(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            대상 TimePeriod와 기간이 겹치는 TimePeriod 요소가 존재하는가?
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodCollection.HasIntersectionPeriods(System.DateTime)">
      <summary>
        <paramref name="moment" /> 을 기간안에 포함하는 TimePeriod 가 존재하는가?
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodCollection.HasIntersectionPeriods(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            대상 TimePeriod와 기간이 교차하는 TimePeriod 요소가 존재하는가?
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodCollection.InsidePeriods(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            대상 TimePeriod 기간을 포함하는 TimePeriod 들을 열거합니다.
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodCollection.OverlapPeriods(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            대상 TimePeriod 기간과 겹치는 TimePeriod 들을 열거합니다.
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodCollection.IntersectionPeriods(System.DateTime)">
      <summary>
        <paramref name="moment" /> 을 기간안에 포함하는 TimePeriod 들을 열거합니다.
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodCollection.IntersectionPeriods(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="target" /> 기간과 교차하는 TimePeriod 들을 열거합니다.
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodCollection.RelationPeriods(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.PeriodRelation)">
      <summary>
            대상 TimePeriod 와 특정 관계를 가지는 TimePeriod 요소들을 열거합니다.
            </summary>
      <param name="target">
      </param>
      <param name="relation">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.ITimePeriodCollection.RelationPeriods(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.PeriodRelation[])">
      <summary>
            대상 TimePeriod 와 특정 관계를 가지는 TimePeriod 요소들을 열거합니다.
            </summary>
      <param name="target">
      </param>
      <param name="relations">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.IYearAndWeekOfYear">
      <summary>
            특정년도와 주차를 표현하는 인터페이스
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.IYearAndWeekOfYear.Year">
      <summary>
            년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.IYearAndWeekOfYear.WeekOfYear">
      <summary>
            주차
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.PeriodContext">
      <summary>
            현재 Thread 하에서 TimePeriod 관련하여 제공할 정보를 제공합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.PeriodContext.Current">
      <summary>
            현 Thread Context 하에서 설정된 TimeCalendar 관련 설정 정보
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.PeriodContext.Current.TimeCalendar">
      <summary>
            현재 Thread Context하에서 사용할 TimeCalendar입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.PeriodContext.Current.Culture">
      <summary>
            현 Thread 하에서 TimePeriod에서 사용할 기본 Culture
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.PeriodContext.Current.WeekOfYearRule">
      <summary>
            현 Thread 하에서 TimePeriod 연산에 사용할 <see cref="T:NSoft.NFramework.TimePeriods.WeekOfYearRuleKind" /></summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.PeriodContext.Current.CalendarWeekRule">
      <summary>
            현 Thread 하에서 한 해의 첫 주를 결정하는 규칙
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.PeriodContext.Current.FirstDayOfWeek">
      <summary>
            현 Thread 하에서 한 주의 첫번째 요일 정보
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.PeriodInvoker">
      <summary>
            특정 반복 주기마다 메소드를 호출해주는 Class입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.PeriodInvoker.Start">
      <summary>
            반복 호출 작업을 시작합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.PeriodInvoker.Stop">
      <summary>
            반복 호출 작업을 취소합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.PeriodInvoker.DoInvokeByPeriodTime(System.String,System.TimeSpan,System.Action{System.Object},System.Threading.CancellationToken)">
      <summary>
            반복 주기에 따라 지정된 Action을 비동기 방식으로 작업을 수행합니다.
            </summary>
      <param name="periodTimeFormat">주기 표현식</param>
      <param name="idleTimeSpan">유휴 시간 간격</param>
      <param name="periodAction">주기 도래시 수행할 델리게이트</param>
      <param name="token">취소시 필요한 토큰</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.PeriodInvoker.DoInvokeByTimeSpan(System.TimeSpan,System.Action{System.Object},System.Threading.CancellationToken)">
      <summary>
            반복 주기에 따라 지정된 Action을 비동기 방식으로 수행하는 작업을 수행합니다.
            </summary>
      <param name="periodTimeSpan">반복 작업 간의 시간 간격</param>
      <param name="periodAction">주기 도래시 수행할 델리게이트</param>
      <param name="token">취소시 필요한 토큰</param>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.PeriodInvoker.IsStarted">
      <summary>
            시작 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.PeriodInvoker.PeriodTimeSpan">
      <summary>
            주기
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.PeriodTimeFormat">
      <summary>
            반복 작업의 주기를 설정하기 위한 방법으로 사용하는 형식을 나타낸다.
            </summary>
      <remarks>
            반복 주기를 나타내는 문자열 형식은 다음과 같다. 첫번째 열부터 분, 시간, 일, 월, 요일 을 나타낸다.<br /><br />
            분 (minute)     : 0 ~ 59<br />
            시 (hour)       : 0 ~ 23<br />
            일 (day of month) : 1 ~ 31<br />
            월 (month)        : 1 ~ 12<br />
            요일 (day of week): 0 ~ 7 (일요일이 0)<br /></remarks>
      <example>
              // 5 * * * *      : 매시 5분에
              // 0,30 * * * *   : 매시 0분, 30분에
              // 0 21 * * * *   : 매일 21시 00분에
              // 0 15,21 * * *  : 매일 15시, 21시에
              // 31 15  * * *   : 매일 15시 31분에
              // 7 4 * * 6      : 토요일 4시 7분에
              // 15 21 4 7 *    : 7월 4일 21시 15분에
            
              // 이것은 아직 하지 않았다.
              // 현재 단위별이 아닌 격주, 격월 등은 'b' 를 접두사로 두면 된다.
              // 0 3 * * b6     : 격주 토요일 3시 0분 마다
            
            // 
            // 매일 0시와 15시에 반복수행하도록 설정, 현재시각에 지정된 작업을 새로 수행해야 할지 검사한다. (True 를 반환하면 새로운 작업 수행, 아니면 필요없다.)
              Console.WriteLine(PeriodTimeFormat.IsExpired("0 0,15 * * *",
                                                           new DateTime(2007, 3, 22, 16, 0, 0),
                                                           new DateTime(2007, 3, 22, 22, 0, 0));
            </example>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.PeriodTimeFormat.IsExpired(System.String,System.DateTime,System.Nullable{System.DateTime})">
      <summary>
            현재 시각이 지정된 주기를 경과했는지 확인합니다.
            </summary>
      <param name="periodFormat">반복 스케쥴 설정을 나타내는 문자열</param>
      <param name="getTime">마지막에 반복한 스케쥴의 시간 (이전 실행 시간)</param>
      <param name="currTime">현재 시각</param>
      <returns>지정된 시간이 경과했으면 True, 아직 경과시간이 안되었으면 False</returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeBlock">
      <summary>
            기준 일자의 시간 간격을 이용하여 기간을 표현합니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeBlock.Anytime">
      <summary>
            기간이 무한대인 TimeBlock
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.op_Explicit(NSoft.NFramework.TimePeriods.TimeBlock)~NSoft.NFramework.TimePeriods.TimeRange">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeRange" /> 인스턴스를 암묵적으로 <see cref="T:NSoft.NFramework.TimePeriods.TimeBlock" /> 형식의 인스턴스로 Casting합니다.
            </summary>
      <param name="block">원본 TimeRange 인스턴스</param>
      <returns>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeBlock" /> 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.op_Explicit(NSoft.NFramework.TimePeriods.TimeBlock)~NSoft.NFramework.TimePeriods.TimeInterval">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeBlock" /> 인스턴스를 명시적으로 <see cref="T:NSoft.NFramework.TimePeriods.TimeInterval" /> 형식의 인스턴스로 Casting합니다.
            </summary>
      <param name="block">원본 TimeBlock 인스턴스</param>
      <returns>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeBlock" /> 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.Copy">
      <summary>
            현 TimeBlock 를 복사합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.Copy(System.TimeSpan)">
      <summary>
            현 TimeBlock에서 오프셋만큼 Shift 한 <see cref="T:NSoft.NFramework.TimePeriods.TimeBlock" /> 반환합니다.
            </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.Setup(System.DateTime,System.TimeSpan)">
      <summary>
            기간 설정
            </summary>
      <param name="newStart">
      </param>
      <param name="duration">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.DurationFromStart(System.TimeSpan)">
      <summary>
            시작시각(<see cref="P:NSoft.NFramework.TimePeriods.ITimeBlock.Start" />)은 고정, 기간(duration)으로 완료시각(<see cref="P:NSoft.NFramework.TimePeriods.ITimeBlock.End" />)를 재설정
            </summary>
      <param name="newDuration">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.DurationFromEnd(System.TimeSpan)">
      <summary>
            완료시각(<see cref="P:NSoft.NFramework.TimePeriods.ITimeBlock.End" />)은 고정 이전 기간(duration)으로 시작시간을 계산하여, 기간으로 재설정
            </summary>
      <param name="newDuration">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.GetPreviousBlock">
      <summary>
            현 TimeBlock의 이전 TimeBlock을 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.GetPreviousBlock(System.TimeSpan)">
      <summary>
            지정된 Offset만큼 기간이 이전 시간으로 이동한 TimeBlock을 반환한다.
            </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.GetNextBlock">
      <summary>
            현재 TimeBlock 이후 TimeBlock을 반환합니다
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.GetNextBlock(System.TimeSpan)">
      <summary>
            지정된 Offset만큼 기간이 이후 시간으로 이동한 TimeBlock을 반환한다.
            </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.GetIntersection(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 겹치는 기간을 반환합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.GetUnion(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 합집합 기간을 반환합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeBlock.AssertValidDuration(System.TimeSpan)">
      <summary>
        <paramref name="duration" />이 유효한 값인지 검사합니다.
            </summary>
      <param name="duration">
      </param>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeBlock.Start">
      <summary>
            기간의 시작 시각. 시작 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MinPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeBlock.End">
      <summary>
            기간의 완료 시각. 완료 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeBlock.Duration">
      <summary>
            기간을 TimeSpan으료 표현, 기간이 정해지지 않았다면 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodDuration" /> 을 반환합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeCalendar">
      <summary>
             문화권에 따른 날짜 표현, 날짜 계산 등을 제공하는 Calendar 입니다. (ISO 8601, Korean 등)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeCalendar.DefaultStartOffset">
      <summary>
            시작 시각에 대한 기본 Offset (<see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.NoDuration" />)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeCalendar.DefaultEndOffset">
      <summary>
            완료 시각에 대한 기본 Offset (<see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MinNegativeDuration" />)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.New">
      <summary>
            기본 환경설정으로 <see cref="T:NSoft.NFramework.TimePeriods.TimeCalendar" />를 생성합니다.
            </summary>
      <returns>TimeCalendar 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.New(System.Globalization.CultureInfo)">
      <summary>
        <paramref name="culture" />를 문화권으로 하는 TimeCalendar를 생성합니다.
            </summary>
      <param name="culture">문화권</param>
      <returns>TimeCalendar 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.New(System.Int32)">
      <summary>
            한해의 시작 월이 <paramref name="yearBaseMonth" />인 TimeCalendar를 생성합니다.
            </summary>
      <param name="yearBaseMonth">한 해의 시작 월</param>
      <returns>TimeCalendar 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.New(System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
      <summary>
            시작 오프셋(<paramref name="startOffset" />), 완료 오프셋(<paramref name="endOffset" />)을 가지는 TimeCalendar를 생성합니다.
            </summary>
      <param name="startOffset">시작 오프셋</param>
      <param name="endOffset">완료 오프셋</param>
      <returns>TimeCalendar 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.New(System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.Int32})">
      <summary>
            TimeCalendar를 생성합니다.
            </summary>
      <param name="startOffset">시작 오프셋</param>
      <param name="endOffset">완료 오프셋</param>
      <param name="yearBaseMonth">한 해의 시작 월</param>
      <returns>TimeCalendar 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.New(System.Globalization.CultureInfo,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
      <summary>
            TimeCalendar를 생성합니다.
            </summary>
      <param name="culture">문화권</param>
      <param name="startOffset">시작 오프셋</param>
      <param name="endOffset">완료 오프셋</param>
      <returns>TimeCalendar</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.New(System.Globalization.CultureInfo,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan},System.Nullable{System.Int32})">
      <summary>
            TimeCalendar를 생성합니다.
            </summary>
      <param name="culture">문화권</param>
      <param name="startOffset">시작 오프셋</param>
      <param name="endOffset">완료 오프셋</param>
      <param name="yearBaseMonth">한 해의 시작 월</param>
      <returns>TimeCalendar 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.New(System.Globalization.CultureInfo,System.Nullable{System.Int32},NSoft.NFramework.TimePeriods.WeekOfYearRuleKind)">
      <summary>
            TimeCalendar를 생성합니다.
            </summary>
      <param name="culture">문화권</param>
      <param name="yearBaseMonth">한 해의 시작 월</param>
      <param name="weekOfYearRule">주차 계산 규칙</param>
      <returns>TimeCalendar 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.New(System.Globalization.CultureInfo,System.Nullable{System.Int32},NSoft.NFramework.TimePeriods.WeekOfYearRuleKind,System.Nullable{System.TimeSpan},System.Nullable{System.TimeSpan})">
      <summary>
            TimeCalendar를 생성합니다.
            </summary>
      <param name="culture">문화권</param>
      <param name="yearBaseMonth">한 해의 시작 월</param>
      <param name="weekOfYearRule">주차 계산 규칙</param>
      <param name="startOffset">시작 오프셋</param>
      <param name="endOffset">완료 오프셋</param>
      <returns>TimeCalendar 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.NewEmptyOffset(System.Int32)">
      <summary>
            시작, 완료 Offset 모두 Zero인 TimeCalendar를 생성합니다.
            </summary>
      <param name="yearBaseMonth">한해의 시작 월</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.NewEmptyOffset(System.Globalization.CultureInfo,System.Int32)">
      <summary>
            시작, 완료 Offset 모두 Zero인 TimeCalendar를 생성합니다.
            </summary>
      <param name="culture">문화권</param>
      <param name="yearBaseMonth">한해의 시작 월</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.#ctor">
      <summary>
            기본 생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.#ctor(NSoft.NFramework.TimePeriods.TimeCalendarConfig)">
      <summary>
            생성자
            </summary>
      <param name="config">TimeCalendar 설정 정보</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.MapStart(System.DateTime)">
      <summary>
        <paramref name="moment" />를 <see cref="P:NSoft.NFramework.TimePeriods.TimeCalendar.StartOffset" />을 적용하여 매핑합니다.
            </summary>
      <param name="moment">대상 일자</param>
      <returns>매핑된 일자</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.MapEnd(System.DateTime)">
      <summary>
        <paramref name="moment" />를 <see cref="P:NSoft.NFramework.TimePeriods.TimeCalendar.EndOffset" />을 적용하여 매핑합니다.
            </summary>
      <param name="moment">대상 일자</param>
      <returns>매핑된 일자</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.UnmapStart(System.DateTime)">
      <summary>
        <paramref name="moment" />를 <see cref="P:NSoft.NFramework.TimePeriods.TimeCalendar.StartOffset" /> 적용을 해제합니다.
            </summary>
      <param name="moment">Offset이 적용된 일자</param>
      <returns>Offset 적용을 제거한 일자</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.UnmapEnd(System.DateTime)">
      <summary>
        <paramref name="moment" />를 <see cref="P:NSoft.NFramework.TimePeriods.TimeCalendar.EndOffset" /> 적용을 해제합니다.
            </summary>
      <param name="moment">Offset이 적용된 일자</param>
      <returns>Offset 적용을 제거한 일자</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetYear(System.DateTime)">
      <summary>
            지정된 일자의 년
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetMonth(System.DateTime)">
      <summary>
            지정된 일자의 월
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetHour(System.DateTime)">
      <summary>
            지정된 시각의 시간
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetMinute(System.DateTime)">
      <summary>
            지정된 시각의 분
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetDayOfMonth(System.DateTime)">
      <summary>
            지정된 날짜의 월 몇번째 일인지
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetDayOfWeek(System.DateTime)">
      <summary>
            지정된 날짜의 요일
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetDaysInMonth(System.Int32,System.Int32)">
      <summary>
            지정된 년,월의 날짜수
            </summary>
      <param name="year">
      </param>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetYearName(System.Int32)">
      <summary>
            년도 이름
            </summary>
      <param name="year">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetHalfYearName(NSoft.NFramework.TimePeriods.HalfyearKind)">
      <summary>
            반기를 표현하는 문자열을 반환합니다.
            </summary>
      <param name="halfyear">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetHalfYearOfYearName(System.Int32,NSoft.NFramework.TimePeriods.HalfyearKind)">
      <summary>
            지정한 년도의 반기를 표현하는 문자열을 반환합니다.
            </summary>
      <param name="year">
      </param>
      <param name="halfyear">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetQuarterName(NSoft.NFramework.TimePeriods.QuarterKind)">
      <summary>
            분기를 표현하는 문자열을 반환합니다. (2사분기)
            </summary>
      <param name="quarter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetQuarterOfYearName(System.Int32,NSoft.NFramework.TimePeriods.QuarterKind)">
      <summary>
            특정년도의 분기를 표현하는 문자열을 반환합니다. (2011년 2사분기)
            </summary>
      <param name="year">
      </param>
      <param name="quarter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetMonthName(System.Int32)">
      <summary>
            지정한 월을 표현하는 문자열을 반환합니다. (예: 1월 | January)
            </summary>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetMonthName(NSoft.NFramework.TimePeriods.MonthKind)">
      <summary>
            월을 표현하는 문자열을 반환합니다. (예: 1월 | January)
            </summary>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetMonthOfYearName(System.Int32,System.Int32)">
      <summary>
            특정 년, 월을 표현하는 문자열을 반환합니다.
            </summary>
      <param name="year">
      </param>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetMonthOfYearName(System.Int32,NSoft.NFramework.TimePeriods.MonthKind)">
      <summary>
            특정 년, 월을 표현하는 문자열을 반환합니다.
            </summary>
      <param name="year">
      </param>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetWeekOfYearName(System.Int32,System.Int32)">
      <summary>
            년,주차를 문자열로 표현합니다.
            </summary>
      <param name="year">
      </param>
      <param name="weekOfYear">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetDayName(System.DayOfWeek)">
      <summary>
            지정한 요일을 문자열로 표현합니다.
            </summary>
      <param name="dayOfWeek">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetWeekOfYear(System.DateTime)">
      <summary>
            지정된 일자의 주차(Week of Year)를 반환합니다. (<see cref="P:NSoft.NFramework.TimePeriods.TimeCalendar.CalendarWeekRule" />, <see cref="P:NSoft.NFramework.TimePeriods.ITimeCalendar.FirstDayOfWeek" />에 따라 달라집니다)
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendar.GetStartOfYearWeek(System.Int32,System.Int32)">
      <summary>
            지정된 년, 주차에 해당하는 주의 첫번째 일자를 반환한다. (예: 2011년 3주차의 첫번째 일자는?) (<see cref="P:NSoft.NFramework.TimePeriods.TimeCalendar.CalendarWeekRule" />, <see cref="P:NSoft.NFramework.TimePeriods.ITimeCalendar.FirstDayOfWeek" />에 따라 달라집니다)
            </summary>
      <param name="year">
      </param>
      <param name="weekOfYear">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendar.Culture">
      <summary>
            문화권 정보 (문화권에 따라 달력에 대한 규칙 및 명칭이 달라집니다.)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendar.YearKind">
      <summary>
            년 종류
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendar.StartOffset">
      <summary>
            시작 오프셋 (시작일자가 1월 1일이 아닌 경우) 
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendar.EndOffset">
      <summary>
            종료 오프셋
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendar.YearBaseMonth">
      <summary>
            년의 기준 월 (한국 교육년은 3월, 미국은 9월, 회계년은 2월 등 다양하다)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendar.WeekOfYearRule">
      <summary>
            년의 주차 계산 방식
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendar.CalendarWeekRule">
      <summary>
            한해의 첫번째 주를 산정하는 방식
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendar.FirstDayOfWeek">
      <summary>
            한 주의 시작 요일 (한국, 미국: Sunday, ISO-8601: Monday)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeCalendarConfig">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeCalendar" />의 설정 정보를 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeCalendarConfig.#ctor(System.Globalization.CultureInfo,NSoft.NFramework.TimePeriods.WeekOfYearRuleKind)">
      <summary>
            생성자
            </summary>
      <param name="culture">문화권</param>
      <param name="weekOfYearRule">주차 산정 룰</param>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendarConfig.Culture">
      <summary>
            날짜를 표현하고, 산정하는데 기준이 되는 문화권 (NULL인 경우에는 Current Culture를 사용합니다)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendarConfig.YearKind">
      <summary>
            년도의 종류 (시스템|회계|교육)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendarConfig.StartOffset">
      <summary>
            Start Time에 대한 Offset (Offset 값에 따라 경계의 포함 여부를 결정짓는다.)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendarConfig.EndOffset">
      <summary>
            End Time에 대한 Offset (Offset 값에 따라 경계의 포함 여부를 결정짓는다.)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendarConfig.YearBaseMonth">
      <summary>
            한해의 시작 월 (기본 1월)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendarConfig.WeekOfYearRule">
      <summary>
            주차 계산을 위한 룰 (Culture 기반| ISO8601 기반)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendarConfig.CalendarWeekRule">
      <summary>
            주차 계산을 위한 룰
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeCalendarConfig.FirstDayOfWeek">
      <summary>
            주의 첫번째 요일 (예: 일요일|월요일)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeFormatter">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />를 문자열로 표현하기 위한 Formatter입니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeFormatter.DefaultContextSeparator">
      <summary>
            객체의 표현식의 구분자(;)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeFormatter.DefaultStartEndSeparator">
      <summary>
            기간의 시작시각과 완료시각의 분리자(~)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeFormatter.DefaultDurationSeparator">
      <summary>
            기간(Duration)의 구분자 (|)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetCollection(System.Int32)">
      <summary>
            컬렉션의 index를 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetCollectionPeriod(System.Int32,System.DateTime,System.DateTime,System.TimeSpan)">
      <summary>
            컬렉션의 기간 정보를 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetDateTime(System.DateTime)">
      <summary>
            지정된 DateTime을 문자열로 표현합니다.
            </summary>
      <param name="dateTime">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetShortDate(System.DateTime)">
      <summary>
            지정된 DateTime을 Short Date 형식으로 문자열을 만듭니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetLongTime(System.DateTime)">
      <summary>
        <paramref name="dateTime" />을 Long Time 형식의 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetShortTime(System.DateTime)">
      <summary>
        <paramref name="dateTime" />을 Short Time 형식의 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetDuration(System.TimeSpan)">
      <summary>
        <paramref name="timeSpan" />을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetDuration(System.TimeSpan,System.Nullable{NSoft.NFramework.TimePeriods.DurationFormatKind})">
      <summary>
        <paramref name="timeSpan" />을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetDuration(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            지정된 기간을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetPeriod(System.DateTime,System.DateTime)">
      <summary>
            시작-완료 시각을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetInterval(System.DateTime,System.DateTime,NSoft.NFramework.TimePeriods.IntervalEdge,NSoft.NFramework.TimePeriods.IntervalEdge,System.TimeSpan)">
      <summary>
            시간 간격을 문자열로 표현합니다.
            </summary>
      <param name="start">
      </param>
      <param name="end">
      </param>
      <param name="startEdge">
      </param>
      <param name="endEdge">
      </param>
      <param name="duration">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetPeriod(System.DateTime,System.DateTime,System.TimeSpan)">
      <summary>
            시작-완료 | 기간 을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetCalendarPeriod(System.String,System.String,System.TimeSpan)">
      <summary>
        <see cref="T:System.Globalization.Calendar" />기준으로 시작-완료 | 기간을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetCalendarPeriod(System.String,System.String,System.String,System.TimeSpan)">
      <summary>
        <see cref="T:System.Globalization.Calendar" />기준으로 시작-완료 | 기간을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeFormatter.GetCalendarPeriod(System.String,System.String,System.String,System.String,System.TimeSpan)">
      <summary>
        <see cref="T:System.Globalization.Calendar" />기준으로 시작-완료 | 기간을 문자열로 표현합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeFormatter.Instance">
      <summary>
            Singleton Instance
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeFormatter.Culture">
      <summary>
            문화권
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeFormatter.ListSeparator">
      <summary>
            목록 구분자
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeFormatter.ContextSeparator">
      <summary>
            요소 구분자
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeFormatter.StartEndSeparator">
      <summary>
            기간의 시작과 완료 시각의 구분자
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeFormatter.DurationSeparator">
      <summary>
            기간(Duration) 구분자
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeFormatter.DateTimeFormat">
      <summary>
            시각 포맷
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeFormatter.ShortDateFormat">
      <summary>
            단순 날짜 포맷
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeFormatter.LongTimeFormat">
      <summary>
            긴 시간 포맷
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeFormatter.ShortTimeFormat">
      <summary>
            짧은 시간 포맷
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeFormatter.DurationKind">
      <summary>
            기간을 문자열로 표현하는 방식
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeFormatter.UseDurationSeconds">
      <summary>
            기간을 초단위로 표시할 것인가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeFormatter.UseIsoIntervalNotation">
      <summary>
            구간에 대한 경계 포함 여부에 대한 표기법을 ISO 표준 표기법을 사용할 것인가?
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeInterval">
      <summary>
            시간 간격을 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.op_Explicit(NSoft.NFramework.TimePeriods.TimeInterval)~NSoft.NFramework.TimePeriods.TimeRange">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeInterval" /> 인스턴스를 명시적으로 <see cref="T:NSoft.NFramework.TimePeriods.TimeRange" /> 형식의 인스턴스로 Casting합니다.
            </summary>
      <param name="interval">원본 TimeInterval 인스턴스</param>
      <returns>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeRange" /> 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.op_Explicit(NSoft.NFramework.TimePeriods.TimeInterval)~NSoft.NFramework.TimePeriods.TimeBlock">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeInterval" /> 인스턴스를 명시적으로 <see cref="T:NSoft.NFramework.TimePeriods.TimeBlock" /> 형식의 인스턴스로 Casting합니다.
            </summary>
      <param name="interval">원본 TimeRange 인스턴스</param>
      <returns>
        <see cref="T:NSoft.NFramework.TimePeriods.TimeBlock" /> 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.Setup(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
      <summary>
            기간을 설정합니다.
            </summary>
      <param name="newStart">설정할 시작 시각</param>
      <param name="newEnd">설정할 완료 시각</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.ExpandStartTo(System.DateTime)">
      <summary>
            시작 시각을 지정된 시각으로 변경합니다. 시작 시각 이후가 되면 안됩니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.ExpandEndTo(System.DateTime)">
      <summary>
            완료 시각을 지정된 시각으로 변경합니다. 완료 시각 이전이 되면 안됩니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.ExpandTo(System.DateTime)">
      <summary>
            시작 시각과 완료시각을 지정된 시각으로 설정합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.ExpandTo(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            시작시각과 완료시각을 지정된 기간 정보를 기준으로 변경합니다.
            </summary>
      <param name="period">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.ShrinkStartTo(System.DateTime)">
      <summary>
            시작 시각을 지정된 시각으로 변경합니다. 시작시각보다 이후 시각이여야 합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.ShrinkEndTo(System.DateTime)">
      <summary>
            완료 시각을 지정된 시각으로 당깁니다. 완료시각보다 이전 시각이여야 합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.ShrinkTo(System.DateTime)">
      <summary>
            시작 시각과 완료시각을 지정된 시각으로 축소 합니다.
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.ShrinkTo(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            기간을 지정한 기간으로 축소시킵니다.
            </summary>
      <param name="period">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.Copy">
      <summary>
            현 인스턴스의 기간을 가진 인스턴스를 새로 생성하여 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.Copy(System.TimeSpan)">
      <summary>
            현재 IInterval에서 오프셋만큼 이동한 <see cref="T:NSoft.NFramework.TimePeriods.ITimeInterval" />정보를 반환합니다.
            </summary>
      <param name="offset">이동할 오프셋</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.Reset">
      <summary>
            Interval을 재설정합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.GetIntersection(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 겹치는 기간을 반환합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimeInterval.GetUnion(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 합집합 기간을 반환합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.IsStartOpen">
      <summary>
            시작 시각이 열린 구간인가 (즉 StartTime이 지정되지 않았음)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.IsEndOpen">
      <summary>
            완료 시각이 열린 구간인가 (즉 EndTime이 지정되지 않았음)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.IsOpen">
      <summary>
            개구간인가? (StartTime, EndTime 모두 설정되어 있지 않을 때)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.IsStartClosed">
      <summary>
            시작시각이 폐구간인지 여부 (시작 시각이 지정되어 있다)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.IsEndClosed">
      <summary>
            완료 시각이 폐구간인지 여부 (완료 시각이 지정되어 있다)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.IsClosed">
      <summary>
            폐구간인가? (StartTime, EndTime 모두 의미있는 값으로 설정되어 있다)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.IsEmpty">
      <summary>
            빈 간격인가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.IsDegenerate">
      <summary>
            인터발로 쓸 수 없는 경우 (IsMoment 이면서, IsClosed 인 경우)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.IsIntervalEnabled">
      <summary>
            사용가능한 시간간격인가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.HasStart">
      <summary>
            시작 시각이 지정되었는가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.StartInterval">
      <summary>
            시작 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.Start">
      <summary>
            기간의 시작 시각. 시작 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MinPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.StartEdge">
      <summary>
            시작 시각의 걔/폐구간 종류
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.HasEnd">
      <summary>
            시작 시각이 지정되었는가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.EndInterval">
      <summary>
            완료 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.End">
      <summary>
            기간의 완료 시각. 완료 시각이 미정인 경우 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodTime" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.EndEdge">
      <summary>
            완료 시각의 개/폐구간 종류
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimeInterval.Duration">
      <summary>
            기간을 TimeSpan으료 표현, 기간이 정해지지 않았다면 <see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodDuration" /> 을 반환합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimePeriodChain">
      <summary>
            ITimePeriod를 시간의 흐름 순으로 Chain (Linked List) 형태로 표현한 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimePeriodContainer">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />를 항목로 가지는 컨테이너를 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.#ctor(System.Collections.Generic.IEnumerable{NSoft.NFramework.TimePeriods.ITimePeriod})">
      <summary>
            생성자
            </summary>
      <param name="periods">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.GetEnumerator">
      <summary>
            컬렉션을 반복하는 열거자를 반환합니다.
            </summary>
      <returns>
            컬렉션을 반복하는 데 사용할 수 있는 <see cref="T:System.Collections.Generic.IEnumerator`1" />입니다.
            </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.Add(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="item" />을 컬렉션의 항목으로 추가합니다.
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.Clear">
      <summary>
            모든 항목을 제거합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.Contains(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="item" />에 해당하는 항목이 들어있는지 검사한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.CopyTo(NSoft.NFramework.TimePeriods.ITimePeriod[],System.Int32)">
      <summary>
            특정 인덱스 (<paramref name="arrayIndex" />) 부터 시작하여 항목들을 <paramref name="array" /> 배열에 복사합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.Remove(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="item" /> 항목을 컬렉션에서 제거합니다.
            </summary>
      <param name="item">제거할 항목</param>
      <returns>제거 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.ContainsPeriod(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            대상 기간을 포함하고 있는지 검사합니다.
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.AddAll(System.Collections.Generic.IEnumerable{NSoft.NFramework.TimePeriods.ITimePeriod})">
      <summary>
            기간이 존재하는 (HasPeriod가 true인) <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />들을 추가합니다.
            </summary>
      <param name="periods">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.SortByStart(NSoft.NFramework.OrderDirection)">
      <summary>
            ITimePeriod 항목들의 Start 속성 값을 기준으로 정렬을 수행합니다.
            </summary>
      <param name="sortDir">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.SortByEnd(NSoft.NFramework.OrderDirection)">
      <summary>
            ITimePeriod 항목들의 End 속성 값을 기준으로 정렬을 수행합니다.
            </summary>
      <param name="sortDir">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.SortByDuration(NSoft.NFramework.OrderDirection)">
      <summary>
            ITimePeriod 항목들의 Duration 속성 값을 기준으로 정렬을 수행합니다.
            </summary>
      <param name="sortDir">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.Setup(System.Nullable{System.DateTime},System.Nullable{System.DateTime})">
      <summary>
            기간을 설정합니다.
            </summary>
      <param name="newStart">
      </param>
      <param name="newEnd">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.Copy(System.TimeSpan)">
      <summary>
            현재 기간에서 오프셋만큼 Shift 한 <see cref="T:NSoft.NFramework.TimePeriods.ITimeRange" />정보를 반환합니다.
            </summary>
      <param name="offset">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.Move(System.TimeSpan)">
      <summary>
            기간을 오프셋만큼 이동
            </summary>
      <param name="offset">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.IsSamePeriod(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간이 같은 기간을 나타내는지 검사합니다
            </summary>
      <param name="other">비교할 대상</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.HasInside(System.DateTime)">
      <summary>
            지정된 시각이 기간에 속하는지 검사합니다.
            </summary>
      <param name="moment">검사할 일자</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.HasInside(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            지정한 기간이 현 기간 내에 속하는지 검사합니다.
            </summary>
      <param name="other">대상 기간</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.IntersectsWith(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            지정한 기간이 현 기간과 겹치는 부분이 있는지 검사합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.OverlapsWith(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            지정한 기간이 현 기간과 겹치는 부분이 있는지 검사합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.Reset">
      <summary>
            Container의 모든 항목을 삭제합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.GetRelation(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            다른 TimePeriod와의 관계를 판단합니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.GetDescription(NSoft.NFramework.TimePeriods.ITimeFormatter)">
      <summary>
            TimePeriod의 설명을 문자열로 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.Format(NSoft.NFramework.TimePeriods.ITimeFormatter)">
      <summary>
        <paramref name="formatter" />로 포맷한 문자열을 반환합니다.
            </summary>
      <param name="formatter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.GetIntersection(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 겹치는 기간을 반환합니다.
            </summary>
      <param name="other">대상 기간</param>
      <returns>겹치는 기간</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.GetUnion(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            두 기간의 합집합 기간을 반환합니다.
            </summary>
      <param name="other">대상기간</param>
      <returns>합집합 기간</returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.IndexOf(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="item" />과 같은 항목의 인덱스를 반환합니다. 없으면 -1 을 반환합니다.
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.Insert(System.Int32,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="item" />을 <paramref name="index" /> 순서에 삽입합니다.
            </summary>
      <param name="index">
      </param>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodContainer.RemoveAt(System.Int32)">
      <summary>
            지정한 인덱스에 해당하는 항목을 제거합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodContainer.Count">
      <summary>
            항목의 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodContainer.IsReadOnly">
      <summary>
            읽기 전용
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodContainer.Start">
      <summary>
            기간의 시작 시각. 시작 시각이 미정인 경우 <see cref="F:System.DateTime.MinValue" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodContainer.End">
      <summary>
            기간의 완료 시각. 완료 시각이 미정인 경우 <see cref="F:System.DateTime.MaxValue" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodContainer.Duration">
      <summary>
            기간을 TimeSpan으료 표현
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodContainer.StartAsNullable">
      <summary>
            기간의 시작 시각. null 인 경우 시작 시각을 정하지 않은 것입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodContainer.EndAsNullable">
      <summary>
            기간의 완료 시각. null인 경우 완료 시각을 정하지 않은 것입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodContainer.HasStart">
      <summary>
            시작 시각이 지정되었는가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodContainer.HasEnd">
      <summary>
            완료 시각이 지정되었는가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodContainer.HasPeriod">
      <summary>
            정해진 기간이 있는지 표시합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodContainer.IsMoment">
      <summary>
            시작 시각과 완료 시각의 값이 같은가? 
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodContainer.IsAnytime">
      <summary>
            시작 시각도 없고, 완료 시각도 없는 구간 (전체 구간)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodContainer.Item(System.Int32)">
      <summary>
            지정한 인덱스에 있는 항목을 가져오거나 설정합니다.
            </summary>
      <returns>
            지정한 인덱스의 항목입니다.
            </returns>
      <param name="index">가져오거나 설정할 항목의 인덱스(0부터 시작)입니다.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" />가 <see cref="T:System.Collections.Generic.IList`1" />의 유효한 인덱스가 아닌 경우</exception>
      <exception cref="T:System.NotSupportedException">속성이 설정되어 있으며 <see cref="T:System.Collections.Generic.IList`1" />가 읽기 전용인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodChain.#ctor">
      <summary>
            기본 생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodChain.#ctor(System.Collections.Generic.IEnumerable{NSoft.NFramework.TimePeriods.ITimePeriod})">
      <summary>
            생성자
            </summary>
      <param name="periods">요소들</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodChain.Add(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            새로운 <paramref name="item" />을 Chain의 제일 끝에 붙여 넣습니다. <paramref name="item" />의 기간이 변경됩니다.
            </summary>
      <param name="item">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodChain.AddAll(System.Collections.Generic.IEnumerable{NSoft.NFramework.TimePeriods.ITimePeriod})">
      <summary>
            기간이 존재하는 (HasPeriod가 true인) <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />들을 추가합니다.
            </summary>
      <param name="periods">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodChain.Insert(System.Int32,NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />의 Chain의 <paramref name="index" />번째에 <paramref name="item" />을 삽입합니다. 선행 Period와 후행 Period의 기간 값이 조정됩니다.
            </summary>
      <param name="index">추가할 위치</param>
      <param name="item">추가할 기간</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodChain.Remove(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            TimePeriodChain에서 요소 <paramref name="item" />을 제거합니다. (제거된 후의 후속 Period들의 시간이 조정됩니다)
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodChain.RemoveAt(System.Int32)">
      <summary>
            TimePeriodChain의 <paramref name="index" /> 번째 요소를 제거합니다.
            </summary>
      <param name="index">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodChain.AssertSpaceBefore(System.DateTime,System.TimeSpan)">
      <summary>
        <paramref name="moment" /> 이전에 <paramref name="duration" /> 만큼의 시간적 공간이 있는지 여부 (새로운 기간을 추가하기 위해서는 공간이 필요합니다)
            </summary>
      <param name="moment">
      </param>
      <param name="duration">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodChain.AssertSpaceAfter(System.DateTime,System.TimeSpan)">
      <summary>
        <paramref name="moment" /> 이후에 <paramref name="duration" /> 만큼의 시간적 공간이 있는지 여부 (새로운 기간을 추가하기 위해서는 공간이 필요합니다)
            </summary>
      <param name="moment">검사할 시각</param>
      <param name="duration">필요한 시간 간격</param>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodChain.Start">
      <summary>
            Chain 범위의 시작 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodChain.End">
      <summary>
            Chain 범위의 완료 시각
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodChain.First">
      <summary>
            Period Chain의 첫번째 TimePeriod (없으면 null 반환)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodChain.Last">
      <summary>
            Period Chain의 마지막 TimePeriod (없으면 null 반환)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodChain.Item(System.Int32)">
      <summary>
            인덱서
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimePeriodCollection">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" />의 컬렉션입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCollection.#ctor">
      <summary>
            기본 생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCollection.#ctor(System.Collections.Generic.IEnumerable{NSoft.NFramework.TimePeriods.ITimePeriod})">
      <summary>
            생성자
            </summary>
      <param name="timePeriods">추가할 요소들</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCollection.HasInsidePeriods(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            대상 TimePeriod 를 포함하는 TimePeriod 요소가 존재하는가?
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCollection.HasOverlapPeriods(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            대상 TimePeriod와 기간이 겹치는 TimePeriod 요소가 존재하는가?
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCollection.HasIntersectionPeriods(System.DateTime)">
      <summary>
        <paramref name="moment" />와 기간이 교차하는 TimePeriod 요소가 존재하는가?
            </summary>
      <param name="moment">대상 일자</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCollection.HasIntersectionPeriods(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="target" /> 기간과 기간이 교차하는 TimePeriod 요소가 존재하는가?
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCollection.InsidePeriods(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="target" /> 기간을 포함하는 TimePeriod 들을 열거합니다.
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCollection.OverlapPeriods(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
        <paramref name="target" /> 기간과 겹치는 TimePeriod 들을 열거합니다.
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCollection.IntersectionPeriods(System.DateTime)">
      <summary>
        <paramref name="moment" /> 을 기간안에 포함하는 TimePeriod 들을 열거합니다.
            </summary>
      <param name="moment">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCollection.IntersectionPeriods(NSoft.NFramework.TimePeriods.ITimePeriod)">
      <summary>
            대상 TimePeriod 기간과 교차하는 TimePeriod 들을 열거합니다.
            </summary>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCollection.RelationPeriods(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.PeriodRelation)">
      <summary>
            대상 TimePeriod 와 특정 관계를 가지는 TimePeriod 요소들을 열거합니다.
            </summary>
      <param name="target">
      </param>
      <param name="relation">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCollection.RelationPeriods(NSoft.NFramework.TimePeriods.ITimePeriod,NSoft.NFramework.TimePeriods.PeriodRelation[])">
      <summary>
            대상 TimePeriod 와 특정 관계를 가지는 TimePeriod 요소들을 열거합니다.
            </summary>
      <param name="target">
      </param>
      <param name="relations">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimePeriodCombiner`1">
      <summary>
        <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriod" /> 기간들을 결합하는 클래스입니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCombiner`1.#ctor">
      <summary>
            기본생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCombiner`1.#ctor(NSoft.NFramework.TimePeriods.ITimePeriodMapper)">
      <summary>
            생성자
            </summary>
      <param name="mapper">시각 Mapper</param>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCombiner`1.CombinePeriods(NSoft.NFramework.TimePeriods.ITimePeriod[])">
      <summary>
        <paramref name="periods" />들을 모아 <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriodCollection" />으로 만듭니다.
            </summary>
      <param name="periods">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.TimePeriods.TimePeriodCombiner`1.CombinePeriods(NSoft.NFramework.TimePeriods.ITimePeriodContainer)">
      <summary>
        <paramref name="periods" />의 기간들을 결합하여, <see cref="T:NSoft.NFramework.TimePeriods.ITimePeriodCollection" />을 생성합니다.
            </summary>
      <param name="periods">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimePeriods.TimePeriodCombiner`1.PeriodMapper">
      <summary>
            시각을 Offset을 이용하여 Map, UnMap을 수행합니다. (<see cref="T:NSoft.NFramework.TimePeriods.TimeCalendar" />)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimePeriods.TimeSpec">
      <summary>
            시간 단위에 대한 상수
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.MonthsPerYear">
      <summary>
            1년의 개월 수 (12)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.HalfyearsPerYear">
      <summary>
            1년의 반기 수 (2)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.QuartersPerYear">
      <summary>
            1년의 분기 수 (4)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.QuartersPerHalfyear">
      <summary>
            반기의 분기 수 (2)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.MonthsPerHalfyear">
      <summary>
            반기의 개월 수 (6)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.MonthsPerQuarter">
      <summary>
            분기의 개월 수 (3)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxWeeksPerYear">
      <summary>
            1년의 최대 주차 (53주)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxDaysPerMonth">
      <summary>
            한달의 최대 일수 (31)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.DaysPerWeek">
      <summary>
            한 주의 일 수 (7)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.HoursPerDay">
      <summary>
            일일의 시간 (24)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.MinutesPerHour">
      <summary>
            단위 시간의 분 (60)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.SecondsPerMinute">
      <summary>
            단위 분의 초 (60)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.MillisecondsPerSecond">
      <summary>
            단위 초의 밀리 초 (1000)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.CalendarYearStartMonth">
      <summary>
            1년의 시작 월 (1)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.WeekDaysPerWeek">
      <summary>
            한 주의 주중 일 수 (5)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.WeekEndsPerWeek">
      <summary>
            한 주의 주말 일 수 (2)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.FirstWorkingDayOfWeek">
      <summary>
            한 주의 첫번째 주중 요일 (월요일)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.FirstQuarterMonth">
      <summary>
            1분기 시작 월 (1월)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.SecondQuarterMonth">
      <summary>
            2분기 시작 월 (4월)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.ThirdQuarterMonth">
      <summary>
            3분기 시작 월 (7월)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.FourthQuarterMonth">
      <summary>
            4분기 시작 월 (10월)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.FirstHalfyearMonths">
      <summary>
            전반기에 속하는 월 (1월~6월)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.SecondHalfyearMonths">
      <summary>
            후반기에 속하는 월 (7월~12월)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.FirstQuarterMonths">
      <summary>
            1분기에 속하는 월 (1월~3월)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.SecondQuarterMonths">
      <summary>
            2분기에 속하는 월 (4월~6월)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.ThirdQuarterMonths">
      <summary>
            3분기에 속하는 월 (7월~9월)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.FourthQuarterMonths">
      <summary>
            4분기에 속하는 월 (10월~12월)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.NoDuration">
      <summary>
            기간 없음 (TimeSpan.Zero)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.EmptyDuration">
      <summary>
            기간 없음 (TimeSpan.Zero)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.MinPositiveDuration">
      <summary>
            양(Positive)의 최소 기간 (TimeSpan(1))
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.MinNegativeDuration">
      <summary>
            음(Negative)의 최소 기간 (TimeSpan(-1))
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.MinPeriodTime">
      <summary>
            최소 기간에 해당하는 일자 (<see cref="F:System.DateTime.MinValue" />)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodTime">
      <summary>
            최대 기간에 해당하는 일자 (<see cref="F:System.DateTime.MaxValue" />)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.MinPeriodDuration">
      <summary>
            최소 기간 (0입니다. 즉 <see cref="F:System.TimeSpan.Zero" />)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodDuration">
      <summary>
            최대 기간 (<see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MaxPeriodTime" />-<see cref="F:NSoft.NFramework.TimePeriods.TimeSpec.MinPeriodTime" />)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Tools.ActivatorTool">
      <summary>
            특정 수형을 생성해주는 Activator
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.ActivatorTool.CreateInstance(System.String,System.Object[])">
      <summary>
            지정된 타입명(클래스 이름)을 가진 클래스에 대해 동적으로 인스턴스를 생성한다.
            </summary>
      <param name="typeName">타입명</param>
      <param name="args">생성자 호출시의 인자들</param>
      <returns>동적으로 생성된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ActivatorTool.CreateInstance(System.String,System.Boolean)">
      <summary>
            지정된 타입명(클래스 이름)을 가진 클래스에 대해 동적으로 기본 생성자를 이용하여 인스턴스를 생성한다.
            </summary>
      <param name="typeName">생성할 객체의 타입명</param>
      <param name="nonPublic">비공용 생성자를 사용할 수 있는지 여부, Singleton 패턴의 경우 기본 생성자가 private이므로 이런 클래스의 생성시에는 nonPublic을 true 로 해주어야 한다.</param>
      <returns>동적으로 생성된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ActivatorTool.CreateInstance(System.Type,System.Reflection.BindingFlags)">
      <summary>
            지정한 타입의 인스턴스를 동적으로 생성한다.
            </summary>
      <param name="type">타입</param>
      <returns>동적으로 생성된 인스턴스</returns>
      <param name="bindingFlags">Binding Flags</param>
    </member>
    <member name="M:NSoft.NFramework.Tools.ActivatorTool.CreateInstance(System.Type,System.Object[])">
      <summary>
            지정한 타입의 인스턴스를 동적으로 생성한다.
            </summary>
      <param name="type">타입</param>
      <param name="args">생성자의 인자값</param>
      <returns>동적으로 생성된 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ActivatorTool.CreateInstance(System.Type,System.Boolean)">
      <summary>
            지정한 타입의 인스턴스를 동적으로 생성한다.
            </summary>
      <param name="type">타입</param>
      <param name="nonPublic">비공용 생성자를 사용할 수 있는지 여부, Singleton 패턴의 경우 기본 생성자가 private이므로 이런 클래스의 생성시에는 nonPublic을 true 로 해주어야 한다.</param>
      <returns>동적으로 생성된 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ActivatorTool.CreateInstance``1">
      <summary>
            Generic을 이용하여 지정된 타입을 기본생성자를 이용하여 동적으로 인스턴스를 생성시킨다.
            </summary>
      <typeparam name="T">생성할 인스턴스의 타입</typeparam>
    </member>
    <member name="M:NSoft.NFramework.Tools.ActivatorTool.CreateInstance``1(System.Object[])">
      <summary>
            지정된 인자를 가지는 생성자를 호출하여 인스턴스를 생성합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="args">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ActivatorTool.CreateInstance``1(System.Reflection.BindingFlags)">
      <summary>
            지정된 인자를 가지는 생성자를 호출하여 인스턴스를 생성합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="bindingFlags">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ActivatorTool.CreateInstance``1(System.Reflection.BindingFlags,System.Object[])">
      <summary>
            지정된 인자를 가지는 생성자를 호출하여 인스턴스를 생성합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="bindingFlags">
      </param>
      <param name="args">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Tools.ArrayTool">
      <summary>
            Utility class for management of array object.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.Compare``1(``0[],``0[])">
      <summary>
            두개의 Array가 같은 값들을 가졌는지 (equivalent) 를 알아본다.
            </summary>
      <remarks>
            요소를 하나하나 비교하므로 너무 느리다. CompareString, CompareBytes, CompareStream을 사용할 것
            </remarks>
      <typeparam name="T">비교할 배열의 수형, IComparable을 구현해야 한다.</typeparam>
      <param name="arr1">비교할 대상</param>
      <param name="arr2">비교할 대상</param>
      <returns>두 인자가 모두 null 이면 false, 두 인자의 배열길이가 다르면 false입니다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.CompareString(System.String,System.String,System.Text.Encoding)">
      <summary>
            HashAlgorithm을 이용하여 긴 문자열 비교를 수행한다.
            </summary>
      <remarks>긴 두 문자열을 비교하기 위해 해쉬값을 계산한 후 두 해쉬값만 비교한다.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.CompareStream(System.IO.Stream,System.IO.Stream)">
      <summary>
            HashAlgorithm을 이용하여 길이가 긴 Stream 들을 비교한다. (성능이 빠르다.)
            </summary>
      <remarks>
            크기가 큰 파일인 경우에는 BufferedStream을 만들어서 비교하면 성능이 빠르다.
            </remarks>
      <returns>둘다 null이면 참, 둘중 하나만 null이면 거짓, 둘의 길이 차이가 있으면 거짓</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.CompareBytes(System.Byte[],System.Byte[])">
      <summary>
            HashAlgorithm을 사용하여 두 배열을 비교한다.
            </summary>
      <param name="a">
      </param>
      <param name="b">
      </param>
      <returns>둘다 null이면 참, 둘중 하나만 null이면 거짓, 둘의 길이 차이가 있으면 거짓</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.EnsureCapacity``1(``0[]@,System.Int32)">
      <summary>
            지정된 배열의 용량을 지정된 최소 용량보다 작을 때에는 지정된 최소용량이나 기존 용량의 두배 크기로 키운다. 
            기존 데이타는 보존된다.
            </summary>
      <typeparam name="T">지정된 배열의 수형</typeparam>
      <param name="array">크기를 조절할 배열</param>
      <param name="minCapacity">최소 용량</param>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.EnsureCapacity``1(``0[]@,System.Int32,System.Int32)">
      <summary>
            지정된 배열의 용량을 지정된 최소 용량보다 작을 때에는 최소용량이나 기본 용량의 두배 크기로 키운다. 
            기존 데이타는 보존된다.
            </summary>
      <typeparam name="T">지정된 배열의 수형</typeparam>
      <param name="array">크기를 조절할 배열</param>
      <param name="minCapacity">최소 용량</param>
      <param name="defaultCapacity">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.Combine``1(``0[],``0[])">
      <summary>
            두개의 배열을 합쳐서 하나의 배열로 만든다.
            </summary>
      <typeparam name="T">지정된 배열의 수형</typeparam>
      <param name="buffer1">
      </param>
      <param name="buffer2">
      </param>
      <returns>두 배열을 합친 새로운 배열</returns>
      <exception cref="T:System.ArgumentNullException">인자가 null 인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.Copy``1(``0[],System.Int32,System.Int32)">
      <summary>
            원본 배열로부터 복사를 수행한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.Copy``1(``0[],``0[])">
      <summary>
        <paramref name="src" /> 정보를 <paramref name="dest" />로 복사한다.
            </summary>
      <typeparam name="T">배열 요소의 수형</typeparam>
      <param name="src">
      </param>
      <param name="dest">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.GetRandomBytes(System.Int32)">
      <summary>
            암호화 모듈 같은데서 사용하기 위해서 지정한 크기의 Random 한 byte 배열을 만든다. 
            </summary>
      <param name="size">랜덤 배열의 크기</param>
      <returns>램덤 값이 채워진 1차원 바이트 배열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.GetRandomBytes(System.Byte[])">
      <summary>
            암호화 모듈 같은데서 사용하기 위해서 Random 한 byte 배열을 만든다. 
            </summary>
      <param name="bytes">Random 값을 채울 바이트 배열</param>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.InitArray``1(``0[],``0)">
      <summary>
            지정된 배열의 모든 요소의 값을 지정된 값으로 설정한다.
            </summary>
      <typeparam name="T">지정된 배열의 수형</typeparam>
      <param name="array">초기화할 배열</param>
      <param name="value">초기화할 값</param>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.AsString``1(``0[])">
      <summary>
            지정된 배열의 모든 요소를 string 형식으로 변환하여 배열을 표현하게 한다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="array">
      </param>
      <returns>배열표현 형식의 문자열</returns>
      <example>
        <code>
                double[] array = new double[] { 100.0, 200.0, 300.0};
                string abc = ArrayTool.AsString(array);
                
                Console.WriteLine(abc);
                // console out is
                // { 100.0, 200.0, 300.0 }
            
                Console.WriteLine(ArrayTool.AsString(null));
                // console out is "null"
            
                Console.WriteLine(ArrayTool.AsString(new object[0]));
                // console out is "{}"
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.Swap``1(``0@,``0@)">
      <summary>
            지정된 두 변수의 값을 교환한다.
            </summary>
      <typeparam name="T">지정된 수형</typeparam>
      <param name="a">
      </param>
      <param name="b">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.IsZeroLengthArray``1(``0[])">
      <summary>
            배열이 null 이거나 zero length 인지 여부를 판단한다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="array">
      </param>
      <returns>배열이 null이거나, 길이가 0이면 true를 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.IndexOf``1(``0[],``0[],System.Int32)">
      <summary>
            대상 배열에서 검색할 값 배열이 존재하는지 찾고, 위치를 반환한다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="array">대상 배열</param>
      <param name="values">검색할 값 배열</param>
      <param name="startIndex">시작 위치</param>
      <returns>검색한 배열 위치, 실패시에는 -1을 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ArrayTool.ByteArrayIndexOf(System.Byte[],System.Byte[],System.Int32,System.Int32)">
      <summary>
            지정된 바이트 배열에서 지정된 값 배열의 위치를 찾는다.
            </summary>
      <param name="array">원본 배열</param>
      <param name="values">찾고자하는 배열</param>
      <param name="startIndex">시작 인덱스</param>
      <param name="count">찾을 범위 - 시작 인덱스로부터 범위</param>
      <returns>찾은 위치</returns>
      <remarks>
            Array.IndexOf 는 한 byte에 대해서는 찾을 수 있지만 찾고자하는 키값이 1차원 배열일 때 이 함수를 사용해야 한다.
            </remarks>
      <example>
            스트링에서 원하는 배열의 스트링을 찾는다.
            <code>
            	public void TestOfByteArrayIndexOf()
            	{
            		const int multiply = 50000;
            		StringBuilder result = new StringBuilder(str.Length * multiply);
            	
            		for(int i=0; i &lt; multiply; i++)
            		{				
            			result.Append(str);
            		}
            		result.Append(s);
            	
            		byte[] buffer = Encoding.Default.GetBytes(result.AsString());
            		byte[] boundary = Encoding.Default.GetBytes(s);
            	
            		PerfCount.Start();
            		
            		int pos = StringTool.ByteArrayIndexOf(buffer, boundary);
            	
            		Console.WriteLine("\n--------------------------");
            		Console.WriteLine("Buffer Size: " + buffer.Length.AsString());
            		Console.WriteLine("Position: " + pos);
            		Console.WriteLine("Search Time: " + PerfCount.End());
            	
            		result = null;
            	}
            </code></example>
    </member>
    <member name="T:NSoft.NFramework.Tools.AssemblyTool">
      <summary>
            Assembly extension methods
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetTitle(System.Reflection.Assembly)">
      <summary>
            get title attribute of assembly.
            </summary>
      <param name="asm">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetDescription(System.Reflection.Assembly)">
      <summary>
            get description of assembly
            </summary>
      <param name="asm">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetCodeBase(System.Reflection.Assembly)">
      <summary>
            get location of assembly file.
            </summary>
      <param name="asm">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetCompany(System.Reflection.Assembly)">
      <summary>
            get company attribute of assembly.
            </summary>
      <param name="asm">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetProduct(System.Reflection.Assembly)">
      <summary>
            get product attribute of assembly.
            </summary>
      <param name="asm">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetCopyright(System.Reflection.Assembly)">
      <summary>
            get copyright attribute of assembly
            </summary>
      <param name="asm">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetCulture(System.Reflection.Assembly)">
      <summary>
            get culture attribute of assembly
            </summary>
      <param name="asm">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetDefaultAlias(System.Reflection.Assembly)">
      <summary>
            get DefaultAlias attribute of assembly
            </summary>
      <param name="asm">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetVersion(System.Reflection.Assembly)">
      <summary>
            Assembly의 버전 정보를 가져옵니다.
            </summary>
      <param name="asm">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetFileVersion(System.Reflection.Assembly)">
      <summary>
            Assembly의 파일버전 정보를 가져옵니다.
            </summary>
      <param name="asm">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetInformationalVersion(System.Reflection.Assembly)">
      <summary>
            Assembly의 정보용 버전 정보를 가져옵니다.
            </summary>
      <param name="asm">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetConfiguration(System.Reflection.Assembly)">
      <summary>
            Assembly의 Configuration 정보를 가져옵니다.
            </summary>
      <param name="asm">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetTrandemark(System.Reflection.Assembly)">
      <summary>
            Assembly에서 Trademark 정보를 가져옵니다.
            </summary>
      <param name="asm">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.AssemblyTool.GetAttribute``1(System.Reflection.Assembly,System.Boolean)">
      <summary>
            Assembly에서 특정 Custom Attribute를 찾습니다. 없으면 null을 반환합니다.
            </summary>
      <typeparam name="T">Custom Attribute의 수형</typeparam>
      <param name="asm">
      </param>
      <param name="inherit">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Tools.BitTool">
      <summary>
            Bit 연산 Method 를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.BitTool.ToText(System.Collections.BitArray)">
      <summary>
            BitArray의 비트 값을 문자열로 표현합니다. 예:01010011
            </summary>
      <param name="bits">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.BitTool.ToBytes(System.Collections.BitArray,System.Int32,System.Int32)">
      <summary>
            BitArray의 Bit 값을 ByteArray로 환산합니다. 이진법을 16진법으로 변경한다는 얘기입니다. (0011 은 0x03)
            </summary>
      <param name="bits">
      </param>
      <param name="startIndex">
      </param>
      <param name="count">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.BitTool.BitOn(System.Int32,System.Int32)">
      <summary>
            value 의 특정 bit를 On 한다.
            </summary>
      <param name="value">대상 값</param>
      <param name="bitToOn">On 시킬 bit의 값</param>
      <returns>bit on value</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.BitTool.BitOff(System.Int32,System.Int32)">
      <summary>
            value 의 특정 bit를 Off 한다.
            </summary>
      <param name="value">대상 값</param>
      <param name="bitToOff">On 시킬 bit의 값</param>
      <returns>bit off value</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.BitTool.BitFlip(System.Int32,System.Int32)">
      <summary>
            value의 특정 bit 를 Flip 시킨다.
            </summary>
      <param name="value">대상 값</param>
      <param name="bitToFlip">Flip 시킬 bit의 값</param>
      <returns>bit flip value</returns>
    </member>
    <member name="T:NSoft.NFramework.Tools.BooleanTool">
      <summary>
            Boolean 값에 대한 Extension Methods 입니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Tools.BooleanTool.YES">
      <summary>
            Yes
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Tools.BooleanTool.NO">
      <summary>
            No
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Tools.BooleanTool.True">
      <summary>
            True
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Tools.BooleanTool.False">
      <summary>
            False
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.BooleanTool.ToYesNo(System.Boolean)">
      <summary>
            Boolean 값을 Yes / No 문자열로 변환한다.
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.BooleanTool.ToTrueFalse(System.Boolean)">
      <summary>
            Boolean 값을 True / False 문자열로 변환한다.
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.BooleanTool.ToInt32(System.Boolean)">
      <summary>
            Boolean 값을 True : 1, False : 0 값으로 반환한다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Tools.CodecTool">
      <summary>
            Encoding/Decoding 함수를 제공하는 Utility Class
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.CodecTool.EncodeBase64(System.Byte[])">
      <summary>
            지정된 데이타를 Base64 인코딩 방식으로 인코딩을 수행한다.
            </summary>
      <param name="data">인코딩할 데이타</param>
      <returns>인코딩된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CodecTool.DecodeBase64(System.String)">
      <summary>
            Base64 형식으로 인코딩된 문자열을 디코딩하여 1차원 바이트 배열로 반환한다.
            </summary>
      <param name="data">Base64로 인코딩된 문자열</param>
      <returns>디코딩된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CodecTool.Md5(System.Byte[])">
      <summary>
            지정된 데이타를 Md5 형식으로 인코딩한다.
            </summary>
      <param name="data">인코딩할 데이타</param>
      <returns>MD5 형식으로 인코딩된 데이타</returns>
      <exception cref="T:System.ArgumentNullException">data 가 null일 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Tools.CodecTool.Md5Hex(System.Byte[])">
      <summary>
            지정된 data를 Md5 형식으로 암호화한 후 16진수(Hex) 포맷으로 문자열을 만든다.
            </summary>
      <param name="data">암호화할 바이트 배열</param>
      <returns>MD5로 암호화된 바이트배열을 알기 쉽게 16진수 (Hex) 포맷으로 문자열을 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CodecTool.Sha1(System.Byte[])">
      <summary>
            지정된 data를 SHA1 형식으로 암호화한다.
            </summary>
      <param name="data">암호화할 데이타</param>
      <returns>SHA1형식으로 암호화된 바이트 배열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CodecTool.Sha1Hex(System.Byte[])">
      <summary>
            지정된 데이타를 SHA1 형식으로 암호화한 다음 알기 쉽게 16진수 포맷인 Hex string으로 반환한다.
            </summary>
      <param name="data">암호화할 데이타</param>
      <returns>암호화한 데이타를 16진수 포맷인 문자열로 반환한다.</returns>
    </member>
    <member name="T:NSoft.NFramework.Tools.CommandLineParser">
      <summary>
            Application의 Command Line 인자에 대한 파서입니다.
            </summary>
      <example>
        <code>
            // 유효 Parameter 형식:
            // {-, /, --}param{ ,=,:}((",')value(",'))
            
            SampleApp.exe -param1 value1 --param2 /params3:"Test-:-work" /param4=happy -param5 '--=nice==='
            </code>
      </example>
    </member>
    <member name="T:NSoft.NFramework.Tools.ConfigTool">
      <summary>
            Application, Web 환경 설정 정보를 제공합니다. 기존 (AppConfig)
            </summary>
      <example>
        <code>
            	string companyName = ConfigTool.GetAppSettings{string}("Company", "RealWeb");
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Tools.ConfigTool.GetAppSettings``1(System.String)">
      <summary>
            app/web configuration에 지정된 key에 해당하는 값을 가져온다. 지정한 키가 없다면 defaultValue를 반환한다.
            </summary>
      <typeparam name="TValue">설정값의 수형</typeparam>
      <param name="key">설정 Key</param>
      <returns>설정 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ConfigTool.GetAppSettings``1(System.String,``0)">
      <summary>
            app/web configuration에 지정된 key에 해당하는 값을 가져온다. 지정한 키가 없다면 defaultValue를 반환한다.
            </summary>
      <typeparam name="TValue">설정값의 수형</typeparam>
      <param name="key">설정 Key</param>
      <param name="defaultValue">기본 설정값</param>
      <returns>설정 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ConfigTool.GetAppSettings``1(System.String,System.Func{``0})">
      <summary>
            환경설정 AppSettings section에 설정된 key에 해당하는 값을 조회합니다. 지정한 키가 없다면, 기본값 생성 함수를 실행하여, 반환합니다.
            </summary>
      <typeparam name="TValue">
      </typeparam>
      <param name="key">
      </param>
      <param name="defaultValueFactory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ConfigTool.HasAppSettings(System.String)">
      <summary>
            지정된 key의 설정이 app/web configuration 파일에 존재하는가?
            </summary>
      <param name="key">설정 Key</param>
      <returns>설정 존재 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ConfigTool.GetAppSettings">
      <summary>
            AppSettings 컬렉션 전체를 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ConfigTool.GetConnectionSettings(System.String)">
      <summary>
            지정된 이름의 <see cref="T:System.Configuration.ConnectionStringSettings" /> 정보를 조회합니다. 
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ConfigTool.HasConnectionSettings(System.String)">
      <summary>
            지정된 이름의 <see cref="T:System.Configuration.ConnectionStringSettings" /> 설정이 있는지 검사한다.
            </summary>
      <param name="name">ConnectionString name</param>
      <returns>존재 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ConfigTool.GetConnectionStringSettingsCollection">
      <summary>
            ConnectionStringSettings 컬렉션을 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ConfigTool.GetConnectionString(System.String)">
      <summary>
            지정된 이름의 ConnectionString 정보를 가져온다.
            </summary>
      <param name="name">ConnectionString name</param>
      <returns>ConnectionString</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ConfigTool.HasConnectionString(System.String)">
      <summary>
            지정된 이름의 ConnectionString 설정이 있는지 검사한다.
            </summary>
      <param name="name">ConnectionString name</param>
      <returns>존재 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ConfigTool.GetDatabaseNames">
      <summary>
            환경설정에 설정된 ConnectionStrings 섹션의 <see cref="T:System.Configuration.ConnectionStringSettings" /> 의 이름을 가져온다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.ConfigTool.GetConnectionStringSettings">
      <summary>
            환경설정에 설정된 ConnectionStrings 섹션의 <see cref="T:System.Configuration.ConnectionStringSettings" /> 을 모두 가져온다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Tools.ConfigTool.IsWebContext">
      <summary>
            웹 Application 환경인지 판단한다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Tools.CultureTool">
      <summary>
        <see cref="T:System.Globalization.CultureInfo" />에 대한 Extension Methods
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.ToString(System.DateTime,System.String)">
      <summary>
            지정된 DateTime 값을 Pattern을 적용하여, 문자열로 반환한다.
            </summary>
      <param name="date">
      </param>
      <param name="dateTimePattern">
      </param>
      <returns>
      </returns>
      <seealso cref="T:System.Globalization.DateTimeFormatInfo" />
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.ToFullDateTimeString(System.DateTime)">
      <summary>
            DateTime 값을 long date, long time 이 모두 들어간 문자열로 변환합니다.
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.ToSortableString(System.DateTime,System.Boolean)">
      <summary>
             DateTime 값을 정렬이 가능한 문자열로 변환합니다. (예: 2009-10-14T13:15:00, 2009-10-14 13:15:00) 
            </summary>
      <param name="date">
      </param>
      <param name="excludeDateTimeSeparator">true면 'T' 자를 없애줍니다.</param>
      <returns>
      </returns>
      <see cref="P:System.Globalization.DateTimeFormatInfo.SortableDateTimePattern" />
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.FromSortableString(System.String)">
      <summary>
            정렬가능한 문자열로 변환된 DateTime을 파싱하여 DateTime으로 다시 변환합니다.
            </summary>
      <param name="dateStr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.ToFileSortableString(System.DateTime)">
      <summary>
            지정한 DateTime 을 정렬가능한 문자열로 표현합니다. (형식: "yyyyMMdd'T'HHmmss")
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.FromFileSortableString(System.String)">
      <summary>
            DateTime을 정렬 가능한 문자열로 표현된 정보를 역으로 DateTime 수형으로 파싱합니다. (형식: "yyyyMMdd'T'HHmmss")
            </summary>
      <param name="dateStr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.ToRFC1123String(System.DateTime)">
      <summary>
            날짜를 RFC1123 형식의 문자열로 반환합니다.	( "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'" )
            </summary>
      <see cref="P:System.Globalization.DateTimeFormatInfo.RFC1123Pattern" />
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.ToMonthDayString(System.DateTime)">
      <summary>
            지정된 문자열을 현재 문화권의 표시 방식으로 월, 일만으로 문자열을 만듭니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.ToYearMonthString(System.DateTime)">
      <summary>
            지정된 문자열을 현재 문화권의 년/월 표시 방식으로 문자열을 만듭니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.ToUniversalSortableDateTimeString(System.DateTime)">
      <summary>
            지정된 문자열을 현재 문화권의 년/월 표시 방식으로 문자열을 만듭니다. (예: 2009-10-14 13:15:00Z) 마지막에 'Z' 가 붙는다
            </summary>
      <see cref="P:System.Globalization.DateTimeFormatInfo.UniversalSortableDateTimePattern" />
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.GetAbbreviatedDayName(System.DateTime)">
      <summary>
            일자의 요일명의 축약어를 반환한다.
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.GetDayName(System.DateTime)">
      <summary>
            현재 문화권에 해당하는 요일명을 가져온다.
            </summary>
      <param name="date">
      </param>
      <returns>현재 문화권의 요일명 (예: 월, 화 .. Monday...)</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.GetShortestDayName(System.DateTime)">
      <summary>
            지정된 일자의 최대 축약 요일명을 가져옵니다. 
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.GetAbbreivatedMonthName(System.DateTime)">
      <summary>
            현재 문화권에서의 월의 이름의 축약어를 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.GetAbbreivatedMonthName(System.Int32)">
      <summary>
            현재 문화권에서의 월의 이름의 축약어를 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.GetMonthName(System.DateTime)">
      <summary>
            지정된 일자의 월의 이름을 반환한다.
            </summary>
      <param name="date">Month Name을 얻고자하는 일자</param>
      <returns>현재 문화권에서의 Month Name</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.GetMonthName(System.Int32)">
      <summary>
            지정된 일자의 월의 이름을 반환한다.
            </summary>
      <param name="month">월 (1 ~ 12)</param>
      <returns>현재 문화권에서의 Month Name</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.IsNullCulture(System.Globalization.CultureInfo)">
      <summary>
            지정된 Culture 객체가 null 이거나 Name 속성 값이 빈문자열이라면 참을 반환한다.
            </summary>
      <param name="culture">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.GetOrCurrentUICulture(System.Globalization.CultureInfo)">
      <summary>
            지정된 Culture가 null이라면 <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" />를 반환한다.
            </summary>
      <param name="culture">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.GetOrCurrentCulture(System.Globalization.CultureInfo)">
      <summary>
            지정된 Culture가 null이라면 <see cref="P:System.Globalization.CultureInfo.CurrentCulture" />를 반환한다.
            </summary>
      <param name="culture">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.GetOrInvaliant(System.Globalization.CultureInfo)">
      <summary>
            지정된 Culture가 null이라면 <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />를 반환한다.
            </summary>
      <param name="culture">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.CultureTool.GetCulture(System.Globalization.CultureInfo,System.Globalization.CultureInfo)">
      <summary>
            지정된 Culture가 null이라면, 지정된 <paramref name="defaultCulture" />를 반환한다.
            </summary>
      <param name="culture">
      </param>
      <param name="defaultCulture">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Tools.CultureTool.CurrentCalendar">
      <summary>
            현재 문화권의 <see cref="T:System.Globalization.Calendar" /> 정보입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Tools.CultureTool.CurrentDateFormat">
      <summary>
            현재 문화권의 <see cref="T:System.Globalization.DateTimeFormatInfo" /> 입니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Tools.DateTool.UnixEpoch">
      <summary>
            Timestamp 값이 1970-01-01 부터의 Tick 값을 표현한 것이다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartMonthOfQuarter(NSoft.NFramework.Quarters)">
      <summary>
            해당 분기의 시작월
            </summary>
      <param name="quarter">해당 분기</param>
      <returns>해당분기의 시작월</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndMonthOfQuarter(NSoft.NFramework.Quarters)">
      <summary>
            해당 분기의 마지막 월
            </summary>
      <param name="quarter">해당 분기</param>
      <returns>해당 분기의 마지막 월</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfQuarter(NSoft.NFramework.Quarters)">
      <summary>
            현재 분기 첫번째 일자(<see cref="T:System.DateTime" /></summary>
      <param name="quarter">해당 분기</param>
      <returns>특정 분기의 첫번째 DateTime <see cref="T:System.DateTime" /> (2007-04-01 00:00:00:000)</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfQuarter(NSoft.NFramework.Quarters,System.Int32)">
      <summary>
            해당 년도의 분기 첫번째 일자(<see cref="T:System.DateTime" /></summary>
      <param name="year">해당 년도</param>
      <param name="quarter">해당 분기</param>
      <returns>특정 분기의 첫번째 DateTime <see cref="T:System.DateTime" /> (2007-04-01 00:00:00:000)</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfQuarter(NSoft.NFramework.Quarters)">
      <summary>
            현재 년도의 지정된 분기의 마지막 시각 (3월 31일 23:59:59:999)
            </summary>
      <param name="quarter">quarter</param>
      <returns>해당 분기의 마지막 <see cref="T:System.DateTime" /> (2007-03-31 23:59:59:999)</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfQuarter(NSoft.NFramework.Quarters,System.Int32)">
      <summary>
            해당년도의 해당 분기 마지막 시각 (3월 31일 23:59:59:999)
            </summary>
      <param name="quarter">quarter</param>
      <param name="year">year</param>
      <returns>해당 분기의 마지막 <see cref="T:System.DateTime" /> (2007-03-31 23:59:59:999)</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetQuarter(System.Int32)">
      <summary>
            지정된 월이 속한 분기
            </summary>
      <param name="month">조회할 월</param>
      <returns>월이 속한 분기</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetQuarter(System.DateTime)">
      <summary>
            지정된 날짜의 분기를 구한다.
            </summary>
      <param name="date">날짜</param>
      <returns>날짜가 속한 분기</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetLastQuarter">
      <summary>
            현재 날짜 기준의 분기 바로 전의 분기를 구한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetLastQuarter(System.DateTime)">
      <summary>
            지정된 날짜의 분기의 앞의 분기를 구한다.
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfLastquarter">
      <summary>
            전(前) 분기의 시작 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfLastquarter">
      <summary>
            전(前) 분기의 마지막 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfCurrentQuarter">
      <summary>
            현재 분기의 시작 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfCurrentQuarter">
      <summary>
            현재 분기의 마지막 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfLastWeek">
      <summary>
            전(前) 주(week)의 시작 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfLastWeek">
      <summary>
            전(前) 주의 마지막 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfCurrentWeek">
      <summary>
            금주의 시작 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfCurrentWeek">
      <summary>
            금주의 마지막 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfWeek(System.DateTime)">
      <summary>
            지정된 날짜가 속한 주(week)의 첫번째 요일 (한국:일요일, ISO8601:월요일)의 날짜
            </summary>
      <param name="time">일자</param>
      <returns>지정된 일자가 속한 주의 첫번째 요일의 일자를 반환한다. 문화권에 따라 한주의 첫번째 요일은 다르다. 한국은 Sunday, ISO 9601로는 Monday이다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfWeek(System.DateTime,System.DayOfWeek)">
      <summary>
            지정된 날짜가 속한 주(week)의 첫번째 요일 (일요일)의 날짜
            </summary>
      <param name="time">일자</param>
      <param name="firstDayOfWeek">한 주의 첫번째 요일</param>
      <returns>지정된 일자가 속한 주의 첫번째 요일의 일자를 반환한다. 문화권에 따라 한주의 첫번째 요일은 다르다. 한국은 Sunday, ISO 9601로는 Monday이다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfWeek(System.DateTime)">
      <summary>
            지정된 날짜가 속한 주(week)의 마지막 날짜 (한국:토요일, ISO8601:일요일)
            </summary>
      <param name="time">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfWeek(System.DateTime,System.DayOfWeek)">
      <summary>
            지정된 날짜가 속한 주(week)의 마지막 날짜 (한국:토요일, ISO8601:일요일)
            </summary>
      <param name="time">
      </param>
      <param name="firstDayOfWeek">한 주의 첫번째 요일</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfMonth(System.DateTime)">
      <summary>
            지정된 일자가 속한 월의 시작일자
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfMonth(System.Int32,System.Int32)">
      <summary>
            해당 년, 월의 시작 시각
            </summary>
      <param name="year">
      </param>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfMonth(System.DateTime)">
      <summary>
            지정된 날짜가 속한 월의 마지막 시각
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfMonth(System.Int32,System.Int32)">
      <summary>
            해당 년, 월의 마지막 시각
            </summary>
      <param name="year">
      </param>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfLastMonth">
      <summary>
            전(前)월의 시작 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfLastMonth">
      <summary>
            전(前)월의 마지막 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfCurrentMonth">
      <summary>
            금월의 시작 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfCurrentMonth">
      <summary>
            금월의 마지막 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetHalfYear(System.DateTime)">
      <summary>
            일자의 반기를 반환합니다. (전반기 : 1, 후반기 : 2)
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfHalfYear(System.DateTime)">
      <summary>
            반기의 시작일자를 구한다. N년 1월1일, N년 7월 1일
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfHalfYear(System.DateTime)">
      <summary>
            반기의 마지막 일자를 구한다. N년 6월30일, N년 12월 31일
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfYear(System.Int32)">
      <summary>
            지정된 년도의 시작 시각
            </summary>
      <param name="year">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfYear(System.Int32)">
      <summary>
            지정된 년도의 마지막 시각
            </summary>
      <param name="year">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfLastYear">
      <summary>
            전년도 시작 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfLastYear">
      <summary>
            전년도 마지막 시각
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfYear(System.DateTime)">
      <summary>
            지정된 날짜에 해당하는 년도의 첫번째 일자
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfYear(System.DateTime)">
      <summary>
            지정된 날짜에 해당하는 년도의 마지막 일자
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfCurrentYear">
      <summary>
            이번 년도의 첫번째 일자
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfCurrentYear">
      <summary>
            이변년도의 마지막 일자
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetStartOfDay(System.DateTime)">
      <summary>
            지정된 날짜의 시작 시각 (시간 파트가 0 이다.)
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.GetEndOfDay(System.DateTime)">
      <summary>
            지정된 날짜의 마지막 시각
            </summary>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.NextDayOfWeek(System.DateTime,System.DayOfWeek)">
      <summary>
            현재날짜로부터 가장 가까운 지정된 요일을 반환한다.
            </summary>
      <param name="current">
      </param>
      <param name="dow">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.PrevDayOfWeek(System.DateTime,System.DayOfWeek)">
      <summary>
            현재날짜로 지난 날짜 중에 가장 가까운 지정된 요일을 반환한다.
            </summary>
      <param name="current">
      </param>
      <param name="dow">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetDate(System.DateTime,System.Int32,System.Int32,System.Int32)">
      <summary>
            지정된 날짜의 년, 월, 일을 새로 설정한다. Time Part는 그대로
            </summary>
      <param name="date">
      </param>
      <param name="year">
      </param>
      <param name="month">
      </param>
      <param name="day">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetDate(System.DateTime,System.Int32,System.Int32)">
      <summary>
            지정된 날짜의 년, 월을 새로 설정한다. 일, Time Part는 그대로
            </summary>
      <param name="date">
      </param>
      <param name="year">
      </param>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetDate(System.DateTime,System.Int32)">
      <summary>
            DateTime의 년도만 지정된 년도로 설정한다.
            </summary>
      <param name="date">
      </param>
      <param name="year">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetYear(System.DateTime,System.Int32)">
      <summary>
            DateTime의 년도를 지정된 값으로 설정한다.
            </summary>
      <param name="date">
      </param>
      <param name="year">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetMonth(System.DateTime,System.Int32)">
      <summary>
            DateTime의 월만 지정된 월로 바꾼다.
            </summary>
      <param name="date">
      </param>
      <param name="month">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetDay(System.DateTime,System.Int32)">
      <summary>
            DateTime의 일만 지정된 일로 바꾼다.
            </summary>
      <param name="date">
      </param>
      <param name="day">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.Combine(System.DateTime,System.DateTime)">
      <summary>
            Date Part와 TimePart를 합한다.
            </summary>
      <param name="datePart">Date 정보만</param>
      <param name="timePart">Time 정보만</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetTime(System.DateTime,System.Int32)">
      <summary>
            지정된 날짜의 시간 파트를 설정한다.
            </summary>
      <param name="date">
      </param>
      <param name="hour">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetTime(System.DateTime,System.Int32,System.Int32)">
      <summary>
            지정된 날짜의 시간 파트를 설정한다.
            </summary>
      <param name="date">
      </param>
      <param name="hour">
      </param>
      <param name="minute">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetTime(System.DateTime,System.Int32,System.Int32,System.Int32)">
      <summary>
            지정된 날짜의 시간 파트를 설정한다.
            </summary>
      <param name="date">
      </param>
      <param name="hour">
      </param>
      <param name="minute">
      </param>
      <param name="second">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetTime(System.DateTime,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            날짜의 시간 파트를 설정한다.
            </summary>
      <param name="date">설정할 DateTime</param>
      <param name="hour">시</param>
      <param name="minute">분</param>
      <param name="second">초</param>
      <param name="millisecond">밀리초</param>
      <returns>설정된 DateTime</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetHour(System.DateTime,System.Int32)">
      <summary>
            날짜의 시간을 설정한다.
            </summary>
      <param name="date">대상 DateTime</param>
      <param name="hour">시</param>
      <returns>설정된 DateTime</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetMinute(System.DateTime,System.Int32)">
      <summary>
            날짜의 분을 설정한다.
            </summary>
      <param name="date">대상 DateTime</param>
      <param name="minute">분</param>
      <returns>설정된 DateTime</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetSecond(System.DateTime,System.Int32)">
      <summary>
             날짜의 초을 설정한다.
            </summary>
      <param name="date">대상 DateTime</param>
      <param name="second">초</param>
      <returns>설정된 DateTime</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.SetMillisecond(System.DateTime,System.Int32)">
      <summary>
            날짜의 밀리초을 설정한다.
            </summary>
      <param name="date">대상 DateTime</param>
      <param name="millisecond">밀리초</param>
      <returns>설정된 DateTime</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.Noon(System.DateTime)">
      <summary>
            지정된 날짜의 정오를 가르키는 시간을 만든다.
            </summary>
      <param name="date">기준 DateTime</param>
      <returns>지정된 날짜의 정오를 가르키는 DateTime</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.ToDateTime(System.String,System.DateTime)">
      <summary>
            DateTime 형식으로 변환한다.
            </summary>
      <param name="value">날짜를 나타내는 문자열</param>
      <param name="defaultValue">변환 실패시의 기본값</param>
      <returns>변환된 DateTime 인스턴스 개체</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.ToDateTime(System.String)">
      <summary>
            DateTime 형식으로 변환한다. 실패시에는 new DateTime(0) 를 반환한다.
            </summary>
      <param name="value">날짜를 나타내는 문자열</param>
      <returns>변환된 DateTime 인스턴스 개체, 실패시에는 Ticks가 0인 DateTime을 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.Weeks(System.Int32)">
      <summary>
            지정된 week 수만큼의 TimeSpan을 구한다.
            </summary>
      <param name="weeks">TimeSpan값을 구할 week 수</param>
      <returns>지정된 week 만큼의 TimeSpan</returns>
      <example>
        <code>
            	// 1주일 (7일 = 7 * 24 Hour) 기간의 TimeSpan
            	TimeSpan ts = 1.Weeks();
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.Days(System.Int32)">
      <summary>
             지정된 Day 만큼의 TimeSpan을 구한다.
            </summary>
      <param name="days">TimeSpan을 구할 Day값</param>
      <returns>지정된 Day만큼의 TimeSpan</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.Hours(System.Int32)">
      <summary>
            지정된 시간에 대한 TimeSpan
            </summary>
      <param name="hours">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.Minutes(System.Int32)">
      <summary>
            지정된 분에 대한 TimeSpan
            </summary>
      <param name="minutes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.Seconds(System.Int32)">
      <summary>
            지정된 초에 대한 TimeSpan
            </summary>
      <param name="seconds">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.Milliseconds(System.Int32)">
      <summary>
            지정된 Millisecond 에 대한 TimeSpan
            </summary>
      <param name="milliseconds">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.Ago(System.TimeSpan,System.DateTime)">
      <summary>
            지정된 일자에 TimeSpan을 뺀 날자를 반환한다.
            </summary>
      <param name="from">
      </param>
      <param name="date">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.From(System.TimeSpan,System.DateTime)">
      <summary>
            지정된 일자에 TimeSpan을 더한 날짜를 반환한다.
            </summary>
      <param name="from">더할 TimeSpan</param>
      <param name="date">대상 DateTime</param>
      <returns>날짜에 TimeSpan을 더한 날짜</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.FromNow(System.TimeSpan)">
      <summary>
            현재 날짜에 지정된 TimeSpan을 더한 날짜를 반환한다.
            </summary>
      <param name="from">더할 TimeSpan</param>
      <returns>현재 날짜에 TimeSpan을 더한 날짜</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.Since(System.TimeSpan,System.DateTime)">
      <summary>
            지정된 일자에 TimeSpan을 더한 날짜를 반환한다. <see cref="M:NSoft.NFramework.Tools.DateTool.From(System.TimeSpan,System.DateTime)" />과 같다.
            </summary>
      <param name="from">더할 TimeSpan</param>
      <param name="date">대상 DateTime</param>
      <returns>날짜에 TimeSpan을 더한 날짜</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DateTool.ToSqlPrecision(System.DateTime)">
      <summary>
            .NET DateTime 을 SQL Server DateTime 수형의 정밀도로 표현합니다. (SQL Server의 DateTime의 정밀도가 좀 낮다)
            </summary>
      <param name="dt">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Tools.DictionaryTool">
      <summary>
            Utility class for IDictionary{T,V}
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.DictionaryTool.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
      <summary>
            Dictionary의 지정된 키에 해당하는 값을 반환한다. 지정된 키가 없다면, 예외가 발생한다.
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DictionaryTool.GetValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
      <summary>
            Dictionary의 지정된 키에 해당하는 값을 반환한다. 해당 키가 없다면, 기본 값을 반환한다. 
            </summary>
      <typeparam name="TKey">Type of key of dictionary</typeparam>
      <typeparam name="TValue">Type of value of dictionary</typeparam>
      <param name="dictionary">dictionary</param>
      <param name="key">key to retrieve value</param>
      <param name="defval">default value</param>
      <returns>value matched the specified key, if key does not exists, return defval</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DictionaryTool.AddValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
      <summary>
            Dictionary에 값을 추가합니다. Key가 있다면, 값을 대체하고, Key가 없다면 추가합니다.
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="key">
      </param>
      <param name="value">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Tools.DictionaryTool.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
      <summary>
            Dictionary에서 지정한 키에 해당하는 값을 가져옵니다. 만약 없다면, <paramref name="valueFactory" />로 값을 등록한 후 반환합니다.
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="key">
      </param>
      <param name="valueFactory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DictionaryTool.SetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Action{``1})">
      <summary>
            Dictionary에 지정한 키에 해당하는 값을 찾아서, <paramref name="valuePropertySetter" />로 값을 변경합니다.
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="key">
      </param>
      <param name="valuePropertySetter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DictionaryTool.SetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1},System.Action{``1})">
      <summary>
            Dictionary에 지정한 키에 해당하는 값을 찾아서, <paramref name="valuePropertySetter" />로 값을 변경합니다.
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="dictionary">
      </param>
      <param name="key">
      </param>
      <param name="valueFactory">
      </param>
      <param name="valuePropertySetter">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DictionaryTool.AsString(System.Collections.IDictionary)">
      <summary>
            지정된 Dictionary 정보를 문자열로 표현합니다. (거의 JSON 포맷과 같습니다!!!)
            </summary>
      <param name="dictionary">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.DictionaryTool.AsString``2(System.Collections.Generic.IDictionary{``0,``1})">
      <summary>
            지정된 Dictionary 정보를 문자열로 표현합니다.
            </summary>
      <typeparam name="TKey">
      </typeparam>
      <typeparam name="TValue">
      </typeparam>
      <param name="dictionary">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Tools.EnumTool">
      <summary>
            Enum 관련 Helper Class
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.EnumTool.GetEnumValues``1">
      <summary>
            지정된 Enum 수형의 모든 Enum값을 반환한다.
            </summary>
      <typeparam name="T">Enum 수형</typeparam>
      <returns>Enum 수형의 모든 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.EnumTool.GetEnumValues(System.Object)">
      <summary>
            지정된 Enum 값의 Enum 수형의 모든 Enum 값을 반환한다.
            </summary>
      <param name="enumValue">Enum 값</param>
      <returns>모든 Enum 값</returns>
    </member>
    <!-- Badly formed XML comment ignored for member "T:NSoft.NFramework.Tools.GuidTool" -->
    <member name="M:NSoft.NFramework.Tools.GuidTool.NewComb">
      <summary>
            Guid.Comb 스타일의 Guid 값을 생성합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.GuidTool.NewSequentialGuid">
      <summary>
            SQL Server 2005 처럼 순차적인 Guid를 생성한다.
            </summary>
      <returns>생성된 Guid 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.GuidTool.NewSequentialGuid(System.Int32)">
      <summary>
            SQL Server 처럼 순차적인 Guid 값을 지정된 갯수만큼 생성한다.
            </summary>
      <param name="count">생성할 순차 Guid 의 갯수</param>
      <returns>생성된 Guid의 배열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.GuidTool.AsEnumerable(System.Int32)">
      <summary>
            SQL Server 처럼 순차적인 Guid 값을 지정된 갯수만큼 생성합니다.
            </summary>
      <param name="count">생성할 Guid 인스턴스 갯수</param>
      <returns>생성한 Guid 인스턴스의 컬렉션</returns>
    </member>
    <member name="T:NSoft.NFramework.Tools.HexTextTool">
      <summary>
            16진수 문자열에 대한 변환을 수행하는 Helper Class 입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.HexTextTool.GetBytesFromHexString(System.String)">
      <summary>
            16진수를 표현한 문자열을 byte 배열로 변환한다.
            </summary>
      <example>
        <code>
                byte[] byte = RwHexText.GetBytesFromHexString("D3B5DA375E350B9A1EAF");
            </code>
      </example>
      <param name="hexString">16진수 포맷의 문자열</param>
      <returns>파싱된 바이트 배열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.HexTextTool.GetBytesFromHexString(System.String,System.String)">
      <summary>
            16진수 byte 배열을 BitConverter를 통해서 변환된 문자열은 '-' 를 구분자로 하고 있으므로
            다시 byte 배열로 바꿀 때에는 구분자로 '-' 를 주어야 한다.
            </summary>
      <param name="hexString">16진수 형식의 문자열</param>
      <param name="delimiter">바이트문자열 구분자</param>
      <returns>파싱된 바이트 배열</returns>
      <example>
        <code>
                byte[] byte = HexTextTool.GetBytesFromHexString("D3B5DA375E350B9A1EAF");
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Tools.HexTextTool.GetHexStringFromBytes(System.Byte[],System.String)">
      <summary>
            Byte 배열을 Hex 형식의 string으로 변환한다.
            </summary>
      <remarks>byte.AsString("X2") 를 사용한다.</remarks>
      <param name="bytes">바이트 배열</param>
      <param name="delimiter">구분자</param>
      <returns>16진수 형식의 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.HexTextTool.GetHexDumpString(System.IO.Stream)">
      <summary>
            Stream 객체를 Hex Code로 Dump해서 문자열로 만든다.
            Ultra Edit의 Hex Code Editor에 나타내는 것 처럼
            </summary>
      <param name="stream">원본 데이타</param>
      <returns>
            야래와 같은 형식의 문자열을 반환한다.<br />
            LINE####: XX XX XX XX  XX XX XX XX  XX XX XX XX  XX XX XX XX  CCCCCCCCCCCCCCCC
            </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.HexTextTool.GetHexDumpString(System.Byte[])">
      <summary>
            바이트 배열을 받아 Hex Code로 Dump해서 문자열로 만든다.
            Ultra Edit의 Hex Code Editor에 나타내는 것 처럼
            </summary>
      <param name="data">원본 데이타</param>
      <returns>
            야래와 같은 형식의 문자열을 반환한다.<br />
            LINE####: XX XX XX XX  XX XX XX XX  XX XX XX XX  XX XX XX XX  CCCCCCCCCCCCCCCC
            </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.HexTextTool.IntToHex(System.Int32)">
      <summary>
            지정한 Integer 값을 해당 character로 변경합니다. 예: 6 =&gt; '6', 12 =&gt; 'c'  로
            </summary>
      <param name="n">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.HexTextTool.HexToInt(System.Char)">
      <summary>
            char 를 int 수형으로 변환한다. ('a' =&gt; 10, '8' =&gt; 8)
            </summary>
      <param name="h">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Tools.MimetypeTool">
      <summary>
            특정 파일 형식의 Content Type 을 나태내는 MIME에 대한 정보를 제공합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.MimetypeTool.GetMime(System.String)">
      <summary>
            지정된 파일명의 MIME Type을 구합니다.
            </summary>
      <param name="filename">파일명이나 extensions (예: png)</param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Tools.ResourceTool">
      <summary>
            리소스 조회를 위한 Tool 클래스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.ResourceTool.GetEmbeddedResourceFile(System.Reflection.Assembly,System.String)">
      <summary>
            지정된 Assembly에 포함된 리소스 파일의 정보를 반환한다.
            참고 : http://www.attilan.com/2006/08/accessing_embedded_resources_u.php
            http://msdn.microsoft.com/en-us/library/ht9h2dk8.aspx
            </summary>
      <param name="assembly">리소스를 읽어올 Assembly</param>
      <param name="filename">리소스로 포함된 파일의 이름 (실제로는 NameSpace까지 줘야하지만, 파일명만 주면, 첫번째 리소스 파일을 반환한다.</param>
      <returns>파일 내용을 담은 Stream, 리소스 파일이 없을 경우는 null을 반환한다.</returns>
      <example>
        <code>
            	var asm = ReflectionTool.LoadAssembly("NSoft.NFramework.FusionCharts.dll");
            	var swf = asm.GetEmbeddedResourceFile("line.swf");					// 실제 리소스 파일명은 NSoft.NFramework.FusionCharts.Resources.Line.swf 이다.
                Assert.IsNotNull(swf);
                
            	// 여러군데 같은 파일명이 있을 경우 최소한의 Namespace로 구분할 수 있으면 된다.
            	var swf = asm.GetEmbeddedResourceFile("Resources.line.swf");
            </code>
      </example>
    </member>
    <member name="T:NSoft.NFramework.SingletonTool`1">
      <summary>
            Singleton Pattern을 구현할 때 많이 사용하는 방법은 두가지가 있다. 
            <list type="table"><listheader><term>구현방법</term><description>설명</description></listheader><item><term>double-check locking pattern</term><description>Instance를 반환하기 전, 객체를 Locking한 후 두번에 걸쳐서 singleton 객체가 null인지를 검사한다.</description><term>static pattern</term><description>static 변수에 직접 생성해 버린다. - 간단하지만 어떤에러가 있을 지 모른다.</description></item></list><see cref="T:NSoft.NFramework.SingletonTool`1" />는 위의 double-check locking pattern을 변형하여 더욱 정교하고, Thread-safe 한 Singleton Pattern을 구현한다.
            </summary>
      <remarks>
            단 기본생성자가 제공되어야 합니다.
            </remarks>
      <example>
            	아래 예는 일반적인 Singleton 객체를 ThreadSafeSingletonFactory{T} 를 이용하여 만드는 방법이다.
            	<code>
            	public static class SomeSingleton
            	{
            		public static SomeSingleton Instance
            		{
            			get
            			{
            				return SingletonTool&lt;SomeSingleton&gt;.Instance;
            			}
            		}
            	}
            	</code></example>
    </member>
    <member name="P:NSoft.NFramework.SingletonTool`1.Instance">
      <summary>
            Thread-Safe 한 Singleton 인스턴스	(단 기본생성자가 제공되어야 합니다.)
            </summary>
      <example>
        <code>
            // Thread-safe 한 Singleton Pattern을 구현하려면, 구현하려는 class를 만들고
            // 해당 class의 instance를 반환하는 property를 만든 후 SingletonTool를 사용해
            // 아래와 같이 만들면 된다.
            public static class SomeSingleton
            {
            	public static SomeSingleton Instance
            	{
            		get
            		{
            			return SingletonTool&lt;SomeSingleton&gt;.Instance;
            		}
            	}
            }
            </code>
      </example>
    </member>
    <member name="T:NSoft.NFramework.Tools.StringTool">
      <summary>
            String 관련 Utility class
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Tools.StringTool.TrimmingString">
      <summary>
            문자열 축약을 표현하는 문자열 ("...")
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Tools.StringTool.NullTerminatorChar">
      <summary>
            C language에서 string의 끝을 나타내는 char
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Tools.StringTool.Null">
      <summary>
            null 을 표현하는 문자열
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Tools.StringTool.WhiteSpace">
      <summary>
            공백
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.GetLongestCommonSubstring(System.String,System.String,System.String@)">
      <summary>
            두 문자열의 최대 공통 문자열 (Longest common substring) 을 찾습니다. 공통된 부분이 없다면 sequence는 빈 문자열을 가집니다.
            참고: http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Longest_common_substring
            </summary>
      <param name="str1">
      </param>
      <param name="str2">
      </param>
      <param name="substring">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.GetLongestCommonSequence(System.String,System.String,System.String@)">
      <summary>
            두 문자열의 최대 공통 문자열 (Longest common substring) 을 찾습니다. 공통된 부분이 없다면 sequence는 빈 문자열을 가집니다.
            참고: http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Longest_common_substring
            </summary>
      <param name="str1">
      </param>
      <param name="str2">
      </param>
      <param name="sequence">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToStream(System.String,System.Text.Encoding)">
      <summary>
            문자열을 스트림 (<see cref="T:System.IO.MemoryStream" />)의 인스턴스로 변환한다.
            </summary>
      <param name="s">대상 문자열</param>
      <param name="enc">인코딩 형식</param>
      <returns>변환된 Stream 인스턴스 객체</returns>
      <remarks>사용하고 난 Stream 인스턴스 객체는 Close()를 호출하여 메모리에서 제거해야 한다.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToStream(System.String)">
      <summary>
            문자열을 기본 인코딩 방식으로 스트림 (<see cref="T:System.IO.MemoryStream" />)의 인스턴스로 변환한다.
            </summary>
      <param name="s">대상문자열</param>
      <returns>기본인코딩 방식으로 Stream을 만든다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToStream(System.Byte[])">
      <summary>
            byte 배열을 stream으로 만듭니다.
            </summary>
      <param name="bytes">byte 배열</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToStream(System.Byte[],System.Int32,System.Int32)">
      <summary>
            byte 배열을 stream으로 만듭니다.
            </summary>
      <param name="bytes">byte 배열</param>
      <param name="index">시작 인덱스</param>
      <param name="count">크기</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToString(System.IO.Stream,System.Text.Encoding)">
      <summary>
            주어진 Stream 내용을 지정된 인코딩 방식으로 문자열로 변환한다.
            </summary>
      <param name="stream">
      </param>
      <param name="enc">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToString(System.IO.Stream)">
      <summary>
        <paramref name="stream" /> 내용을 읽어 문자열로 반환합니다.
            </summary>
      <param name="stream">읽을 스트림</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToString(System.String,System.Text.Encoding)">
      <summary>
            주어진 문자열을 주어진 인코딩 방식의 문자열로 변환한다.
            </summary>
      <param name="s">
      </param>
      <param name="enc">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToString(System.Byte[])">
      <summary>
            Byte 배열을 시스템 기본 인코딩 방식의 문자열로 변환한다.
            </summary>
      <param name="bytes">원본 바이트 배열</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToString(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Byte 배열의 지정된 범위를 기본 인코딩 방식의 문자열로 변환한다.
            </summary>
      <param name="bytes">원본 바이트 배열</param>
      <param name="index">시작 위치</param>
      <param name="count">범위</param>
      <returns>시스템 기본 인코딩 형식의 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToString(System.Byte[],System.Text.Encoding)">
      <summary>
            지정된 인코딩 방식으로 Byte 배열을 문자열로 변환한다.
            </summary>
      <param name="bytes">원본 바이트 배열</param>
      <param name="enc">인코딩 방식</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToString(System.Byte[],System.Text.Encoding,System.Int32,System.Int32)">
      <summary>
            지정된 인코딩 방식으로 주어진 범위의 Byte 배열을 문자열로 변환한다.
            </summary>
      <param name="bytes">원본 바이트 배열</param>
      <param name="enc">인코딩 방식</param>
      <param name="index">시작 위치</param>
      <param name="count">변환할 갯수</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToStringUnsafe(System.Byte[])">
      <summary>
            Unsafe 모드로 byte 배열을 문자열로 변환한다.
            </summary>
      <remarks>
            Managed 함수보다 2배정도 빠르다. Network 같은데서 사용하기 좋다.
            </remarks>
      <param name="bytes">원본 바이트 배열</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToStringUnsafe(System.SByte[])">
      <summary>
            Unsafe 모드로 byte 배열을 문자열로 변환한다.
            </summary>
      <remarks>
            Managed 함수보다 2배정도 빠르다. Network 같은데서 사용하기 좋다.
            </remarks>
      <param name="bytes">원본 바이트 배열</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToStringUnsafe(System.Char[])">
      <summary>
            Unsafe 모드로 byte 배열을 문자열로 변환한다.
            </summary>
      <remarks>
            Managed 함수보다 2배정도 빠르다. Network 같은데서 사용하기 좋다.
            </remarks>
      <param name="chars">원본 문자열</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToText(System.IO.Stream)">
      <summary>
        <paramref name="stream" /> 내용을 읽어 문자열로 반환합니다.
            </summary>
      <param name="stream">문자열로 바꿀 스트림</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToText(System.IO.Stream,System.Int32)">
      <summary>
        <paramref name="stream" /> 내용의 일부분을 읽어 문자열로 반환합니다.
            </summary>
      <param name="stream">
      </param>
      <param name="length">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToText(System.IO.Stream,System.Text.Encoding)">
      <summary>
            주어진 Stream 내용을 지정된 인코딩 방식으로 문자열로 변환한다.
            </summary>
      <param name="stream">문자열로 바꿀 스트림</param>
      <param name="enc">인코딩 방식</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToText(System.Byte[])">
      <summary>
            Byte 배열의 지정된 범위를 기본 인코딩 방식의 문자열로 변환한다.
            </summary>
      <param name="bytes">원본 바이트 배열</param>
      <returns>시스템 기본 인코딩 형식의 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToText(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Byte 배열의 지정된 범위를 기본 인코딩 방식의 문자열로 변환한다.
            </summary>
      <param name="bytes">원본 바이트 배열</param>
      <param name="index">시작 위치</param>
      <param name="count">범위</param>
      <returns>시스템 기본 인코딩 형식의 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToText(System.Byte[],System.Text.Encoding)">
      <summary>
            지정된 인코딩 방식으로 주어진 범위의 Byte 배열을 문자열로 변환한다.
            </summary>
      <param name="bytes">원본 바이트 배열</param>
      <param name="enc">인코딩 방식</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToText(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)">
      <summary>
            지정된 인코딩 방식으로 주어진 범위의 Byte 배열을 문자열로 변환한다.
            </summary>
      <param name="bytes">원본 바이트 배열</param>
      <param name="enc">인코딩 방식</param>
      <param name="index">시작 위치</param>
      <param name="count">변환할 갯수</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToTextUnsafe(System.Byte[])">
      <summary>
            Unsafe 모드로 byte 배열을 문자열로 변환한다.
            </summary>
      <remarks>
            Managed 함수보다 2배정도 빠르다. Network 같은데서 사용하기 좋다.
            </remarks>
      <param name="bytes">원본 바이트 배열</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToTextUnsafe(System.Byte[],System.Text.Encoding)">
      <summary>
            Unsafe 모드로 byte 배열을 문자열로 변환한다.
            </summary>
      <remarks>
            Managed 함수보다 2배정도 빠르다. Network 같은데서 사용하기 좋다.
            </remarks>
      <param name="bytes">원본 바이트 배열</param>
      <param name="encoding">인코딩 방식</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToTextUnsafe(System.SByte[])">
      <summary>
            Unsafe 모드로 byte 배열을 문자열로 변환한다.
            </summary>
      <remarks>
            Managed 함수보다 2배정도 빠르다. Network 같은데서 사용하기 좋다.
            </remarks>
      <param name="bytes">원본 바이트 배열</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToTextUnsafe(System.SByte[],System.Text.Encoding)">
      <summary>
            Unsafe 모드로 byte 배열을 문자열로 변환한다.
            </summary>
      <remarks>
            Managed 함수보다 2배정도 빠르다. Network 같은데서 사용하기 좋다.
            </remarks>
      <param name="bytes">원본 바이트 배열</param>
      <param name="encoding">인코딩 방식</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToTextUnsafe(System.Char[])">
      <summary>
            Unsafe 모드로 byte 배열을 문자열로 변환한다.
            </summary>
      <remarks>
            Managed 함수보다 2배정도 빠르다. Network 같은데서 사용하기 좋다.
            </remarks>
      <param name="chars">원본 바이트 배열</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToBytes(System.String)">
      <summary>
            문자열을 시스템 기본 인코딩 방식을 이용하여 Byte Array로 변환한다.
            </summary>
      <param name="s">대상문자열</param>
      <returns>변환된 바이트 배열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToBytes(System.String,System.Text.Encoding)">
      <summary>
            문자열을 주어진 인코딩 방식을 이용하여 Byte Array로 변환한다.
            </summary>
      <param name="s">변환할 문자열</param>
      <param name="enc">인코딩 방식</param>
      <returns>변환된 바이트 배열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToBytes(System.IO.Stream)">
      <summary>
            지정된 스트림 객체의 내용을 byte 배열로 변환한다. (멀티바이트 언어를 나타내는 접두사(3바이트)가 붙을 경우, 제거하고 반환합니다.)
            </summary>
      <param name="stream">변환할 스트림</param>
      <returns>변환된 바이트 배열</returns>
    </member>
    <member name="F:NSoft.NFramework.Tools.StringTool.MultiBytesPrefixBytes">
      <summary>
            MultiByte 언어를 Stream 으로 변환 시에, MultiByte 임을 나타내는 Byte 접두사 (0xEF, 0xBB, 0xBF), FusionCharts에서도 이 bytes 가 쓰인다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Tools.StringTool.DefaultEncoding">
      <summary>
            Default Encoding (<see cref="P:System.Text.Encoding.Default" />) 를 나타낸다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Tools.StringTool.NewLine">
      <summary>
            시스템 개행 문자
            </summary>
      <value>Windows 시스템에서는 \r\n 값을 갖는다.</value>
    </member>
    <member name="F:NSoft.NFramework.Tools.StringTool.WhiteSpaceChars">
      <summary>
            문자열에서 공백과 같이 취급되는 제어 문자들 (개행문자, 탭, 라인피드 등)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.IsNull(System.String)">
      <summary>
            지정된 문자열이 Null인지 확인
            </summary>
      <param name="s">검사할 문자열</param>
      <returns>null 인지 검사 결과</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.IsNotNull(System.String)">
      <summary>
            지정된 문자열이 Null이 아닌지 확인
            </summary>
      <param name="s">
      </param>
      <returns>s가 null이 아니면 true, null이면 false</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.IsEmpty(System.String,System.Boolean)">
      <summary>
            지정된 문자열이 Null이거나 Trim을 수행하여 길이가 0가 된 문자열인지 확인.
            </summary>
      <param name="s">검사할 문자열</param>
      <param name="withTrim">문자열을 Trim후에 길이 검사를 할 것인지 여부</param>
      <returns>빈 문자열 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.IsNotEmpty(System.String,System.Boolean)">
      <summary>
            지정된 문자열에 내용이 있으면 True, Null이거나 길이가 0인 문자열이면 False를 반환
            </summary>
      <param name="s">검사할 문자열</param>
      <param name="withTrim">공백 제거 여부</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.IsWhiteSpace(System.String)">
      <summary>
            문자열이 null이거나, 빈 문자열 또는 공백만 있는 문자열, \n, \r, \t, \f 같은 제어문자만 있는 문자열이라면 이라면 true를 반환한다.
            </summary>
      <param name="s">검사할 문자열</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.IsNotWhiteSpace(System.String)">
      <summary>
            문자열이 null이거나, 빈 문자열 또는 공백만 있는 문자열, \n, \r, \t, \f 같은 제어문자만 있는 문자열이라면 이라면 false를 반환한다.
            </summary>
      <param name="s">검사할 문자열</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.IsMultiByteString(System.Byte[])">
      <summary>
            지정된 바이트 배열이 2-byte 문자열 정보인지 파악합니다. 선두의 3개의 요소가 <see cref="F:NSoft.NFramework.Tools.StringTool.MultiBytesPrefixBytes" />라면 2-byte 문자열입니다.
            </summary>
      <param name="bytes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.IsMultiByteString(System.String)">
      <summary>
            지정된 문자열이 ASCII가 아닌 2 바이트 문자열인지 검사한다.
            </summary>
      <param name="s">검사할 문자열</param>
      <returns>2Byte 문자열이면 true, ascii 문자열이면 false</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Copy(System.String)">
      <summary>
            원본 문자열과 같은 문자열을 생성합니다. 메모리 번지가 다른 인스턴스를 새로 만듭니다.
            </summary>
      <param name="source">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.DeleteCharAny(System.String,System.Char[])">
      <summary>
            지정된 대상 문자열에서 지정된 문자들을 삭제한다.
            </summary>
      <param name="s">대상 문자열</param>
      <param name="charArray">삭제할 문자들</param>
      <returns>대상문자열에서 지정된 문자를 삭제한 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.DeleteChar(System.String,System.Char[])">
      <summary>
            지정된 문자열에서 지정된 문자배열에 있는 문자들을 삭제한다.
            </summary>
      <param name="s">대상 문자열</param>
      <param name="charArray">삭제할 문자들</param>
      <returns>대상문자열에서 지정된 문자를 삭제한 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.DeleteChar(System.String,System.Char)">
      <summary>
            지정된 문자열에서 지정된 문자를 삭제한다.
            </summary>
      <param name="s">대상 문자열</param>
      <param name="c">삭제할 문자</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Join(System.String,System.String[])">
      <summary>
            문자열 배열을 구분자를 중간에 넣어서 결합시킨다.
            <see cref="M:System.String.Join(System.String,System.String[])" /> 함수는 string[] 만을 인자로 받는다.
            </summary>
      <param name="separator">문장 구분자</param>
      <param name="value">결합할 문자열 배열</param>
      <returns>결합된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Join(System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            문자열 시퀀스를 구분자를 중간에 넣어서 결합시킨다.
            </summary>
      <param name="strs">
      </param>
      <param name="separator">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.QuotedStr(System.String)">
      <summary>
            지정된 문자열을 SQL 문법의 문자열에 맞게 홑따옴표 형식으로 바꾼다.
            </summary>
      <param name="s">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.QuotedStr(System.String,System.String)">
      <summary>
            지정된 문자열을 SQL 문법의 문자열에 맞게 홑따옴표 형식으로 바꾼다.
            지정된 문자열이 null이거나 빈 문자열이면 기본값의 홑따옴표 형식을 반환한다.
            </summary>
      <param name="s">
      </param>
      <param name="defaultStr">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Reverse(System.String)">
      <summary>
            문자열의 char 순서를 역순으로 변경한다.
            </summary>
      <param name="s">대상 문자열</param>
      <returns>역순 문자열</returns>
      <remarks>Encoding 방법과 무관하게 실행되므로 한글등에서는 문제가 생길 수 있다.</remarks>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Replicate(System.String,System.Int32)">
      <summary>
            지정한 횟수만큼 문자 식을 반복합니다.
            </summary>
      <param name="s">문자식</param>
      <param name="n">반복 횟수</param>
      <returns>지정된 문자열이 반복되어진 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Capitalize(System.String)">
      <summary>
            문자열의 WORD 단위로 첫문자만 대문자로 만든다.
            </summary>
      <param name="s">
      </param>
      <returns>
      </returns>
      <example>
        <code>
            	string s = "abc PROJECT ID 한글 oH nO file name fileName"
            	Console.WriteLine("{0} to Capitalize : {1}", s, s.Captitalize());
            
            	// "aBC PROJECT_ID 한글 oH nO file name fileName" to Capitalize : "Abc Project_Id 한글 Oh No File Name Filename"
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.ToOracleNaming(System.String,System.String)">
      <summary>
            Class나 Property의 Naming 방식인 Pascal Naming 또는 Camelcase Naming 방식의 문자열을 ORACLE Naming 방식의 문자열로 변환합니다.
            </summary>
      <param name="s">변환할 문자열</param>
      <param name="delimiter">단어 사이의 구분자 (기본값은 '_')</param>
      <returns>변환된 문자열</returns>
      <example>
        <code>
            	"CompanyName".ToOracleNaming().Should().Be("COMPANY_NAME");
            	"UserId".ToOracleNaming().Should().Be("USER_ID");
                "ExAttr1".ToOracleNaming().Should().Be("EX_ATTR1");
            	"IX_CompanyName.ToOracleNaming().Should().Be("IX_COMPANY_NAME");
            	"IX_User_CompanyId".ToOracleNaming().Should().Be("IX_USER_COMPANY_ID");
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Split(System.String,System.Char[])">
      <summary>
            지정된 문자열을 구분자로 구분하여 문자열 배열을 만든다.
            </summary>
      <param name="s">대상 문자열</param>
      <param name="separator">구분할 문자열</param>
      <returns>빈문자열을 준 경우 길이가 0인 문자열 배열을 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Split(System.String,System.StringSplitOptions,System.Char[])">
      <summary>
            지정된 문자열을 구분자로 구분하여 문자열 배열을 만든다.
            </summary>
      <param name="s">대상 문자열</param>
      <param name="splitOptions">Split 시 옵션</param>
      <param name="separator">구분할 문자열</param>
      <returns>빈문자열을 준 경우 길이가 0인 문자열 배열을 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Split(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
      <summary>
            지정된 문자열을 지정된 패턴을 구분자로 하여 문자열 배열로 만든다.
            </summary>
      <param name="s">대상 문자열</param>
      <param name="pattern">구분할 문자열</param>
      <param name="ignoreCase">대소문자 구분 여부 </param>
      <param name="culture">
        <c>CultureInfo</c>
      </param>
      <returns>문자열 1차원 배열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Replace(System.String,System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
      <summary>
            원본 문자열에서 oldPattern에 해당하는 문자열을 newPattern의 문자열로 교체한다.
            </summary>
      <param name="S">원본 문자열</param>
      <param name="oldPattern">바뀔 문자열</param>
      <param name="newPattern">새로운 문자열</param>
      <param name="ignoreCase">대소문자 구분 여부</param>
      <param name="culture">
        <c>CultureInfo</c>
      </param>
      <returns>바뀐 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.FormatWith(System.String,System.Object)">
      <summary>
            지정된 포맷 문자열을 이용하여, 서식 지정 문자열로 됩니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.FormatWith(System.String,System.Object,System.Object)">
      <summary>
            지정된 포맷 문자열을 이용하여, 서식 지정 문자열로 됩니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.FormatWith(System.String,System.Object[])">
      <summary>
            지정된 포맷 문자열을 이용하여, 서식 지정 문자열로 됩니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.FormatWith(System.String,System.IFormatProvider,System.Object[])">
      <summary>
            지정된 포맷 문자열을 이용하여, 서식 지정 문자열로 됩니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.WhiteSpaceAsNull(System.String)">
      <summary>
            null 이거나 빈 문자열인 경우에는 null을 반환합니다.
            </summary>
      <param name="text">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.WordCount(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
      <summary>
            지정된 문자열에 지정된 패턴이 검색되는 횟수를 반환한다.
            </summary>
      <param name="text">대상 문자열</param>
      <param name="pattern">검색 문자열 패턴</param>
      <param name="ignoreCase">대소문자 구분 여부</param>
      <param name="culture">특정 CultureInfo</param>
      <returns>검색 횟수</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.WordCount(System.String,System.Char[])">
      <summary>
            지정된 문자열에 지정된 문자들의 갯수를 구한다.
            </summary>
      <param name="s">대상 문자열</param>
      <param name="word">찾을 char</param>
      <returns>문자열에서 찾은 수</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
      <summary>
            문자열을 <see cref="P:System.Globalization.CultureInfo.CurrentCulture" />를 이용하여 비교한다.
            </summary>
      <remarks>
            string.Compare 에 관련된 많은 함수들이 제공되므로 더 자세한 제어는 그 함수를 이용하세요.
            </remarks>
      <param name="s1">비교 문자열 1</param>
      <param name="s2">비교 문자열 2</param>
      <param name="ignoreCase">대소문자 구분 여부</param>
      <param name="culture">문화권</param>
      <returns>s1과 s2가 같다면 0, s1 &gt; s2 면 양수, s1 &lt; s2 이면 음수</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.EqualTo(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
      <summary>
            지정된 두 문자열이 같은지 검사합니다.
            </summary>
      <param name="s1">
      </param>
      <param name="s2">
      </param>
      <param name="ignoreCase">대소문자 구분</param>
      <param name="culture">문화권</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.GetFirstLine(System.String)">
      <summary>
            지정된 문자열의 첫번째 라인의 문자열만 (개행문자는 제외하고) 추출한다.
            </summary>
      <param name="text">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.IndexOfN(System.String,System.String,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
      <summary>
            문자열에서 N 번째 찾을 sub string의 인덱스 (인덱스는 0부터 시작합니다.) 를 반환합니다.
            </summary>
      <param name="s">원본 문자열</param>
      <param name="sub">찾을 문자열</param>
      <param name="nth">nth 번째 검색</param>
      <param name="ignoreCase">대소문자 구분 여부</param>
      <param name="culture">문화권</param>
      <returns>찾은 위치, 검색 실패시에는 -1을 반환, 인덱스는 0부터 시작합니다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.FirstOf(System.String,System.String)">
      <summary>
            첫번째 찾은 문자열 위치로부터 왼쪽에 있는 문자열을 반환
            </summary>
      <param name="text">대상 문자열</param>
      <param name="c">찾을 문자열</param>
      <returns>string to the left of c.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.FirstOf(System.String,System.String,System.Int32)">
      <summary>
            n 번째 찾은 문자열 위치로부터 왼쪽에 있는 문자열 반환
            </summary>
      <param name="text">대상 문자열</param>
      <param name="c">찾을 문자열</param>
      <param name="n">찾는 횟수</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.LastOf(System.String,System.String)">
      <summary>
            첫번째 찾은 위치의 오른쪽에 있는 문자열 반환
            </summary>
      <param name="text">대상 문자열</param>
      <param name="c">찾을 문자열</param>
      <returns>string to the right of c.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.LastOf(System.String,System.String,System.Int32)">
      <summary>
            n 번째 찾은 문자열 위치로부터 오른쪽에 남은 문자열을 반환
            </summary>
      <param name="text">대상 문자열</param>
      <param name="c">찾을 문자열</param>
      <param name="n">찾는 횟수</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.FirstOfLastIndexOf(System.String,System.String)">
      <summary>
            대상문자열의 처음부터 ~ 뒤에서부터 찾은 위치 전까지의 문자열을 찾는다.
            </summary>
      <param name="text">대상 문자열</param>
      <param name="sub">찾을 문자열</param>
      <returns>대상문자열의 처음부터 ~ 뒤부터 찾은 위치 전까지의 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.LastOfLastIndexOfthis(System.String,System.String)">
      <summary>
            대상문자열의 뒤부터 찾은 위치부터 마지막 문자까지
            </summary>
      <param name="text">대상 문자열</param>
      <param name="sub">찾을 문자열</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Between(System.String,System.String,System.String)">
      <summary>
            대상문자열에서 첫번째 찾은 위치 ~ 두번째 찾은 위치 중간의 문자열을 반환한다.
            </summary>
      <param name="text">대상 문자열</param>
      <param name="start">첫번째 찾을 문자열</param>
      <param name="end">두번째 찾을 문자열</param>
      <returns>둘 중 하나라도 찾지 못한다면, 빈 문자열을 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.LastChar(System.String)">
      <summary>
            대상 문자열의 마지막 문자를 반환한다.
            </summary>
      <param name="text">대상 문자열</param>
      <returns>빈 문자열인 경우 C의 '\0' (null char)가 반환된다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.EllipsisChar(System.String,System.Int32)">
      <summary>
            문자열 최대크기만큼만 SubString을 수행하고, 문자열 마지막에 줄임표(...)를 붙인다.
            </summary>
      <param name="text">트리밍할 문자열</param>
      <param name="maxLength">트리밍의 최대 크기</param>
      <returns>트리밍된 문자열</returns>
      <seealso cref="M:NSoft.NFramework.Tools.StringTool.EllipsisPath(System.String,System.Int32)" />
      <seealso cref="M:NSoft.NFramework.Tools.StringTool.EllipsisFirst(System.String,System.Int32)" />
      <example>
        <code>
            string text="1234567890";
            string trimed = text.EllipsisChar(5); // trimed is "12345...";
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.EllipsisPath(System.String,System.Int32)">
      <summary>
            문자열 최대 크기만큼만 문자열 앞과 뒷 문장을 남기고, 중간에 줄임표(...)를 붙인다.
            </summary>
      <param name="text">트리밍할 문자열</param>
      <param name="maxLength">트리밍의 최대 크기</param>
      <returns>트리밍된 문자열</returns>
      <seealso cref="M:NSoft.NFramework.Tools.StringTool.EllipsisChar(System.String,System.Int32)" />
      <seealso cref="M:NSoft.NFramework.Tools.StringTool.EllipsisFirst(System.String,System.Int32)" />
      <example>
        <code>
            string text="1234567890";
            string trimed = text.EllipsisChar(5); // trimed is "123...90";
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.EllipsisFirst(System.String,System.Int32)">
      <summary>
            문자열 최대 크기만큼만 문자열 앞과 뒷 문장을 남기고, 중간에 줄임표(...)를 붙인다.
            </summary>
      <param name="text">트리밍할 문자열</param>
      <param name="maxLength">트리밍의 최대 크기</param>
      <returns>트리밍된 문자열</returns>
      <seealso cref="M:NSoft.NFramework.Tools.StringTool.EllipsisChar(System.String,System.Int32)" />
      <seealso cref="M:NSoft.NFramework.Tools.StringTool.EllipsisPath(System.String,System.Int32)" />
      <example>
        <code>
            string text="1234567890";
            
            text.EllipsisChar(5);	// return "12345...";
            text.EllipsisPath(5);	// return "123...90";
            text.EllipsisFirst(5);	// return "...67890";
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.HighlightText(System.String,System.String,System.Func{System.String,System.String})">
      <summary>
            문자열에서 검색한 단어에 Highlight를 주는 함수입니다.
            </summary>
      <param name="text">검색 대상 문자열</param>
      <param name="searchWord">검색할 단어</param>
      <param name="highlightFunc">검색된 문자를 Highlight 하는 함수</param>
      <returns>Highlight된 문자열</returns>
      <example>
        <code>
            var highlightedText = text.HighlightText("function", true, str =&gt; string.Concat("[", str, "]"));
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.HighlightText(System.String,System.String,System.Boolean,System.Func{System.String,System.String})">
      <summary>
            문자열에서 검색한 단어에 Highlight를 주는 함수입니다.
            </summary>
      <param name="text">검색 대상 문자열</param>
      <param name="searchWord">검색할 단어</param>
      <param name="ignoreCase">검색 시 대소문자 구분 여부(기본은 True)</param>
      <param name="highlightFunc">검색된 문자를 Highlight 하는 함수</param>
      <returns>Highlight된 문자열</returns>
      <example>
        <code>
            var highlightedText = text.HighlightText("function", true, str =&gt; string.Concat("[", str, "]"));
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Utf8Encode(System.String)">
      <summary>
            해당 문자열을 UTF8 (<c>RwConsts.XmlEncoding</c>) 방식으로 변환한다.
            </summary>
      <param name="s">원본 문자열</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Utf8Encode(System.IO.Stream)">
      <summary>
            해당 Stream 내용을 UTF8 (<c>RwConsts.XmlEncoding</c>) 방식으로 변환한다.
            </summary>
      <param name="stream">원본 스트림 객체</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Utf8Decode(System.String)">
      <summary>
            UTF8 형식의 문자열을 시스템 기본 인코딩 (<see cref="P:System.Text.Encoding.Default" />) 방식으로 변환한다. 
            </summary>
      <param name="s">원본 문자열</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Utf8Decode(System.IO.Stream)">
      <summary>
            UTF8 형식의 스트림 객체를 시스템 기본 인코딩 (<see cref="P:System.Text.Encoding.Default" />) 방식으로 변환한다. 
            </summary>
      <param name="stream">원본 스트림 객체</param>
      <returns>변환된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Base64Encode(System.Byte[],System.Char[]@)">
      <summary>
            Byte Array를 Base64 형식으로 Encoding 한다.
            </summary>
      <param name="inArray">
      </param>
      <param name="outArray">
      </param>
      <example>
            아래 예제는 일반 파일을 읽어서 Base64로 Encoding하는 예제입니다.
            <code>
            byte[] binData;
            char[] base64CharArray;
              
            using(FileStream inFile = new FileStream(inFileName, FileMode.Open, FileAccess.Read))
            {
            	binData = new byte[inFile.Length];
            	long readCount = inFile.Read(binData, 0, (int)inFile.Length);
            }
            
            Base64Encode(binData, out base64CharArray);
            
            if( base64CharArray.Length == 0 )
            	throw new InvalidOperationException("Cannot Encoding");
            	
            using( StreamWriter outFile = new StreamWriter(outFileName, false, Encoding.Default) )
            {
            	outFile.Write(base64CharArray);
            }
            </code></example>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Base64Encode(System.Byte[])">
      <summary>
            Byte Array를 Base64형식의 문자열로 변환한다.
            </summary>
      <param name="inArray">바이트 배열</param>
      <returns>Base64형식으로 인코딩된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Base64Encode(System.String)">
      <summary>
            일반 문자열을 Base64 문자열로 만든다.
            </summary>
      <param name="s">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Base64Encode(System.String,System.Text.Encoding)">
      <summary>
            일반 문자열을 Base64 문자열로 만든다.
            </summary>
      <param name="s">
      </param>
      <param name="enc">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.Base64Decode(System.String)">
      <summary>
            Base64형식으로 인코딩된 문자열을 디코딩하여 바이트 배열로 변환한다.
            </summary>
      <param name="s">Base64형식으로 인코딩된 문자열</param>
      <returns>문자열이 null이거나, 실패시에는 길이가 0인 바이트 배열을 반환한다.</returns>
      <example>
        <code>
              string base64String;
              
              // Base64로 Encoding 된 파일로부터 내용을 읽어온다.
            using(StreamReader inFile = new streamReader(inFileName, Encoding.Default))
            {
            	char[] base64CharArray = new char[inFile.BaseStream.Length];
            	inFile.Read(base64CharArray, 0, (int)inFile.BaseStream.Length);
            	base64String = new string(base64CharArray);
            }
            
            byte[] binData = Base64Decode(base64String);
            
            // 디코딩된 바이트 배열을 파일에 쓴다.
            using(FileStream outFile = new FileStream(outFileName, FileMode.Create, FileAccess.Write))
            {
            	outFile.Write(binData, 0, binData.Length);
            }
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.AsUnicode(System.Char)">
      <summary>
            Char를 Unicode char의 문자열로 표현합니다.
            </summary>
      <param name="c">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.StringTool.WriteCharAsUnicode(System.IO.TextWriter,System.Char)">
      <summary>
            지정한 char 의 unicode string을 <paramref name="writer" />에 쓴다.
            </summary>
      <param name="writer">
      </param>
      <param name="c">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Tools.TypeTool">
      <summary>
        <see cref="T:System.Type" />과 관련된 Utility Class.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.GetObjectType(System.Object)">
      <summary>
            지정된 객체의 수형을 반환한다. 객체가 null이면, null을 반환한다.
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.GetProperties(System.Object)">
      <summary>
            인스턴스의 속성 정보를 "속성 명=속성 값" 형태로 만들어 반환합니다.
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.GetProperties(System.Object,System.Text.StringBuilder)">
      <summary>
            인스턴스의 속성 정보를 "속성 명=속성 값" 형태로 만들어 반환합니다.
            </summary>
      <param name="obj">대상 인스턴스</param>
      <param name="result">속성정보를 담을 객체</param>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.GetProperties(System.Object,System.Collections.IDictionary)">
      <summary>
            인스턴스의 속성명, 값을 지정된 IDictionary에 채운다.
            </summary>
      <param name="obj">대상 인스턴스</param>
      <param name="props">속성정보를 담을 <see cref="T:System.Collections.IDictionary" /> 객체</param>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.GetFields(System.Object)">
      <summary>
            해당 객체의 Field 정보를 string으로 반환한다.
            </summary>
      <param name="obj">개체</param>
      <returns>Filed 정보</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.GetFields(System.Object,System.Text.StringBuilder)">
      <summary>
            해당 객체의 Field 정보를 지정된 StringBuilder에 채운다.
            </summary>
      <param name="obj">개체</param>
      <param name="result">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.GetFields(System.Object,System.Collections.IDictionary)">
      <summary>
            해당 객체의 Field 정보를 지정된 Hashtable에 채운다.
            </summary>
      <param name="obj">개체</param>
      <param name="infos">필드 정보를 컬렉션 개체</param>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.GetTypeDefaultValue(System.Type)">
      <summary>
            특정 수형의 기본값을 반환합니다. ValueType인 경우는 기본 생성자를 통해 값을 반환하고, ValueType이 아닌 경우에는 null을 반환합니다.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.HasDefaultConstructor(System.Type)">
      <summary>
            지정된 수형이 인자가 없는 기본 생성자를 제공하는지 여부를 반환합니다.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsSimpleTypeObject(System.Object)">
      <summary>
            간단한 수형인지 판단한다.
            </summary>
      <remarks>
        <see cref="P:System.Type.IsPrimitive" /> 를 이면 간단한 수형이고,
            stirng, Decimal, DateTime, DBNull 형식이면 SimpleType이라 규정한다.
            </remarks>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsSimpleType(System.Type)">
      <summary>
            간단한 수형인지 판단한다.
            </summary>
      <remarks>
        <see cref="P:System.Type.IsPrimitive" /> 를 이면 간단한 수형이고, 
            stirng, Decimal, DateTime, DBNull 형식이면 SimpleType이라 규정한다.
            </remarks>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsNumeric(System.Object)">
      <summary>
            check specified object is numeric type
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsNumericType(System.Type)">
      <summary>
        <paramref name="type" />이 Numeric 수형인지 판단합니다. Generic 클래스나 메소드에서 수학연산을 수행하기 위해 꼭 점검해야 합니다.
            </summary>
      <param name="type">대상 수형</param>
      <returns>대상 수형이 Numeric 수형이면 True, 아니면 False</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsCloneableType(System.Type,System.Boolean@)">
      <summary>
            지정된 수형이 ICloneable 인터페이스를 상속하여 Clone() 함수를 제공하는 지 여부를 판단한다.
            </summary>
      <param name="type">
      </param>
      <param name="isValueType">Value 타입인지를 </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsInstanceOfType(System.Type,System.Object)">
      <summary>
            지정된 인스턴스가 지정된 타입의 인스턴스인지 검사한다.
            </summary>
      <param name="type">
      </param>
      <param name="target">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsInstantiatableType(System.Type)">
      <summary>
            인스턴스 생성을 할 수 있는 타입인가? 즉 new 로 인스턴스를 생성할 수 있는 형식인가?
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsNullable(System.Type)">
      <summary>
            지정한 타입이 null을 할당 받을 수 있는지 검사합니다.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsNullableType(System.Type)">
      <summary>
            지정한 타입이 Nullable{T} 형식인지 검사합니다.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsSerializable(System.Type)">
      <summary>
            지정된 형식이 SerializableAttribute를 지정하였는지 판단한다.
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.SimpleClassName(System.Type)">
      <summary>
            System.Type.Name 값에서 Namespace를 뺀 class name 만을 뽑아낸다.
            </summary>
      <param name="type">대상 인스턴스의 타입 객체</param>
      <returns>클래스명</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.CanAssign(System.Object,System.Type)">
      <summary>
            지정된 오브젝트 객체를 원하는 타입으로 형변환이 가능한지 알아본다.
            </summary>
      <param name="target">대상 객체</param>
      <param name="assignType">변경할 타입</param>
      <returns>변경 가능 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsSameOrSubclassOf(System.Object,System.Type)">
      <summary>
            지정된 오브젝트 객체의 타입이 기본 타입과 같거나 상속한 타입인지 검사한다.
            </summary>
      <param name="target">검사할 객체</param>
      <param name="baseType">기본 타입</param>
      <returns>검사할 객체가 기본 타입과 같거나 상속된 타입이면 True, 아니면 False 이다. </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsSameOrSubclassOf(System.Type,System.Type)">
      <summary>
            지정된 srcType이 baseType과 같거나 상속받은 클래스인가를 검사한다.
            </summary>
      <param name="srcType">검사할 타입</param>
      <param name="baseType">기본 타입</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsSameOrSubclassOrImplementedOf(System.Object,System.Type)">
      <summary>
            지정된 srcType이 baseType과 같거나 상속받은 클래스인가 또는 baseType이 Interface이고, 이 인터페이스를 구현한 것인지 검사한다.
            </summary>
      <param name="target">검사할 객체</param>
      <param name="baseType">기본 타입</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.IsSameOrSubclassOrImplementedOf(System.Type,System.Type)">
      <summary>
            지정된 srcType이 baseType과 같거나 상속받은 클래스인가 또는 baseType이 Interface이고, 이 인터페이스를 구현한 것인지 검사한다.
            </summary>
      <param name="srcType">검사할 타입</param>
      <param name="baseType">기본 타입</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.ToStringWithAssemblyName(System.Type)">
      <summary>
            Type을 문자열로 표현한다. 형식은 [Type.FullName, AssemblyName] 이 된다. 
            (Assembly의 Qualified Name은 version, public key도 포함하지만 여기서는 포함하지 안는다.)
            </summary>
      <param name="type">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.MakeGenericType(System.Type,System.Type[])">
      <summary>
            개방된 Generic 수형을 <paramref name="innerTypes" /> 들로 Closed Generic 수형을 생성합니다.
            </summary>
      <param name="genericTypeDefinition">
      </param>
      <param name="innerTypes">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.CreateGeneric(System.Type,System.Type,System.Object[])">
      <summary>
            개방된 Generic 수형을 <paramref name="innerType" />의 Closed Generic 수형으로 만들고, 인스턴스를 생성해서 반환합니다.
            </summary>
      <param name="genericTypeDefinition">Opened Generic Type</param>
      <param name="innerType">Generic의 내부 수형</param>
      <param name="args">생성자의 인자들</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Tools.TypeTool.CreateGeneric(System.Type,System.Type[],System.Object[])">
      <summary>
            개방된 Generic 수형을 <paramref name="innerTypes" />의 Closed Generic 수형으로 만들고, 인스턴스를 생성해서 반환합니다.
            </summary>
      <param name="genericTypeDefinition">Opened Generic Type</param>
      <param name="innerTypes">Generic의 내부 수형</param>
      <param name="args">생성자의 인자들</param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.UnitTesting.CrossThreadRunner">
      <summary>
            Multi-Thread 환경하에서 Test를 하기 위한 보조 클래스이다.
            </summary>
      <remarks>
            Multi-Thread 환경에서 Test를 하고자 할 때 
            Test하고자 하는 함수를 <see cref="T:System.Threading.ThreadStart" /> 로 Wrapping 하여 
            <see cref="T:NSoft.NFramework.UnitTesting.CrossThreadRunner" />를 생성시킨다.
            그후 <see cref="T:NSoft.NFramework.UnitTesting.CrossThreadRunner" />.RunEach() 을 호출하면 Test가 이루어진다.
            </remarks>
      <example>
        <code>
                CrossThreadTestRunner threadRunner = new CrossThreadTestRunner(new ThreadStart(doThreadWork));
                threadRunner.RunEach();
                </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.CrossThreadRunner.#ctor(System.Threading.ThreadStart)">
      <summary>
            생성자
            </summary>
      <param name="userDelegate">Thread 안에서 수행할 메소드</param>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.CrossThreadRunner.Run">
      <summary>
            쓰레드 하에서 수행
            </summary>
    </member>
    <member name="T:NSoft.NFramework.UnitTesting.OperationTimer">
      <summary>
            UnitTest시에 성능검사를 위한 Timer
            </summary>
      <example>
        <code>
            using(new OperationTimer("Performance Test"))
            {
            	// some test...
            }
            
            // log 에 다음과 같이 출력된다. (INFO 레벨)
            ### Performace Test took xxxx msec
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.OperationTimer.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.OperationTimer.#ctor(System.String,System.Boolean)">
      <summary>
            생성자
            </summary>
      <param name="message">이 객체가 소멸될 때 표시되는 메시지</param>
      <param name="clearGabage">테스트 전 후에 Gabage collection을 수행할 것인가?</param>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.OperationTimer.Dispose">
      <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="T:Microsoft.Silverlight.Testing.TagAttribute">
      <summary>
            Silverlight 테스팅 시에 NUnit의 Category 역할을 하도록 하는 Attribute 입니다. Tag에 해당되는 단위 테스트들만 테스트를 수행하도록 할 수 있습니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.UnitTesting.TestTool">
      <summary>
            단위 테스트 시 필요한 함수들 (대부분 멅티스레드로 테스트를 수행합니다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.TestTool.RunTasks(System.Int32,System.Action)">
      <summary>
            지정된 Action을 지정된 횟수만큼 병렬로 실행합니다. 멀티스레드 테스트가 가능합니다.
            </summary>
      <param name="count">
      </param>
      <param name="action">수행할 델리게이트</param>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.TestTool.RunTasks(System.Int32,System.Action[])">
      <summary>
            지정된 Action들을 지정된 횟수만큼 병렬 방식으로 실행합니다. 멀티스레드 테스트가 가능합니다.
            </summary>
      <param name="count">
      </param>
      <param name="actions">
      </param>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.TestTool.RunTasks(System.Int32,System.Int32,System.Action{System.Int32})">
      <summary>
        <paramref name="actions" />를 지정한 범위만큼 수행합니다.
            </summary>
      <param name="fromInclusive">
      </param>
      <param name="toExclusive">
      </param>
      <param name="actions">
      </param>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.TestTool.RunTaskQueue(System.Int32,System.Action[])">
      <summary>
        <paramref name="actions" />를 <paramref name="count" /> 수 만큼 순서대로 수행합니다.
            </summary>
      <param name="count">
      </param>
      <param name="actions">
      </param>
      <seealso cref="T:NSoft.NFramework.Parallelism.DataStructures.SerialTaskQueue" />
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.TestTool.ThreadStress(System.Threading.ThreadStart,System.Int32)">
      <summary>
            지정된 Thread 메소드에 대해, 갯수 만큼 Thread 를 만들어서 실행시킨다. (ThreadPool 을 사용하는게 아니므로, 
            좋은 방법은 아닙니다. <see cref="M:NSoft.NFramework.UnitTesting.TestTool.RunTasks(System.Int32,System.Action)" />을 사용하세요.
            </summary>
      <param name="testMethod">실행할 메소드를 ThreadStart로 delegate 한 메소드</param>
      <param name="threadCount">수행할 횟수</param>
      <example>
        <code>
            	TestTool.ThreadStress(new ThreadStart(WorkMethod), 100);
            
            
            	...
            
            	public void WorkMethod()
                {
                      // something to work
                      ...
            	}
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.TestTool.ThreadStress(System.Collections.Generic.IList{System.Threading.Thread})">
      <summary>
            지정된 Thread 컬렉션들을 모두 실행시킵니다.
            </summary>
      <param name="threads">
      </param>
      <example>
        <code>
                List{Thread} threads = new List{Thread}();
                for(int i=0;i &lt; 100; i++)
                    threads.Add(new Thread(new ThreadStart(WorkMethod)));
            
            	TestTool.ThreadStress(threads);
            
            	...
            
            	public void WorkMethod()
                {
                      // something to work
                      ...
            	}
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.TestTool.RunThread(System.Int32,System.Int32,System.Threading.WaitCallback)">
      <summary>
        <see cref="T:System.Threading.ThreadPool" /> 에 callback 을 지정된 갯수만큼 넣고 실행시킵니다. 일반적으로 Thread 컬렉션보다 성능이 좋습니다.
            </summary>
      <param name="maxThreads">
      </param>
      <param name="workerThreads">
      </param>
      <param name="callback">
      </param>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.TestTool.ThreadStressByThreadPool(System.Threading.WaitCallback,System.Int32)">
      <summary>
        <see cref="T:System.Threading.ThreadPool" />을 이용하여, 지정한 callback 함수를 지정한 갯수만큼 수행합니다.
            </summary>
      <param name="callback">
      </param>
      <param name="count">
      </param>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.TestTool.ThreadStressByThreadPool(System.Threading.WaitCallback,System.Collections.Generic.IEnumerable{System.Object})">
      <summary>
        <see cref="T:System.Threading.ThreadPool" />을 이용하여, 지정된 callback 함수를 지정된 state 인자값 수만큼 실행합니다.
            </summary>
      <param name="callback">
      </param>
      <param name="states">
      </param>
    </member>
    <member name="M:NSoft.NFramework.UnitTesting.TestTool.ThreadStressByThreadPool(System.Collections.Generic.IEnumerable{System.Threading.WaitCallback},System.Int32)">
      <summary>
        <see cref="T:System.Threading.ThreadPool" />을 이용하여, 지정한 callback 함수들을 지정한 갯수만큼 수행합니다.
            </summary>
      <param name="callbacks">수행할 callback 함수들</param>
      <param name="count">callback 함수 수행 횟수</param>
    </member>
    <member name="T:NSoft.NFramework.AsmInfo">
      <summary>
            Assembly의 AssemblyInfo에 정의된 정보를 제공합니다. <see cref="T:NSoft.NFramework.Tools.AssemblyTool" />을 이용해도 되지만, 
            이 함수를 사용하면 한꺼번에 정보를 추출하여 가지고 있으므로, 복제할 때 좋다.
            </summary>
      <seealso cref="T:NSoft.NFramework.Tools.AssemblyTool" />
    </member>
    <member name="M:NSoft.NFramework.AsmInfo.#ctor(System.Reflection.Assembly)">
      <summary>
            Constructor
            </summary>
      <param name="assembly">
      </param>
    </member>
    <member name="M:NSoft.NFramework.AsmInfo.GetHashCode">
      <summary>
            Serves as a hash function for a particular type. 
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.FullName">
      <summary>
            Assembly Full Name.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.AssemblyName">
      <summary>
            Assembly Name
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.CodeBase">
      <summary>
            Codebase는 동적으로 Loading한 Assembly에 대해서는 값을 조회할 수 없습니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.Company">
      <summary>
            Company
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.Configuration">
      <summary>
            Configuration
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.Copyright">
      <summary>
            Copyright
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.Culture">
      <summary>
            Culture
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.DefaultAlias">
      <summary>
            DefaultAlias
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.Description">
      <summary>
            Description
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.InfomationalVersion">
      <summary>
            Informational Version
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.Product">
      <summary>
            Product
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.Title">
      <summary>
            Title
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.Trademark">
      <summary>
            Trademark
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.Version">
      <summary>
            Version
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AsmInfo.Win32FileVersion">
      <summary>
            File Version
            </summary>
    </member>
    <member name="T:NSoft.NFramework.DisposableAction">
      <summary>
            Context 처리시에 더 직관적인 문법을 사용하기 위한 Class입니다.
            Java의 anonymous class를 흉내낸 것으로서, 
            이 클래스의 인스턴스가 Dispose 될 때, 어떤 Method를 호출하여 처리하도록 하기 위해서 사용된다.
            </summary>
      <remarks>
            try / finally 구문과 유사하지만, exception 발생시에는 disposable이 수행되지 않는다.
            </remarks>
      <example>
        <code>
            // using 구문 안의 code가 수행 된 후 action이 수행되도록 한다. (try / finally 구문과 유사 - exception 발생 시에는 action이 수행되지 않는다.)
            bool calledAtDisposing = false;
            using (DisposableAction action = new DisposableAction(delegate { calledAtDisposing = true; }))
            {
            	// some codes executed before execute action.
            	Thread.Sleep(50);
            }
            
            Assert.IsTrue(calledAtDisposing);   // calledAtDisposing is true at action is disposing
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.DisposableAction.#ctor(System.Action)">
      <summary>
            생성자
            </summary>
      <param name="action">dispose 시에 수행할 action</param>
    </member>
    <member name="M:NSoft.NFramework.DisposableAction.Finalize">
      <summary>
             Allows an <see cref="T:System.Object" /> to attempt to free resources and perform other cleanup operations before the <see cref="T:System.Object" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.DisposableAction.Dispose">
      <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.DisposableAction.Dispose(System.Boolean)">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <param name="disposing">need to dispose managed resources.</param>
    </member>
    <member name="P:NSoft.NFramework.DisposableAction.Action">
      <summary>
            현재 인스턴스가 Dispose될 때 실행할 Action
            </summary>
    </member>
    <member name="P:NSoft.NFramework.DisposableAction.IsDisposed">
      <summary>
            메모리 해제 여부
            </summary>
    </member>
    <member name="T:NSoft.NFramework.DisposableAction`1">
      <summary>
            Context 처리시에 더 직관적인 문법을 사용하기 위한 Class입니다.
            Java의 anonymous class를 흉내낸 것으로서, 
            이 클래스의 인스턴스가 Dispose 될 때, 어떤 Method를 호출하여 처리하도록 하기 위해서 사용된다.
            </summary>
      <remarks>
            주의할 점은 try / finally 구문과 유사하지만, exception 발생 시에는 disposable이 수행되지 않는다.
            </remarks>
      <example>
        <code>
            // using 구문 안의 code가 수행 된 후 action이 수행되도록 한다.
            
            int expected = 4543;
            int actual = 0;
            
            DisposableAction{int} action = new DisposableAction{int}(delegate(int i) { actual = i; }, expected);
            
            Assert.AreNotEqual(actual, expected);   // before disposing
            
            action.Dispose();
            
            Assert.AreEqual(actual, expected);      // after dispoing
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.DisposableAction`1.#ctor(System.Action{`0},`0)">
      <summary>
            생성자
            </summary>
      <param name="action">Disposing 시에 호출되는 Action</param>
      <param name="val">Action 호출시 인자</param>
    </member>
    <member name="M:NSoft.NFramework.DisposableAction`1.Finalize">
      <summary>
             Allows an <see cref="T:System.Object" /> to attempt to free resources and perform other cleanup operations before the <see cref="T:System.Object" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.DisposableAction`1.Dispose">
      <summary>
             Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.DisposableAction`1.Dispose(System.Boolean)">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <param name="disposing">need to dispose managed resources.</param>
    </member>
    <member name="P:NSoft.NFramework.DisposableAction`1.Value">
      <summary>
            Disposing시에 호출되는 Action 대리자의 인자
            </summary>
    </member>
    <member name="P:NSoft.NFramework.DisposableAction`1.Action">
      <summary>
            Disposing 시에 호출될 Action
            </summary>
    </member>
    <member name="P:NSoft.NFramework.DisposableAction`1.IsDisposed">
      <summary>
            메모리 해제 여부
            </summary>
    </member>
    <member name="T:NSoft.NFramework.EnumComparer">
      <summary>
            Enum 형식에 대한 Comparer를 제공하는 Class입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.EnumComparer.For``1">
      <summary>
            지정된 Enum 형식에 대한 Comparer를 제공합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.EnumComparer`1">
      <summary>
            Enum 형식에 대한 Comparer입니다. Lambda Expression을 이용하여, 비교자를 구현했습니다.
            <see cref="P:System.Collections.Generic.Comparer`1.Default" />를 사용했을 때보다 속도가 10배 이상 빨라집니다.
            </summary>
      <remarks>
            참고 : http://www.netgore.com/docs/a01975_source.html
            원본 : http://www.codeproject.com/KB/cs/EnumComparer.aspx
            </remarks>
      <typeparam name="T">사용자 enum 형식</typeparam>
    </member>
    <member name="M:NSoft.NFramework.EnumComparer`1.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.EnumComparer`1.Equals(`0,`0)">
      <summary>
            Determines whether the specified objects are equal.
            </summary>
      <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
      <param name="x">The first object of type {T} to compare.</param>
      <param name="y">The second object of type {T} to compare.</param>
    </member>
    <member name="M:NSoft.NFramework.EnumComparer`1.GetHashCode(`0)">
      <summary>
            Returns a hash code for the specified object.
            </summary>
      <returns>
            A hash code for the specified object.
            </returns>
      <param name="instance">The <see cref="T:System.Object" /> for which a hash code is to be returned.</param>
      <exception cref="T:System.ArgumentNullException">
            The type of <paramref name="instance" /> is a reference type and <paramref name="instance" /> is null.
            </exception>
    </member>
    <member name="P:NSoft.NFramework.EnumComparer`1.Instance">
      <summary>
            Instance of EnumComparer{T}
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Guard">
      <summary>
            Guard 패턴을 이용하여, 조건에 맞는 상황인지를 검사합니다. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeEquals(System.Object,System.Object,System.String)">
      <summary>
        <paramref name="value" /> 이 <paramref name="targetValue" />과 같아야 합니다. 두 값이 다르면 예외가 발생합니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="targetValue">비교 대상 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">value와 targetValue가 값이 다르면 발생합니다.</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeEquals(System.Object,System.Object,System.String)">
      <summary>
        <paramref name="value" /> 이 <paramref name="targetValue" />과 같지 않아야 합니다. 만약 같다면 예외를 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="targetValue">비교 대상 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">value와 targetValue가 같으면 발생합니다.</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeNull(System.Object,System.String)">
      <summary>
            지정된 <paramref name="value" />가 Null이면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다. 값이 null 이면 예외가 발생합니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.ArgumentNullException">value가 null인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeDefault``1(``0,System.String)">
      <summary>
        <paramref name="value" />가 default(T)와 같다면, <see cref="T:System.InvalidOperationException" />을 발생시킵니다. default(T)와 같으면 예외를 발생시킵니다.
            </summary>
      <typeparam name="T">값의 수형</typeparam>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.ArgumentNullException">value가 default(T)인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeEmpty(System.String,System.String)">
      <summary>
            지정한 문자열이 null, 빈 문자열, 공백만 있는 문자열이라면 예외를 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">검사할 값의 명</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 NULL, 빈문자열일 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeEmpty(System.String,System.String,System.Boolean)">
      <summary>
            지정한 문자열이 null 이거나, 빈 문자열이라면 예외를 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <param name="doTrim">Trim 후 검사</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 NULL, 빈문자열, 공백만 있는 문자열일때 발생한다.</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeWhiteSpace(System.String,System.String)">
      <summary>
        <paramref name="value" />가 NULL, 빈문자열, 공백만 있는 문자열이라면 예외를 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 NULL, 빈문자열, 공백만 있는 문자열일때 발생한다.</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeEmpty(System.Collections.IEnumerable,System.String)">
      <summary>
            지정한 시퀀스가 null 이거나 빈 컬렉션이면 예외를 발생시킵니다.
            </summary>
      <param name="sequence">검사할 시퀀스</param>
      <param name="sequenceName">시퀀스 명</param>
      <exception cref="T:System.InvalidOperationException">지정한 시퀀스가 null이거나 빈 컬렉션인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeEmpty``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            지정한 시퀀스가 null 이거나 빈 컬렉션이면 예외를 발생시킵니다.
            </summary>
      <param name="sequence">검사할 시퀀스</param>
      <param name="sequenceName">시퀀스 명</param>
      <exception cref="T:System.InvalidOperationException">지정한 시퀀스가 null이거나 빈 컬렉션인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeExists``1(System.Collections.Generic.IEnumerable{``0},System.String)">
      <summary>
            지정한 시퀀스에 요소가 있어야 합니다. NULL이거나 요소가 없다면 예외를 발생시킵니다.
            </summary>
      <param name="sequence">검사할 시퀀스</param>
      <param name="sequenceName">시퀀스 명</param>
      <exception cref="T:System.InvalidOperationException">지정한 시퀀스가 null이거나 빈 컬렉션인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNumeric(System.Object,System.String)">
      <summary>
            지정한 객체가 Numeric 수형이여야 합니다. Numeric 수형이 아니면 예외를 발생시킨다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">값이 Numeric 수형이 아닌 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNumericType(System.Type)">
      <summary>
            지정한 수형이 Numeric 수형이어야 합니다.
            </summary>
      <param name="type">검사할 수형</param>
      <exception cref="T:System.InvalidOperationException">값이 Numeric 수형이 아닌 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeInstanceOf``1(System.Object,System.String)">
      <summary>
        <paramref name="instance" /> 가 <typeparamref name="TTarget" /> 수형의 인스턴스가 아니라면 <see cref="T:System.InvalidOperationException" /> 예외를 발생시킵니다.
            </summary>
      <typeparam name="TTarget">
      </typeparam>
      <param name="instance">검사할 객체</param>
      <param name="instanceName">객체명</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="instance" /> 가 <typeparamref name="TTarget" /> 수형의 인스턴스가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeZero(System.Int32,System.String)">
      <summary>
        <paramref name="value" />이 0이면 예외를 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeZero(System.Int64,System.String)">
      <summary>
            지정한 값이 0이면 예외를 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeZero(System.Single,System.String)">
      <summary>
            지정한 값이 0이면 예외를 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeZero(System.Double,System.String)">
      <summary>
            지정한 값이 0이면 예외를 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeZero(System.Int16,System.String)">
      <summary>
            지정한 값이 0이면 예외를 발생시킵니다.
            </summary>
      <exception cref="T:System.InvalidOperationException">값이 0일때</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeZero(System.Decimal,System.String)">
      <summary>
            지정한 값이 0이면 예외를 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBePositive(System.Int32,System.String)">
      <summary>
        <paramref name="value" />이 양수 (0 초과의 값) 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 보다 큰 값이 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBePositive(System.Int64,System.String)">
      <summary>
        <paramref name="value" />이 양수 (0 초과의 값) 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 보다 큰 값이 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBePositive(System.Single,System.String)">
      <summary>
        <paramref name="value" />이 양수 (0 초과의 값) 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 보다 큰 값이 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBePositive(System.Double,System.String)">
      <summary>
        <paramref name="value" />이 양수 (0 초과) 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 보다 큰 값이 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBePositive(System.Int16,System.String)">
      <summary>
        <paramref name="value" />이 양수 (0 초과) 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 보다 큰 값이 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBePositive(System.Decimal,System.String)">
      <summary>
        <paramref name="value" />이 양수 (0 초과) 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 보다 큰 값이 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBePositiveOrZero(System.Int32,System.String)">
      <summary>
        <paramref name="value" />이 0이거나 양수 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 이거나 양수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBePositiveOrZero(System.Int64,System.String)">
      <summary>
        <paramref name="value" />이 0이거나 양수 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 이거나 양수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBePositiveOrZero(System.Single,System.String)">
      <summary>
        <paramref name="value" />이 0이거나 양수 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 이거나 양수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBePositiveOrZero(System.Double,System.String)">
      <summary>
        <paramref name="value" />이 0이거나 양수 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 이거나 양수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBePositiveOrZero(System.Int16,System.String)">
      <summary>
        <paramref name="value" />이 0이거나 양수 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 이거나 양수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBePositiveOrZero(System.Decimal,System.String)">
      <summary>
        <paramref name="value" />이 0이거나 양수 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 이거나 양수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNegative(System.Int32,System.String)">
      <summary>
        <paramref name="value" />이 음수 (0 미만) 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 미만의 음수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNegative(System.Int64,System.String)">
      <summary>
        <paramref name="value" />이 음수 (0 미만) 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 미만의 음수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNegative(System.Single,System.String)">
      <summary>
        <paramref name="value" />이 음수 (0 미만) 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 미만의 음수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNegative(System.Double,System.String)">
      <summary>
        <paramref name="value" />이 음수 (0 미만) 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 미만의 음수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNegative(System.Int16,System.String)">
      <summary>
        <paramref name="value" />이 음수 (0 미만) 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 미만의 음수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNegative(System.Decimal,System.String)">
      <summary>
        <paramref name="value" />이 음수 (0 미만) 이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0 미만의 음수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNegativeOrZero(System.Int32,System.String)">
      <summary>
        <paramref name="value" />이 0이거나 음수이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0이거나 음수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNegativeOrZero(System.Int64,System.String)">
      <summary>
        <paramref name="value" />이 0이거나 음수이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0이거나 음수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNegativeOrZero(System.Single,System.String)">
      <summary>
        <paramref name="value" />이 0이거나 음수이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0이거나 음수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNegativeOrZero(System.Double,System.String)">
      <summary>
        <paramref name="value" />이 0이거나 음수이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0이거나 음수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNegativeOrZero(System.Int16,System.String)">
      <summary>
        <paramref name="value" />이 0이거나 음수이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0이거나 음수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeNegativeOrZero(System.Decimal,System.String)">
      <summary>
        <paramref name="value" />이 0이거나 음수이어야 합니다. 그렇지 않으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 0이거나 음수가 아닐 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeNaN(System.Double,System.String)">
      <summary>
        <paramref name="value" />이 NaN 이면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 NaN인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeNaN(System.Single,System.String)">
      <summary>
        <paramref name="value" />이 NaN 이면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 NaN인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeGreaterThan``1(``0,``0,System.String)">
      <summary>
        <paramref name="value" />이 <paramref name="target" /> 보다 커야 합니다. 같거나 작으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="target">대상 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 <paramref name="target" />보다 작거나 같은 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeGreaterOrEqual``1(``0,``0,System.String)">
      <summary>
        <paramref name="value" />이 <paramref name="target" /> 보다 크거나 같아야 합니다. 작으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="target">대상 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 <paramref name="target" />보다 작은 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeLessThan``1(``0,``0,System.String)">
      <summary>
        <paramref name="value" />이 <paramref name="target" /> 보다 작아야 합니다. 크거나 같으면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="target">대상 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 <paramref name="target" />보다 크거나 같은 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeLessOrEqual``1(``0,``0,System.String)">
      <summary>
        <paramref name="value" />이 <paramref name="target" /> 보다 작거나 같아야 합니다. 크면 <see cref="T:System.InvalidOperationException" />을 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="target">대상 값</param>
      <param name="valueName">명칭</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="value" />가 <paramref name="target" />보다 큰 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeInRange``1(``0,``0,``0,System.String)">
      <summary>
        <paramref name="value" />가 <paramref name="fromInclude" /> 이상이고, <paramref name="toExclude" /> 미만이어야 합니다. 아니면 예외를 발생시킵니다.
            </summary>
      <param name="value">검사할 값</param>
      <param name="fromInclude">하한 값 (범위에 포함됨)</param>
      <param name="toExclude">상한 값 (범위에 포함 안됨)</param>
      <param name="valueName">검사할 값의 명칭</param>
      <exception cref="T:System.InvalidOperationException">값이 범위를 벗어났을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeBetween``1(``0,``0,``0,System.String)">
      <summary>
            두 값 사이 (경계 포함)에 있어야 한다. 그렇지 않으면, <see cref="T:System.InvalidOperationException" />을 발생시킨다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="value">검사할 값</param>
      <param name="lowerInclusive">하한 값 (범위에 포함)</param>
      <param name="upperInclusive">상한 값 (범위에 포함)</param>
      <param name="valueName">검사할 값의 명칭</param>
      <exception cref="T:System.InvalidOperationException">값이 범위 내에 있지 않을 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeEqualTo``1(``0,``0)">
      <summary>
        <paramref name="actual" /> 값이 <paramref name="expected" />값이 같아야 합니다. 다르면 예외를 발생시킵니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="actual">실제 값</param>
      <param name="expected">예상 값</param>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeEqualTo``1(``0,``0)">
      <summary>
        <paramref name="actual" /> 값이 <paramref name="expected" />값이 달라야 합니다. 같으면 예외를 발생시킵니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="actual">
      </param>
      <param name="expected">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBeGreatThan``1(``0,``0)">
      <summary>
        <paramref name="actual" /> 값이 <paramref name="expected" />값보다 커야 합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="actual">
      </param>
      <param name="expected">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBeGreatThan``1(``0,``0)">
      <summary>
        <paramref name="actual" /> 값이 <paramref name="expected" />값보다 커서는 안됩니다. (이하여야 합니다)
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="actual">
      </param>
      <param name="expected">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldBe(System.Linq.Expressions.Expression{System.Func{System.Boolean}},System.String)">
      <summary>
        <paramref name="conditionExpr" />을 수행해서 True가 나와야 합니다. False가 반환되면 예외를 발생시킵니다.
            </summary>
      <param name="conditionExpr">
      </param>
      <param name="message">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Guard.ShouldNotBe(System.Linq.Expressions.Expression{System.Func{System.Boolean}},System.String)">
      <summary>
        <paramref name="conditionExpr" />을 수행해서 False가 나와야 합니다. True가 반환되면 예외를 발생시킵니다.
            </summary>
      <param name="conditionExpr">
      </param>
      <param name="message">
      </param>
    </member>
    <member name="T:NSoft.NFramework.ILocalData">
      <summary>
            하나의 ThreadContext 내에 정보를 저장합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.ILocalData.TryGetValue(System.Object,System.Object@)">
      <summary>
            지정된 키에 해당하는 값을 조회합니다.
            </summary>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ILocalData.Clear">
      <summary>
            저장소의 모든 정보를 삭제합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.ILocalData.GetOrAdd``1(System.Object,System.Func{``0})">
      <summary>
            저장된 값을 반환합니다. 저장된 값이 없다면, <paramref name="valueFactory" />를 이용하여 생성한 값을 저장소에 저장한 후 저장한 값을 반환한다.
            </summary>
      <typeparam name="TValue">
      </typeparam>
      <param name="key">
      </param>
      <param name="valueFactory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ILocalData.SetValue``1(System.Object,System.Action{``0})">
      <summary>
            지정된 키에 이용하여 생성한 값을 저장소에 저장한 후 저장한 값을 반환한다.
            </summary>
      <param name="key">키 값</param>
      <param name="valuePropertySetter">Value 속성 값을 변경할 Action</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ILocalData.SetValue``1(System.Object,System.Func{``0},System.Action{``0})">
      <summary>
            지정된 키에 <paramref name="valueFactory" />를 이용하여 생성한 값을 저장소에 저장한 후 저장한 값을 반환한다.
            </summary>
      <param name="key">키 값</param>
      <param name="valueFactory">해당 정보가 없을 때 사용할 Value 생성자</param>
      <param name="valuePropertySetter">Value 속성 값을 변경할 Action</param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.ILocalData.Item(System.Object)">
      <summary>
            Get or sets the <see cref="T:System.Object" /> with the specified key.
            </summary>
      <param name="key">키 값</param>
      <returns>저장된 값을 반환합니다. 저장된 값이 없다면 null을 반환합니다.</returns>
    </member>
    <member name="T:NSoft.NFramework.Local">
      <summary>
            이 클래스는 Thread context별로 local data를 관리하기 위해서 사용됩니다.
            단 비동기 방식에서는 Thread 가 달라지므로 사용할 수 없습니다. 
            예외적으로, 웹 환경에서는 비동기 방식의 작업 환경이라도, 저장소가 일정하므로 가능합니다.
            </summary>
      <example>
        <code>
            // 각 Thread 마다 원하는 Data를 독립적으로 저장할 수 있다.
            [Test]
            [ThreadedRepeat(5)]
            public void CanSaveAndLoadData()
            {
                string key = "LocalDataFixture.Key";
                string value = Guid.NewSequentialGuid().AsString();
            
            
                Local.Data[key] = value;
            
                if (log.IsDebugEnabled)
                    log.DebugFormat("Key=[{0}], Value=[{1}]", key, Local.Data[key]);
            
                Assert.AreEqual(value, Local.Data[key]);
            }
            </code>
      </example>
    </member>
    <member name="P:NSoft.NFramework.Local.Data">
      <summary>
            Get the current data. 이 속성은 Singleton 이지만, 내부 저장소는 Thread별로 관리된다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Local.IsInWebContext">
      <summary>
            indicating whether running in the web context
            </summary>
    </member>
    <member name="T:NSoft.NFramework.StackTracer">
      <summary>
            Stack Trace 정보를 가져오는 Helper Class
            </summary>
    </member>
    <member name="M:NSoft.NFramework.StackTracer.GetCurrentStackTraceInfo">
      <summary>
            이 함수 호출전까지의 StackTrace 정보를 제공한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.StackTracer.GetStackTraceInfo(System.String)">
      <summary>
            지정된 StackTrace 정보중에 StackTrace 정보를 얻기 위한 작업을 제거한
            실제 코드상에서 일어난 정보만을 추려서 반환한다.
            </summary>
      <param name="currentStackTrace">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.StackTracer.GetCurrentStackTraceDepth">
      <summary>
            현재 StackTrace 정보의 갯수를 반환한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.StackTracer.GetStackTraceDepth(System.String)">
      <summary>
            현재 StackTrace 정보의 갯수를 반환한다.
            </summary>
      <param name="currentStackTrace">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.StackTracer.GetCurrentStackTraces">
      <summary>
            현재 StackTrace 정보중에 Method 호출한 부분만을 추출하여 문자열 배열로 반환한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.StackTracer.GetStackTraces(System.String)">
      <summary>
            StackTrace 정보중에 Method 호출한 부분만을 추출하여 문자열 배열로 반환한다.
            </summary>
      <param name="currentStackTrace">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.With.TryAction(System.Action,System.Action{System.Exception},System.Action)">
      <summary>
            지정된 Action을 수행합니다.
            </summary>
      <param name="tryAction">수행할 action</param>
      <param name="exceptionAction">예외 시 수행할 action</param>
      <param name="finallyAction">뒷처리를 위한 action</param>
    </member>
    <member name="M:NSoft.NFramework.With.TryFunction``1(System.Func{``0},System.Func{``0},System.Action{System.Exception},System.Action)">
      <summary>
            지정된 Function을 수행합니다.
            </summary>
      <param name="tryFunc">수행할 action</param>
      <param name="exceptionAction">예외 시 수행할 action</param>
      <param name="finallyAction">뒷처리를 위한 action</param>
      <param name="valueFactory">예외 시 반환할 기본 값을 생성하는 Factory</param>
    </member>
    <member name="M:NSoft.NFramework.With.TryActionAsync(System.Action,System.Action{System.AggregateException},System.Action)">
      <summary>
            비동기 방식의 작업을 수행할 때 예외처리를 담당해 줍니다. 비동기 방식 작업을 수행할 때에는 이 함수를 호출하시기 바랍니다.
            </summary>
      <param name="asyncAction">비동기 방식 작업을 수행하는 Action</param>
      <param name="ageAction">예외 처리를 담당하는 Action</param>
      <param name="finallyAction">Finally Block 처리를 담당하는 Action</param>
      <returns>작업 성공 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.With.TryFunctionAsync``1(System.Func{``0},System.Func{``0},System.Action{System.AggregateException},System.Action)">
      <summary>
            비동기 방식의 작업을 수행할 때 예외처리를 담당해 줍니다. 비동기 방식 작업을 수행할 때에는 이 함수를 호출하시기 바랍니다.
            </summary>
      <param name="asyncFunc">비동기 방식 작업을 수행하는 Function</param>
      <param name="valueFactory">함수 실행 실패 시의 반환할 값 생성 함수</param>
      <param name="ageAction">예외 처리를 담당하는 Action</param>
      <param name="finallyAction">Finally Block 처리를 담당하는 Action</param>
      <returns>함수 반환 값</returns>
    </member>
    <member name="M:NSoft.NFramework.With.TryFunctionAsync``1(System.Func{``0},``0@)">
      <summary>
            비동기 방식의 작업을 수행할 때 예외처리를 담당해 줍니다. 비동기 방식 작업을 수행할 때에는 이 함수를 호출하시기 바랍니다.
            </summary>
      <param name="asyncFunc">비동기 방식 작업을 수행하는 Function</param>
      <param name="resultValue">
        <paramref name="asyncFunc" /> 반환 값</param>
      <returns>작업 성공 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.With.TryFunctionAsync``1(System.Func{``0},System.Action{System.AggregateException},``0@)">
      <summary>
            비동기 방식의 작업을 수행할 때 예외처리를 담당해 줍니다. 비동기 방식 작업을 수행할 때에는 이 함수를 호출하시기 바랍니다.
            </summary>
      <param name="asyncFunc">비동기 방식 작업을 수행하는 Function</param>
      <param name="ageAction">예외 처리를 담당하는 Action</param>
      <param name="resultValue">
        <paramref name="asyncFunc" /> 반환 값</param>
      <returns>작업 성공 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.With.TryFunctionAsync``1(System.Func{``0},System.Action{System.AggregateException},System.Action,``0@)">
      <summary>
            비동기 방식의 작업을 수행할 때 예외처리를 담당해 줍니다. 비동기 방식 작업을 수행할 때에는 이 함수를 호출하시기 바랍니다.
            </summary>
      <param name="asyncFunc">비동기 방식 작업을 수행하는 Function</param>
      <param name="ageAction">예외 처리를 담당하는 Action</param>
      <param name="finallyAction">Finally Block 처리를 담당하는 Action</param>
      <param name="resultValue">
        <paramref name="asyncFunc" /> 반환 값</param>
      <returns>작업 성공 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.With.OperationTimer(System.Action,System.Boolean)">
      <summary>
            지정된 함수를 수행하는데 걸리는 시간 (msec)을 검사한다.
            </summary>
      <param name="gabageCollect">시간측정을 더 정밀하게 하기 위해 GabageCollect()를 수행하고 할 것인가?</param>
      <param name="action">시간 측정이 필요한 함수</param>
      <returns>지정된 함수 수행 시간 (milliseconds)</returns>
      <example>
        <code>
            int msec = With.OperationTime(false,
            		   delegate 
                       {
                           // some code...
                       });
            </code>
      </example>
    </member>
    <member name="T:NSoft.NFramework.Validations.ValidatorFactory">
      <summary>
            FluentValidation 의 Validator를 생성합니다.<br /></summary>
      <example>
        <code>
            var customer = new Customer();
            var factory = new ValidatorFactory()
            
            var validator = factory.GetValidator(customer.GetType());
            
            var result = validator.Validate(customer);
            
            result.IsValid.Should().Be.True();	   
            result.Errors.Count.Should().Be(0);
            </code>
      </example>
    </member>
    <!-- Badly formed XML comment ignored for member "M:NSoft.NFramework.Validations.ValidatorFactory.CreateInstance(System.Type)" -->
    <member name="T:NSoft.NFramework.Validations.ValidatorTool">
      <summary>
            FluentValidation 어셈블리를 이용히여, 정보에 대한 유효성 검증을 수행하는 Validator 및 메소드들을 제공합니다.
            참고 : http://fluentvalidation.codeplex.com/
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Validations.ValidatorTool.GetValidator(System.Type)">
      <summary>
        <paramref name="targetType" />에 해당하는 <see cref="T:FluentValidation.IValidator" />를 반환합니다.
            </summary>
      <param name="targetType">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Validations.ValidatorTool.GetValidator``1">
      <summary>
        <typeparamref name="T" /> 수형의 인스턴스에 대한 유효성 검증을 수행할 <see cref="T:FluentValidation.IValidator`1" />를 반환합니다.
            </summary>
      <typeparam name="T">유효성 검증 대상 엔티티의 수형</typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Validations.ValidatorTool.GetValidatorOf(System.Object)">
      <summary>
        <paramref name="target" />의 유효성 검증을 수행할 <see cref="T:FluentValidation.IValidator" />의 인스턴스를 반환합니다.
            </summary>
      <param name="target">유효성 검증 대상 객체</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Validations.ValidatorTool.Validate(System.Object)">
      <summary>
        <paramref name="target" />에 해당하는 수형에 대한 Validator를 이용하여, Validation을 수행한 후 결과를 반환합니다.
            </summary>
      <param name="target">유효성 검증 대상 객체</param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Web.Caching.SysCacheOutputCacheProvider">
      <summary>
            .NET 4.0 이상에서 ASP.NET Page의 OutputCache를 Membase 에 저장합니다.
            참고:
                 http://www.4guysfromrolla.com/articles/061610-1.aspx
                 http://weblogs.asp.net/gunnarpeipman/archive/2009/11/19/asp-net-4-0-writing-custom-output-cache-providers.aspx
                 http://weblogs.asp.net/scottgu/archive/2010/01/27/extensible-output-caching-with-asp-net-4-vs-2010-and-net-4-0-series.aspx
            </summary>
      <example>
        <code>
          <system.web>
            <compilation debug="true" targetFramework="4.0" />
            <caching>
              <outputCache defaultProvider="SysCacheOutputCacheProvider">
                <providers>
                  <add name="SysCacheOutputCacheProvider" type="NSoft.NFramework.Web.Caching.SysCacheOutputCacheProvider, NSoft.NFramework.Web" />
                </providers>
              </outputCache>
            </caching>
          </system.web>
        </code>
      </example>
    </member>
    <member name="T:NSoft.NFramework.Web.AbstractOutputCacheProvider">
      <summary>
            .NET 4.0 이상에서 ASP.NET Page의 OutputCache를 <see cref="P:NSoft.NFramework.Web.AbstractOutputCacheProvider.CacheRepository" />를 통해 저장/로드됩니다.
            참고:
                 http://www.4guysfromrolla.com/articles/061610-1.aspx
                 http://weblogs.asp.net/gunnarpeipman/archive/2009/11/19/asp-net-4-0-writing-custom-output-cache-providers.aspx
                 http://weblogs.asp.net/scottgu/archive/2010/01/27/extensible-output-caching-with-asp-net-4-vs-2010-and-net-4-0-series.aspx
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.IOutputCacheProvider.Get(System.String)">
      <summary>
            출력 캐시에서 지정된 항목에 대한 참조를 반환합니다.
            </summary>
      <returns>
            캐시에서 지정된 항목을 식별하는 <paramref name="key" /> 값이거나 캐시에 지정된 항목이 없는 경우 null입니다.
            </returns>
      <param name="key">출력 캐시에서 캐시된 항목에 대한 고유 식별자입니다. </param>
    </member>
    <member name="M:NSoft.NFramework.Web.IOutputCacheProvider.Add(System.String,System.Object,System.DateTime)">
      <summary>
            지정된 항목을 출력 캐시에 삽입합니다. 
            </summary>
      <returns>
            지정된 공급자에 대한 참조입니다. 
            </returns>
      <param name="key">
        <paramref name="entry" />에 대한 고유 식별자입니다.</param>
      <param name="entry">출력 캐시에 추가할 내용입니다.</param>
      <param name="utcExpiry">캐시된 항목이 만료되는 시각입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Web.IOutputCacheProvider.Set(System.String,System.Object,System.DateTime)">
      <summary>
            지정된 항목을 출력 캐시에 삽입하고 이미 캐시되어 있는 경우 해당 항목을 덮어씁니다.
            </summary>
      <param name="key">
        <paramref name="entry" />에 대한 고유 식별자입니다.</param>
      <param name="entry">출력 캐시에 추가할 내용입니다.</param>
      <param name="utcExpiry">캐시된 <paramref name="entry" />가 만료되는 시각입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Web.IOutputCacheProvider.Remove(System.String)">
      <summary>
            출력 캐시에서 지정된 항목을 제거합니다.
            </summary>
      <param name="key">출력 캐시에서 제거할 항목에 대한 고유 식별자입니다. </param>
    </member>
    <member name="P:NSoft.NFramework.Web.IOutputCacheProvider.CacheRepository">
      <summary>
            실제 캐시 저장소에 데이타를 저장/조회하는 API를 제공하는 Repository입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractOutputCacheProvider.Get(System.String)">
      <summary>
            출력 캐시에서 지정된 항목에 대한 참조를 반환합니다.
            </summary>
      <returns>
            캐시에서 지정된 항목을 식별하는 <paramref name="key" /> 값이거나 캐시에 지정된 항목이 없는 경우 null입니다.
            </returns>
      <param name="key">출력 캐시에서 캐시된 항목에 대한 고유 식별자입니다. </param>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractOutputCacheProvider.Add(System.String,System.Object,System.DateTime)">
      <summary>
            지정된 항목을 출력 캐시에 삽입합니다. 
            </summary>
      <returns>
            지정된 공급자에 대한 참조입니다. 
            </returns>
      <param name="key">
        <paramref name="entry" />에 대한 고유 식별자입니다.</param>
      <param name="entry">출력 캐시에 추가할 내용입니다.</param>
      <param name="utcExpiry">캐시된 항목이 만료되는 날짜와 시간입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractOutputCacheProvider.Set(System.String,System.Object,System.DateTime)">
      <summary>
            지정된 항목을 출력 캐시에 삽입하고 이미 캐시되어 있는 경우 해당 항목을 덮어씁니다.
            </summary>
      <param name="key">
        <paramref name="entry" />에 대한 고유 식별자입니다.</param>
      <param name="entry">출력 캐시에 추가할 내용입니다.</param>
      <param name="utcExpiry">캐시된 <paramref name="entry" />가 만료되는 날짜와 시간입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractOutputCacheProvider.Remove(System.String)">
      <summary>
            출력 캐시에서 지정된 항목을 제거합니다.
            </summary>
      <param name="key">출력 캐시에서 제거할 항목에 대한 고유 식별자입니다. </param>
    </member>
    <member name="P:NSoft.NFramework.Web.AbstractOutputCacheProvider.CacheRepository">
      <summary>
            실제 캐시 저장소에 데이타를 저장/조회하는 API를 제공하는 Repository입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.Caching.SysCacheRepository">
      <summary>
        <see cref="T:System.Web.Caching.Cache" />를 저장소로 사용하는 CacheRepository
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.Caching.SysCacheRepository.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.Caching.SysCacheRepository.#ctor(NSoft.NFramework.ISerializer,System.TimeSpan)">
      <summary>
            생성자
            </summary>
      <param name="serializer">객체 Serializer</param>
      <param name="expiry">유효기간</param>
    </member>
    <member name="M:NSoft.NFramework.Web.Caching.SysCacheRepository.Get(System.String)">
      <summary>
            캐시에 저장된 항목을 반환합니다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Caching.SysCacheRepository.Set(System.String,System.Object,System.TimeSpan)">
      <summary>
            캐시에 항목을 저장합니다.
            </summary>
      <param name="key">
      </param>
      <param name="item">
      </param>
      <param name="validFor">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.Caching.SysCacheRepository.Remove(System.String)">
      <summary>
            캐시에서 항목을 제거합니다.
            </summary>
      <param name="key">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.Caching.SysCacheRepository.Clear">
      <summary>
            캐시의 모든 항목을 삭제합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.ControlAdapters.AspImageControlAdapter">
      <summary>
            ASP Image Control의 ImageUrl이 Full Path인 경우, 브라우저의 다운로드가 빠르다. 이 점에 착안하여, IamgeUrl 이 full path를 가지도록 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.ControlAdapters.AspImageControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)">
      <summary>
            ASP Image control의 ImageUrl 가 http로 시작하지 않고, 상대 경로를 사용하다면, 절대경로로 바꾼다. 
            이렇게 하면 여러 이미지를 한꺼번에 다운로드 받아 페이지 로딩 속도가 빨라집니다.
            </summary>
      <param name="writer">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase">
      <summary>
            Lazy Pattern을 이용하여, 웹 Application 시작 시에 미리 준비해야 할 작업이 있다면, 그 작업을 비동기적으로 실행시켜줍니다.
            이렇게 하면, 실제 데이터를 필요로 할 때, 미리 준비된 데이터를 사용할 수 있으므로, 성능상에 유리하게 됩니다.
            </summary>
      <remarks>
            Application_Start, Session_Start, Session_End, Application_End 시점에 비동기적으로 실행할 메소드를 재정의하면, 
            각 싯점마다, 비동기적으로 실행해줍니다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.Application_Start(System.Object,System.EventArgs)">
      <summary>
            HttpApplication Instance 중 첫번째 인스턴스만 호출되는 이벤트입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.Application_Error(System.Object,System.EventArgs)">
      <summary>
            HttpApplication에서 예외가 발생했을 때 호출되는 이벤트 핸들러입니다. 기본적으로는 예외에 대한 내용을 로그로 작성하는 작업을 수행합니다)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.Session_Start(System.Object,System.EventArgs)">
      <summary>
            Session이 시작했을 때 발생하는 이벤트입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.Session_End(System.Object,System.EventArgs)">
      <summary>
            Timeout에 의해, 혹은 사용자의 로그아웃에 의해 Session이 끝났을 때 발생하는 이벤트입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.Application_Disposed(System.Object,System.EventArgs)">
      <summary>
            HttpApplication 인스턴스들이 Dispose 될 때마다 호출된다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.Application_End(System.Object,System.EventArgs)">
      <summary>
            마지막 HttpApplication 인스턴스가 Dispose 될 때 호출된다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.OnBeginRequest(System.Object,System.EventArgs)">
      <summary>
            Client 요청 처리 시작 이벤트입니다.
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.OnPreRequestHandlerExecute(System.Object,System.EventArgs)">
      <summary>
            Client 요청 처리 사전 작업의 마지막 단계입니다. 이 이벤트 처리기 이후에는 바로 Page 관련 작업을 수행합니다.
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.OnPostRequestHandlerExecute(System.Object,System.EventArgs)">
      <summary>
            Page 작업이 완료된 후 바로 수행되는 단계입니다.
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.OnEndRequest(System.Object,System.EventArgs)">
      <summary>
            모든 요청을 처리하고, 마무리하는 단계입니다.
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.ApplicationStartAfter(System.Web.HttpContext)">
      <summary>
            Application_Start 시에 실행할 비동기 작업의 본체입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.ApplicationInitAfter(System.Web.HttpContext)">
      <summary>
            Application_Init 시에 실행할 비동기 작업의 본체입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.ApplicationErrorAfter(System.Web.HttpContext,System.Exception)">
      <summary>
            Application_Error 시에 비동기적으로 실행할 작업입니다. (기본적으로는 로그에 쓰는 작업을 합니다)
            overriding 시 base method를 호출해 주셔야합니다.
            </summary>
      <param name="context">현재 Context 정보</param>
      <param name="exception">Web Applicatoin 예외 정보</param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.SessionStartAfter(System.Web.HttpContext)">
      <summary>
            Session_Start 시에 비동기적으로 실행할 작업입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.SessionEndAfter(System.Web.HttpContext)">
      <summary>
            Session_End 시에 비동기적으로 실행할 작업입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.ApplicationDisposedAfter(System.Web.HttpContext)">
      <summary>
            Application_Disposed 시에 비동기적으로 실행할 작업입니다. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.AsyncHttpApplicationBase.ApplicationEndAfter(System.Web.HttpContext)">
      <summary>
            Application_End 시에 비동기적으로 실행할 작업입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpApplications.WindsorAsyncHttpApplication">
      <summary>
            Future Pattern을 이용하여, 웹 Application 시작 시에 미리 준비해야 할 작업이 있다면, 그 작업을 비동기적으로 실행시켜줍니다.
            이렇게 하면, 실제 데이터를 필요로 할 때, 미리 준비된 데이터를 사용할 수 있으므로, 성능상에 유리하게 됩니다.
            </summary>
      <remarks>
            Application_Start, Session_Start, Session_End, Application_End 시점에 비동기적으로 실행할 메소드를 재정의하면, 각 시점마다, 비동기적으로 실행해줍니다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.WindsorAsyncHttpApplication.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.WindsorAsyncHttpApplication.InitializeIoC">
      <summary>
        <see cref="T:NSoft.NFramework.InversionOfControl.IoC" />를 초기화 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.WindsorAsyncHttpApplication.SetUpContainer">
      <summary>
            Windsor Container를 초기화하여 반환합니다. <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" /> 를 이용한 초기화를 수행할 수 있습니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpApplications.WindsorAsyncHttpApplication.Container">
      <summary>
            IoC/DI 패턴을 위한 Castle.Windsor의 Container입니다.
            </summary>
    </member>
    <!-- Badly formed XML comment ignored for member "T:NSoft.NFramework.Web.HttpApplications.WindsorHttpApplication" -->
    <member name="M:NSoft.NFramework.Web.HttpApplications.WindsorHttpApplication.#ctor">
      <summary>
            Initialize a new instance of IocHttpApplication.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.WindsorHttpApplication.ExecutePrefetchTask">
      <summary>
        <see cref="T:System.Web.HttpApplication" /> 시작 시에 미리 실행하면, 성능상 잇점이 있는 작업을 비동기적으로 수행하도록 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.WindsorHttpApplication.OnBeginRequest(System.Object,System.EventArgs)">
      <summary>
            Web Application의 요청 처리 전에 사전 준비 사항을 처리한다.
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.WindsorHttpApplication.OnEndRequest(System.Object,System.EventArgs)">
      <summary>
            Web Application의 요청 처리 후 사후 처리를 한다. (실제 처리하는 것은 없고, 재정의가 가능하도록 남겨두었다.)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.WindsorHttpApplication.OnDisposed(System.Object,System.EventArgs)">
      <summary>
        <see cref="T:System.Web.HttpApplication" />이 메모리에서 제거될 때 발생하는 이벤트의 처리기
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.WindsorHttpApplication.OnError(System.Object,System.EventArgs)">
      <summary>
            Web Application에서 예외가 발생한 경우 발생하는 이벤트의 처리기
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.WindsorHttpApplication.InitializeIoC">
      <summary>
        <see cref="T:NSoft.NFramework.InversionOfControl.IoC" />를 초기화합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpApplications.WindsorHttpApplication.SetUpContainer">
      <summary>
            Windsor Container를 초기화하여 반환합니다. <see cref="T:Castle.MicroKernel.Registration.IWindsorInstaller" /> 를 이용한 초기화를 수행할 수 있습니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpApplications.WindsorHttpApplication.Container">
      <summary>
            현재 사용하는 Castle.Windsor의 Container
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpHandlers.AbstractHttpAsyncHandler">
      <summary>
            비동기 처리가 가능한 HttpHandler의 기본 클래스입니다.	 
            <see cref="M:NSoft.NFramework.Web.HttpHandlers.AbstractHttpHandler.DoProcessRequest(System.Web.HttpContext)" />메소드를 override 해서 원하시는 작업을 정의하시면 됩니다.
            참고 : http://madskristensen.net/post/How-to-use-the-IHttpAsyncHandler-in-ASPNET.aspx
            </summary>
      <remarks>
        <see cref="M:NSoft.NFramework.Web.HttpHandlers.AbstractHttpHandler.DoProcessRequest(System.Web.HttpContext)" /> 메소드 내에서 Response.End() 메소드를 호출하지 마십시요. 비동기 방식에서는 예외가 발생합니다.
            </remarks>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpHandlers.AbstractHttpHandler">
      <summary>
            HttpHandler의 가장 기본이 되는 클래스입니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.HttpHandlers.AbstractHttpHandler.DefaultCompressionThreshold">
      <summary>
            최소 압축 크기
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpHandlers.AbstractHttpHandler.DoProcessRequest(System.Web.HttpContext)">
      <summary>
            HttpHandler의 작업의 메인 메소드입니다. 재정의 하여 원하는 기능을 수행하되, 제일 첫번째에 부모 클래스의 메소들를 호출해주어야 합니다.
            </summary>
      <param name="context">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpHandlers.AbstractHttpHandler.CompressionThreshold">
      <summary>
            압축하기 위한 최소 크기 (이 크기 이하의 컨텐츠는 굳이 압축하지 않는다)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpHandlers.AbstractHttpHandler.CompressionKind">
      <summary>
            Client가 수용할 수 있는 압축 방법
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpHandlers.AbstractHttpHandler.CanCompression">
      <summary>
            압축을 할 수 있는지?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpHandlers.AbstractHttpHandler.Compressor">
      <summary>
            압축기
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpHandlers.AbstractHttpAsyncHandler.BeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)">
      <summary>
            HTTP 처리기에 대한 비동기 호출을 시작합니다.
            </summary>
      <returns>
            프로세스 상태에 대한 정보가 들어 있는 <see cref="T:System.IAsyncResult" />입니다.
            </returns>
      <param name="context">
            Request, Response, Session, Server 등과 같이 HTTP 요청을 처리하는 데 사용되는 내장 서버 개체에 대한 참조를 제공하는 <see cref="T:System.Web.HttpContext" /> 개체입니다.
            </param>
      <param name="cb">비동기 메서드 호출이 완료될 때 호출할 <see cref="T:System.AsyncCallback" />입니다.<paramref name="cb" />이 null이면 대리자가 호출되지 않습니다.</param>
      <param name="extraData">요청을 처리하는 데 필요한 모든 추가 데이터입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpHandlers.AbstractHttpAsyncHandler.EndProcessRequest(System.IAsyncResult)">
      <summary>
            처리가 끝날 때 비동기 프로세스 End 메서드를 제공합니다.
            </summary>
      <param name="result">프로세스 상태에 대한 정보가 들어 있는 <see cref="T:System.IAsyncResult" />입니다.</param>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpHandlers.AbstractHttpAsyncHandler.IsReusable">
      <summary>
            비동기 호출방식에서는 HttpHandler 인스턴스의 재사용은 문제를 일으킬 수 있습니다. 문제가 발생하면, False로 변환해보시기 바랍니다.
            </summary>
    </member>
    <!-- Badly formed XML comment ignored for member "T:NSoft.NFramework.Web.HttpHandlers.MultiFileHttpHandler" -->
    <member name="F:NSoft.NFramework.Web.HttpHandlers.MultiFileHttpHandler.FileDelimiter">
      <summary>
            파일 구분자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpHandlers.MultiFileHttpHandler.DoProcessRequest(System.Web.HttpContext)">
      <summary>
            HttpContext의 요청정보를 바탕으로 HttpHandler의 실제 작업을 처리하는 메소드입니다.
            </summary>
      <param name="context">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpHandlers.MultiFileHttpHandler.CacheDuration">
      <summary>
            캐시 Duration입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpHandlers.PerformanceCounterHandlerBase">
      <summary>
            시스템의 성능 측정기(<see cref="T:System.Diagnostics.PerformanceCounter" />의 값을 읽어 제공한다.
            </summary>
      <remarks>
            CategoryName, CounterName [, InstanceName] 을 제공해야 합니다.
            </remarks>
      <example>
        <code>
            // 
            PerformanceCounterHandler.ashx?
            </code>
      </example>
      <seealso cref="T:NSoft.NFramework.Diagnostics.PerformanceCounterTool" />
      <seealso cref="T:NSoft.NFramework.Diagnostics.IPerformanceCounterProvider" />
    </member>
    <member name="M:NSoft.NFramework.Web.HttpHandlers.PerformanceCounterHandlerBase.ParseRequestParameters(System.String@,System.String@,System.String@)">
      <summary>
            얻고자하는 성능 측정 값을 얻는다.
            </summary>
      <param name="categoryName">
      </param>
      <param name="counterName">
      </param>
      <param name="instanceName">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpHandlers.PerformanceCounterHandlerBase.RetrivePerformanceCount(System.String,System.String)">
      <summary>
            지정된 범주의 PerformanceCount를 얻어서 HttpResponse 객체에 씁니다.
            </summary>
      <param name="categoryName">
      </param>
      <param name="counterName">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpHandlers.PerformanceCounterHandlerBase.RetrivePerformanceCount(System.String,System.String,System.String)">
      <summary>
            지정된 범주의 PerformanceCount를 얻어서 HttpResponse 객체에 씁니다.
            </summary>
      <param name="categoryName">
      </param>
      <param name="counterName">
      </param>
      <param name="instanceName">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpHandlers.PerformanceCounterHandlerBase.CurrentContext">
      <summary>
            Current HttpContext Instance
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpHandlers.PerformanceCounterHandlerBase.Request">
      <summary>
            Current HttpRequest Instance
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpHandlers.PerformanceCounterHandlerBase.Response">
      <summary>
            Current HttpResponse Instance
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpHandlers.StaticFileHttpHandler">
      <summary>
            Static file을 제공할 때, 압축이 가능하면 압축을 사용하고, 캐시로 저장해두어, 사용자의 정적 파일 요청을 빠르게 처리하는 HttpHandler입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpHandlers.StaticFileHttpHandler.DoProcessRequest(System.Web.HttpContext)">
      <summary>
            HttpHandler의 작업의 메인 메소드입니다. 재정의 하여 원하는 기능을 수행하되, 제일 첫번째에 부모 클래스의 메소들를 호출해주어야 합니다.
            </summary>
      <param name="context">
      </param>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpHandlers.StaticFileHttpHandler.CacheDuration">
      <summary>
            캐시 Duration입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpModules.UriExecutionTime">
      <summary>
            페이지 처리 성능 정보
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.UriExecutionTime.IncreseExecutionCount">
      <summary>
            실행 횟수 한 회 증가
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.UriExecutionTime.CompareTo(NSoft.NFramework.Web.HttpModules.UriExecutionTime)">
      <summary>
            이 비교 함수가 Ranking을 결정할 알고리즘을 담고 있습니다.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpModules.UriExecutionTime.UriString">
      <summary>
            대상 페이지
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpModules.UriExecutionTime.ExecutionTime">
      <summary>
            평균 실행 시간
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpModules.UriExecutionTime.ExecutionCount">
      <summary>
            실행 횟수
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpModules.UriExecutionTimeRankModule">
      <summary>
             요청정보에 대한 처리 시간이 가장 긴 Top N 개를 주기적으로 계산해서, 로그에 쓰고, Application 에 "PagePerformanceRank" 라는 이름으로 목록을 저장합니다.
             </summary>
      <remarks>
             만들 제품 : 웹 Application에서 실행시간이 긴 Top N 을 알려주는 프로그램
            
             1. 형식 : HttpModule
            
             2. 평가 방법
            
                 각 Page별 실행시간의 평균에 대한 순위
            
                 1. 단순 실행시간 방식 : 모든 페이지의 전체 실행 시간 (BeginRequest~EndRequest),  순수 페이지 실행 시간(PreRequestExecuteHandler ~ PostRequestExecuteHandler) 에 대한 단순 Ranking 선정
                 2. Page 요청 빈도에 따른 가중치에 의한 Ranking (이게 더 합리적이지요^^)
            
             3. Ranking 정보 배포 방식
            
                 1. 주기적인 로깅 (Info Level)
                 2. HttpApplication 의 특정 변수에 List로 전달 (각자 알아서 사용 가능) ==&gt; 당근 Readonly 로 활용하세요.
            
             4. 주의 사항
                 1. 웹 서비스나 WCF 서비스는 순수 페이지 실행 시간을 측정할 수 없습니다.
                 2. 비동기 방식에 대해서도 측정이 가능하도록 합니다. (Stopwatch가 Local 에 담기도록...)
             </remarks>
    </member>
    <member name="F:NSoft.NFramework.Web.HttpModules.UriExecutionTimeRankModule.RankingUpdateCount">
      <summary>
            Ranking 정보를 갱신할 요청 갯수 (요쳥 갯수만큼을 받아서 Ranking을 재정렬 해야만 Ranking 정보를 Update합니다.)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.HttpModules.UriExecutionTimeRankModule.RankingCount">
      <summary>
            Top N 개의 순위
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.HttpModules.UriExecutionTimeRankModule.RankByTotalTime">
      <summary>
            평균이 아닌 실행시간 * 실행 횟수를 순위 값을 사용한다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpModules.AbstractHttpModule">
      <summary>
            일반적인 HttpModule의 추상 클래스이며, 
            HttpModule 테스트를 수행하기 쉽도록 하기 위해 <see cref="T:System.Web.HttpContextWrapper" />를 이용하도록 하였다.
            </summary>
      <remarks>
            AbstractHttpModule을 상속받아 구현한 모듈은 웹 Application이 없어도 Mocking을 통해 쉽게 테스트가 가능합니다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.AbstractHttpModule.Init(System.Web.HttpApplication)">
      <summary>
            모듈을 초기화하고 요청을 처리할 수 있도록 준비합니다.
            </summary>
      <param name="context">ASP.NET 응용 프로그램 내의 모든 응용 프로그램 개체에 공통되는 메서드, 속성 및 이벤트에 액세스할 수 있도록 하는 <see cref="T:System.Web.HttpApplication" />입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.AbstractHttpModule.Dispose">
      <summary>
        <see cref="T:System.Web.IHttpModule" />을 구현하는 모듈에서 사용하는 리소스(메모리 제외)를 삭제합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.AbstractHttpModule.OnBeginRequest(System.Web.HttpContextBase)">
      <summary>
            HttpApplication이 사용자 요청을 받기 시작했을 때 호출되는 메소드입니다.
            </summary>
      <param name="context">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.AbstractHttpModule.OnError(System.Web.HttpContextBase)">
      <summary>
            HttpApplication에서 예외가 발생했을 때 호출되는 메소드입니다.
            </summary>
      <param name="context">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.AbstractHttpModule.OnEndRequest(System.Web.HttpContextBase)">
      <summary>
            HttpApplication이 사용자 요청을 처리 완료 했을 때 호출되는 메소드입니다.
            </summary>
      <param name="context">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpModules.AsyncAccessLogModule">
      <summary>
            비동기적으로, 웹 응용프로그램에 대한 요청 정보를 로그합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.AsyncAccessLogModule.Init(System.Web.HttpApplication)">
      <summary>
            모듈 초기화
            </summary>
      <param name="context">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpModules.PageAccessLogModule">
      <summary>
            ASP.NET 요청에 대한 접근 정보를 로깅합니다.
            </summary>
      <remarks>
            로깅관련 포맷 및 레벨을 환경설정에서 설정할 수 있도록 하면 좋겠다.
            </remarks>
      <example>
        <code lang="none">
            // IIS 7.0 클래식 모드와 IIS 7.0 이전 버전에 적용할 때
            <configuration><system.web><httpModule><add name="PageAccessLogModule" type="NSoft.NFramework.Web.HttpModules.PageAccessLogModule, NSoft.NFramework.Web" /></httpModule></system.web></configuration></code>
        <code>
            // IIS 7.0 통합모드에 적용할 때
            <configuration><system.webServer><module><add name="PageAccessLogModule" type="NSoft.NFramework.Web.HttpModules.PageAccessLogModule, NSoft.NFramework.Web" /></module></system.webServer></configuration></code>
      </example>
    </member>
    <member name="F:NSoft.NFramework.Web.HttpModules.PageAccessLogModule.PRE_REQUEST_LOG_FORMAT">
      <summary>
            Log message format that used Before Request Executing
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.HttpModules.PageAccessLogModule.POST_REQUEST_LOG_FORMAT">
      <summary>
            Log message format that used After Request Executing
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.PageAccessLogModule.Init(System.Web.HttpApplication)">
      <summary>
            모듈을 초기화하고 요청을 처리할 수 있도록 준비합니다.<br />
            요청처리를 위한 전처리/후처리는 <see cref="E:System.Web.HttpApplication.BeginRequest" />, <see cref="E:System.Web.HttpApplication.EndRequest" /> 이벤트에서 하는 것이 아니라,
            <see cref="E:System.Web.HttpApplication.PreRequestHandlerExecute" />, <see cref="E:System.Web.HttpApplication.PostRequestHandlerExecute" />에서 처리하도록 합니다.<br />
            이는 ASP.NET Web Application의 실제 페이지 처리 직전, 직후의 Event가 PreRequestHandlerExecute, PostRequestHandlerExecute이기 때문이다.<br />
            참고 URL : ms-help://MS.MSDNQTR.v90.ko/fxref_system.web/html/aaf0c446-d27c-fe68-155e-0921c2357f02.htm
            </summary>
      <param name="context">
            ASP.NET 응용 프로그램 내의 모든 응용 프로그램 개체에 공통되는 메서드, 속성 및 이벤트에 액세스할 수 있도록 하는 <see cref="T:System.Web.HttpApplication" />입니다. 
            </param>
      <seealso cref="E:System.Web.HttpApplication.BeginRequest" />
      <seealso cref="E:System.Web.HttpApplication.EndRequest" />
      <seealso cref="E:System.Web.HttpApplication.AcquireRequestState" />
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.PageAccessLogModule.Dispose">
      <summary>
        <see cref="T:System.Web.IHttpModule" />을 구현하는 모듈에서 사용하는 리소스(메모리 제외)를 삭제합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.PageAccessLogModule.OnBeginRequestHandler(System.Object,System.EventArgs)">
      <summary>
            ASP.NET에서 페이지 또는 XML Web services 같은 이벤트 처리기의 실행을 시작하기 바로 전에 발생하는 Event에 대한 Handler<br />
            Page 처리 요청정보를 로깅한다.
            </summary>
      <remarks>
            로그 레벨은 DEBUG 입니다.<br />
            이 함수를 override하여, 원하는 형식으로, 원하는 저장소에 기록할 수 있다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.PageAccessLogModule.OnEndRequestHandler(System.Object,System.EventArgs)">
      <summary>
            ASP.NET 이벤트 처리기(예: 페이지 또는 XML Web services)가 실행을 완료하는 경우 발생하는 Event의 Handler<br />
            Page 처리 결과를 로깅한다.
            </summary>
      <remarks>
            로그 레벨은 DEBUG 입니다.<br />
            이 함수를 override하여, 원하는 형식으로, 원하는 저장소에 기록할 수 있다.
            </remarks>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpModules.PagePerformanceModule">
      <summary>
            ASP.NET Page 처리 성능을 알아보기 위해 log4net을 이용하여 성능 측정값을 로그에 쓴다.
            </summary>
      <remarks>
            이 모듈을 사용하려면 log4net 을 사용해야하고, Log Level은 DEBUG 여야 합니다.<br />
            
            log4net layout conversion Pattern에 %property{page_duration} 을 추가하면 duration값이 나온다.
            PagePerformanceModule에 대해서만 다른 log appender를 사용하면, 특정 DB / TABLE에 따로 저장할 수 있다.
            </remarks>
      <example>
            IIS 7.0 클래식 모드와 IIS 7.0 이전 버전에 적용할 때
            <code>
            &lt;configuration&gt;
              &lt;system.web&gt;
            	&lt;httpModule&gt;
            		&lt;add name="PagePerformanceModule" type="NSoft.NFramework.Web.HttpModules.PagePerformanceModule, NSoft.NFramework.Web"/&gt;
            	&lt;/httpModule&gt;
              &lt;/system.web&gt;
            &lt;/configuration&gt;
            </code>
            IIS 7.0 통합모드에 적용할 때
            <code>
            &lt;configuration&gt;
              &lt;system.webServer&gt;
            	&lt;module&gt;
            		&lt;add name="PagePerformanceModule" type="NSoft.NFramework.Web.HttpModules.PagePerformanceModule, NSoft.NFramework.Web"/&gt;
            	&lt;/module&gt;
              &lt;/system.webServer&gt;
            &lt;/configuration&gt;
            </code>
            log4net layout conversionPattern
            <code>
            // AdoAppender 등 DB를 사용해서 성능 정보를 DB화 할 수 있습니다.
            &lt;param name="ConversionPattern" value="%property{pageUrl} %property{startTime} %property{duration}" /&gt;
            </code></example>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.PagePerformanceModule.Init(System.Web.HttpApplication)">
      <summary>
            모듈을 초기화하고 요청을 처리할 수 있도록 준비합니다.<br /></summary>
      <remarks>
            요청처리를 위한 전처리/후처리는 <see cref="E:System.Web.HttpApplication.BeginRequest" />, <see cref="E:System.Web.HttpApplication.EndRequest" /> 이벤트에서 하는 것이 아니라,
            <see cref="E:System.Web.HttpApplication.PreRequestHandlerExecute" />, <see cref="E:System.Web.HttpApplication.PostRequestHandlerExecute" />에서 처리하도록 합니다.<br />
            이는 ASP.NET Web Application의 실제 페이지 처리 직전, 직후의 Event가 PreRequestHandlerExecute, PostRequestHandlerExecute이기 때문이다.<br />
            참고 URL : ms-help://MS.MSDNQTR.v90.ko/fxref_system.web/html/aaf0c446-d27c-fe68-155e-0921c2357f02.htm"
            </remarks>
      <param name="context">
            ASP.NET 응용 프로그램 내의 모든 응용 프로그램 개체에 공통되는 메서드, 속성 및 이벤트에 액세스할 수 있도록 하는 <see cref="T:System.Web.HttpApplication" />입니다. 
            </param>
      <seealso cref="E:System.Web.HttpApplication.BeginRequest" />
      <seealso cref="E:System.Web.HttpApplication.EndRequest" />
      <seealso cref="E:System.Web.HttpApplication.AcquireRequestState" />
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.PagePerformanceModule.Dispose">
      <summary>
        <see cref="T:System.Web.IHttpModule" />을 구현하는 모듈에서 사용하는 리소스(메모리 제외)를 삭제합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.PagePerformanceModule.OnPreRequestHandlerExecute(System.Object,System.EventArgs)">
      <summary>
            ASP.NET에서 페이지 또는 XML Web services 같은 이벤트 처리기의 실행을 시작하기 바로 전에 발생하는 Event에 대한 Handler<br />
            Page 처리 시작 시각을 기록합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.PagePerformanceModule.OnPostRequestHandlerExecute(System.Object,System.EventArgs)">
      <summary>
            ASP.NET 이벤트 처리기(예: 페이지 또는 XML Web services)가 실행을 완료하는 경우 발생하는 Event의 Handler<br />
            성능측정을 하고, 결과를 로그에 기록합니다. 로그 레벨은 DEBUG 입니다.
            </summary>
      <remarks>
            로그 레벨은 DEBUG 입니다.
            재정의를 통해 로그 형식등을 변경할 수 있습니다.
            </remarks>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpModules.UserLocalizationModule">
      <summary>
            웹 Application이 다국어를 지원할 경우, 사용자별 Locale 지정을 관리한다.
            </summary>
      <remarks>
            로깅관련 포맷 및 레벨을 환경설정에서 설정할 수 있도록 하면 좋겠다.
            </remarks>
      <example>
            IIS 7.0 클래식 모드와 IIS 7.0 이전 버전에 적용할 때
            <code><configuration><system.web><httpModule><add name="UserLocalizationModule" type="NSoft.NFramework.Web.HttpModules.UserLocalizationModule, NSoft.NFramework.Web" /></httpModule></system.web></configuration></code>
            IIS 7.0 통합모드에 적용할 때
            <code><configuration><system.webServer><module><add name="UserLocalizationModule" type="NSoft.NFramework.Web.HttpModules.UserLocalizationModule, NSoft.NFramework.Web" /></module></system.webServer></configuration></code>
            
            AppSetting에 설정할 정보 ( User Locale을 사용할 것인지, User Locale 정보가 저장될 쿠키 명)
            <code><appSettings><add key="Use.UserLocale" value="True" /><add key="UserLocale.CookieName" value="_USER_COOKIE_" /></appSettings></code></example>
    </member>
    <member name="F:NSoft.NFramework.Web.HttpModules.UserLocalizationModule.USE_USERLOCALE_KEY">
      <summary>
            사용자 Locale 정보를 사용할지 여부에 대한 AppSetting의 키 (Localization.Use.UserLocale)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.HttpModules.UserLocalizationModule.USER_LOCALE_COOKIE">
      <summary>
            사용자 Locale 정보를 저장할 쿠키 이름에 대한 AppSetting의 키 (Localization.UserLocale.CookieName)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.HttpModules.UserLocalizationModule.DEFAULT_USER_LOCALE_COOKIE_NAME">
      <summary>
            사용자 Locale 정보를 저장할 쿠키 이름의 기본값 (_USER_LOCALE_) (다른 것으로 변경하려면 <see cref="P:NSoft.NFramework.Web.HttpModules.UserLocalizationModule.UserLocaleCookieName" /> 설명을 참조하세요.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.UserLocalizationModule.Init(System.Web.HttpApplication)">
      <summary>
            모듈을 초기화하고 요청을 처리할 수 있도록 준비합니다.
            </summary>
      <param name="context">
            ASP.NET 응용 프로그램 내의 모든 응용 프로그램 개체에 공통되는 메서드, 속성 및 이벤트에 액세스할 수 있도록 하는 <see cref="T:System.Web.HttpApplication" />입니다. 
            </param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.UserLocalizationModule.Dispose">
      <summary>
        <see cref="T:System.Web.IHttpModule" />을 구현하는 모듈에서 사용하는 리소스(메모리 제외)를 삭제합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.UserLocalizationModule.OnBeginRequest(System.Object,System.EventArgs)">
      <summary>
            ASP.NET에서 현재 요청과 관련된 현재 상태(예: 세션 상태)를 가져오는 경우 발생하는 이벤트에 대한 핸들러입니다.<br />
            사용자의 Locale 정보를 읽어서 현재 Context의 CultureInfo를 설정합니다. 
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpModules.UserLocalizationModule.UseUserLocale">
      <summary>
            Web Application의 Culture를 사용하는 것이 아니라, 사용자별로 다국어를 지원할 것인지 여부를 판단합니다.<br />
            AppSettings에 정의되어 있지 않다면, True를 기본값으로 합니다.
            </summary>
      <remarks>
            사용자별로 Culture를 사용한다면, 다음의 정보를 이용하여
            1. <see cref="P:NSoft.NFramework.Web.HttpModules.UserLocalizationModule.UserLocaleCookieName" />의 쿠키 정보<br />
            2. 사용자 Browser의 사용가능한 Language중의 첫번째 것 (<see cref="P:System.Web.HttpRequest.UserLanguages" />)<br />
            Culture를 지정합니다.
            </remarks>
      <example>
        <code>
            // web.Config appSettings에 Use.UserLocale이 정의되어 있어야 합니다. (없으면 True로 간주합니다.)
            <appSettings><add key="Localization.Use.UserLocale" value="True" /></appSettings></code>
      </example>
    </member>
    <member name="P:NSoft.NFramework.Web.HttpModules.UserLocalizationModule.UserLocaleCookieName">
      <summary>
            사용자 Locale 정보가 저장될 쿠키 명<br />
            appSettings에 UserLocale.CookieName 의 값을 가져옵니다.<br />
            AppSettings에 정의되어 있지 않다면 <see cref="F:NSoft.NFramework.Web.HttpModules.UserLocalizationModule.DEFAULT_USER_LOCALE_COOKIE_NAME" /> 을 기본값으로 사용합니다.
            </summary>
      <example>
        <code>
            // web.Config appSettings에 UserLocale.CookieName이 정의되어 있어야 합니다.
            <appSettings><add key="Localization.UserLocale.CookieName" value="_USER_LOCALE_" /></appSettings></code>
      </example>
    </member>
    <member name="T:NSoft.NFramework.Web.HttpModules.WindsorHttpModule">
      <summary>
            Web Application에서 Castle.Windsor 를 이용한 IoC 를 초기화를 담당한다.<br />
            IoCHttpModule을 사용하면, <see cref="T:NSoft.NFramework.Web.HttpApplications.WindsorHttpApplication" />와 같이 상속을 받을 필요 없이, 
            IoC Container에 대한 초기화를 담당해주므로, 확장성이 뛰어나고, DNN 처럼 CustomHttpApplication이 있는 경우에 PlugIn 방식으로 끼워 넣을 수도 있다.
            </summary>
      <remarks>
            이 모듈을 사용하려면 환경설정에 기본적으로 Castle.Windsor 환경 설정 정보가 있어야 합니다. 
            <see cref="T:NSoft.NFramework.InversionOfControl.IoC" /> 사용시에 초기화 여부를 검사할 필요가 없다.
            </remarks>
      <example>
            IIS 7.0 클래식 모드와 IIS 7.0 이전 버전에 적용할 때
            <code><configuration><system.web><httpModule><add name="WindsorHttpModule" type="NSoft.NFramework.Web.WindsorHttpModule, NSoft.NFramework" /></httpModule></system.web></configuration></code>
            IIS 7.0 통합모드에 적용할 때
            <code><configuration><system.webServer><module><add name="WindsorHttpModule" type="NSoft.NFramework.Web.WindsorHttpModule, NSoft.NFramework" /></module></system.webServer></configuration></code></example>
      <seealso cref="T:NSoft.NFramework.Web.HttpApplications.WindsorHttpApplication" />
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.WindsorHttpModule.Init(System.Web.HttpApplication)">
      <summary>
            모듈을 초기화하고 요청을 처리할 수 있도록 준비합니다.
            </summary>
      <param name="context">
            ASP.NET 응용 프로그램 내의 모든 응용 프로그램 개체에 공통되는 메서드, 속성 및 이벤트에 액세스할 수 있도록 하는 <see cref="T:System.Web.HttpApplication" />입니다. 
            </param>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.WindsorHttpModule.Dispose">
      <summary>
        <see cref="T:System.Web.IHttpModule" />을 구현하는 모듈에서 사용하는 리소스(메모리 제외)를 삭제합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.WindsorHttpModule.OnBeginRequest(System.Object,System.EventArgs)">
      <summary>
            ASP.NET에서 페이지 또는 XML Web services 같은 이벤트 처리기의 실행을 시작하기 바로 전에 발생하는 Event에 대한 Handler<br />
            IoC 관련 정보를 초기화 합니다.
            </summary>
      <remarks>
            기본 설정 파일이 아닌 다른 파일에 대해 초기화를 하려면 재정의를 해야 한다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Web.HttpModules.WindsorHttpModule.OnEndRequest(System.Object,System.EventArgs)">
      <summary>
            Web Application의 요청 처리 후 사후 처리를 한다. (실제 처리하는 것은 없고, 재정의가 가능하도록 남겨두었다.)
            </summary>
      <param name="sender">
      </param>
      <param name="e">
      </param>
    </member>
    <member name="T:NSoft.NFramework.Web.PageAdapters.IoCPageStateAdapter">
      <summary>
            Castle.Windsor IoC를 이용하여, PageStatePersister를 인스턴싱합니다. IoC 환경설정에서 Persister마다 다양한 설정을 수행할 수 있으므로, 유연성에 좋습니다.
            단 꼭 component의 lifestyle을 transient로 해야 합니다.
            
            참고: http://www.eggheadcafe.com/tutorials/aspnet/b48875f6-525b-4267-a3a8-64dd33bfc2fe/keep-viewstate-out-of-pag.aspx
            참고: http://www.codeproject.com/KB/viewstate/ViewStateTricks.aspx
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.PageAdapters.IoCPageStateAdapter.GetStatePersister">
      <summary>
            컨트롤 상태와 뷰 상태를 유지하기 위해 웹 페이지에서 사용하는 개체를 반환합니다.
            </summary>
      <returns>
        <see cref="T:System.Web.UI.Page" />의 결합된 컨트롤 상태와 뷰 상태를 만들고 추출하는 것을 지원하는 <see cref="T:System.Web.UI.PageStatePersister" />에서 파생된 개체입니다.
            </returns>
    </member>
    <member name="T:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister">
      <summary>
            ViewState를 다른 저장소에 저장하고, Load해서, 네트웍 속도를 증가시키도록 합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.IServerPageStatePersister">
      <summary>
        <see cref="T:System.Web.UI.PageStatePersister" />를 IoC를 통해 다양하게 제공하기 위해 Service Type으로 제공하기 위해 인터페이스를 정의합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.IServerPageStatePersister.Load">
      <summary>
            저장된 Page의 ViewState 정보를 Load합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.IServerPageStatePersister.Save">
      <summary>
            Page의 ViewState 정보를 원하는 장소(Cache, 파일, DB 등)에 저장합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.IServerPageStatePersister.PersisterName">
      <summary>
            Persister Type Name  
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.IServerPageStatePersister.Compressor">
      <summary>
            ViewState를 압축 저장하기 위한 Compressor. Compressor가 지정되지 않았으면, 기본적으로 <see cref="T:NSoft.NFramework.Compressions.Compressors.SharpGZipCompressor" />을 사용합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.IServerPageStatePersister.CompressThreshold">
      <summary>
            최소 압축 크기
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.IServerPageStatePersister.Expiration">
      <summary>
            ViewState 유효 기간
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.PersisterKey">
      <summary>
            어떤 종류의 Persister인지를 Client에 알려주기 위해 Hidden Field로 알려줍니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.StateKey">
      <summary>
            State 값이 저장된 저장소의 토큰 값을 나타내는 Hidden Field Name입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.Load">
      <summary>
            저장된 Page의 ViewState 정보를 Load합니다. Load 후에는 저장소에서 삭제하셔야 합니다. ViewState는 매 요청시마다 다른 토큰으로 저장되기 때문입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.Save">
      <summary>
            Page의 ViewState 정보를 원하는 장소(Cache, 파일, DB 등)에 저장합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.LoadFromRepository">
      <summary>
            ViewState 저장소로부터 저장된 ViewState 정보를 가져옵니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.SaveToRepository">
      <summary>
            Page의 ViewState 정보를 특정 저장소에 저장하고, 저장 토큰 값을 <see cref="P:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.StateValue" />에 저장합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.GetCacheKey">
      <summary>
            Persister만을 위한 캐시 키를 빌드합니다. (캐시 시스템에서 다른 용도의 캐시 정보와 구분하기 위해 PersisterName을 Prefix로 사용합니다)
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.CreateStateValue">
      <summary>
            새로운 StateValue를 생성합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.PersisterName">
      <summary>
            Persister Type Name 
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.StateValue">
      <summary>
            ViewState 키 값
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.CompressThreshold">
      <summary>
            최소 압축 크기
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.Expiration">
      <summary>
            ViewState 유효 기간 (분단위)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.Compressor">
      <summary>
            ViewState를 압축 저장하기 위한 Compressor. Compressor가 지정되지 않았으면, 기본적으로 <see cref="T:NSoft.NFramework.Compressions.Compressors.SharpGZipCompressor" />을 사용합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.Serializer">
      <summary>
            Binary Serializer
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.PageStatePersisters.CompressableSessionPageStatePersister">
      <summary>
            웹 페이지의 상태정보(ViewState)정보를 Session에 압축 저장하고, 필요 시 로드합니다. 
            
            참고: http://www.eggheadcafe.com/tutorials/aspnet/b48875f6-525b-4267-a3a8-64dd33bfc2fe/keep-viewstate-out-of-pag.aspx
            참고: http://www.codeproject.com/KB/aspnet/ViewStateTricks.aspx
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.PageStatePersisters.CompressableSessionPageStatePersister.LoadFromRepository">
      <summary>
            ViewState 저장소로부터 저장된 ViewState 정보를 가져옵니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.PageStatePersisters.CompressableSessionPageStatePersister.SaveToRepository">
      <summary>
            Page의 ViewState 정보를 특정 저장소에 저장하고, 저장 토큰 값을 <see cref="P:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.StateValue" />에 저장합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.PageStatePersisters.CompressHiddenFieldPersister">
      <summary>
            Page의 상태정보를 <see cref="T:NSoft.NFramework.Compressions.ICompressor" />으로 압축하여 Client Hidden Field로 저장하여, Client에 전송하고, Postback시에는 압축 복원합니다. 
            통신량을 줄여, 속도를 향상시킵니다.
            
            참고: http://www.codeproject.com/KB/viewstate/ViewStateTricks.aspx
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.PageStatePersisters.ConcurrentPageStatePersister">
      <summary>
        <see cref="T:NSoft.NFramework.Caching.ConcurrentCacheRepository" />를 이용한 PageStatePersister 입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.PageStatePersisters.PageStatePersister`1">
      <summary>
      </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Web.PageStatePersisters.PageStatePersister`1.LoadFromRepository">
      <summary>
            ViewState 저장소로부터 저장된 ViewState 정보를 가져옵니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.PageStatePersisters.PageStatePersister`1.SaveToRepository">
      <summary>
            Page의 ViewState 정보를 특정 저장소에 저장하고, 저장 토큰 값을 <see cref="P:NSoft.NFramework.Web.PageStatePersisters.AbstractServerPageStatePersister.StateValue" />에 저장합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.PageStatePersisters.PageStateEntity">
      <summary>
            Web Page 상태 정보를 Persister가 저장하고 로드하는 엔티티의 원형입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.IPageStateEntity">
      <summary>
            Web Page 상태 정보를 Persister가 저장하고 로드하는 엔티티의 인터페이스입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.IPageStateEntity.Id">
      <summary>
            엔티티의 Identifier
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.IPageStateEntity.IsCompressed">
      <summary>
            압축 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.IPageStateEntity.Value">
      <summary>
            Page 상태 정보의 Snapshot
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.IPageStateEntity.CreatedDate">
      <summary>
            생성 일자
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.PageStatePersisters.PageStateEntity.Id">
      <summary>
            엔티티의 Identifier
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.PageStatePersisters.PageStateEntity.IsCompressed">
      <summary>
            압축 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.PageStatePersisters.PageStateEntity.Value">
      <summary>
            Page 상태 정보의 Snapshot
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.PageStatePersisters.PageStateEntity.CreatedDate">
      <summary>
            생성 일자
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.PageStatePersisters.PageStateTool">
      <summary>
            웹 Page 상태 정보를 관리하는 Utility 클래스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.PageStatePersisters.PageStateTool.CreateStateEntity(System.String,System.Object,NSoft.NFramework.Compressions.ICompressor,System.Int32)">
      <summary>
        <paramref name="pageState" /> 정보를 직렬화해서, <see cref="T:NSoft.NFramework.Web.IPageStateEntity" /> 객체로 빌드합니다.
            </summary>
      <param name="id">
      </param>
      <param name="pageState">
      </param>
      <param name="compressor">
      </param>
      <param name="compressThreshold">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.PageStatePersisters.PageStateTool.TryParseStateEntity(NSoft.NFramework.Web.IPageStateEntity,NSoft.NFramework.Compressions.ICompressor,System.Object@)">
      <summary>
        <paramref name="stateEntity" /> 정보를 파싱하여 원본 Page 상태정보를 빌드합니다.
            </summary>
      <param name="stateEntity">
      </param>
      <param name="compressor">
      </param>
      <param name="pageState">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.Web.PageStatePersisters.SysCachePageStatePersister">
      <summary>
            Web Page 상태를 서버 ASP.NET Cache에 압축 저장하도록 해주는 PageStatePersister 입니다.
            
            참고: http://www.eggheadcafe.com/tutorials/aspnet/b48875f6-525b-4267-a3a8-64dd33bfc2fe/keep-viewstate-out-of-pag.aspx
            참고: http://www.codeproject.com/KB/viewstate/ViewStateTricks.aspx
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.PageStatePersisters.SysCachePageStatePersister.#ctor(System.Web.UI.Page)">
      <summary>
            생성자
            </summary>
      <param name="page">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.HtmlEncode(System.String)">
      <summary>
            HTML 문서상의 TEXT로 안정된 문자열로 변환한다.
            </summary>
      <param name="value">입력 문자열</param>
      <returns>HTML 로 인코딩된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.HtmlEncode(System.Object,System.String)">
      <summary>
            HTML 문서상의 TEXT로 안정된 문자열로 변환한다.
            </summary>
      <param name="value">입력 값</param>
      <param name="defaultValue">입력 값이 null 이거나 빈 문자열일 경우 대체할 기본 값</param>
      <returns>HTML 로 인코딩된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.HtmlAttributeEncode(System.String)">
      <summary>
            HTML Element의 Attribute 값을 안전한 값으로 인코딩한다.
            </summary>
      <param name="value">일반 문자열</param>
      <returns>HTML Element의 Attribute 값에 지정할 안전한 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.HtmlAttributeEncode(System.Object,System.String)">
      <summary>
            HTML Element의 Attribute 값을 안전한 값으로 인코딩한다.
            </summary>
      <param name="value">Attribute에 지정될 값</param>
      <param name="defaultValue">지정될 값이 null이거나 빈 문자열일때 대체할 문자열</param>
      <returns>HTML Element의 Attribute 값에 지정할 안전한 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.UrlEncode(System.String)">
      <summary>
            URL 주소를 Encoding 한다.
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.UrlEncode(System.Object,System.String)">
      <summary>
            URL 주소를 Encoding 한다.
            </summary>
      <param name="value">
      </param>
      <param name="defaultValue">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.XmlEncode(System.String)">
      <summary>
            XML 문법에 맞는 문자열로 인코딩한다.
            </summary>
      <param name="value">원본 문자열</param>
      <returns>Xml 형식으로 인코딩된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.XmlEncode(System.Object,System.String)">
      <summary>
            XML 문법에 맞는 문자열로 인코딩한다.
            </summary>
      <param name="value">원본 문자열</param>
      <param name="defaultValue">원본이 null이거나 빈 문자열이면, 대체할 값</param>
      <returns>Xml 형식으로 인코딩된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.XmlAttributeEncode(System.String)">
      <summary>
            XML Attribute Node에 들어갈 문자열을 XML 형식에 맞게끔 인코딩한다.
            </summary>
      <param name="value">원본 문자열</param>
      <returns>XML 포맷으로 인코딩된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.XmlAttributeEncode(System.Object,System.String)">
      <summary>
            XML Attribute Node에 들어갈 문자열을 XML 형식에 맞게끔 인코딩한다.
            </summary>
      <param name="value">원본 문자열</param>
      <param name="defaultValue">원본이 null이거나 빈문자열일 경우, 대체할 기본값</param>
      <returns>XML 포맷으로 인코딩된 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.JavaScriptEncode(System.String,System.Boolean)">
      <summary>
            javascript 문을 동적으로 생성할 때 script 코드 내용을 javascript 문법에 맞게끔 인코딩한다.
            </summary>
      <param name="value">인코딩할 문자열</param>
      <param name="flagForQuote">인용문구를 씌울 것인가?</param>
      <returns>javascript 형식에 맞는 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.JavaScriptEncode(System.Object,System.String)">
      <summary>
            javascript 문을 동적으로 생성할 때 script 코드 내용을 javascript 문법에 맞게끔 인코딩한다.
            </summary>
      <param name="value">인코딩할 문자열</param>
      <param name="defaultValue">대상값이 null이거나 빈문자열인 경우, 대체할 기본값</param>
      <returns>javascript 형식에 맞는 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.VBScriptEncode(System.String)">
      <summary>
            Visual Basic Script 문을 동적으로 생성시, script 코드 내용을 vb script 문법에 맞게끔 인코딩한다.
            </summary>
      <param name="value">대상 문자열</param>
      <returns>Visual Basic Script 로 인코딩한 문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.AntiXssTool.VBScriptEncode(System.Object,System.String)">
      <summary>
            Visual Basic Script 문을 동적으로 생성시, script 코드 내용을 vb script 문법에 맞게끔 인코딩한다.
            </summary>
      <param name="value">대상 문자열</param>
      <param name="defaultValue">대상 문자열이 null이거나 빈 문자열인 경우, 대체할 기본값</param>
      <returns>Visual Basic Script 로 인코딩한 문자열</returns>
    </member>
    <member name="T:NSoft.NFramework.Web.ClientScriptUtils">
      <summary>
            Client Script (javascript, vbscript)를 생성하기 위한 Utility Class
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.ToJsSingleQuoteSafeString(System.String)">
      <summary>
            Toes the js single quote safe string.
            </summary>
      <param name="str">The STR.</param>
      <returns>The formated str.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.ToJsDoubleQuoteSafeString(System.String)">
      <summary>
            Toes the js double quote safe string.
            </summary>
      <param name="str">The STR.</param>
      <returns>The formated str.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.ToVbsQuoteSafeString(System.String)">
      <summary>
            Toes the VBS quote safe string.
            </summary>
      <param name="str">The STR.</param>
      <returns>The formated str.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.WrapScriptTag(System.String[])">
      <summary>
            Wraps the script tag.
            </summary>
      <param name="scripts">The scripts.</param>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.PopAlert(System.String)">
      <summary>
            Pops the alert.
            </summary>
      <param name="msg">The MSG.</param>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.PopConfirm(System.String)">
      <summary>
            Pops the confirm.
            </summary>
      <param name="msg">The MSG.</param>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.PopPrompt(System.String,System.String)">
      <summary>
            Pops the prompt.
            </summary>
      <param name="msg">The MSG.</param>
      <param name="defaultValue">The default value.</param>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.CloseSelf">
      <summary>
            Closes the self.
            </summary>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.CloseParent">
      <summary>
            Closes the parent.
            </summary>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.CloseOpener">
      <summary>
            Closes the opener.
            </summary>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.RefreshSelf">
      <summary>
            Refreshes the self.
            </summary>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.RefreshOpener">
      <summary>
            Refreshes the opener.
            </summary>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.RefreshParent">
      <summary>
            Refreshes the parent.
            </summary>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.ShowModalDialog(System.String,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
      <summary>
            Shows the modal dialog.
            </summary>
      <param name="url">The URL.</param>
      <param name="status">if set to <c>true</c> [status].</param>
      <param name="resizable">if set to <c>true</c> [resizable].</param>
      <param name="height">The height.</param>
      <param name="width">The width.</param>
      <param name="top">The top.</param>
      <param name="left">The left.</param>
      <param name="scroll">if set to <c>true</c> [scroll].</param>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.ShowModalDialog(System.String,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Shows the modal dialog.
            </summary>
      <param name="url">The URL.</param>
      <param name="status">if set to <c>true</c> [status].</param>
      <param name="resizable">if set to <c>true</c> [resizable].</param>
      <param name="height">The height.</param>
      <param name="width">The width.</param>
      <param name="center">if set to <c>true</c> [center].</param>
      <param name="scroll">if set to <c>true</c> [scroll].</param>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.ShowModelessDialog(System.String,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
      <summary>
            Shows the modeless dialog.
            </summary>
      <param name="url">The URL.</param>
      <param name="status">if set to <c>true</c> [status].</param>
      <param name="resizable">if set to <c>true</c> [resizable].</param>
      <param name="height">The height.</param>
      <param name="width">The width.</param>
      <param name="top">The top.</param>
      <param name="left">The left.</param>
      <param name="scroll">if set to <c>true</c> [scroll].</param>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.ShowModelessDialog(System.String,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Shows the modeless dialog.
            </summary>
      <param name="url">The URL.</param>
      <param name="status">if set to <c>true</c> [status].</param>
      <param name="resizable">if set to <c>true</c> [resizable].</param>
      <param name="height">The height.</param>
      <param name="width">The width.</param>
      <param name="center">if set to <c>true</c> [center].</param>
      <param name="scroll">if set to <c>true</c> [scroll].</param>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.SelfGoBack">
      <summary>
            Selfs the go back.
            </summary>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.ParentGoBack">
      <summary>
            Parents the go back.
            </summary>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.OpenerGoBack">
      <summary>
            Openers the go back.
            </summary>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.Open(System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Opens the specified URL.
            </summary>
      <param name="url">The URL.</param>
      <param name="frameName">Name of the frame.</param>
      <param name="status">if set to <c>true</c> [status].</param>
      <param name="location">if set to <c>true</c> [location].</param>
      <param name="menubar">if set to <c>true</c> [menubar].</param>
      <param name="resizable">if set to <c>true</c> [resizable].</param>
      <param name="height">The height.</param>
      <param name="width">The width.</param>
      <param name="top">The top.</param>
      <param name="left">The left.</param>
      <param name="scrollbars">if set to <c>true</c> [scrollbars].</param>
      <param name="toolbar">if set to <c>true</c> [toolbar].</param>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.Open(System.String,System.String)">
      <summary>
            Opens the specified URL.
            </summary>
      <param name="url">The URL.</param>
      <param name="frameName">Name of the frame.</param>
      <returns>The script.</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.ClientScriptUtils.ToJsStringArray(System.String[])">
      <summary>
            Toes the js string array.
            </summary>
      <param name="strs">The STRS.</param>
      <returns>The script.</returns>
    </member>
    <member name="T:NSoft.NFramework.Web.CookieChunker`1">
      <summary>
            Cookie Size를 조절하여 4096 byte보다 큰 경우에는 쪼개서 저장한다.
            </summary>
      <remarks>
            Browser에서 Cookie 관련한 RFC 2109의 추천 조건:<br />
            1. 적어도 300개의 쿠키를 저장할 수 있어야 한다.<br />
            2. 적어도 쿠키 값의 크기는 4096 byte 가 되어야 한다.<br />
            3. 적어도 도메인별 쿠키는 20개를 지원해야 한다.<br /></remarks>
    </member>
    <member name="F:NSoft.NFramework.Web.CookieChunker`1.MAX_SIZE">
      <summary>
            단위 Chunk의 최대 크기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.CookieChunker`1.CHUNK_DELIMITER">
      <summary>
            Chunk 구분자
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.CookieChunker`1.EmptyCookieCollection">
      <summary>
            빈 쿠키 컬렉션
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.CookieChunker`1.Chunk(System.String,`0)">
      <summary>
            지정된 이름과 값을 이용하여, 대용량 값을 chunk하여, 쿠키 컬렉션을 만든다.
            </summary>
      <param name="name">쿠키 명</param>
      <param name="value">쿠키 값</param>
      <returns>collection of chuncked cookies</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.CookieChunker`1.Unchunk(System.Web.HttpCookieCollection,System.String)">
      <summary>
            chunck된 cookie collection으로부터 실제 값을 복원한다.
            </summary>
      <param name="cookies">collection of chunked cookie</param>
      <param name="name">값을 구할 쿠키명</param>
      <returns>쿠키 값</returns>
    </member>
    <member name="P:NSoft.NFramework.Web.CookieChunker`1.Instance">
      <summary>
            Singleton instance of CookieChunker{T}
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.CookieTool">
      <summary>
            Utility class for <see cref="T:System.Web.HttpCookie" /></summary>
      <remarks>
            쿠키 사이즈 제한을 어느정도 없앨 수 있도록, 압축 및 Chunking을 지원합니다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Web.CookieTool.Set(System.String,System.String,System.Nullable{System.DateTime},System.String)">
      <summary>
            쿠키에 문자열 값을 저장합니다.
            </summary>
      <param name="name">쿠키 명</param>
      <param name="value">쿠키 값 (Plain Text여야 합니다.)</param>
      <param name="expireDate">유효기간</param>
      <param name="domain">쿠키 도메인명</param>
    </member>
    <member name="M:NSoft.NFramework.Web.CookieTool.Get(System.String)">
      <summary>
            지정된 쿠키에 저장된 값을 반환합니다.
            </summary>
      <param name="name">쿠키 명</param>
      <returns>쿠키 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.CookieTool.Get``1(System.String,``0)">
      <summary>
            지정된 쿠키에 저장된 값을 형변환을 하여 반환합니다.
            </summary>
      <typeparam name="T">반환받는 값의 형식</typeparam>
      <param name="name">쿠키명</param>
      <param name="defaultValue">쿠키 값 얻기에 실패했을 시에 사용할 기본값</param>
      <returns>쿠키 값</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.CookieTool.SetChuck``1(System.String,``0,System.Nullable{System.DateTime},System.String)">
      <summary>
            쿠키 정보를 생성하여 HttpResponse에 추가합니다. 대용량 값인 경우 <see cref="T:NSoft.NFramework.Web.CookieChunker`1" />를 이용하여 값을 조각내어 저장합니다.
            </summary>
      <typeparam name="T">쿠키 값의 수형</typeparam>
      <param name="name">쿠키 명</param>
      <param name="value">쿠키 값</param>
      <param name="expireDate">폐기일자</param>
      <param name="domain">Domain name</param>
    </member>
    <member name="M:NSoft.NFramework.Web.CookieTool.GetChuck``1(System.String)">
      <summary>
            HttpRequeest로부터 쿠키 정보를 읽어옵니다.
            </summary>
      <typeparam name="T">쿠키 값의 수형</typeparam>
      <param name="name">쿠키 명</param>
      <returns>해당 쿠키 값, 없으면 기본값 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Web.CookieTool.DeleteChuck(System.String)">
      <summary>
            Delete cookie by name
            </summary>
      <param name="name">cookie name</param>
      <returns>삭제여부</returns>
    </member>
    <member name="T:NSoft.NFramework.Web.UrlBuilder">
      <summary>
            URL 문자열을 Fluent 방식으로 빌드해주는 클래스입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.WebControlUtils">
      <summary>
            UserControl 조작에 사용되는 Utility Class
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.WebControlUtils.RenderControlAsString(System.Web.UI.Control)">
      <summary>
        <see cref="T:System.Web.UI.Control" />를 Rendering 해서 문자열로 반환한다.
            </summary>
      <param name="ctrl">control to render as string</param>
      <returns>string of control</returns>
    </member>
    <member name="T:NSoft.NFramework.Web.Tools.WebTool">
      <summary>
      </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.Tools.WebTool.ScriptSeparatorChar">
      <summary>
            Script Path 구분자 ('/')
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.Tools.WebTool.DefaultMimetype">
      <summary>
            기본 Mime type
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.Tools.WebTool.JavascriptMimetype">
      <summary>
            Javascript 파일의 Mime type (application/javascript)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.Tools.WebTool.NoCompressionFileExtensions">
      <summary>
            이미 압축이 되어 있는 파일을 압축할 필요 없다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetUserIdentity">
      <summary>
            로그인 사용자의 <see cref="T:System.Security.Principal.IIdentity" /> 정보를 반환한다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.RemoveHtml(System.String)">
      <summary>
            HTML 문자열에서 HTML Tag를 제거하고, 순수 TEXT만 반환합니다.
            </summary>
      <param name="htmlString">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetQueryString(System.Web.HttpRequest)">
      <summary>
        <see cref="P:System.Web.HttpRequest.QueryString" />의 모든 정보를 문자열로 반환한다.
            </summary>
      <param name="request">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetAppSettings``1(System.String,``0)">
      <summary>
            web.config의 appSetting의 값을 읽어온다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="key">
      </param>
      <param name="defaultValue">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetAppSettings(System.String)">
      <summary>
            현재 호출자가 Web Context하에서 호출되면 Web Application 환경설정 중에 appSettings 의 정보를 가져오고,
            Application Context 하에서 호출되면 Application 환경 설정 중의 appSettings에서 정보를 가져온다.
            </summary>
      <param name="key">
      </param>
      <returns>
      </returns>
      <seealso cref="T:System.Web.Configuration.WebConfigurationManager" />
      <seealso cref="T:System.Configuration.ConfigurationManager" />
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetConnectionStringSettings(System.String)">
      <summary>
            환경설정에서 지정된 이름의 <see cref="T:System.Configuration.ConnectionStringSettings" /> 인스턴스를 가져온다.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetConnectionString(System.String)">
      <summary>
            지정된 이름의 ConnectionString 정보를 가져온다.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetPhysicalPath(System.String)">
      <summary>
            파일 경로를 상대적인 값으로 표현 했을 경우
            </summary>
      <param name="virtualPath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetScriptPath(System.String)">
      <summary>
            Script 전체 경로를 반환한다.
            </summary>
      <param name="virtualPath">
      </param>
      <returns>
      </returns>
      <seealso cref="M:System.Web.UI.Control.ResolveUrl(System.String)" />
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.CanBrowserAcceptGzip(System.Web.HttpContext)">
      <summary>
            현재 context 의 client가 GZip 압축을 지원하는지?
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.CanBrowserAcceptDeflate(System.Web.HttpContext)">
      <summary>
            현재 context 의 client가 Deflate 압축을 지원하는지?
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.SaveCacheItem(System.Web.Caching.Cache,System.String,System.Object,System.TimeSpan)">
      <summary>
            정보를 Cache에 저장합니다.
            </summary>
      <param name="cache">
      </param>
      <param name="key">
      </param>
      <param name="value">
      </param>
      <param name="slidingExpiration">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.LoadCacheItem(System.Web.Caching.Cache,System.String,System.Func{System.Object})">
      <summary>
            캐시에서 지정된 키의 값을 반환한다.
            </summary>
      <param name="cache">
      </param>
      <param name="key">
      </param>
      <param name="defaultValueFactory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.RemoveCacheItem(System.Web.Caching.Cache,System.String)">
      <summary>
            캐시에서 지정된 키의 값을 제거하여, 반환한다.
            </summary>
      <param name="cache">
      </param>
      <param name="key">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetUrlScheme(System.Web.HttpContext)">
      <summary>
        <paramref name="context" />의 Uri Sheme을 추출합니다. 기본은 http 입니다.
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetPort(System.Web.HttpContext)">
      <summary>
        <paramref name="context" />의 Http Port 값을 추출합니다.
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetHostName(System.Web.HttpContext)">
      <summary>
             Web Application 서버 이름 (ex: www.realweb21.com, localhost)
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetServerName(System.Web.HttpContext)">
      <summary>
            서버 이름 (예: http://www.realweb21.com:8080)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetApplicationVirtualPath(System.Web.HttpContext)">
      <summary>
            ASP.NET 응용 프로그램의 가상 응용 프로그램 루트 경로를 서버에서 가져옵니다. (예: /NFramework )
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetApplicationRootPath(System.Web.HttpContext)">
      <summary>
            ASP.NET 응용 프로그램의 Root Path를 가져옵니다. (예: http://localhost:3500/NFramework )
            </summary>
      <param name="context">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.WriteResponse(System.Web.HttpContext,System.Byte[],System.Action{System.Web.HttpResponse})">
      <summary>
            응답 정보를 <paramref name="context" />에 씁니다. <paramref name="responseSettings" />을 통해 <see cref="T:System.Web.HttpResponse" />의 부가 설정을 수행합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.WriteResponse(System.Web.HttpContext,System.String,System.Action{System.Web.HttpResponse})">
      <summary>
            응답 정보를 <paramref name="context" />에 씁니다. <paramref name="responseSettings" />을 통해 <see cref="T:System.Web.HttpResponse" />의 부가 설정을 수행합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.GetMime(System.String)">
      <summary>
            지정된 파일명의 MIME Type을 구합니다.
            </summary>
      <param name="filename">파일명이나 extensions (예: png)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.SerializeSessionState(System.Web.SessionState.SessionStateItemCollection)">
      <summary>
            Session 정보를 직렬화합니다. (일반적인 직렬화 방식은 안되고, SessionStateItemCollection 자체의 Serialize를 사용해서 직렬화합니다.)
            </summary>
      <param name="items">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.Tools.WebTool.DeserializeSessionState(System.Byte[])">
      <summary>
            Session 정보를 역직렬화합니다.  (일반적인 역직렬화 방식은 안되고, SessionStateItemCollection 자체의 Deserialize를 사용해서 직렬화합니다.)
            </summary>
      <param name="serializedItems">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Web.Tools.WebTool.IsWebContext">
      <summary>
            웹 Application Context가 존재하는가?
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.Tools.WebTool.HostName">
      <summary>
            Web Application 서버 이름 (ex: www.realweb21.com, localhost)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.Tools.WebTool.Port">
      <summary>
            Web Application 의 Port Number (기본은 80)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.Tools.WebTool.ServerName">
      <summary>
            서버 이름 (ex: http://www.realweb21.com:8080)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.Tools.WebTool.AppPath">
      <summary>
            ASP.NET 응용 프로그램의 가상 응용 프로그램 루트 경로를 서버에서 가져옵니다. (예: /NFramework )
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.Tools.WebTool.ApplicationRootPath">
      <summary>
            ASP.NET 응용 프로그램의 Root Path를 가져옵니다. (예: http://localhost:3500/NFramework )
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Web.Tools.WebTool.UserName">
      <summary>
            로그인 사용자 이름을 반환한다. User Identity가 없으면 Username은 빈문자열이다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.AbstractSessionStateStoreProvider">
      <summary>
            ASP.NET 웹 Application의 세션 정보를  캐시 서버에 저장해주는 클래스입니다. <br />
            참고 : https://github.com/enyim/EnyimMemcached/wiki/MemcachedClient-Usage
            참고 : http://msdn.microsoft.com/en-us/library/ms178589.aspx
            </summary>
      <example>
        <code>
            // web.config 에서 다음과 같이 환경 설정하면 됩니다.
            <system.web><sessionState cookieless="true" regenerateExpiredSessionId="true" mode="Custom" customProvider="MemcachedSessionStateStoreProvider"><providers><add name="MemcachedSessionStateStoreProvider" type="NSoft.NFramework.Memcached.Web.MemcachedSessionStateStoreProvider, NSoft.NFramework.Memcached" /></providers></sessionState></system.web></code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.#ctor">
      <summary>
            생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.#ctor(System.Func{NSoft.NFramework.ICacheRepository})">
      <summary>
            생성자
            </summary>
      <param name="repositoryFactory">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.CreateNewStoreData(System.Web.HttpContext,System.Int32)">
      <summary>
            현재 요청에 사용할 새 <see cref="T:System.Web.SessionState.SessionStateStoreData" /> 개체를 만듭니다.
            </summary>
      <returns>
            현재 요청에 대한 새 <see cref="T:System.Web.SessionState.SessionStateStoreData" />입니다.
            </returns>
      <param name="context">현재 요청에 대한 <see cref="T:System.Web.HttpContext" />입니다.</param>
      <param name="timeout">새 <see cref="T:System.Web.SessionState.SessionStateStoreData" />의 세션 상태 <see cref="P:System.Web.SessionState.HttpSessionState.Timeout" /> 값입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.CreateUninitializedItem(System.Web.HttpContext,System.String,System.Int32)">
      <summary>
            데이터 저장소에 새 세션 상태 항목을 추가합니다.
            </summary>
      <param name="context">현재 요청에 대한 <see cref="T:System.Web.HttpContext" />입니다.</param>
      <param name="id">현재 요청에 대한 <see cref="P:System.Web.SessionState.HttpSessionState.SessionID" />입니다.</param>
      <param name="timeout">현재 요청에 대한 세션 <see cref="P:System.Web.SessionState.HttpSessionState.Timeout" />입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.EndRequest(System.Web.HttpContext)">
      <summary>
            요청이 끝날 때 <see cref="T:System.Web.SessionState.SessionStateModule" /> 개체에 의해 호출됩니다.
            </summary>
      <param name="context">현재 요청에 대한 <see cref="T:System.Web.HttpContext" />입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.GetItem(System.Web.HttpContext,System.String,System.Boolean@,System.TimeSpan@,System.Object@,System.Web.SessionState.SessionStateActions@)">
      <summary>
            세션 데이터 저장소에서 읽기 전용 세션 상태 데이터를 반환합니다.
            </summary>
      <returns>
            세션 데이터 저장소의 세션 값과 정보로 채워진 <see cref="T:System.Web.SessionState.SessionStateStoreData" />입니다.
            </returns>
      <param name="context">현재 요청에 대한 <see cref="T:System.Web.HttpContext" />입니다.</param>
      <param name="id">현재 요청에 대한 <see cref="P:System.Web.SessionState.HttpSessionState.SessionID" />입니다.</param>
      <param name="locked">이 메서드가 반환될 때 요청된 세션 항목이 세션 데이터 저장소에서 잠겨 있으면 true로 설정된 부울 값이 포함되고, 그렇지 않으면 false로 설정된 부울 값이 포함됩니다.</param>
      <param name="lockAge">이 메서드가 반환될 때 세션 데이터 저장소의 항목이 잠겨 있는 시간으로 설정된 <see cref="T:System.TimeSpan" /> 개체가 포함됩니다.</param>
      <param name="lockId">이 메서드가 반환될 때 현재 요청에 대한 잠금 식별자로 설정된 개체가 포함됩니다.잠금 식별자에 대한 자세한 내용은 <see cref="T:System.Web.SessionState.SessionStateStoreProviderBase" /> 클래스 요약에서 "세션 저장소 데이터 잠금"을 참조하십시오.</param>
      <param name="actions">이 메서드가 반환될 때 현재 세션이 초기화되지 않은 쿠키 없는 세션인지 여부를 나타내는 <see cref="T:System.Web.SessionState.SessionStateActions" /> 값 중 하나가 포함됩니다.</param>
    </member>
    <!-- Badly formed XML comment ignored for member "M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.GetItemExclusive(System.Web.HttpContext,System.String,System.Boolean@,System.TimeSpan@,System.Object@,System.Web.SessionState.SessionStateActions@)" -->
    <member name="M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.Initialize(System.String,System.Collections.Specialized.NameValueCollection)">
      <summary>
            공급자를 초기화합니다.
            </summary>
      <param name="name">공급자의 이름입니다.</param>
      <param name="config">이 공급자에 대해 구성에 지정된 공급자별 특성을 나타내는 이름/값 쌍의 컬렉션입니다.</param>
      <exception cref="T:System.ArgumentNullException">공급자 이름이 null인 경우</exception>
      <exception cref="T:System.ArgumentException">공급자 이름의 길이가 0인 경우</exception>
      <exception cref="T:System.InvalidOperationException">공급자가 이미 초기화된 후 공급자에 대해 <see cref="M:System.Configuration.Provider.ProviderBase.Initialize(System.String,System.Collections.Specialized.NameValueCollection)" />를 호출하려고 한 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.InitializeRequest(System.Web.HttpContext)">
      <summary>
            요청별 초기화를 위해 <see cref="T:System.Web.SessionState.SessionStateModule" /> 개체에 의해 호출됩니다.
            </summary>
      <param name="context">현재 요청에 대한 <see cref="T:System.Web.HttpContext" />입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.ReleaseItemExclusive(System.Web.HttpContext,System.String,System.Object)">
      <summary>
            세션 데이터 저장소의 항목에 대한 잠금을 해제합니다.
            </summary>
      <param name="context">현재 요청에 대한 <see cref="T:System.Web.HttpContext" />입니다.</param>
      <param name="id">현재 요청에 대한 세션 식별자입니다.</param>
      <param name="lockId">현재 요청에 대한 잠금 식별자입니다. </param>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.RemoveItem(System.Web.HttpContext,System.String,System.Object,System.Web.SessionState.SessionStateStoreData)">
      <summary>
            세션 데이터 저장소에서 항목 데이터를 삭제합니다.
            </summary>
      <param name="context">현재 요청에 대한 <see cref="T:System.Web.HttpContext" />입니다.</param>
      <param name="id">현재 요청에 대한 세션 식별자입니다.</param>
      <param name="lockId">현재 요청에 대한 잠금 식별자입니다.</param>
      <param name="item">데이터 저장소에서 삭제할 항목을 나타내는 <see cref="T:System.Web.SessionState.SessionStateStoreData" />입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.ResetItemTimeout(System.Web.HttpContext,System.String)">
      <summary>
            세션 데이터 저장소에 있는 항목의 만료 날짜와 시간을 업데이트합니다.
            </summary>
      <param name="context">현재 요청에 대한 <see cref="T:System.Web.HttpContext" />입니다.</param>
      <param name="id">현재 요청에 대한 세션 식별자입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.SetItemExpireCallback(System.Web.SessionState.SessionStateItemExpireCallback)">
      <summary>
            Global.asax 파일에 정의된 Session_OnEnd 이벤트의 <see cref="T:System.Web.SessionState.SessionStateItemExpireCallback" /> 대리자에 대한 참조를 설정합니다.
            </summary>
      <returns>
            세션 상태 저장소 공급자가 Session_OnEnd 이벤트의 호출을 지원하면 true이고, 그렇지 않으면 false입니다.
            </returns>
      <param name="expireCallback">Global.asax 파일에 정의된 Session_OnEnd 이벤트의 <see cref="T:System.Web.SessionState.SessionStateItemExpireCallback" /> 대리자입니다.</param>
    </member>
    <member name="M:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.SetAndReleaseItemExclusive(System.Web.HttpContext,System.String,System.Web.SessionState.SessionStateStoreData,System.Object,System.Boolean)">
      <summary>
            세션 상태 데이터 저장소의 세션 항목 정보를 현재 요청의 값으로 업데이트하고 데이터에 대한 잠금을 해제합니다.
            </summary>
      <param name="context">현재 요청에 대한 <see cref="T:System.Web.HttpContext" />입니다.</param>
      <param name="id">현재 요청에 대한 세션 식별자입니다.</param>
      <param name="item">저장할 현재 세션 값이 포함된 <see cref="T:System.Web.SessionState.SessionStateStoreData" /> 개체입니다.</param>
      <param name="lockId">현재 요청에 대한 잠금 식별자입니다. </param>
      <param name="newItem">세션 항목이 새 항목임을 확인하면 true이고, 세션 항목이 기존 항목임을 확인하면 false입니다.</param>
    </member>
    <member name="P:NSoft.NFramework.Web.AbstractSessionStateStoreProvider.CacheRepository">
      <summary>
            Cache Repository
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.WebClientFactory">
      <summary>
        <see cref="T:System.Net.WebClient" /> 와 <see cref="T:System.Net.HttpWebRequest" />에 대해서, 일반 브라우저와 같은 속성 값을 미리 설정해서 생성해줍니다.
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.WebClientFactory.UserAgentFireFox">
      <summary>
            FireFox의 User-Agent 값
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.WebClientFactory.UserAgentChrome">
      <summary>
            Chrome의 User-Agent 값
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.WebClientFactory.UserAgentIE8">
      <summary>
            IE8의 User-Agent 값
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.WebClientFactory.UserAgentIE9">
      <summary>
            IE9의 User-Agent 값
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Web.WebClientFactory.CreateWebClientAsFirefox">
      <summary>
        <see cref="T:System.Net.WebClient" /> 인스턴스를 빌드합니다. FireFox와 같은 형태의	 브라우저로 취급할 수 있도록 요청 Header를 설정합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.WebClientFactory.CreateWebClientAsChrome">
      <summary>
        <see cref="T:System.Net.WebClient" /> 인스턴스를 빌드합니다. 구글 크롬과 같은 형태의 브라우저로 취급할 수 있도록 요청 Header를 설정합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.WebClientFactory.CreateWebClientAsIE8">
      <summary>
        <see cref="T:System.Net.WebClient" /> 인스턴스를 빌드합니다. IE8와 같은 형태의 브라우저로 취급할 수 있도록 요청 Header를 설정합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.WebClientFactory.CreateWebClientAsIE9">
      <summary>
        <see cref="T:System.Net.WebClient" /> 인스턴스를 빌드합니다. IE9와 같은 형태의 브라우저로 취급할 수 있도록 요청 Header를 설정합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.WebClientFactory.CreateHttpRequest(System.String)">
      <summary>
            User-Agent를 IE8으로 하는 HttpWebRequest를 생성합니다.
            </summary>
      <param name="uriString">요청할 웹 주소</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.WebClientFactory.CreateHttpRequestAsFirefox(System.String)">
      <summary>
            FireFox 3.6.8 에서 요청하는 HttpWebRequest를 생성합니다. (Mozilla 5.0 호환)
            </summary>
      <param name="uriString">요청할 웹 주소</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.WebClientFactory.CreateHttpRequestAsChrome(System.String)">
      <summary>
            Chrome 에서 요청하는 HttpWebRequest를 생성합니다. (Mozilla 5.0 호환)
            </summary>
      <param name="uriString">요청할 웹 주소</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.WebClientFactory.CreateHttpRequestAsIE8(System.String)">
      <summary>
            IE8 에서 요청하는 HttpWebRequest를 생성합니다. (Mozilla 5.0 호환)
            </summary>
      <param name="uriString">요청할 웹 주소</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.WebClientFactory.CreateHttpRequestAsIE9(System.String)">
      <summary>
            IE9 에서 요청하는 HttpWebRequest를 생성합니다. (Mozilla 5.0 호환)
            </summary>
      <param name="uriString">요청할 웹 주소</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Web.WebClientFactory.CreateHttpRequestCore(System.Uri)">
      <summary>
            HttpWebRequest를 빌드합니다. 압축된 응답스트림을 받을 수 있도록 요청헤더에 gzip 가능을 표시합니다.
            </summary>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.Web.WebClientFactory.Instance">
      <summary>
            WebClientFactory의 Singleton Instance입니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Web.WebCompressionKind">
      <summary>
            Web Content에 대한 사용가능한 압축알고리즘의 종류
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.WebCompressionKind.None">
      <summary>
            None
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.WebCompressionKind.GZip">
      <summary>
            GZip compression
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Web.WebCompressionKind.Deflate">
      <summary>
            Deflate compression
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Xml.XLinqTool">
      <summary>
            XLinq 관련 Utility Class 입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Xml.XLinqTool.GetElementValue(System.Xml.Linq.XElement,System.String)">
      <summary>
        <paramref name="element" />의 Value 값을 반환합니다. 없으면, <paramref name="defaultValue" />를 반환합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Xml.XLinqTool.GetAttrValue(System.Xml.Linq.XAttribute,System.String)">
      <summary>
        <paramref name="attribute" />의 Value 값을 반환합니다. 없으면, <paramref name="defaultValue" />를 반환합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Xml.XmlDoc">
      <summary>
            RealWeb XmlDocument Class
            System.Xml.XmlDocument로부터 상속 받음<br />
            XmlDocument를 다루기위한 Helper Function들을 추가함
            </summary>
      <remarks>
            현재 Namespace URI등은 함수에서 지원하지 않으므로 XmlDocument 에서 직접 사용해야 합니다.
            </remarks>
            TODO: Namespace URI 등을 지원하기 위한 함수 추가
        </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.#ctor">
      <summary>
            기본 생성자
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.#ctor(System.String)">
      <summary>
            주어진 xml 문자열이 순수 XML string이거나 URI 이거나 
            모두 load하여 XmlDocument를 구성한다.
            </summary>
      <param name="xmlText">xml text이거나 xml 파일경로, URI 등이 된다.</param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.#ctor(System.Uri)">
      <summary>
            생성자 ( System.Uri 개체의 AbsoluteUri 속성을 통해 XmlDocument를 생성합니다.
            </summary>
      <param name="uri">
        <c>System.Uri</c>개체</param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.#ctor(System.Xml.XmlDocument)">
      <summary>
            생성자 - <paramref name="document" />을 읽어서 새로운 <see cref="T:System.Xml.XmlDocument" /> 인스턴스를 생성한다.
            </summary>
      <param name="document">원본 XmlDocument</param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.#ctor(System.IO.Stream)">
      <summary>
        <paramref name="stream" /> 정보를 읽어서 XmlDocument 인스턴스를 생성한다.
            </summary>
      <param name="stream">원본 Stream 객체</param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.CreateElementText(System.String,System.String)">
      <summary>
            Create a new instance of XmlElement with name and text
            </summary>
      <param name="name">XmlElement의 이름</param>
      <param name="text">XmlElement의 Inner Text</param>
      <returns>생성된 XmlElement</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.CreateElementXml(System.String)">
      <summary>
        <paramref name="xml" /> 로부터 새로운 XmlElement를 생성한다.
            </summary>
      <param name="xml">Xml 형식의 문자열</param>
      <returns>생성된 <see cref="T:System.Xml.XmlElement" /> 객체, 실패시에는 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.FindElement(System.String)">
      <summary>
        <paramref name="xpath" />에 해당하는 XmlElement를 XmlDocument 전체에서 검색하여 반환한다.
            </summary>
      <param name="xpath">검색 식</param>
      <returns>검색한 XmlElement, 없으면 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.FindElement(System.Xml.XmlNode,System.String)">
      <summary>
        <paramref name="xpath" />에 해당하는 XmlElement를 지정된 <paramref name="parentNode" /> 자식 노드에서 검색하여 반환한다.
            </summary>
      <param name="parentNode">검색 기준이 되는 parent node</param>
      <param name="xpath">검색 식</param>
      <returns>검색한 XmlElement, 없으면 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.FindElements(System.String)">
      <summary>
            이 <see cref="T:NSoft.NFramework.Xml.XmlDoc" />에서 <paramref name="xpath" />에 해당하는 모든 XmlElement를 리스트로 반환한다.
            </summary>
      <param name="xpath">검색 식</param>
      <returns>XmlNodeList</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.FindElements(System.Xml.XmlNode,System.String)">
      <summary>
        <paramref name="parentNode" />에서 <paramref name="xpath" />에 해당하는 모든 XmlElement를 리스트로 반환한다.
            </summary>
      <param name="parentNode">기준이 되는 parent node</param>
      <param name="xpath">검색 식</param>
      <returns>XmlNodeList</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.IsNodeCanHaveChildNode(System.Xml.XmlNode)">
      <summary>
        <paramref name="node" />가 자식 노드를 가질 수 있는지 판단한다.
            </summary>
      <param name="node">검사할 노드</param>
      <returns>자식노드를 가질 수 있는지 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.FindNode(System.String)">
      <summary>
            XmlNode를 찾는다.
            </summary>
      <param name="xpath">XPATH 형식 ("//ROOT") </param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.FindNode(System.Xml.XmlNode,System.String)">
      <summary>
            지정된 노드내에서 XmlNode를 찾는다.
            </summary>
      <param name="parentNode">부모 노드</param>
      <param name="xpath">XPATH 형식 ("ROOT") </param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddAttribute(System.Xml.XmlNode,System.String,System.Object,System.Boolean)">
      <summary>
        <paramref name="parentNode" />에 새로운 Attribute를 추가한다.
            </summary>
      <param name="parentNode">부모 노드</param>
      <param name="name">특성 이름</param>
      <param name="attrValue">특성 값</param>
      <param name="replace">기존 존재시 대체 여부</param>
      <returns>성공시 추가된 XmlAttribute, 실패시에는 null</returns>
      <exception cref="T:System.ArgumentNullException">parentNode가 null일 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddAttribute(System.Xml.XmlNode,System.String,System.Object)">
      <summary>
        <paramref name="parentNode" />에 새로운 Attribute를 추가한다.
            </summary>
      <param name="parentNode">부모 노드</param>
      <param name="name">특성 이름</param>
      <param name="attrValue">특성 값</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddAttribute(System.Xml.XmlNode,System.Xml.XmlAttribute)">
      <summary>
            parentNode에 Attribute를 추가한다.
            </summary>
      <param name="parentNode">부모 노드</param>
      <param name="srcAttribute">원본 XmlAttribute 객체</param>
      <returns>
      </returns>
      <exception cref="T:System.ArgumentNullException">parentNode가 null일 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddCDataSection(System.Xml.XmlNode,System.String)">
      <summary>
            XmlCDataSection Node를 부모 노드에 추가한다. (&lt;![CDATA[ xxxx ]]&gt;)
            </summary>
      <param name="parentNode">부모노드</param>
      <param name="cdata">CDataSection의 값</param>
      <returns>
      </returns>
      <exception cref="T:System.ArgumentNullException">parentNode가 null일 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddComment(System.Xml.XmlNode,System.String)">
      <summary>
            XmlCommend Node를 추가한다.
            </summary>
      <param name="parentNode">
      </param>
      <param name="comment">Commant Text</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddElementXml(System.Xml.XmlNode,System.String)">
      <summary>
            Xml 문자열을 XmlDocument로 만들어서 Root Node를 부모 노드의 자식 노드로 추가한다.
            </summary>
      <param name="parentNode">
      </param>
      <param name="xmlText">
      </param>
      <returns>추가에 성공한 노드, 실패하면 null이 반환된다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddElementText(System.Xml.XmlNode,System.String,System.String)">
      <summary>
            XmlElement를 생성하여 부모 노드에 추가한다.
            </summary>
      <param name="parentNode">
      </param>
      <param name="name">Element Tag Name (Element의 TagName은 문자, '_', ':' 만 가능하다.)</param>
      <param name="text">Element Text Value</param>
      <returns>추가된 XmlElement</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddElement(System.Xml.XmlNode,System.Xml.XmlElement)">
      <summary>
            부모 노드에 원본 노드의 복사본을 추가한다.
            </summary>
      <param name="parentNode">부모 노드</param>
      <param name="srcNode">복사할 대상 요소</param>
      <returns>새로 복사해서 부모노드에 추가한 요소(<see cref="T:System.Xml.XmlElement" />)</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddElement(System.Xml.XmlNode,System.String,System.String)">
      <summary>
            부모노드에 지정된 이름과 지정된 Text 값을 가진 <see cref="T:System.Xml.XmlElement" />를 Parent Node에 추가한다.
            </summary>
      <param name="parentNode">
      </param>
      <param name="name">
      </param>
      <param name="text">XmlElement의 Text 속성</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddEntity(System.Xml.XmlNode,System.String)">
      <summary>
            부모노드에 <see cref="T:System.Xml.XmlEntity" />를 추가한다.
            </summary>
      <param name="parentNode">부모 노드</param>
      <param name="name">Entity 노드 이름</param>
      <returns>추가된 <see cref="T:System.Xml.XmlEntity" /> 노드</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddEntityRef(System.Xml.XmlNode,System.String)">
      <summary>
        <paramref name="parentNode" />에 <see cref="T:System.Xml.XmlEntityReference" />를 추가한다.
            </summary>
      <param name="parentNode">대상 노드</param>
      <param name="name">추가할 <see cref="T:System.Xml.XmlEntityReference" />의 이름</param>
      <returns>추가된 <see cref="T:System.Xml.XmlEntityReference" /></returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddFileElement(System.Xml.XmlNode,System.String,System.String)">
      <summary>
            XML Element로 파일 내용을 넣는다<br />
            파일내용은 bin.base64 형태로 XML string을 만들어서 XmlElement의 InnerText로 넣는다.
            </summary>
      <param name="parentNode">부모 노드</param>
      <param name="name">새로운 XML Element TagName</param>
      <param name="filename">DOM에 포함시킬 파일 이름(fullpath)</param>
      <returns>추가된 XmlElement</returns>
      <remarks>
            파일 내용을 XML DOM에 넣어서 기존의 MSXML2.IXmlHttp를 사용하면 속도문제가 크다.<br />
            .NET Version에서는 XMLHttp를 WebHttpRequest/WebHttpResponse를 사용하므로 문제없다. 
            Client용 Application 중 MSXML 2,3,4를 사용하면 속도문제는 해결되지 않는다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddNode(System.Xml.XmlNode,System.Xml.XmlNodeType,System.String,System.String)">
      <summary>
            부모 노드에 노드를 추가한다.
            </summary>
      <param name="parentNode">부모노드</param>
      <param name="nodeType">System.Xml.XmlNodeType</param>
      <param name="name">Tag Name</param>
      <param name="text">Node Value or Text</param>
      <returns>추가된 System.Xml.XmlNode</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddPI(System.Xml.XmlNode,System.String,System.String)">
      <summary>
            Processing Instruction Node를 추가한다.
            </summary>
      <param name="parentNode">
      </param>
      <param name="target">
      </param>
      <param name="data">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.AddTextNode(System.Xml.XmlNode,System.String)">
      <summary>
            Text Node를 추가한다.
            </summary>
      <param name="parentNode">
      </param>
      <param name="text">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.GetAttributeNode(System.Xml.XmlElement,System.String)">
      <summary>
            Element 내의 지정한 이름의 Attribute를 반환한다.
            </summary>
      <param name="node">
      </param>
      <param name="name">
      </param>
      <returns>Attribute 객체, 없으면 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.GetElement(System.Xml.XmlNode,System.String)">
      <summary>
            XmlElement를 찾는다.
            </summary>
      <param name="parentNode">
      </param>
      <param name="xpath">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.GetElement(System.String)">
      <summary>
        <paramref name="xpath" />로 검색한 XmlElement 노드를 반환한다. - <see cref="M:NSoft.NFramework.Xml.XmlDoc.FindElement(System.String)" />와 같다.
            </summary>
      <param name="xpath">검색 식</param>
      <returns>검색한 XmlElement 인스턴스, 없으면 null</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.GetElementText(System.String)">
      <summary>
            XmlElement를 찾아서 InnerText값을 반환한다.
            </summary>
      <param name="xpath">검색 식</param>
      <returns>검색한 XmlElement의 Text 속성 값, 없으면 빈 문자열 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.GetElementText(System.Xml.XmlNode,System.String)">
      <summary>
        <paramref name="parentNode" />를 기준으로 XmlElement를 찾아서 InnerText값을 반환한다.
            </summary>
      <param name="parentNode">검색 기준이 되는 parent node</param>
      <param name="xpath">검색 식</param>
      <returns>검색한 XmlElement의 Text 속성 값, 없으면 빈 문자열 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.GetElementTextArray(System.String)">
      <summary>
            xpath에 해당하는 XmlElement 들을 찾아서 Element의 Text 를 string array로 반환한다.
            </summary>
      <returns>문자열 배열, 찾은 내용이 없으면 길이가 0인 문자열 배열</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.InsertElementBefore(System.Xml.XmlElement,System.String,System.String)">
      <summary>
            새로운 XmlElement를 refNode 앞에 추가한다.
            </summary>
      <returns>실패시에는 null을 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.InsertElementBefore(System.Xml.XmlElement,System.Xml.XmlElement)">
      <summary>
            새로운 XmlElement를 refNode 앞에 추가한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.InsertElementBefore(System.Xml.XmlElement,System.String)">
      <summary>
            새로운 XmlElement를 refNode 앞에 추가한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.IsValidNodeIndex(System.Int32)">
      <summary>
            속도가 느리기 때문에 사용하지 안는 것이 좋다.
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.RemoveElement(System.Xml.XmlElement)">
      <summary>
            지정된 Element를 삭제한다.
            </summary>
      <param name="element">
      </param>
      <returns>삭제여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.RemoveElement(System.Xml.XmlNode,System.String)">
      <summary>
            Element Node를 찾아서 삭제한다.
            </summary>
      <param name="parentNode">
      </param>
      <param name="xpath">
      </param>
      <returns>제거 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.RemoveNamedItem(System.Xml.XmlNamedNodeMap,System.Xml.XmlNode)">
      <summary>
            NamedNodeMap에서 해당 node를 삭제한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.RemoveNamedItem(System.Xml.XmlNamedNodeMap,System.String)">
      <summary>
            NamedNodeMap(대부분 XmlAttributeCollection)에서 해당 node를 삭제한다.
            </summary>
      <param name="nodeMap">
      </param>
      <param name="nodeName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.RemoveSelection(System.String)">
      <summary>
            xpath로 찾은 모든 XmlNode를 삭제한다.
            </summary>
      <param name="xpath">
      </param>
      <returns>제거된 노드의 수</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.SaveFileElement(System.Xml.XmlElement,System.String)">
      <summary>
            File 정보를 담고 있는 XmlElement를 filename으로 저장한다.
            </summary>
      <param name="fileNode">
      </param>
      <param name="filename">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.SaveFileElement(System.Xml.XmlElement,System.String,System.Boolean)">
      <summary>
            File 정보를 담고 있는 XmlElement를 filename으로 저장한다.
            </summary>
      <param name="fileNode">파일 Stream 을 가지고 있는 Node</param>
      <param name="filename">저장할 파일 이름</param>
      <param name="overwrite">겹쳐쓰기 여부</param>
      <returns>저장된 파일 이름</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.SaveToFile(System.String)">
      <summary>
            Xml 내용을 파일로 저장한다.
            </summary>
      <param name="filename">전체 경로 명</param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.SaveToTemp(System.String)">
      <summary>
            Xml 내용을 System Temporary Directory에 저장한다.
            </summary>
      <param name="filename">저장할 파일명 (전체 경로가 아닌 파일명만 적는다.)</param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.SetElementText(System.String,System.String)">
      <summary>
            xpath로 찾은 Element의 InnerText값을 지정한다.
            </summary>
      <param name="xpath">XPath</param>
      <param name="text">탐색한 XmlElement에 설정할 Text값</param>
      <exception cref="T:System.Xml.XmlException">해당 Element를 찾지 못했을 때</exception>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.SetNamedItem(System.Xml.XmlNamedNodeMap,System.Xml.XmlNode)">
      <summary>
            XmlNamedNodeMap에 Node를 추가한다.
            </summary>
      <param name="node">
      </param>
      <param name="nodeMap">
      </param>
      <returns>실패시 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.SetNamedItem(System.Xml.XmlNamedNodeMap,System.String,System.String)">
      <summary>
            XmlNamedNodeMap에 Node를 추가한다.
            </summary>
      <returns>실패시 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlDoc.IsValidTagName(System.String)">
      <summary>
            Element의 TagName은 문자, '_', ':' 만 가능하다. 
            되도록 Element Tag Name에 특수 문자를 사용하지 마시요.
            </summary>
      <param name="tagName">Element의 TagName</param>
      <returns>사용 가능여부</returns>
      <remarks>
            이 함수는 되도록 사용하지 마십시요. DOM을 생성해서 TEST하는 것이므로 속도가 매우 느립니다.
            </remarks>
    </member>
    <member name="P:NSoft.NFramework.Xml.XmlDoc.Root">
      <summary>
            XmlDocument.DocumentElement 즉 XmlDocument Root Node를 반환한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Xml.XmlDoc.Xml">
      <summary>
            XmlDocument의 Xml 문자열을 반환한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Xml.XmlDoc.Text">
      <summary>
            XmlDocument의 내용을 일반 Text형식으로 반환한다. (XmlDocument.OuterXml)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Xml.XmlDoc.XmlStream">
      <summary>
            XmlDocument의 xml 내용을 MemoryStream 형태로 보낸다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Xml.XmlDoc.Reader">
      <summary>
            XmlDocument를 읽을 수 있는 XmlNodeReader를 반환한다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.Xml.XmlDoc.IsValidDocument">
      <summary>
            유효한 XmlDocument 객체인가 판단.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Xml.XmlSerializer`1">
      <summary>
            객체를 XML 형식으로 직렬화 / 역직렬화를 수행합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlSerializer`1.Serialize(`0)">
      <summary>
            지정된 객체를 Serialize를 수행한다.
            </summary>
      <param name="graph">object to be serialized.</param>
      <returns>직렬화된 객체, graph가 null이면, 길이가 0인 byte[] 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlSerializer`1.Deserialize(System.Byte[])">
      <summary>
            Serialized 된 정보를 Deserialize 를 수행해서 객체로 반환한다.
            </summary>
      <param name="data">serialized data to be deserialized.</param>
      <returns>deserialized object</returns>
    </member>
    <member name="F:NSoft.NFramework.Xml.XmlTool.XmlIndent">
      <summary>
            XML 포맷의 문자열을 만들때 들여쓰기 값
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Xml.XmlTool.XmlEncoding">
      <summary>
            XML 형식의 문자열의 기본 인코딩 방식 (<see cref="P:System.Text.Encoding.UTF8" />)
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.IsValidDocument(System.Xml.XmlDocument)">
      <summary>
            Xml Document가 유효한 것인지 판단한다.
            </summary>
      <param name="document">검사할 <see cref="T:System.Xml.XmlDocument" /> 인스턴스</param>
      <returns>
      </returns>
      <remarks>
            지정된 document가 null이 아니고, document의 root element가 null이 아니면 유효한 document라 판단한다.
            </remarks>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.IsValidNode(System.Xml.XmlNode)">
      <summary>
            XmlNode가 유효한 것인지 판단한다.
            </summary>
      <remarks>
            지정된 노드가 Null이 아니고, 노드를 소유한 <see cref="T:System.Xml.XmlDocument" /> 개체가 null이 아니면 유효한 노드이다.
            </remarks>
      <param name="node">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.IsNotValidNode(System.Xml.XmlNode)">
      <summary>
            XmlNode가 유효하지 않을 때 참을 반환합니다.
            </summary>
      <param name="node">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.IsNodeCanHaveChildNode(System.Xml.XmlNode)">
      <summary>
        <paramref name="node" />가 자식 노드를 가질 수 있는 지 검사한다.
            </summary>
      <param name="node">검사할 노드</param>
      <returns>
        <paramref name="node" />가 자식을 가질 수 있는 노드면 true, 아니면 false를 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.CheckNull(System.Xml.XmlNode)">
      <summary>
        <paramref name="node" />가 null인지 검사한다.
            </summary>
      <param name="node">검사할 노드</param>
      <exception cref="T:System.Xml.XmlException">
        <paramref name="node" />가 null 이거나, Owner Document가 null인 경우
            </exception>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.CheckNullElement(System.Xml.XmlElement)">
      <summary>
        <paramref name="element" />가 null인지 검사한다.
            </summary>
      <param name="element">검사할 XmlElement</param>
      <exception cref="T:System.Xml.XmlException">
        <paramref name="element" />가 null 이거나, Owner Document가 null인 경우
            </exception>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.CheckDocument(System.Xml.XmlDocument)">
      <summary>
        <paramref name="document" />가 유효한지 검사한다.
            </summary>
      <param name="document">검사할 XmlDocument 인스턴스</param>
      <exception cref="T:System.Xml.XmlException">
        <paramref name="document" />가 null이거나 <paramref name="document" />.DocumentElement가 null인 경우
            </exception>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.CreateXmlDocument(System.String)">
      <summary>
             지정된 xml 문자열로 XmlDocument 객체를 만든다.
            </summary>
      <param name="xmlText">Xml 문자열 또는 Uri string</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.CreateXmlDocument(System.IO.Stream)">
      <summary>
            Stream 객체로부터 XmlDocument를 생성한다.
            </summary>
      <param name="stream">
      </param>
      <returns>XmlDoc 인스턴스, 실패시에는 null</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.GetXmlDocument(System.String)">
      <summary>
        <see cref="M:NSoft.NFramework.Xml.XmlTool.CreateXmlDocument(System.String)" />과 같은 기능을 합니다.
            </summary>
      <param name="xmlText">xml 형식의 문자열</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.GetXmlDocument(System.IO.Stream)">
      <summary>
        <see cref="M:NSoft.NFramework.Xml.XmlTool.CreateXmlDocument(System.IO.Stream)" />과 같은 기능을 합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.AddAttribute(System.Xml.XmlElement,System.String,System.String)">
      <summary>
            지정된 XmlElement에 지정된 이름과 값을 가진 Attribute Node를 추가한다.
            </summary>
      <param name="element">Attribute를 추가할 Element</param>
      <param name="attrName">속성 명</param>
      <param name="attrValue">속성 값</param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.GetAttributeValue``1(System.Xml.XmlElement,System.String,``0)">
      <summary>
            지정된 xml element 의 속정 값을 가져온다.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="element">
      </param>
      <param name="attrName">
      </param>
      <param name="defValue">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.AttributeToInt32(System.Xml.XmlElement,System.String,System.Int32)">
      <summary>
            해당 XmlElement의 지정된 속성 값을 Int32로 반환한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.AttributeToString(System.Xml.XmlElement,System.String,System.String)">
      <summary>
            해당 XmlElement의 지정된 속성명을 가진 속성의 값을 문자열로 변환한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.AttributeToBoolean(System.Xml.XmlElement,System.String,System.Boolean)">
      <summary>
            해당	XmlElement의 특성 값을 System.Boolean으로 반환한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.AttributeToDateTime(System.Xml.XmlElement,System.String,System.DateTime)">
      <summary>
            해당 XmlElement의 특성 값을 System.DateTime 으로 반환한다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.XmlEncode(System.String)">
      <summary>
            XML string 을 XML TEXT FORMAT에 맞게 encoding을 수행한다.
            </summary>
      <remarks>
        <pre>&amp;, &lt;, &gt; 등 Xml에 쓰이는 특수 문자를 변환해 준다.</pre>
      </remarks>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.XmlEncodeEx(System.String)">
      <summary>
            XML 문법에 맞게 특수 문자들을 encoding 한다. 
            </summary>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.XmlDecode(System.String)">
      <summary>
            Xml Text 내용중에 이중 Encoding된 것들 즉 XmlText Node에 Xml format 문자열이 있는 경우
            이를 Decoding한다.
            </summary>
      <remarks>아직 개발중입니다. 사용하지 마십시요</remarks>
      <param name="xml">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.DecodeXml(System.String)">
      <summary>
            Xml Text 형식의 문자열을 일반 문자열로 변환한다.
            </summary>
      <remarks>아직 개발중입니다. 사용하지 마십시요</remarks>
      <param name="src">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.AddElement(System.Xml.XmlNode,System.String)">
      <summary>
            XML string 을 XmlElement로 변환해서 parentNode node에 child로 추가한다.
            </summary>
      <param name="parentNode">xml을 추가할 node</param>
      <param name="xml">XML format의 string : 주의사항 XmlFragment가 아니다 즉 이 XML 또한 하나의 ROOT만 있어야 한다.</param>
      <returns>새로추가된 XmlElement 인스턴스</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.AddElement(System.Xml.XmlNode,System.Xml.XmlElement)">
      <summary>
            parentNode XmlElement 밑에 newElement를 추가한다.
            </summary>
      <param name="parentNode">대상 XML Element</param>
      <param name="newElement">추가될 XmlElement</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.AddElement(System.Xml.XmlNode,System.String,System.String)">
      <summary>
            parentNode에 새로운 XmlElement를 추가한다.
            </summary>
      <param name="parentNode">
      </param>
      <param name="name">
      </param>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.AddElementList(System.Xml.XmlNode,System.Xml.XmlNodeList)">
      <summary>
            XmlNodeList의 Node들을 parentNode에 추가한다.
            </summary>
      <param name="parentNode">대상 Element</param>
      <param name="elementList">XmlNodeList 형식의 Element (같은 Level의 Element만 써야한다.)</param>
      <returns>추가된 XmlNode의 갯수</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.AddXmlFragment(System.Xml.XmlNode,System.String)">
      <summary>
            주어진 xml 문자열로 XmlDocumentFragment를 만들고 이를 parentNode에 추가한다.
            이때 xml 문자열은 Root Node를 가질 필요 없다.
            </summary>
      <param name="parentNode">
      </param>
      <param name="xmlText">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.GetElementText(System.Xml.XmlDocument,System.String,System.String)">
      <summary>
            XPATH에 해당하는 Element를 찾아서 InnerText 값을 반환한다. 
            (여러개의 Element일 경우에는 제일 처음 검색된 것을 사용한다.)
            </summary>
      <param name="document">
      </param>
      <param name="xpath">
      </param>
      <param name="defaultValue">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.GetElementTextToArrayList(System.Xml.XmlDocument,System.String)">
      <summary>
            XPATH에 해당하는 Element들을 찾아서 InnerText 값을 StringCollection에 담아 반환한다.
            </summary>
      <param name="document">
      </param>
      <param name="xpath">
      </param>
      <returns>찾는 Element가 없을 시에는 빈 컬렉션 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.GetElementTextList(System.Xml.XmlDocument,System.String,System.Collections.Specialized.StringCollection)">
      <summary>
            XPATH에 해당하는 Element들을 찾아서 InnerText 값을 StringCollection에 담아 반환한다.
            </summary>
      <param name="document">
      </param>
      <param name="xpath">찾고자하는 경로</param>
      <param name="list">결과를 담을 컬렉션</param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.GetElementTextList(System.Xml.XmlDocument,System.String,System.Collections.Generic.List{System.String})">
      <summary>
            XPATH에 해당하는 Element들을 찾아서 InnerText 값을 리스트에 담아 반환한다.
            </summary>
      <param name="document">
      </param>
      <param name="xpath">
      </param>
      <param name="list">
      </param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.RemoveSelection(System.Xml.XmlDocument,System.String)">
      <summary>
            Xpath로 찾은 XmlNode들을 삭제한다.
            </summary>
      <param name="document">조작할 XmlDocument</param>
      <param name="xpath">삭제할 노드를 찾기 위한 XPath 구문</param>
      <returns>삭제된 Node의 수, 없으면 0</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Serialize(System.Object,System.IO.Stream,System.Text.Encoding,System.Boolean)">
      <summary>
            주어진 객체를 Xml 직렬화하여 Stream 객체에 쓴다.
            </summary>
      <param name="target">직렬화할 개체</param>
      <param name="enc">인코딩 방식</param>
      <param name="useIndent">들여쓰기를 이용한 포맷 사용여부</param>
      <param name="outStream">직렬화한 정보가 담길 stream</param>
      <exception cref="T:System.ArgumentNullException">target이 null이거나 stream이 null인 경우</exception>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Serialize(System.Object,System.IO.Stream,System.Text.Encoding)">
      <summary>
            객체를 Xml 직렬화하여 outStream에 쓴다.
            </summary>
      <param name="target">직렬화할 객체</param>
      <param name="outStream">직렬화된 정보를 쓸 Stream</param>
      <param name="enc">Stream에 쓸때 사용할 인코딩 방식</param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Serialize(System.Object,System.IO.Stream,System.Boolean)">
      <summary>
            객체를 Xml 직렬화하여 outStream에 쓴다.
            </summary>
      <param name="target">직렬화할 객체</param>
      <param name="outStream">직렬화된 정보를 쓸 Stream</param>
      <param name="useIndent">들여쓰기 사용 여부</param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Serialize(System.Object,System.IO.Stream)">
      <summary>
            객체를 Xml 직렬화하여 outStream에 쓴다.
            </summary>
      <param name="target">직렬화할 객체</param>
      <param name="outStream">직렬화된 정보를 쓸 Stream</param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Serialize(System.Object,System.Byte[]@)">
      <summary>
            객체를 XmlSerialize를 수행하여 Byte 배열로 변환한다.
            </summary>
      <param name="target">직렬화할 객체</param>
      <param name="outBytes">직렬화된 데이타</param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Serialize(System.Object,System.Xml.Linq.XDocument@)">
      <summary>
            객체를 XML 직렬화하여 <see cref="T:System.Xml.Linq.XDocument" /> 객체로 변환한다.
            </summary>
      <param name="target">직렬화할 객체</param>
      <param name="xdoc">직렬화된 객체 정보를 담은 <see cref="T:System.Xml.Linq.XDocument" />의 인스턴스</param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Serialize(System.Object,System.Xml.XmlDocument@)">
      <summary>
            객체를 직렬화하여 <see cref="T:System.Xml.XmlDocument" /> 객체로 변환한다.
            </summary>
      <param name="target">직렬화할 객체</param>
      <param name="document">직렬화 정보를 담은 <see cref="T:System.Xml.XmlDocument" /></param>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize(System.Type,System.IO.Stream)">
      <summary>
            지정된 Stream을 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <param name="targetType">역직렬화해서 만들 객체의 수형</param>
      <param name="stream">직렬화 정보를 가진 Stream</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize(System.Type,System.IO.Stream,System.Text.Encoding)">
      <summary>
            지정된 Stream을 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <param name="targetType">역직렬화해서 만들 객체의 수형</param>
      <param name="stream">직렬화 정보를 가진 Stream</param>
      <param name="enc">XML 인코딩 방식</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize(System.Type,System.Byte[])">
      <summary>
            byte array를 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <param name="targetType">역직렬화해서 만들 객체의 수형</param>
      <param name="inBytes">직렬화 정보를 가진 byte array.</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize(System.Type,System.Byte[],System.Text.Encoding)">
      <summary>
            byte array를 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <param name="targetType">역직렬화해서 만들 객체의 수형</param>
      <param name="inBytes">직렬화 정보를 가진 byte array.</param>
      <param name="enc">XML 인코딩 방식</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize(System.Type,System.Xml.Linq.XDocument)">
      <summary>
            XmlDocument 를 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <param name="targetType">역직렬화해서 만들 객체의 수형</param>
      <param name="xdoc">직렬화 정보를 가진 <see cref="T:System.Xml.Linq.XDocument" />인스턴스</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize(System.Type,System.Xml.Linq.XDocument,System.Text.Encoding)">
      <summary>
            XmlDocument 를 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <param name="targetType">역직렬화해서 만들 객체의 수형</param>
      <param name="xdoc">직렬화 정보를 가진 <see cref="T:System.Xml.Linq.XDocument" />인스턴스</param>
      <param name="enc">인코딩 방식</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize(System.Type,System.Xml.XmlDocument)">
      <summary>
            XmlDocument 를 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <param name="targetType">역직렬화해서 만들 객체의 수형</param>
      <param name="document">직렬화 정보를 가진 XmlDocument 인스턴스</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize(System.Type,System.Xml.XmlDocument,System.Text.Encoding)">
      <summary>
            XmlDocument 를 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <param name="targetType">역직렬화해서 만들 객체의 수형</param>
      <param name="document">직렬화 정보를 가진 XmlDocument 인스턴스</param>
      <param name="enc">XML 인코딩 방식</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize``1(System.IO.Stream)">
      <summary>
            지정된 Stream을 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <typeparam name="T">역직렬화해서 만들 객체의 수형</typeparam>
      <param name="stream">직렬화 정보를 가진 Stream</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize``1(System.IO.Stream,System.Text.Encoding)">
      <summary>
            지정된 Stream을 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <typeparam name="T">역직렬화해서 만들 객체의 수형</typeparam>
      <param name="stream">직렬화 정보를 가진 Stream</param>
      <param name="enc">XML 인코딩 방식</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize``1(System.Byte[])">
      <summary>
            byte array를 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <typeparam name="T">역직렬화해서 만들 객체의 수형</typeparam>
      <param name="inBytes">직렬화 정보를 가진 byte array.</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize``1(System.Byte[],System.Text.Encoding)">
      <summary>
            byte array를 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <typeparam name="T">역직렬화해서 만들 객체의 수형</typeparam>
      <param name="inBytes">직렬화 정보를 가진 byte array.</param>
      <param name="enc">XML 인코딩 방식</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize``1(System.Xml.Linq.XDocument)">
      <summary>
            XmlDocument 를 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <typeparam name="T">역직렬화해서 만들 객체의 수형</typeparam>
      <param name="xdoc">직렬화 정보를 가진 <see cref="T:System.Xml.Linq.XDocument" />인스턴스</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize``1(System.Xml.Linq.XDocument,System.Text.Encoding)">
      <summary>
            XmlDocument 를 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <typeparam name="T">역직렬화해서 만들 객체의 수형</typeparam>
      <param name="xdoc">직렬화 정보를 가진 <see cref="T:System.Xml.Linq.XDocument" />인스턴스</param>
      <param name="enc">인코딩 방식</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize``1(System.Xml.XmlDocument)">
      <summary>
            XmlDocument 를 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <typeparam name="T">역직렬화해서 만들 객체의 수형</typeparam>
      <param name="document">직렬화 정보를 가진 XmlDocument 인스턴스</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XmlTool.Deserialize``1(System.Xml.XmlDocument,System.Text.Encoding)">
      <summary>
            XmlDocument 를 읽어서 Xml Deserialize를 수행한다.
            </summary>
      <typeparam name="T">역직렬화해서 만들 객체의 수형</typeparam>
      <param name="document">직렬화 정보를 가진 XmlDocument 인스턴스</param>
      <param name="enc">XML 인코딩 방식</param>
      <returns>역직렬화된 객체</returns>
    </member>
    <member name="T:NSoft.NFramework.Xml.XStreamReader">
      <summary>
            Silverlight, Windows Phone 에서 사용하기 쉽게 <see cref="T:System.Xml.XmlReader" /> 를 IEnumerable{XElement} 형식으로 열거할 수 있도록 해 줍니다.
            </summary>
      <example>
        <code>
            var rss =
            	XStreamReader.Load("http://services.social.microsoft.com/feeds/feed/CSharpHeadlines")
            		.Descendants("item")
            		.Select(x =&gt; new
            					 {
            						 Title = x.Element("title").GetValue(),
            						 Description = x.Element("description").GetValue(),
            						 PubDate = x.Element("pubDate").GetValue().AsDateTime()
            					 })
            		.ToList();
            </code>
      </example>
    </member>
    <member name="M:NSoft.NFramework.Xml.XStreamReader.Load(System.IO.Stream)">
      <summary>
        <paramref name="stream" />으로부터 정보를 읽어들이는 XStreamReader를 생성합니다.
            </summary>
      <param name="stream">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XStreamReader.Load(System.String)">
      <summary>
        <paramref name="uri" />으로부터 정보를 읽어들이는 XStreamReader를 생성합니다.
            </summary>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XStreamReader.Load(System.IO.TextReader)">
      <summary>
        <paramref name="textReader" />으로부터 정보를 읽어들이는 XStreamReader를 생성합니다.
            </summary>
      <param name="textReader">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XStreamReader.Load(System.Xml.XmlReader)">
      <summary>
        <paramref name="reader" />으로부터 정보를 읽어들이는 XStreamReader를 생성합니다.
            </summary>
      <param name="reader">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XStreamReader.Parse(System.String)">
      <summary>
        <paramref name="text" />를 파싱하여 XStreamReader를 생성합니다.
            </summary>
      <param name="text">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XStreamReader.Attribute(System.Xml.Linq.XName)">
      <summary>
        <paramref name="name" />의 Attribute를 반환합니다.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XStreamReader.Attributes(System.Xml.Linq.XName)">
      <summary>
        <paramref name="name" />에 해당하는 Attribute 들을 열거합니다.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XStreamReader.Attributes">
      <summary>
            모든 Attribute 들을 열거합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XStreamReader.Element(System.Xml.Linq.XName)">
      <summary>
            Element Name 이 <paramref name="name" />인 첫번째 XElement를 반환합니다.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XStreamReader.Elements">
      <summary>
            모든 XElement를 반환합니다.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XStreamReader.Elements(System.Xml.Linq.XName)">
      <summary>
            Element Name 이 <paramref name="name" />인 XElement를 열거합니다.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.Xml.XStreamReader.Descendants(System.Xml.Linq.XName)">
      <summary>
            Element Name 이 <paramref name="name" />인 모든 자손 XElement들을 열거합니다.
            </summary>
      <param name="name">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.AbstractAsyncResult">
      <summary>
        <see cref="T:System.IAsyncResult" />를 표현하기 위한 기본 클래스입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.AbstractAsyncResult.Success">
      <summary>
            비동기 작업이 성공적으로 완료되었다고 설정합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.AbstractAsyncResult.Fail(System.Exception)">
      <summary>
            비동기 작업을 실패로 설정한다.
            </summary>
      <param name="exception">
      </param>
    </member>
    <member name="M:NSoft.NFramework.AbstractAsyncResult.Cancel">
      <summary>
            비동기 작업이 취소되었다고 설정합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.AbstractAsyncResult.CheckResult">
      <summary>
            예외가 발생하여, 실퍠로 설정되었다면, 그 예외를 rethrow 합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AbstractAsyncResult.IsCompleted">
      <summary>
            비동기 작업의 성공여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AbstractAsyncResult.AsyncWaitHandle">
      <summary>
            비동기 작업의 대기 핸들
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AbstractAsyncResult.IsFaulted">
      <summary>
            비동기 작업의 실패 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AbstractAsyncResult.IsCanceled">
      <summary>
            비동기 작업의 취소 여부
            </summary>
    </member>
    <member name="P:NSoft.NFramework.AbstractAsyncResult.Exception">
      <summary>
            비동기 작업시 발생한 예외 정보
            </summary>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsValue(System.Object,System.Type)">
      <summary>
        <paramref name="source" /> 인스턴스를 <paramref name="targetType" /> 형식으로 변환합니다.
            </summary>
      <param name="source">원본 인스턴스</param>
      <param name="targetType">대상 형식</param>
      <returns>대상 형식으로 변환된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsValue(System.Object,System.Type,System.Object)">
      <summary>
        <paramref name="source" /> 인스턴스를 <paramref name="targetType" /> 형식으로 변환합니다.
            </summary>
      <param name="source">원본 인스턴스</param>
      <param name="targetType">대상 형식</param>
      <param name="defaultValue">대상 형식으로 변환 실패 시, 반환하는 기본값</param>
      <returns>대상 형식으로 변환된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsValue(System.Object,System.Type,System.Func{System.Object})">
      <summary>
        <paramref name="source" /> 인스턴스를 <paramref name="targetType" /> 형식으로 변환합니다.
            </summary>
      <param name="source">원본 인스턴스</param>
      <param name="targetType">대상 형식</param>
      <param name="defaultValueFactory">대상 형식으로 변환 실패 시, 기본값을 제공하는 함수</param>
      <returns>대상 형식으로 변환된 객체</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsValue``1(System.Object,``0)">
      <summary>
        <paramref name="source" />를 T 수형으로 변환합니다.
            </summary>
      <typeparam name="T">변환할 수형</typeparam>
      <param name="source">변환할 객체</param>
      <param name="defaultValue">변환 실패시, source가 null 일 경우, 기본값</param>
      <returns>변환된 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsValue``1(System.Object,System.Func{``0})">
      <summary>
        <paramref name="source" />를 T 수형으로 변환합니다.
            </summary>
      <typeparam name="T">변환할 수형</typeparam>
      <param name="source">변환할 객체</param>
      <param name="defaultValueFactory">기본값을 제공하는 함수</param>
      <returns>변환된 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsValueNullable``1(System.Object)">
      <summary>
        <paramref name="source" />를 Nullable{T} 수형으로 변환합니다.
            </summary>
      <typeparam name="T">변환할 수형</typeparam>
      <param name="source">변환할 객체</param>
      <returns>변환된 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsValueNullable``1(System.Object,System.Func{System.Nullable{``0}})">
      <summary>
        <paramref name="source" />를 Nullable{T} 수형으로 변환합니다.
            </summary>
      <typeparam name="T">변환할 수형</typeparam>
      <param name="source">변환할 객체</param>
      <param name="defaultValueFactory">기본값 반환 함수</param>
      <returns>변환된 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsEnum(System.Object,System.Enum)">
      <summary>
        <paramref name="source" />를 enum 값으로 변경합니다.
            </summary>
      <param name="source">변환할 객체</param>
      <param name="defaultValue">변환 실패시 기본 enum 값</param>
      <returns>변환된 enum 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsEnum``1(System.Object,``0)">
      <summary>
        <paramref name="source" />를 enum 값으로 변경합니다.
            </summary>
      <param name="source">변환할 객체</param>
      <param name="defaultValue">변환 실패시 기본 enum 값</param>
      <returns>변환된 enum 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsEnumNullable``1(System.Object,``0)">
      <summary>
        <paramref name="source" />를 enum 값으로 변경합니다.
            </summary>
      <typeparam name="T">enum 수형</typeparam>
      <param name="source">변환할 객체</param>
      <param name="defaultValue">변환 실패시 기본 enum 값</param>
      <returns>변환된 enum 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsBool(System.Object,System.Boolean)">
      <summary>
        <paramref name="source" />를 bool 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValue">변환 실퍠시에 반환할 값</param>
      <returns>변환된 boolean 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsBool(System.Object,System.Func{System.Boolean})">
      <summary>
        <paramref name="source" />를 bool 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실퍠시에 반환할 값을 생성하는 Factory</param>
      <returns>변환된 boolean 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsBoolNullable(System.Object)">
      <summary>
        <paramref name="source" />를 bool? 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 boolean? 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsBoolNullable(System.Object,System.Func{System.Nullable{System.Boolean}})">
      <summary>
        <paramref name="source" />를 bool? 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실퍠시에 반환할 값을 생성하는 Factory</param>
      <returns>변환된 boolean? 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsChar(System.Object)">
      <summary>
        <paramref name="source" />를 char 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 char 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsChar(System.Object,System.Char)">
      <summary>
        <paramref name="source" />를 char 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValue">변환 실퍠시에 반환할 값</param>
      <returns>변환된 char 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsChar(System.Object,System.Func{System.Char})">
      <summary>
        <paramref name="source" />를 char 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실퍠시에 반환할 값을 생성하는 Factory</param>
      <returns>변환된 char 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsCharNullable(System.Object)">
      <summary>
        <paramref name="source" />를 char? 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 char? 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsCharNullable(System.Object,System.Func{System.Nullable{System.Char}})">
      <summary>
        <paramref name="source" />를 char? 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실퍠시에 반환할 값을 생성하는 Factory</param>
      <returns>변환된 char? 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsByte(System.Object)">
      <summary>
        <paramref name="source" />를 byte 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 byte 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsByte(System.Object,System.Byte)">
      <summary>
        <paramref name="source" />를 byte 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValue">변환 실퍠시에 반환할 값</param>
      <returns>변환된 byte 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsByte(System.Object,System.Func{System.Byte})">
      <summary>
        <paramref name="source" />를 byte 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실퍠시에 반환할 값을 생성하는 Factory</param>
      <returns>변환된 byte 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsByteNullable(System.Object)">
      <summary>
        <paramref name="source" />를 byte? 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 byte? 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsByteNullable(System.Object,System.Func{System.Nullable{System.Byte}})">
      <summary>
        <paramref name="source" />를 byte? 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실퍠시에 반환할 값을 생성하는 Factory</param>
      <returns>변환된 byte? 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsShort(System.Object,System.Int16)">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Int16" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValue">변환 실패시 반환할 기본값</param>
      <returns>변환된 Int16 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsShort(System.Object,System.Func{System.Int16})">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Int16" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실패시 반환할 기본값 생성자</param>
      <returns>변환된 Int16 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsShortNullable(System.Object)">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Nullable`1" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 <see cref="T:System.Nullable`1" /> 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsShortNullable(System.Object,System.Func{System.Nullable{System.Int16}})">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Nullable`1" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실패시 반환할 기본값 생성자</param>
      <returns>변환된 <see cref="T:System.Nullable`1" /> 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsInt(System.Object,System.Int32)">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Int32" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValue">변환 실패시 반환할 기본값</param>
      <returns>변환된 Int32 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsInt(System.Object,System.Func{System.Int32})">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Int32" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실패시 반환할 기본값 생성자</param>
      <returns>변환된 Int32 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsIntNullable(System.Object)">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Nullable`1" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 <see cref="T:System.Nullable`1" /> 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsIntNullable(System.Object,System.Func{System.Nullable{System.Int32}})">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Nullable`1" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실패시 반환할 기본값 생성자</param>
      <returns>변환된 <see cref="T:System.Nullable`1" /> 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsLong(System.Object,System.Int64)">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Int64" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValue">변환 실패시 반환할 기본값</param>
      <returns>변환된 Int64 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsLong(System.Object,System.Func{System.Int64})">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Int64" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실패시 반환할 기본값 생성자</param>
      <returns>변환된 Int64 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsLongNullable(System.Object)">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Nullable`1" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 <see cref="T:System.Nullable`1" /> 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsLongNullable(System.Object,System.Func{System.Nullable{System.Int64}})">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Nullable`1" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실패시 반환할 기본값 생성자</param>
      <returns>변환된 <see cref="T:System.Nullable`1" /> 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsDecimal(System.Object,System.Decimal)">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Decimal" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValue">변환 실패시 반환할 기본값</param>
      <returns>변환된 Decimal 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsDecimal(System.Object,System.Func{System.Decimal})">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Decimal" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실패시 반환할 기본값 생성자</param>
      <returns>변환된 Decimal 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsDecimalNullable(System.Object)">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Nullable`1" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 <see cref="T:System.Nullable`1" /> 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsDecimalNullable(System.Object,System.Func{System.Nullable{System.Decimal}})">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Nullable`1" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실패시 반환할 기본값 생성자</param>
      <returns>변환된 <see cref="T:System.Nullable`1" /> 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsFloat(System.Object,System.Single)">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Single" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValue">변환 실패시 반환할 기본값</param>
      <returns>변환된 float 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsFloat(System.Object,System.Func{System.Single})">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Single" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실패시 반환할 기본값 생성자</param>
      <returns>변환된 float 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsFloatNullable(System.Object)">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Nullable`1" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 <see cref="T:System.Nullable`1" /> 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsFloatNullable(System.Object,System.Func{System.Nullable{System.Single}})">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Nullable`1" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실패시 반환할 기본값 생성자</param>
      <returns>변환된 <see cref="T:System.Nullable`1" /> 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsDouble(System.Object,System.Double)">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Double" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValue">변환 실패시 반환할 기본값</param>
      <returns>변환된 double 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsDouble(System.Object,System.Func{System.Double})">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Double" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실패시 반환할 기본값 생성자</param>
      <returns>변환된 double 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsDoubleNullable(System.Object)">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Nullable`1" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 <see cref="T:System.Nullable`1" /> 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsDoubleNullable(System.Object,System.Func{System.Nullable{System.Double}})">
      <summary>
        <paramref name="source" /> 의 값을 <see cref="T:System.Nullable`1" /> 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실패시 반환할 기본값 생성자</param>
      <returns>변환된 <see cref="T:System.Nullable`1" /> 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsDateTime(System.Object)">
      <summary>
        <paramref name="source" />를 DateTime 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 DateTime 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsDateTime(System.Object,System.DateTime)">
      <summary>
        <paramref name="source" />를 DateTime 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValue">변환 실퍠시에 반환할 값</param>
      <returns>변환된 DateTime 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsDateTime(System.Object,System.Func{System.DateTime})">
      <summary>
        <paramref name="source" />를 DateTime 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실퍠시에 반환할 값을 생성하는 Factory</param>
      <returns>변환된 DateTime 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsDateTimeNullable(System.Object)">
      <summary>
        <paramref name="source" />를 DateTime? 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 DateTime? 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsDateTimeNullable(System.Object,System.Func{System.Nullable{System.DateTime}})">
      <summary>
        <paramref name="source" />를 DateTime? 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실퍠시에 반환할 값을 생성하는 Factory</param>
      <returns>변환된 DateTime? 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsTimeSpan(System.Object)">
      <summary>
        <paramref name="source" />를 TimeSpan 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 TimeSpan 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsTimeSpan(System.Object,System.TimeSpan)">
      <summary>
        <paramref name="source" />를 TimeSpan 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValue">변환 실퍠시에 반환할 값</param>
      <returns>변환된 TimeSpan 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsTimeSpan(System.Object,System.Func{System.TimeSpan})">
      <summary>
        <paramref name="source" />를 TimeSpan 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실퍠시에 반환할 값을 생성하는 Factory</param>
      <returns>변환된 TimeSpan 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsTimeSpanNullable(System.Object)">
      <summary>
        <paramref name="source" />를 TimeSpan? 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 TimeSpan? 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsTimeSpanNullable(System.Object,System.Func{System.Nullable{System.TimeSpan}})">
      <summary>
        <paramref name="source" />를 TimeSpan? 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실퍠시에 반환할 값을 생성하는 Factory</param>
      <returns>변환된 TimeSpan? 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsGuid(System.Object)">
      <summary>
        <paramref name="source" />를 Guid 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 Guid 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsGuid(System.Object,System.Guid)">
      <summary>
        <paramref name="source" />를 Guid 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValue">변환 실퍠시에 반환할 값</param>
      <returns>변환된 Guid 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsGuid(System.Object,System.Func{System.Guid})">
      <summary>
        <paramref name="source" />를 Guid 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실퍠시에 반환할 값을 생성하는 Factory</param>
      <returns>변환된 Guid 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsGuidNullable(System.Object)">
      <summary>
        <paramref name="source" />를 Guid? 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <returns>변환된 Guid? 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsGuidNullable(System.Object,System.Func{System.Nullable{System.Guid}})">
      <summary>
        <paramref name="source" />를 Guid? 값으로 변환합니다.
            </summary>
      <param name="source">원본 값</param>
      <param name="defaultValueFactory">변환 실퍠시에 반환할 값을 생성하는 Factory</param>
      <returns>변환된 Guid? 값</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsText(System.Object,System.String)">
      <summary>
            인스턴스를 문자열로 변환합니다. NULL이거나 변환 실패시에는 <paramref name="defaultValue" />를 반환합니다.
            </summary>
      <param name="source">인스턴스</param>
      <param name="defaultValue">기본 문자열</param>
      <returns>인스턴스를 문자열로 변환한 값</returns>
      <seealso cref="M:NSoft.NFramework.ConvertTool.AsValue(System.Object,System.Type,System.Object)" />
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsText(System.Object,System.IFormatProvider)">
      <summary>
            인스턴스를 문자열로 변환합니다.
            </summary>
      <param name="source">
      </param>
      <param name="provider">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.AsText(System.Object,System.Func{System.String})">
      <summary>
            인스턴스를 문자열로 변환합니다. NULL이거나 변환 실패시에는 <paramref name="defaultValueFactory" />를 이용하여 기본값을 생성하여 반환합니다.
            </summary>
      <param name="source">인스턴스</param>
      <param name="defaultValueFactory">기본값 생성 함수</param>
      <returns>인스턴스를 문자열로 변환한 값</returns>
      <seealso cref="M:NSoft.NFramework.ConvertTool.AsValue(System.Object,System.Type,System.Func{System.Object})" />
      <seealso cref="M:NSoft.NFramework.ConvertTool.AsValue``1(System.Object,System.Func{``0})" />
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.DefValue(System.Object,System.Object)">
      <summary>
            값을 변환한다. 지정된 value가 null일 경우 defaultValue를 반환한다.
            </summary>
      <param name="value">추출할 값</param>
      <param name="defaultValue">추출을 실패시의 기본값</param>
      <returns>추출을 실패시에는 defaultValue를 반환한다.</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.DefValue``1(System.Object,``0,System.Boolean)">
      <summary>
            Generic을 이용하여 값 변환을 사용한다.
            </summary>
      <remarks>
            변환 실패시 혹은 값이 null인 경우 지정된 defaultValue를 반환한다.
            </remarks>
      <typeparam name="T">추출할 값의 수형</typeparam>
      <param name="value">추출할 값</param>
      <param name="defaultValue">추출 실패시의 기본값</param>
      <param name="useCurrentCulture">현재 AppDomain의 CultureInfo를 사용할 것인가.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.DefValue``1(System.Object,System.Func{``0},System.Boolean)">
      <summary>
        <paramref name="value" />를 <typeparamref name="T" /> 수형으로 변환합니다. 실패 시에는 <paramref name="defaultValueFactory" />의 값을 반환합니다.
            </summary>
      <typeparam name="T">추출할 값의 수형</typeparam>
      <param name="value">추출할 값</param>
      <param name="defaultValueFactory">추출 실패 시의 기본을 제공하는 Factory</param>
      <param name="useCurrentCulture">현재 AppDomain의 CultureInfo를 사용할 것인가.</param>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.TryParse``1(System.Object,``0@)">
      <summary>
        <paramref name="value" />를 <typeparamref name="T" /> 수형으로 변환을 시도합니다.
            </summary>
      <typeparam name="T">변환 대상 수형</typeparam>
      <param name="value">변환 하려는 값</param>
      <param name="parsedValue">변환 결과 값</param>
      <returns>변환 성공 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.TryParse(System.Object,System.Type,System.Object@)">
      <summary>
        <paramref name="value" />를 <paramref name="targetType" /> 수형으로 변환을 시도합니다.
            </summary>
      <param name="value">변환 하려는 값</param>
      <param name="targetType">변환 대상 수형</param>
      <param name="parsedValue">변환 결과 값</param>
      <returns>변환 성공 여부</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.ConvertValue(System.Object,System.Type,System.Boolean)">
      <summary>
            개체를 지정된 형식으로 변환한다.
            </summary>
      <param name="value">변환될 값</param>
      <param name="targetType">변환할 형식</param>
      <param name="useCurrentCulture">현재의 CultureInfo를 사용할 것인가? InvariantCulture 정보를 이용할 것인가 여부</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.ConvertValue(System.Object,System.Type,System.Globalization.CultureInfo)">
      <summary>
            개체를 지정된 형식으로 변환한다.
            </summary>
      <param name="value">변환될 값</param>
      <param name="targetType">변환할 형식</param>
      <param name="culture">변환시 사용할 CultureInfo 객체</param>
      <returns>실패시 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.TryConvertValue(System.Object,System.Type,System.Object@)">
      <summary>
            개체를 지정된 형식으로 변환한다.
            </summary>
      <param name="value">변환될 값</param>
      <param name="targetType">변환할 형식</param>
      <param name="converted">변환 여부</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.TryConvertValue(System.Object,System.Type,System.Boolean,System.Object@)">
      <summary>
            개체를 지정된 형식으로 변환한다.
            </summary>
      <param name="value">변환될 값</param>
      <param name="targetType">변환할 형식</param>
      <param name="useCurrentCulture">현재의 CultureInfo를 사용할 것인가? InvariantCulture 정보를 이용할 것인가 여부</param>
      <param name="converted">변환 여부</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.TryConvertValue(System.Object,System.Type,System.Globalization.CultureInfo,System.Object@)">
      <summary>
            개체를 지정된 형식으로 변환한다.
            </summary>
      <param name="value">변환될 값</param>
      <param name="targetType">변환할 형식</param>
      <param name="culture">변환시 사용할 CultureInfo 객체</param>
      <param name="converted">변환 여부</param>
      <returns>실패시 null 반환</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.ToString(System.Object,System.String,System.IFormatProvider)">
      <summary>
            지정된 값을 원하는 포맷형식으로 문자열을 만든다.
            </summary>
      <param name="value">구성할 값</param>
      <param name="format">포맷</param>
      <param name="provider">포맷 프로바이더</param>
      <returns>문자열</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.ConvertEnum(System.Object,System.Enum)">
      <summary>
            지정된 값을 알맞는 enum 값으로 변환한다.
            닷넷에서의 enum 값은 기본적으로 문자열로 저장가능하므로 다시 읽어서, 실제 값으로 변환할 때 사용한다.
            </summary>
      <param name="value">실제 enum 값</param>
      <param name="defaultValue">실패시의 기본 값</param>
      <returns>변환된 enumeration instance.</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.ConvertEnum(System.Object,System.Func{System.Enum})">
      <summary>
            지정된 값을 알맞는 enum 값으로 변환한다.
            닷넷에서의 enum 값은 기본적으로 문자열로 저장가능하므로 다시 읽어서, 실제 값으로 변환할 때 사용한다.
            </summary>
      <param name="value">실제 enum 값</param>
      <param name="defaultValueFactory">변환 실패시의 기본 값을 생성해주는 Factory</param>
      <returns>변환된 enumeration instance.</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.ConvertEnum``1(System.Object,``0)">
      <summary>
            지정된 값을 알맞는 enum 값으로 변환한다.
            닷넷에서의 enum 값은 기본적으로 문자열로 저장가능하므로 다시 읽어서, 실제 값으로 변환할 때 사용한다.
            </summary>
      <param name="value">실제 enum 값</param>
      <param name="defaultValue">실패시의 기본 값</param>
      <returns>변환된 enumeration instance.</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.ConvertEnum``1(System.Object,System.Func{``0})">
      <summary>
            지정된 값을 알맞는 enum 값으로 변환한다.
            닷넷에서의 enum 값은 기본적으로 문자열로 저장가능하므로 다시 읽어서, 실제 값으로 변환할 때 사용한다.
            </summary>
      <param name="value">실제 enum 값</param>
      <param name="defaultValueFactory">변환 실패시의 기본 값을 생성해주는 Factory</param>
      <returns>변환된 enumeration instance.</returns>
    </member>
    <member name="M:NSoft.NFramework.ConvertTool.IsNullOrDbNull(System.Object)">
      <summary>
            지정된 객체가 null이거나 DBNull 이라면 True를 반환한다.
            </summary>
      <param name="value">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.DateRangeKind">
      <summary>
            날짜 구간의 단위 (초 단위, 시간 단위, 일 단위 등)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.DateRangeKind.Second">
      <summary>
            초
            </summary>
    </member>
    <member name="F:NSoft.NFramework.DateRangeKind.Minute">
      <summary>
            분
            </summary>
    </member>
    <member name="F:NSoft.NFramework.DateRangeKind.Hour">
      <summary>
            시
            </summary>
    </member>
    <member name="F:NSoft.NFramework.DateRangeKind.Day">
      <summary>
            일
            </summary>
    </member>
    <member name="F:NSoft.NFramework.DateRangeKind.Week">
      <summary>
            주
            </summary>
    </member>
    <member name="F:NSoft.NFramework.DateRangeKind.Month">
      <summary>
            월
            </summary>
    </member>
    <member name="F:NSoft.NFramework.DateRangeKind.Quarter">
      <summary>
            분기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.DateRangeKind.HalfYear">
      <summary>
            반기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.DateRangeKind.Year">
      <summary>
            년
            </summary>
    </member>
    <member name="T:NSoft.NFramework.DateValue">
      <summary>
        <see cref="T:System.DateTime" />의 시간 부분을 제외한 날짜 부분만을 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.DateValue.#ctor(System.DateTime)">
      <summary>
            생성자
            </summary>
      <param name="moment">
      </param>
    </member>
    <member name="M:NSoft.NFramework.DateValue.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
            생성자
            </summary>
      <param name="year">년</param>
      <param name="month">월</param>
      <param name="day">일</param>
    </member>
    <member name="P:NSoft.NFramework.DateValue.Now">
      <summary>
            현재 날짜
            </summary>
    </member>
    <member name="P:NSoft.NFramework.DateValue.Year">
      <summary>
            년
            </summary>
    </member>
    <member name="P:NSoft.NFramework.DateValue.Month">
      <summary>
            월
            </summary>
    </member>
    <member name="P:NSoft.NFramework.DateValue.Day">
      <summary>
            일
            </summary>
    </member>
    <member name="T:NSoft.NFramework.DefaultAsyncResult">
      <summary>
        <see cref="T:System.IAsyncResult" /> 의 기본 구현체입니다. 비동기 방식의 작업에 대해, 취소, 실패, 성공을 지정할 수 있습니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.FileOpenMode">
      <summary>
            File Open Mode
            </summary>
    </member>
    <member name="F:NSoft.NFramework.FileOpenMode.Read">
      <summary>
            open file for read
            </summary>
    </member>
    <member name="F:NSoft.NFramework.FileOpenMode.Write">
      <summary>
            open file for write
            </summary>
    </member>
    <member name="F:NSoft.NFramework.FileOpenMode.ReadWrite">
      <summary>
            Open file for read or write
            </summary>
    </member>
    <member name="T:NSoft.NFramework.HashTool">
      <summary>
            Hash 값을 계산하는 Tool 입니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.HashTool.Compute(System.Object)">
      <summary>
            지정된 객체들의 HashCode를 계산합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.HashTool.Compute(System.Object,System.Object)">
      <summary>
            지정된 객체들의 HashCode를 계산합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.HashTool.Compute(System.Object,System.Object,System.Object)">
      <summary>
            지정된 객체들의 HashCode를 계산합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.HashTool.Compute(System.Object,System.Object,System.Object,System.Object)">
      <summary>
            지정된 객체들의 HashCode를 계산합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.HashTool.Compute(System.Object[])">
      <summary>
            지정된 객체들의 HashCode를 계산합니다.
            </summary>
      <param name="objs">객체를 입력하세요 (GetHashCode를 넣지 마세요)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.HashTool.Compute(System.Collections.IEnumerable)">
      <summary>
            지정된 객체들의 HashCode를 계산합니다.
            </summary>
      <param name="objs">객체를 입력하세요 (GetHashCode를 넣지 마세요)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NSoft.NFramework.HashTool.CalcHash(System.String)">
      <summary>
            문자열의 HashCode를 반환합니다. null 이거나 빈문자열이면 string.Empty.GetHashCode() 값을 반환합니다. (0은 아닙니다)
            </summary>
      <param name="str">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.IPagingInfo">
      <summary>
            Paging 관련 정보를 가진다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.IPagingInfo.PageIndex">
      <summary>
            현재 Page 번호 (0 부터 시작)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.IPagingInfo.PageSize">
      <summary>
            Page 당 Item의 수 (예: 한 페이지에 10개의 Item이면 PageSize는 10이다.)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.IPagingInfo.TotalPageCount">
      <summary>
            전체 Page 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.IPagingInfo.TotalItemCount">
      <summary>
            전체 Item의 갯수
            </summary>
    </member>
    <member name="T:NSoft.NFramework.IPagingList`1">
      <summary>
            Paging된 List의 정보
            </summary>
      <typeparam name="T">Type of persistent object</typeparam>
    </member>
    <member name="T:NSoft.NFramework.IYearMonth">
      <summary>
            년도와 월만 표현
            </summary>
    </member>
    <member name="P:NSoft.NFramework.IYearMonth.Year">
      <summary>
            년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.IYearMonth.Month">
      <summary>
            월
            </summary>
    </member>
    <member name="T:NSoft.NFramework.IYearMonthWeek">
      <summary>
            년 (Year), 월 (Month), 주 (Week)를 표현합니다.
            </summary>
    </member>
    <member name="T:NSoft.NFramework.IYearWeek">
      <summary>
            WeekOfYear ("Y년 W 번째 주") 를 의미하는 WeekOfYear 정보를 나타내는 인터페이스입니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.IYearWeek.Year">
      <summary>
            년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.IYearWeek.Week">
      <summary>
            년도의 주 (Week)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.MemberNamingRule">
      <summary>
            Class Member의 Naming 규칙 (camelCase, camelCaseUnderScore, pascalCase, pascalCaseUnderscore)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.MemberNamingRule.CamelCase">
      <summary>
            CamelCase (productName)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.MemberNamingRule.CamelCaseUndercore">
      <summary>
            CamelCase with underscore (_productName)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.MemberNamingRule.CamelCase_M_Underscore">
      <summary>
            CamelCase with m underscore (m_productName)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.MemberNamingRule.PascalCase">
      <summary>
            PascalCase (ProductName)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.MemberNamingRule.PascalCaseUnderscore">
      <summary>
            PascalCase with underscore (_ProductName)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.MemberNamingRule.PascalCase_M_Underscore">
      <summary>
            PascalCase with m underscore (m_ProductName)
            </summary>
    </member>
    <member name="T:NSoft.NFramework.NamedIndexer`2">
      <summary>
            C# 처럼 기본 Indexer 말고, 이름을 가진 Indexer를 제공하기 위해 사용된다.
            </summary>
      <typeparam name="TResult">속성의 값의 형식</typeparam>
      <typeparam name="TIndex">Indexer의 index의 형식</typeparam>
    </member>
    <member name="M:NSoft.NFramework.NamedIndexer`2.#ctor(System.Func{`1,`0},System.Action{`1,`0})">
      <summary>
            생성자
            </summary>
      <param name="getter">Indexer 요소 조회 함수</param>
      <param name="setter">Indexer 요소 설정 함수</param>
    </member>
    <member name="P:NSoft.NFramework.NamedIndexer`2.Item(`1)">
      <summary>
            Indexer
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.NamedIndexerGetter`2">
      <summary>
            Allow to add named getter indexers
            </summary>
      <typeparam name="TResult">속성의 값의 형식</typeparam>
      <typeparam name="TIndex">Indexer의 index의 형식</typeparam>
    </member>
    <member name="M:NSoft.NFramework.NamedIndexerGetter`2.#ctor(System.Func{`1,`0})">
      <summary>
            constructor
            </summary>
      <param name="getter">Index의 속성 값을 얻기 위한 함수</param>
    </member>
    <member name="P:NSoft.NFramework.NamedIndexerGetter`2.Item(`1)">
      <summary>
             Indexer
            </summary>
      <param name="index">
      </param>
    </member>
    <member name="T:NSoft.NFramework.NamedIndexerSetter`2">
      <summary>
            Allow to add named setter indexers
            </summary>
      <typeparam name="TResult">속성의 값의 형식</typeparam>
      <typeparam name="TIndex">Indexer의 index의 형식</typeparam>
    </member>
    <member name="M:NSoft.NFramework.NamedIndexerSetter`2.#ctor(System.Action{`1,`0})">
      <summary>
            constructor
            </summary>
      <param name="setter">Indexer 요소 설정 함수</param>
    </member>
    <member name="P:NSoft.NFramework.NamedIndexerSetter`2.Item(`1)">
      <summary>
            Indexer
            </summary>
      <param name="index">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NSoft.NFramework.OrderDirection">
      <summary>
            정렬 방식 (순차, 역순)
            </summary>
    </member>
    <member name="F:NSoft.NFramework.OrderDirection.Asc">
      <summary>
            순차 방식
            </summary>
    </member>
    <member name="F:NSoft.NFramework.OrderDirection.Desc">
      <summary>
            역순 방식
            </summary>
    </member>
    <member name="T:NSoft.NFramework.PagingList`1">
      <summary>
            Persistent Object를 Paging된 Control에 Binding하기 위해 사용되는 List
            </summary>
      <typeparam name="T">Type of persistent object</typeparam>
    </member>
    <member name="M:NSoft.NFramework.PagingList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32,System.Int32,System.Int32)">
      <summary>
            Constructor
            </summary>
      <param name="items">collection of persistent object</param>
      <param name="pageIndex">index of page</param>
      <param name="pageSize">size of page</param>
      <param name="totalItemCount">total count of items</param>
    </member>
    <member name="M:NSoft.NFramework.PagingList`1.ToString">
      <summary>
            현재 인스턴스를 나타내는 문자열을 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.PagingList`1.PageIndex">
      <summary>
            Page Index (0 부터 시작)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.PagingList`1.PageSize">
      <summary>
            Page 당 Item의 수 (예: 한 페이지에 10개의 Item이면 PageSize는 10이다.)
            </summary>
    </member>
    <member name="P:NSoft.NFramework.PagingList`1.TotalPageCount">
      <summary>
            전체 Page 수
            </summary>
    </member>
    <member name="P:NSoft.NFramework.PagingList`1.TotalItemCount">
      <summary>
            전체 Item의 갯수
            </summary>
    </member>
    <member name="T:NSoft.NFramework.Quarters">
      <summary>
            분기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Quarters.First">
      <summary>
            1 분기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Quarters.Second">
      <summary>
            2 분기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Quarters.Third">
      <summary>
            3 분기
            </summary>
    </member>
    <member name="F:NSoft.NFramework.Quarters.Fourth">
      <summary>
            4 분기
            </summary>
    </member>
    <member name="T:NSoft.NFramework.TimeValue">
      <summary>
        <see cref="T:System.DateTime" />의 시간 부분을 제외한 날짜 부분만을 표현합니다.
            </summary>
    </member>
    <member name="M:NSoft.NFramework.TimeValue.#ctor(System.DateTime)">
      <summary>
            생성자
            </summary>
      <param name="time">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimeValue.#ctor(System.TimeSpan)">
      <summary>
            생성자
            </summary>
      <param name="duration">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimeValue.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            생성자
            </summary>
      <param name="hours">
      </param>
      <param name="minutes">
      </param>
      <param name="seconds">
      </param>
      <param name="milliseconds">
      </param>
    </member>
    <member name="M:NSoft.NFramework.TimeValue.GetDateTime(System.DateTime)">
      <summary>
            지정된 날짜에 시간 부분을 무시하고, 현재 시간부분으로 대체한 날짜를 반환합니다.
            </summary>
      <param name="moment">날짜</param>
      <returns>
      </returns>
    </member>
    <member name="P:NSoft.NFramework.TimeValue.Now">
      <summary>
            현재 시각을 나타내는 <see cref="T:NSoft.NFramework.TimeValue" />를 반환합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimeValue.Duration">
      <summary>
            하루중의 시간을 나타냅니다. <see cref="P:System.DateTime.TimeOfDay" /> 와 같다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimeValue.Hour">
      <summary>
            Duration 중의 시간
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimeValue.Minute">
      <summary>
            Duration 중의 분
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimeValue.Second">
      <summary>
            Duration 중의 초
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimeValue.Millisecond">
      <summary>
            Duration 중의 밀리초
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimeValue.TotalHours">
      <summary>
            Duration을 시간 단위로 표현
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimeValue.TotalMinutes">
      <summary>
            Duration을 분 단위로 표현
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimeValue.TotalSeconds">
      <summary>
            Duration을 초 단위로 표현
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimeValue.TotalMilliseconds">
      <summary>
            Duration을 밀리초 단위로 표현
            </summary>
    </member>
    <member name="P:NSoft.NFramework.TimeValue.Ticks">
      <summary>
            Ticks
            </summary>
    </member>
    <member name="T:NSoft.NFramework.ValueObjectEqualityComparer">
      <summary>
        <see cref="T:NSoft.NFramework.IValueObject" />의 인스턴스들이 같은지 비교합니다. 비교 방법은 HashCode 값이 같은지를 비교합니다.<br />
            FluentNHibernate의 PersistenceSpecification에서 속성 값 비교를 위해 사용됩니다.<br />
            참고 : http://wiki.fluentnhibernate.org/Persistence_specification_testing#Testing_references 
            </summary>
    </member>
    <member name="T:NSoft.NFramework.ValueObjects.ValueObjectEqualityComparer`1">
      <summary>
        <see cref="T:NSoft.NFramework.IValueObject" />의 인스턴스들이 같은지 비교합니다. 비교 방법은 HashCode 값이 같은지를 비교합니다.
            </summary>
      <typeparam name="T">
      </typeparam>
    </member>
    <member name="T:NSoft.NFramework.YearMonth">
      <summary>
            년/월을 표현합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.YearMonth.Year">
      <summary>
            년
            </summary>
    </member>
    <member name="P:NSoft.NFramework.YearMonth.Month">
      <summary>
            월 ( 1 ~ 12 의 값을 가진다 )
            </summary>
    </member>
    <member name="T:NSoft.NFramework.YearWeek">
      <summary>
            주차를 표현합니다.
            </summary>
    </member>
    <member name="P:NSoft.NFramework.YearWeek.Year">
      <summary>
            년도
            </summary>
    </member>
    <member name="P:NSoft.NFramework.YearWeek.Week">
      <summary>
            주차
            </summary>
    </member>
  </members>
</doc>